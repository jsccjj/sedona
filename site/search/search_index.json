{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sedona Documentation \u00b6 Disclaimer \u00b6 Tridium no longer hosts Sedona documentation, therefore, this is the hosted/ maintained version of the original documentation contributed by Tridium under APL (Academic Public License v3.0) . Please check Sedona Alliance for background. Note All the older doc pages carry the 'Sedona Framework' Logo on top, which is copyright and trademarked by Tridium. Getting Started \u00b6 Introduction : introduction to the Sedona Framework Setup : getting your development environment setup Architecture : the big picture Tutorial : step by step walk thru example Sedona Language \u00b6 Language : overview of the Sedona language Primitives : basic built-in types Expressions : review of expression constructs Statements : review of statement constructs Classes : class types Fields : field slots Methods : method slots Components : the Sedona Framework component model Reflection : the Sedona Framework reflection APIs Arrays : how arrays work Memory : how memory is laid out and utilized Native Methods : binding APIs to native implementations written in C Logging : how to embed logging into Sedona code Apps \u00b6 Apps : the Sedona Framework application model Security : the Sedona Framework's security model Deployment \u00b6 Kits : unit of modularity, versioning, and dependencies Schema : manifests: type meta-data and schemas Sedona Framework Platforms \u00b6 Platform Definition : the platform definition XML file Platform Archive : metadata about a unique Sedona Framework platform Platform Tutorial : how to create a Sedona platform Sedona Device Simulator : creating special Sedona VMs that run apps for other platforms Sedona Framework Certified Platforms : creating platforms that pass Sedona Framework certification Development \u00b6 Sedonac : command line sedonac tool Testing : how to use the built-in test harness Porting : how to port the SVM to new platforms Niagara AX : how to integrate Sedona components with the Niagara AX Framework Networking \u00b6 Networking : Overview of network communications DASP : Datagram Authenticated Session Protocol Sox : Sox protocol: provisioning and configuration Device Discovery : Sedona device discovery using DASP Appendix \u00b6 License : Academic Free License 3.0 Conventions : Coding conventions SCode Format : reference for scode image binary format Sedona Grammar : Sedona language grammar Release Notes \u00b6 New for 1.2 : New features in Sedona Framework 1.2 APIs \u00b6 API Index : API Index for all available Sedona kits","title":"Index"},{"location":"#sedona-documentation","text":"","title":"Sedona Documentation"},{"location":"#disclaimer","text":"Tridium no longer hosts Sedona documentation, therefore, this is the hosted/ maintained version of the original documentation contributed by Tridium under APL (Academic Public License v3.0) . Please check Sedona Alliance for background. Note All the older doc pages carry the 'Sedona Framework' Logo on top, which is copyright and trademarked by Tridium.","title":"Disclaimer"},{"location":"#getting-started","text":"Introduction : introduction to the Sedona Framework Setup : getting your development environment setup Architecture : the big picture Tutorial : step by step walk thru example","title":"Getting Started"},{"location":"#sedona-language","text":"Language : overview of the Sedona language Primitives : basic built-in types Expressions : review of expression constructs Statements : review of statement constructs Classes : class types Fields : field slots Methods : method slots Components : the Sedona Framework component model Reflection : the Sedona Framework reflection APIs Arrays : how arrays work Memory : how memory is laid out and utilized Native Methods : binding APIs to native implementations written in C Logging : how to embed logging into Sedona code","title":"Sedona Language"},{"location":"#apps","text":"Apps : the Sedona Framework application model Security : the Sedona Framework's security model","title":"Apps"},{"location":"#deployment","text":"Kits : unit of modularity, versioning, and dependencies Schema : manifests: type meta-data and schemas","title":"Deployment"},{"location":"#sedona-framework-platforms","text":"Platform Definition : the platform definition XML file Platform Archive : metadata about a unique Sedona Framework platform Platform Tutorial : how to create a Sedona platform Sedona Device Simulator : creating special Sedona VMs that run apps for other platforms Sedona Framework Certified Platforms : creating platforms that pass Sedona Framework certification","title":"Sedona Framework Platforms"},{"location":"#development","text":"Sedonac : command line sedonac tool Testing : how to use the built-in test harness Porting : how to port the SVM to new platforms Niagara AX : how to integrate Sedona components with the Niagara AX Framework","title":"Development"},{"location":"#networking","text":"Networking : Overview of network communications DASP : Datagram Authenticated Session Protocol Sox : Sox protocol: provisioning and configuration Device Discovery : Sedona device discovery using DASP","title":"Networking"},{"location":"#appendix","text":"License : Academic Free License 3.0 Conventions : Coding conventions SCode Format : reference for scode image binary format Sedona Grammar : Sedona language grammar","title":"Appendix"},{"location":"#release-notes","text":"New for 1.2 : New features in Sedona Framework 1.2","title":"Release Notes"},{"location":"#apis","text":"API Index : API Index for all available Sedona kits","title":"APIs"},{"location":"api/api/","text":"API \u00b6 Kits Description basicSchedule basic schedule functions control Basic function block library datetime date time functions datetimeStd date time OS service using stdlib driver general driver func Basic function block library hvac HVAC function block library inet IP and UDP/TCP Socket APIs logManager Support for managing logs logic Logic function block library math Math function block library platUnix Platform support for Unix based devices platWin32 Platform support for Windows based devices pricomp Priority array component pstore Persistent random access, block storage for app data serial Serial I/O support sox Sox service for remote management soxcert Kit for use in sox certification tests sys Sedona core system module timing Timing function block library types Basic types and constants web Web service and servlet engine Doc Home > API Index","title":"API"},{"location":"api/api/#api","text":"Kits Description basicSchedule basic schedule functions control Basic function block library datetime date time functions datetimeStd date time OS service using stdlib driver general driver func Basic function block library hvac HVAC function block library inet IP and UDP/TCP Socket APIs logManager Support for managing logs logic Logic function block library math Math function block library platUnix Platform support for Unix based devices platWin32 Platform support for Windows based devices pricomp Priority array component pstore Persistent random access, block storage for app data serial Serial I/O support sox Sox service for remote management soxcert Kit for use in sox certification tests sys Sedona core system module timing Timing function block library types Basic types and constants web Web service and servlet engine Doc Home > API Index","title":"API"},{"location":"appendix/conventions/","text":"Conventions \u00b6 Overview \u00b6 This chapter documents the coding conventions we use for the core Sedona Framework code, as well as the supporting Java and C code. Source Files \u00b6 Use 7-bit safe ASCII (subset of UTF-8) Prefer \"\\n\" unix line endings Prefer to put class Foo in source file called \"Foo.sedona\" Indentation \u00b6 Absolutely no tab characters, spaces only Two space indentation Allman styling curly braces: if (flag) { something() } else { somethingElse() } Prefer single statement on each line with no semicolon Leave one space between keyword and opening paren for statements such as if and while . Naming \u00b6 Name classes with upper camel case such as \"Foo\" and \"FooBar\" Name everything else with lower camel case such as \"foo\" and \"fooBar\" including kit names, field names, method names, local variables, and facets Do not use screaming caps such as FOO_BAR (except for defined constants) Comments \u00b6 Prefer /* */ for commenting out sections of code Prefer leading and trailing ** in doc sections, especially for methods: ** ** This is a method that does something. ** Void something() Break logical sections up using line of 65 / chars: //////////////////////////////////////////////////////////////// // Methods //////////////////////////////////////////////////////////////// Use Javadoc-style /** */ comments on classes, methods, and fields so that sedonac can auto-generate documentation for them. Facets \u00b6 All facets should be on the line above the property definition. Exception: The @config facet should always be on the same line as the property definition. @min = 0 @max = minutesInADay @unit = Units . minute @config property short duration @min = 0 @max = 100 property int range @asStr property Buf ( 32 ) filename = \"foo.txt\"","title":"Coding Conventions"},{"location":"appendix/conventions/#conventions","text":"","title":"Conventions"},{"location":"appendix/conventions/#overview","text":"This chapter documents the coding conventions we use for the core Sedona Framework code, as well as the supporting Java and C code.","title":"Overview"},{"location":"appendix/conventions/#source-files","text":"Use 7-bit safe ASCII (subset of UTF-8) Prefer \"\\n\" unix line endings Prefer to put class Foo in source file called \"Foo.sedona\"","title":"Source Files"},{"location":"appendix/conventions/#indentation","text":"Absolutely no tab characters, spaces only Two space indentation Allman styling curly braces: if (flag) { something() } else { somethingElse() } Prefer single statement on each line with no semicolon Leave one space between keyword and opening paren for statements such as if and while .","title":"Indentation"},{"location":"appendix/conventions/#naming","text":"Name classes with upper camel case such as \"Foo\" and \"FooBar\" Name everything else with lower camel case such as \"foo\" and \"fooBar\" including kit names, field names, method names, local variables, and facets Do not use screaming caps such as FOO_BAR (except for defined constants)","title":"Naming"},{"location":"appendix/conventions/#comments","text":"Prefer /* */ for commenting out sections of code Prefer leading and trailing ** in doc sections, especially for methods: ** ** This is a method that does something. ** Void something() Break logical sections up using line of 65 / chars: //////////////////////////////////////////////////////////////// // Methods //////////////////////////////////////////////////////////////// Use Javadoc-style /** */ comments on classes, methods, and fields so that sedonac can auto-generate documentation for them.","title":"Comments"},{"location":"appendix/conventions/#facets","text":"All facets should be on the line above the property definition. Exception: The @config facet should always be on the same line as the property definition. @min = 0 @max = minutesInADay @unit = Units . minute @config property short duration @min = 0 @max = 100 property int range @asStr property Buf ( 32 ) filename = \"foo.txt\"","title":"Facets"},{"location":"appendix/grammar/","text":"Grammar \u00b6 Sedona Grammar \u00b6 The Sedona grammar document formally describes the Sedona language.","title":"Grammar"},{"location":"appendix/grammar/#grammar","text":"","title":"Grammar"},{"location":"appendix/grammar/#sedona-grammar","text":"The Sedona grammar document formally describes the Sedona language.","title":"Sedona Grammar"},{"location":"appendix/license/","text":"The Sedona Framework Open Source License \u00b6 The License, granted by Tridium, Inc. (\"Licensor\"), as set forth below, applies only to the computer software and documentation (collectively, the \"Original Work\") available for download at http://sedonadev.org , which Original Work is copyright \u00a9 2006-2013 Licensor. \"Sedona Framework\" is a trademark of Licensor that our community of customers, partners and developers recognize as an indicator of quality and compatibility. For the avoidance of doubt, the License set forth below does not grant any right to use the \"Sedona Framework\" trademark in connection with the sale, offer for sale or distribution of any product or service. Licensor offers a program that allows you to apply for a permission or license to use the Sedona Framework trademark and related logo to indicate technological compatibility of products you develop with other products built on the Sedona Framework or Niagara Framework. The Powered by Sedona Framework logo is available for your use upon acceptance of your application by Tridium and your acceptance of the terms of the applicable agreement with Tridium. For more information on becoming authorized to use the \"Powered by Sedona Framework\" trademark, go to the certification program page. If you are not authorized by contract with Tridium to use the Sedona Framework logo, the correct way to state that you used the Sedona Framework to build a product is: \"The [insert name of your product] was built on the Sedona Framework\u0099.\" If you make this statement, you should also include in the text of the document or product packaging in which it is used the statement that \"Sedona Framework is a trademark of Tridium, Inc.\" or otherwise indicate that the trademark does not belong to you. Academic Free License (\"AFL\") v. 3.0 \u00b6 This Academic Free License (the \"License\") applies to any original work of authorship (the \"Original Work\") whose owner (the \"Licensor\") has placed the following licensing notice adjacent to the copyright notice for the Original Work: Licensed under the Academic Free License version 3.0 Grant of Copyright License. Licensor grants You a worldwide, royalty-free, non-exclusive, sublicensable license, for the duration of the copyright, to do the following: a. to reproduce the Original Work in copies, either alone or as part of a collective work; b. to translate, adapt, alter, transform, modify, or arrange the Original Work, thereby creating derivative works (\"Derivative Works\") based upon the Original Work; c. to distribute or communicate copies of the Original Work and Derivative Works to the public, under any license of your choice that does not contradict the terms and conditions, including Licensor's reserved rights and remedies, in this Academic Free License; d. to perform the Original Work publicly; and e. to display the Original Work publicly. Grant of Patent License. Licensor grants You a worldwide, royalty-free, non-exclusive, sublicensable license, under patent claims owned or controlled by the Licensor that are embodied in the Original Work as furnished by the Licensor, for the duration of the patents, to make, use, sell, offer for sale, have made, and import the Original Work and Derivative Works. Grant of Source Code License. The term \"Source Code\" means the preferred form of the Original Work for making modifications to it and all available documentation describing how to modify the Original Work. Licensor agrees to provide a machine-readable copy of the Source Code of the Original Work along with each copy of the Original Work that Licensor distributes. Licensor reserves the right to satisfy this obligation by placing a machine-readable copy of the Source Code in an information repository reasonably calculated to permit inexpensive and convenient access by You for as long as Licensor continues to distribute the Original Work. Exclusions From License Grant. Neither the names of Licensor, nor the names of any contributors to the Original Work, nor any of their trademarks or service marks, may be used to endorse or promote products derived from this Original Work without express prior permission of the Licensor. Except as expressly stated herein, nothing in this License grants any license to Licensor's trademarks, copyrights, patents, trade secrets or any other intellectual property. No patent license is granted to make, use, sell, offer for sale, have made, or import embodiments of any patent claims other than the licensed claims defined in Section 2. No license is granted to the trademarks of Licensor even if such marks are included in the Original Work. Nothing in this License shall be interpreted to prohibit Licensor from licensing under terms different from this License any Original Work that Licensor otherwise would have a right to license. External Deployment. The term \"External Deployment\" means the use, distribution, or communication of the Original Work or Derivative Works in any way such that the Original Work or Derivative Works may be used by anyone other than You, whether those works are distributed or communicated to those persons or made available as an application intended for use over a network. As an express condition for the grants of license hereunder, You must treat any External Deployment by You of the Original Work or a Derivative Work as a distribution under section 1\u00a9. Attribution Rights. You must retain, in the Source Code of any Derivative Works that You create, all copyright, patent, or trademark notices from the Source Code of the Original Work, as well as any notices of licensing and any descriptive text identified therein as an \"Attribution Notice.\" You must cause the Source Code for any Derivative Works that You create to carry a prominent Attribution Notice reasonably calculated to inform recipients that You have modified the Original Work. Warranty of Provenance and Disclaimer of Warranty. Licensor warrants that the copyright in and to the Original Work and the patent rights granted herein by Licensor are owned by the Licensor or are sublicensed to You under the terms of this License with the permission of the contributor(s) of those copyrights and patent rights. Except as expressly stated in the immediately preceding sentence, the Original Work is provided under this License on an \"AS IS\" BASIS and WITHOUT WARRANTY, either express or implied, including, without limitation, the warranties of non-infringement, merchantability or fitness for a particular purpose. THE ENTIRE RISK AS TO THE QUALITY OF THE ORIGINAL WORK IS WITH YOU. This DISCLAIMER OF WARRANTY constitutes an essential part of this License. No license to the Original Work is granted by this License except under this disclaimer. Limitation of Liability. Under no circumstances and under no legal theory, whether in tort (including negligence), contract, or otherwise, shall the Licensor be liable to anyone for any indirect, special, incidental, or consequential damages of any character arising as a result of this License or the use of the Original Work including, without limitation, damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses. This limitation of liability shall not apply to the extent applicable law prohibits such limitation. Acceptance and Termination. If, at any time, You expressly assented to this License, that assent indicates your clear and irrevocable acceptance of this License and all of its terms and conditions. If You distribute or communicate copies of the Original Work or a Derivative Work, You must make a reasonable effort under the circumstances to obtain the express assent of recipients to the terms of this License. This License conditions your rights to undertake the activities listed in Section 1, including your right to create Derivative Works based upon the Original Work, and doing so without honoring these terms and conditions is prohibited by copyright law and international treaty. Nothing in this License is intended to affect copyright exceptions and limitations (including \"fair use\" or \"fair dealing\"). This License shall terminate immediately and You may no longer exercise any of the rights granted to You by this License upon your failure to honor the conditions in Section 1\u00a9. Termination for Patent Action. This License shall terminate automatically and You may no longer exercise any of the rights granted to You by this License as of the date You commence an action, including a cross-claim or counterclaim, against Licensor or any licensee alleging that the Original Work infringes a patent. This termination provision shall not apply for an action alleging patent infringement by combinations of the Original Work with other software or hardware. Jurisdiction, Venue and Governing Law. Any action or suit relating to this License may be brought only in the courts of a jurisdiction wherein the Licensor resides or in which Licensor conducts its primary business, and under the laws of that jurisdiction excluding its conflict-of-law provisions. The application of the United Nations Convention on Contracts for the International Sale of Goods is expressly excluded. Any use of the Original Work outside the scope of this License or after its termination shall be subject to the requirements and penalties of copyright or patent law in the appropriate jurisdiction. This section shall survive the termination of this License. Attorneys' Fees. In any action to enforce the terms of this License or seeking damages relating thereto, the prevailing party shall be entitled to recover its costs and expenses, including, without limitation, reasonable attorneys' fees and costs incurred in connection with such action, including any appeal of such action. This section shall survive the termination of this License. Miscellaneous. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Definition of \"You\" in This License. \"You\" throughout this License, whether in upper or lower case, means an individual or a legal entity exercising rights under, and complying with all of the terms of, this License. For legal entities, \"You\" includes any entity that controls, is controlled by, or is under common control with you. For purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. Right to Use. You may use the Original Work in all ways not otherwise restricted or conditioned by this License or by law, and Licensor promises not to interfere with or be responsible for such uses by You. Modification of This License. This License is Copyright \u00a9 2005 Lawrence Rosen. Permission is granted to copy, distribute, or communicate this License without modification. Nothing in this License permits You to modify this License as applied to the Original Work or to Derivative Works. However, You may modify the text of this License and copy, distribute or communicate your modified version (the \"Modified License\") and apply it to other original works of authorship subject to the following conditions: (i) You may not indicate in any way that your Modified License is the \"Academic Free License\" or \"AFL\" and you may not use those names in the name of your Modified License; (ii) You must replace the notice specified in the first paragraph above with the notice \"Licensed under <insert your license name here>\" or with a notice of your own that is not confusingly similar to the notice in this License; and (iii) You may not claim that your original works are open source software unless your Modified License has been approved by Open Source Initiative (OSI) and You comply with its license review and certification process.","title":"License"},{"location":"appendix/license/#the-sedona-framework-open-source-license","text":"The License, granted by Tridium, Inc. (\"Licensor\"), as set forth below, applies only to the computer software and documentation (collectively, the \"Original Work\") available for download at http://sedonadev.org , which Original Work is copyright \u00a9 2006-2013 Licensor. \"Sedona Framework\" is a trademark of Licensor that our community of customers, partners and developers recognize as an indicator of quality and compatibility. For the avoidance of doubt, the License set forth below does not grant any right to use the \"Sedona Framework\" trademark in connection with the sale, offer for sale or distribution of any product or service. Licensor offers a program that allows you to apply for a permission or license to use the Sedona Framework trademark and related logo to indicate technological compatibility of products you develop with other products built on the Sedona Framework or Niagara Framework. The Powered by Sedona Framework logo is available for your use upon acceptance of your application by Tridium and your acceptance of the terms of the applicable agreement with Tridium. For more information on becoming authorized to use the \"Powered by Sedona Framework\" trademark, go to the certification program page. If you are not authorized by contract with Tridium to use the Sedona Framework logo, the correct way to state that you used the Sedona Framework to build a product is: \"The [insert name of your product] was built on the Sedona Framework\u0099.\" If you make this statement, you should also include in the text of the document or product packaging in which it is used the statement that \"Sedona Framework is a trademark of Tridium, Inc.\" or otherwise indicate that the trademark does not belong to you.","title":"The Sedona Framework Open Source License"},{"location":"appendix/license/#academic-free-license-afl-v-30","text":"This Academic Free License (the \"License\") applies to any original work of authorship (the \"Original Work\") whose owner (the \"Licensor\") has placed the following licensing notice adjacent to the copyright notice for the Original Work: Licensed under the Academic Free License version 3.0 Grant of Copyright License. Licensor grants You a worldwide, royalty-free, non-exclusive, sublicensable license, for the duration of the copyright, to do the following: a. to reproduce the Original Work in copies, either alone or as part of a collective work; b. to translate, adapt, alter, transform, modify, or arrange the Original Work, thereby creating derivative works (\"Derivative Works\") based upon the Original Work; c. to distribute or communicate copies of the Original Work and Derivative Works to the public, under any license of your choice that does not contradict the terms and conditions, including Licensor's reserved rights and remedies, in this Academic Free License; d. to perform the Original Work publicly; and e. to display the Original Work publicly. Grant of Patent License. Licensor grants You a worldwide, royalty-free, non-exclusive, sublicensable license, under patent claims owned or controlled by the Licensor that are embodied in the Original Work as furnished by the Licensor, for the duration of the patents, to make, use, sell, offer for sale, have made, and import the Original Work and Derivative Works. Grant of Source Code License. The term \"Source Code\" means the preferred form of the Original Work for making modifications to it and all available documentation describing how to modify the Original Work. Licensor agrees to provide a machine-readable copy of the Source Code of the Original Work along with each copy of the Original Work that Licensor distributes. Licensor reserves the right to satisfy this obligation by placing a machine-readable copy of the Source Code in an information repository reasonably calculated to permit inexpensive and convenient access by You for as long as Licensor continues to distribute the Original Work. Exclusions From License Grant. Neither the names of Licensor, nor the names of any contributors to the Original Work, nor any of their trademarks or service marks, may be used to endorse or promote products derived from this Original Work without express prior permission of the Licensor. Except as expressly stated herein, nothing in this License grants any license to Licensor's trademarks, copyrights, patents, trade secrets or any other intellectual property. No patent license is granted to make, use, sell, offer for sale, have made, or import embodiments of any patent claims other than the licensed claims defined in Section 2. No license is granted to the trademarks of Licensor even if such marks are included in the Original Work. Nothing in this License shall be interpreted to prohibit Licensor from licensing under terms different from this License any Original Work that Licensor otherwise would have a right to license. External Deployment. The term \"External Deployment\" means the use, distribution, or communication of the Original Work or Derivative Works in any way such that the Original Work or Derivative Works may be used by anyone other than You, whether those works are distributed or communicated to those persons or made available as an application intended for use over a network. As an express condition for the grants of license hereunder, You must treat any External Deployment by You of the Original Work or a Derivative Work as a distribution under section 1\u00a9. Attribution Rights. You must retain, in the Source Code of any Derivative Works that You create, all copyright, patent, or trademark notices from the Source Code of the Original Work, as well as any notices of licensing and any descriptive text identified therein as an \"Attribution Notice.\" You must cause the Source Code for any Derivative Works that You create to carry a prominent Attribution Notice reasonably calculated to inform recipients that You have modified the Original Work. Warranty of Provenance and Disclaimer of Warranty. Licensor warrants that the copyright in and to the Original Work and the patent rights granted herein by Licensor are owned by the Licensor or are sublicensed to You under the terms of this License with the permission of the contributor(s) of those copyrights and patent rights. Except as expressly stated in the immediately preceding sentence, the Original Work is provided under this License on an \"AS IS\" BASIS and WITHOUT WARRANTY, either express or implied, including, without limitation, the warranties of non-infringement, merchantability or fitness for a particular purpose. THE ENTIRE RISK AS TO THE QUALITY OF THE ORIGINAL WORK IS WITH YOU. This DISCLAIMER OF WARRANTY constitutes an essential part of this License. No license to the Original Work is granted by this License except under this disclaimer. Limitation of Liability. Under no circumstances and under no legal theory, whether in tort (including negligence), contract, or otherwise, shall the Licensor be liable to anyone for any indirect, special, incidental, or consequential damages of any character arising as a result of this License or the use of the Original Work including, without limitation, damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses. This limitation of liability shall not apply to the extent applicable law prohibits such limitation. Acceptance and Termination. If, at any time, You expressly assented to this License, that assent indicates your clear and irrevocable acceptance of this License and all of its terms and conditions. If You distribute or communicate copies of the Original Work or a Derivative Work, You must make a reasonable effort under the circumstances to obtain the express assent of recipients to the terms of this License. This License conditions your rights to undertake the activities listed in Section 1, including your right to create Derivative Works based upon the Original Work, and doing so without honoring these terms and conditions is prohibited by copyright law and international treaty. Nothing in this License is intended to affect copyright exceptions and limitations (including \"fair use\" or \"fair dealing\"). This License shall terminate immediately and You may no longer exercise any of the rights granted to You by this License upon your failure to honor the conditions in Section 1\u00a9. Termination for Patent Action. This License shall terminate automatically and You may no longer exercise any of the rights granted to You by this License as of the date You commence an action, including a cross-claim or counterclaim, against Licensor or any licensee alleging that the Original Work infringes a patent. This termination provision shall not apply for an action alleging patent infringement by combinations of the Original Work with other software or hardware. Jurisdiction, Venue and Governing Law. Any action or suit relating to this License may be brought only in the courts of a jurisdiction wherein the Licensor resides or in which Licensor conducts its primary business, and under the laws of that jurisdiction excluding its conflict-of-law provisions. The application of the United Nations Convention on Contracts for the International Sale of Goods is expressly excluded. Any use of the Original Work outside the scope of this License or after its termination shall be subject to the requirements and penalties of copyright or patent law in the appropriate jurisdiction. This section shall survive the termination of this License. Attorneys' Fees. In any action to enforce the terms of this License or seeking damages relating thereto, the prevailing party shall be entitled to recover its costs and expenses, including, without limitation, reasonable attorneys' fees and costs incurred in connection with such action, including any appeal of such action. This section shall survive the termination of this License. Miscellaneous. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Definition of \"You\" in This License. \"You\" throughout this License, whether in upper or lower case, means an individual or a legal entity exercising rights under, and complying with all of the terms of, this License. For legal entities, \"You\" includes any entity that controls, is controlled by, or is under common control with you. For purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. Right to Use. You may use the Original Work in all ways not otherwise restricted or conditioned by this License or by law, and Licensor promises not to interfere with or be responsible for such uses by You. Modification of This License. This License is Copyright \u00a9 2005 Lawrence Rosen. Permission is granted to copy, distribute, or communicate this License without modification. Nothing in this License permits You to modify this License as applied to the Original Work or to Derivative Works. However, You may modify the text of this License and copy, distribute or communicate your modified version (the \"Modified License\") and apply it to other original works of authorship subject to the following conditions: (i) You may not indicate in any way that your Modified License is the \"Academic Free License\" or \"AFL\" and you may not use those names in the name of your Modified License; (ii) You must replace the notice specified in the first paragraph above with the notice \"Licensed under <insert your license name here>\" or with a notice of your own that is not confusingly similar to the notice in this License; and (iii) You may not claim that your original works are open source software unless your Modified License has been approved by Open Source Initiative (OSI) and You comply with its license review and certification process.","title":"Academic Free License (\"AFL\") v. 3.0"},{"location":"appendix/scodeFormat/","text":"SCode Format \u00b6 Image Format \u00b6 image { header header item[] items // each item aligned by swSize } header { 0: u4 magic: 0x5ED0BA07 for big endian, 0x07BAD05E for little endian 4: u1 majorVer: 1 5: u1 minorVer: 0 6: u1 blockSize: addr = blockIndex*blockSize + codeBaseAddr 7: u1 refSize: num bytes in address pointers 8: u4 imageSize: num bytes of whole image including full header 12: u4 dataSize: num bytes for static field data 16: bix main method block index 18: bix test table 20: bix kits array block index 22: u1 number of kits in kits array } item { vtable | kit | type | int | float | long | double | str | slot | log | method | tests | qnameType | qnameSlot } vtable { u2[] block indexes to each virtual method } kit { // see sys::Kit field memory layout } type { // see sys::Type field memory layout } slot { // see sys::Slot field memory layout } log { // see sys::Log field memory layout } int { 0: s4 32-bit integer constants } long { 0: s8 64-bit integer constants } float { 0: f4 32-bit float constants } double { 0: f8 64-bit double constants } str { 0: u1[] ASCII char string terminated by 0 (C string literal) } method { 0: u1 numParams (including implicit this) 1: u1 numLocals 2: u1[] opcodes } tests { u2 count test[] table } test { u2: qnameSlot u2: test method } qnameType { u2: kit name str index u2: type name str index } qnameSlot { u2: qnameType index u2: slot name str index }","title":"SCode Format"},{"location":"appendix/scodeFormat/#scode-format","text":"","title":"SCode Format"},{"location":"appendix/scodeFormat/#image-format","text":"image { header header item[] items // each item aligned by swSize } header { 0: u4 magic: 0x5ED0BA07 for big endian, 0x07BAD05E for little endian 4: u1 majorVer: 1 5: u1 minorVer: 0 6: u1 blockSize: addr = blockIndex*blockSize + codeBaseAddr 7: u1 refSize: num bytes in address pointers 8: u4 imageSize: num bytes of whole image including full header 12: u4 dataSize: num bytes for static field data 16: bix main method block index 18: bix test table 20: bix kits array block index 22: u1 number of kits in kits array } item { vtable | kit | type | int | float | long | double | str | slot | log | method | tests | qnameType | qnameSlot } vtable { u2[] block indexes to each virtual method } kit { // see sys::Kit field memory layout } type { // see sys::Type field memory layout } slot { // see sys::Slot field memory layout } log { // see sys::Log field memory layout } int { 0: s4 32-bit integer constants } long { 0: s8 64-bit integer constants } float { 0: f4 32-bit float constants } double { 0: f8 64-bit double constants } str { 0: u1[] ASCII char string terminated by 0 (C string literal) } method { 0: u1 numParams (including implicit this) 1: u1 numLocals 2: u1[] opcodes } tests { u2 count test[] table } test { u2: qnameSlot u2: test method } qnameType { u2: kit name str index u2: type name str index } qnameSlot { u2: qnameType index u2: slot name str index }","title":"Image Format"},{"location":"apps/apps/","text":"Apps \u00b6 Overview \u00b6 Applications for the Sedona Framework are designed and deployed according to the component model, which separates the code from the application. In this architecture you have a clean boundary between the code packaged into kits and the application defined as a tree of components defined in those kits. This model allows you to build applications simply by assembling components, configuring their properties, and linking slots together to define control flow. This style of programming is especially amenable to graphical programming. So when we refer to a Sedona Framework application, we are really talking about a tree of components assembled together. An application is purely declarative, all the code is encapsulated in the kits. The application itself is stored as a file using one of two file formats: SAX : a simple XML representation of the application that is easily generated and consumed by software tools SAB : a compact binary representation of the application, suitable for storage and execution on a Sedona Framework-enabled device You can convert between the two file formats using sedonac . Boot Strap \u00b6 Applications are boot-strapped in the following phases: Loaded : Each component is loaded from the SAB file into memory and its Component.loaded() callback is invoked. Start : Once all the components are loaded, each component has its Component.start() callback invoked. Running : The application enters the main execution loop (described next). Execution \u00b6 The Sedona Framework's execution model is based a single-threaded main loop with a fixed scan rate: Recursively execute components. For each component: a. Step through the component's list of children and execute them first b. Propagate incoming links to this component c. Call this component's execute() virtual method 2. Give any remaining time in the scan cycle to services via Service.work() 3. If no services have remaining work, then relinquish CPU (via yield or sleep) until next cycle Controlling child execution rate \u00b6 For Sedona 1.2 a new virtual method was added to the Component class. If a component's allowChildExecute() returns false , then the app will skip (1a), the recursive step through the component's child components. It will simply call execute() on the current component and then go on to the next one at the same hierarchy level. (The base class version of the method always returns true , which preserves pre-1.2 behavior.) This method can be overridden to force child components to be executed at a slower rate than the main loop. As an example, there is a new component sys::RateFolder that uses this strategy to provide multi-rate app functionality. Yield vs Sleep \u00b6 Depending on the underlying execution environment, the App can either return control to the OS (exit the SVM) or sleep until it's time to run again. Preemptive multithreaded OS \u00b6 These include Windows, Linux or QNX. When a thread calls the OS sleep primitive, other threads are given a chance to run. The SVM thread may be swapped in and out several times during an execute cycle. Main Loop \u00b6 In this environment, the Sedona VM executes as the main loop and all other work is done at ISR level. Once the App completes an execute cycle, it can delay by entering a busy-wait loop. Cooperative tasking OS \u00b6 In this environment, a task must return control to the scheduler to allow other tasks a chance to run. The sleep and busy-wait approaches won't work here since the SVM will never exit, so the SVM must support a clean exit and re-entry. This is accomplished by the yield mechanism described below. Yield \u00b6 The Sedona Framework supports yielding to provide a graceful exit (and subsequent reentry) of the SVM, allowing the platform CPU to perform other operations. Systems that require yield functionality must override the following methods of PlatformService : yieldRequired() - returns true if the SVM should exit after each App execute cycle yield(long yieldTime) - indicates the SVM will be exiting and requests to be resumed in yieldTime nanoseconds If a PlatformService subclass returns true to yieldRequired(), then the App will exit with the error code ERR_YIELD after each execution loop. On exiting, the App will call yield(yieldTime) to determine how soon it needs to be resumed. Native code should resume the SVM via vmResume(SedonaVM*) as soon as possible, but before the requested time. If vmResume is not called before yieldTime expires, App cycle overruns could occur. Hibernation \u00b6 When entering hibernation, the App exits and returns control to the bootstrap code. It is similar to yield but it is expected that the hibernation time will be much longer than a typical yield time. Hibernation is driven by application logic and most likely will not occur each App execute cycle, whereas yield must occur each cycle. To enter the hibernation state, an application calls App.hibernate() . This will set a flag on App and when the current execution cycle is complete, it will cause the App to exit with error code ERR_HIBERNATE . This will gracefully unwind the call stack, returning control to the boot code. The device's boot code should then put the device to sleep. It is a device dependent issue to decide how it will wake up from hibernation. When the device does wake, it should restart the SVM with a call to vmResume(SedonaVM*) . If your device doesn't support hibernation, then you will need to simulate it using code such as the following: result = vmRun ( & vm ); while ( result == ERR_HIBERNATE ) { //printf(\"-- Simulated hibernate --\\n\"); result = vmResume ( & vm ); } If you are developing Sedona Framework components, applications, or drivers you should keep hibernation in mind. Any software that might run on a battery powered device needs to support hibernation cleanly. This means that function blocks should assume the scan rate might have hibernation pauses. If you have services that need to do something special when hibernating or waking, then you will need to override the functions Service.onHibernate() and Service.onUnhibernate() . Service.onHibernate() will be called prior to SVM exit. Service.onUnhibernate() will be called after the SVM is resumed and prior to the App execution loop starting back up. Steady State \u00b6 Most apps will be fully operational by the end of the first cycle. When hardware I/O is involved, however, an app may need to allow additional time for the hardware to warm up, or for complex logic results to propagate fully to all components. For this purpose, the Sedona Framework provides a \"steady state\" timing feature that should be used to protect the hardware from reading or writing transient values while the app is starting up. The steady state feature consists of two pieces: timeToSteadyState : This integer specifies the time delay between the start of app execution and the time at which the app is assumed to be in \"steady state\". It is a config property of the App class, so it can be set in the app definition (.sax file) or at runtime from a remote access tool (e.g. the App property sheet in Sedona Framework Workbench). The default value is 0, meaning that the delay ends when the app enters the \"Running\" phase described above. The correct value for a given App will vary depending on the application logic and the specific hardware involved. - isSteadyState() : This is a method that returns true if the app has entered \"steady state\" mode, i.e. if the time delay defined by timeToSteadyState has elapsed, and false otherwise. Once steady state mode is reached, this method will continue to return true until the app is restarted. Code that affects hardware on the native level should use this method to avoid reading or writing hardware values until steady state is reached. Note : This feature is not used internally within the App. It only affects behavior of components that use the isSteadyState() method. It is the responsibility of each kit developer to call this method as needed to protect the hardware. By default, App.timeToSteadyState applies only to the first time the SVM is started. Once steady time has elapsed, hibernate/yield will not affect it. If App.hibernationResetsSteadyState is set to true, then the steady state flag will be cleared each time device exits hibernation. Links \u00b6 Links are the mechanism used to define control flow in an app. Links are said to be from a given component's slot to another component's slot. Currently links are supported only between properties; you cannot link to an action slot. During link propagation, the from-property value is copied into the to-property . This mechanism could be used, for example, to link sensor inputs through control logic to control actuator outputs. Services \u00b6 Services are special components that subclass from sys::Service . Services have three primary characteristics that set them apart from other types of components: Type Lookup : Services are easy to lookup by type via the App.lookupService method. This allows other components in the App to find a given service at runtime simply by knowing its type. Background work : Other components get a single callback, execute() , to do work during a scan cycle. Service components, on the other hand, have an additional callback, work() to handle background work during any time available at the end of a given scan cycle. Hibernation control : Each time the App finishes an execute cycle, it calls Service.canHibernate() on all services. If a service is not in a state where it can hibernate, it should return false. (For example, if a service is waiting for a network reply, it would return false.) Platform services for devices that never need to hibernate should always return false. Services are often used to provide functionality to other components. For example the UserService is used to lookup and authenticate user accounts. Many services such as protocol drivers also perform background work to service network messages. SAX File Format \u00b6 A SAX file is structured as follows: <sedonaApp> <schema> <kit name= 'sys' /> ... </schema> <app> <comp name= \"play\" id= \"1\" type= \"sys::Folder\" > <comp name= \"rampA\" id= \"7\" type= \"control::Ramp\" > <prop name= \"min\" val= \"20.00000\" /> <prop name= \"max\" val= \"80.00000\" /> </comp> ... </comp> ... </app> <links> <link from= \"/play/rampA.out\" to= \"/play/something.else\" /> ... </links> </sedonaApp> <sedonaApp> root element that contains: <schema> : contains <kit> elements <app> : contains <comp> elements <links> : contains <link> elements <kit> defines the kits used by the application: name : required kit name checksum : optional kit checksum; if omitted the latest version of the kit is assumed <comp> defines each component in the application: <comp> : nested elements map to nested components <prop> : property configuration for the component name : required name of component (limited in length) type : required qname of the component's type id : optional two byte identifier; if omitted an id is auto-generated <prop> defines the property value of a component within a <comp> element. Supported attributes: name : required name of property val : required value. Buf properties should be a base64 encoded value (unless asStr in which case just use string value). <link> element defines a link between two slots using the format of /path/comp.slot : from : the from component and slot name to : the to component and slot name SAB Files \u00b6 While XML is a nice representation for tools to work with app files, XML is too big and difficult to work with in an embedded device. So we use the SAB format when we need a compact binary representation. Sedona Framework devices typically store their application as an SAB file (although often it might just be a location in flash memory versus a real file system). Schemas \u00b6 Sedona Framework application files, whether stored as SAX or SAB format, always contain a schema . This is simply a list of the kits (with matching kit checksums) that the app requires in order to run. The Sedona VM cannot start the app if its current scode image does not contain all the kits in the app's schema. APIs \u00b6 If you want to develop tools for managing Sedona apps, check out the sedona.offline Java APIs for working with both SAX and SAB files: OfflineApp.encodeAppXml OfflineApp.decodeAppXml OfflineApp.encodeAppBinary OfflineApp.decodeAppBinary","title":"Application Model"},{"location":"apps/apps/#apps","text":"","title":"Apps"},{"location":"apps/apps/#overview","text":"Applications for the Sedona Framework are designed and deployed according to the component model, which separates the code from the application. In this architecture you have a clean boundary between the code packaged into kits and the application defined as a tree of components defined in those kits. This model allows you to build applications simply by assembling components, configuring their properties, and linking slots together to define control flow. This style of programming is especially amenable to graphical programming. So when we refer to a Sedona Framework application, we are really talking about a tree of components assembled together. An application is purely declarative, all the code is encapsulated in the kits. The application itself is stored as a file using one of two file formats: SAX : a simple XML representation of the application that is easily generated and consumed by software tools SAB : a compact binary representation of the application, suitable for storage and execution on a Sedona Framework-enabled device You can convert between the two file formats using sedonac .","title":"Overview"},{"location":"apps/apps/#boot-strap","text":"Applications are boot-strapped in the following phases: Loaded : Each component is loaded from the SAB file into memory and its Component.loaded() callback is invoked. Start : Once all the components are loaded, each component has its Component.start() callback invoked. Running : The application enters the main execution loop (described next).","title":"Boot Strap"},{"location":"apps/apps/#execution","text":"The Sedona Framework's execution model is based a single-threaded main loop with a fixed scan rate: Recursively execute components. For each component: a. Step through the component's list of children and execute them first b. Propagate incoming links to this component c. Call this component's execute() virtual method 2. Give any remaining time in the scan cycle to services via Service.work() 3. If no services have remaining work, then relinquish CPU (via yield or sleep) until next cycle","title":"Execution"},{"location":"apps/apps/#controlling-child-execution-rate","text":"For Sedona 1.2 a new virtual method was added to the Component class. If a component's allowChildExecute() returns false , then the app will skip (1a), the recursive step through the component's child components. It will simply call execute() on the current component and then go on to the next one at the same hierarchy level. (The base class version of the method always returns true , which preserves pre-1.2 behavior.) This method can be overridden to force child components to be executed at a slower rate than the main loop. As an example, there is a new component sys::RateFolder that uses this strategy to provide multi-rate app functionality.","title":"Controlling child execution rate"},{"location":"apps/apps/#yield-vs-sleep","text":"Depending on the underlying execution environment, the App can either return control to the OS (exit the SVM) or sleep until it's time to run again.","title":"Yield vs Sleep"},{"location":"apps/apps/#preemptive-multithreaded-os","text":"These include Windows, Linux or QNX. When a thread calls the OS sleep primitive, other threads are given a chance to run. The SVM thread may be swapped in and out several times during an execute cycle.","title":"Preemptive multithreaded OS"},{"location":"apps/apps/#main-loop","text":"In this environment, the Sedona VM executes as the main loop and all other work is done at ISR level. Once the App completes an execute cycle, it can delay by entering a busy-wait loop.","title":"Main Loop"},{"location":"apps/apps/#cooperative-tasking-os","text":"In this environment, a task must return control to the scheduler to allow other tasks a chance to run. The sleep and busy-wait approaches won't work here since the SVM will never exit, so the SVM must support a clean exit and re-entry. This is accomplished by the yield mechanism described below.","title":"Cooperative tasking OS"},{"location":"apps/apps/#yield","text":"The Sedona Framework supports yielding to provide a graceful exit (and subsequent reentry) of the SVM, allowing the platform CPU to perform other operations. Systems that require yield functionality must override the following methods of PlatformService : yieldRequired() - returns true if the SVM should exit after each App execute cycle yield(long yieldTime) - indicates the SVM will be exiting and requests to be resumed in yieldTime nanoseconds If a PlatformService subclass returns true to yieldRequired(), then the App will exit with the error code ERR_YIELD after each execution loop. On exiting, the App will call yield(yieldTime) to determine how soon it needs to be resumed. Native code should resume the SVM via vmResume(SedonaVM*) as soon as possible, but before the requested time. If vmResume is not called before yieldTime expires, App cycle overruns could occur.","title":"Yield"},{"location":"apps/apps/#hibernation","text":"When entering hibernation, the App exits and returns control to the bootstrap code. It is similar to yield but it is expected that the hibernation time will be much longer than a typical yield time. Hibernation is driven by application logic and most likely will not occur each App execute cycle, whereas yield must occur each cycle. To enter the hibernation state, an application calls App.hibernate() . This will set a flag on App and when the current execution cycle is complete, it will cause the App to exit with error code ERR_HIBERNATE . This will gracefully unwind the call stack, returning control to the boot code. The device's boot code should then put the device to sleep. It is a device dependent issue to decide how it will wake up from hibernation. When the device does wake, it should restart the SVM with a call to vmResume(SedonaVM*) . If your device doesn't support hibernation, then you will need to simulate it using code such as the following: result = vmRun ( & vm ); while ( result == ERR_HIBERNATE ) { //printf(\"-- Simulated hibernate --\\n\"); result = vmResume ( & vm ); } If you are developing Sedona Framework components, applications, or drivers you should keep hibernation in mind. Any software that might run on a battery powered device needs to support hibernation cleanly. This means that function blocks should assume the scan rate might have hibernation pauses. If you have services that need to do something special when hibernating or waking, then you will need to override the functions Service.onHibernate() and Service.onUnhibernate() . Service.onHibernate() will be called prior to SVM exit. Service.onUnhibernate() will be called after the SVM is resumed and prior to the App execution loop starting back up.","title":"Hibernation"},{"location":"apps/apps/#steady-state","text":"Most apps will be fully operational by the end of the first cycle. When hardware I/O is involved, however, an app may need to allow additional time for the hardware to warm up, or for complex logic results to propagate fully to all components. For this purpose, the Sedona Framework provides a \"steady state\" timing feature that should be used to protect the hardware from reading or writing transient values while the app is starting up. The steady state feature consists of two pieces: timeToSteadyState : This integer specifies the time delay between the start of app execution and the time at which the app is assumed to be in \"steady state\". It is a config property of the App class, so it can be set in the app definition (.sax file) or at runtime from a remote access tool (e.g. the App property sheet in Sedona Framework Workbench). The default value is 0, meaning that the delay ends when the app enters the \"Running\" phase described above. The correct value for a given App will vary depending on the application logic and the specific hardware involved. - isSteadyState() : This is a method that returns true if the app has entered \"steady state\" mode, i.e. if the time delay defined by timeToSteadyState has elapsed, and false otherwise. Once steady state mode is reached, this method will continue to return true until the app is restarted. Code that affects hardware on the native level should use this method to avoid reading or writing hardware values until steady state is reached. Note : This feature is not used internally within the App. It only affects behavior of components that use the isSteadyState() method. It is the responsibility of each kit developer to call this method as needed to protect the hardware. By default, App.timeToSteadyState applies only to the first time the SVM is started. Once steady time has elapsed, hibernate/yield will not affect it. If App.hibernationResetsSteadyState is set to true, then the steady state flag will be cleared each time device exits hibernation.","title":"Steady State"},{"location":"apps/apps/#links","text":"Links are the mechanism used to define control flow in an app. Links are said to be from a given component's slot to another component's slot. Currently links are supported only between properties; you cannot link to an action slot. During link propagation, the from-property value is copied into the to-property . This mechanism could be used, for example, to link sensor inputs through control logic to control actuator outputs.","title":"Links"},{"location":"apps/apps/#services","text":"Services are special components that subclass from sys::Service . Services have three primary characteristics that set them apart from other types of components: Type Lookup : Services are easy to lookup by type via the App.lookupService method. This allows other components in the App to find a given service at runtime simply by knowing its type. Background work : Other components get a single callback, execute() , to do work during a scan cycle. Service components, on the other hand, have an additional callback, work() to handle background work during any time available at the end of a given scan cycle. Hibernation control : Each time the App finishes an execute cycle, it calls Service.canHibernate() on all services. If a service is not in a state where it can hibernate, it should return false. (For example, if a service is waiting for a network reply, it would return false.) Platform services for devices that never need to hibernate should always return false. Services are often used to provide functionality to other components. For example the UserService is used to lookup and authenticate user accounts. Many services such as protocol drivers also perform background work to service network messages.","title":"Services"},{"location":"apps/apps/#sax-file-format","text":"A SAX file is structured as follows: <sedonaApp> <schema> <kit name= 'sys' /> ... </schema> <app> <comp name= \"play\" id= \"1\" type= \"sys::Folder\" > <comp name= \"rampA\" id= \"7\" type= \"control::Ramp\" > <prop name= \"min\" val= \"20.00000\" /> <prop name= \"max\" val= \"80.00000\" /> </comp> ... </comp> ... </app> <links> <link from= \"/play/rampA.out\" to= \"/play/something.else\" /> ... </links> </sedonaApp> <sedonaApp> root element that contains: <schema> : contains <kit> elements <app> : contains <comp> elements <links> : contains <link> elements <kit> defines the kits used by the application: name : required kit name checksum : optional kit checksum; if omitted the latest version of the kit is assumed <comp> defines each component in the application: <comp> : nested elements map to nested components <prop> : property configuration for the component name : required name of component (limited in length) type : required qname of the component's type id : optional two byte identifier; if omitted an id is auto-generated <prop> defines the property value of a component within a <comp> element. Supported attributes: name : required name of property val : required value. Buf properties should be a base64 encoded value (unless asStr in which case just use string value). <link> element defines a link between two slots using the format of /path/comp.slot : from : the from component and slot name to : the to component and slot name","title":"SAX File Format"},{"location":"apps/apps/#sab-files","text":"While XML is a nice representation for tools to work with app files, XML is too big and difficult to work with in an embedded device. So we use the SAB format when we need a compact binary representation. Sedona Framework devices typically store their application as an SAB file (although often it might just be a location in flash memory versus a real file system).","title":"SAB Files"},{"location":"apps/apps/#schemas","text":"Sedona Framework application files, whether stored as SAX or SAB format, always contain a schema . This is simply a list of the kits (with matching kit checksums) that the app requires in order to run. The Sedona VM cannot start the app if its current scode image does not contain all the kits in the app's schema.","title":"Schemas"},{"location":"apps/apps/#apis","text":"If you want to develop tools for managing Sedona apps, check out the sedona.offline Java APIs for working with both SAX and SAB files: OfflineApp.encodeAppXml OfflineApp.decodeAppXml OfflineApp.encodeAppBinary OfflineApp.decodeAppBinary","title":"APIs"},{"location":"apps/security/","text":"Security \u00b6 Overview \u00b6 The Sedona Framework's security model is based upon the following principles: Users represent an authenticated user account (human or machine) Components are assigned to one or more of four security groups Slots are designated as operator level or admin level Users are assigned permission levels for the four groups Any network access such as Sox checks permissions before any operation Users \u00b6 Any Sedona Framework application that wishes to utilize security must include an instance of the sys::UserService containing at least one sys::User component. Each sys::User component represents a user account. User components must be direct children of the UserService. The Component.name of the User component is the username. Authentication \u00b6 Each User component stores a 20 byte cred property, which is the credentials hash of the user's password. Because credentials are a one-way hash, the password is never readable. Credentials are computed as follows: text = username + \":\" + password bytes = text from step 1 encoded as UTF-8 cred = SHA-1 hash of bytes in step 2 You can use the sedona.util.UserUtil to programmatically compute credentials. Or you can use the command line: D: \\s edona>sedonac sedona.util.UserUtil brian secret User: brian:secret Digest: 0x [ 74091bc2a1f43108df56281b6a74975bab86236f ] Base64: dAkbwqH0MQjfVigbanSXW6uGI28 = Network protocols that support authentication should work as follows: Generate a random nonce to be used only one time Send the nonce to the client Client should generate its credentials from username and password Client creates digest by hashing the credentials from step 3 with the nonce Client sends digest from step 4 to server Server computes expected digest from nonce and known credentials If client's digest from step 5 matches server's digest from step 6 then client is authenticated If a protocol doesn't support authentication, then it should define a configuration property that references a user account to use for security checking. Groups \u00b6 Components are assigned into one or more security groups. There are four security groups indicated by the least significant nibble in the Component.meta property: Group Value Group 1 0x01 Group 2 0x02 Group 3 0x04 Group 4 0x08 Components can be in multiple groups. For example: to assign a component to groups 2 and 3, set the bottom nibble of Component.meta to 0x06 . If a component is not included in any groups, then that component is not network accessible. Slots \u00b6 Every slot in a component is defined as operator level or admin level for security purposes. By default a slot is admin level. You can mark a slot operator level with the @operator facet. Use Slot.isOperator() to check a slot's level. Permissions \u00b6 There are seven security permissions defined as a bitmask: User Permission Bitmask User.or operator read 0x01 User.ow operator write 0x02 User.oi operator invoke 0x04 User.ar admin read 0x08 User.aw admin write 0x10 User.ai admin invoke 0x20 User.ua user admin 0x40 Users are granted zero or more of each of these seven permissions for each user group via the User.perm property. Each group's permissions is stored in a byte: Group Byte Group 1 byte 0 Group 2 byte 1 Group 3 byte 2 Group 4 byte 3 For example to grant a user operator read and write in group 1 and full permissions in group 3: perm = (( or | ow | oi | ar | aw | ai | ua ) << 16 ) | (( or | ow ) << 0 ) Permission Grants \u00b6 To compute the permissions a user has on a given component, we combine the user's configured permissions for each group the given component is a member of. Consider this example of a User's configured permissions: Groups or ow oi ar aw ai ua Group 1 x x - x - - - Group 2 x - x - - - - Group 3 x x x x x x x Group 4 - - - - - - - Some examples of what permissions this user would be granted: Permissions for component in group 1: or, ow, ar Permissions for component in group 2: or, oi Permissions for component in group 3: all Permissions for component in group 4: none Permissions for component in group 1 and 2: or, ow, oi, ar (union of 1 and 2) Access Control \u00b6 The previous sections explain how we compute the permissions granted to a user for a specific component. The following table defines what permissions are required for operations: Perm Operation or to read or subscribe to a component (1) or to read the current value of an operator property ow to modify the current value of an operator property oi to invoke an operator action ar to read the current value of an admin property (2) aw to modify the current value of an admin property ai to invoke an admin action aw on parent to add a child component aw on parent to reorder children components aw on component to rename aw on component to delete ar to read or subscribe to a components links ar/aw ar on \"from\" component and aw on \"to\" component to create link aw on \"to\" component to delete a link ua on User component to read, write, modify, delete Sox Implementation Notes: When reading a component's children via a tree update, unreadable children components are automatically omitted in the result When performing a property update or subscribe, admin properties are not serialized when not available Provisioning \u00b6 Each user is explicitly granted permissions to read and write the files associated with provisioning: Method Permission for file Byte User.provApp read/write \"app.sab\" 0x01 User.provKits read/write \"kits.scode\" 0x02 User.provSvm read/write \"svm.*\" 0x04","title":"Security"},{"location":"apps/security/#security","text":"","title":"Security"},{"location":"apps/security/#overview","text":"The Sedona Framework's security model is based upon the following principles: Users represent an authenticated user account (human or machine) Components are assigned to one or more of four security groups Slots are designated as operator level or admin level Users are assigned permission levels for the four groups Any network access such as Sox checks permissions before any operation","title":"Overview"},{"location":"apps/security/#users","text":"Any Sedona Framework application that wishes to utilize security must include an instance of the sys::UserService containing at least one sys::User component. Each sys::User component represents a user account. User components must be direct children of the UserService. The Component.name of the User component is the username.","title":"Users"},{"location":"apps/security/#authentication","text":"Each User component stores a 20 byte cred property, which is the credentials hash of the user's password. Because credentials are a one-way hash, the password is never readable. Credentials are computed as follows: text = username + \":\" + password bytes = text from step 1 encoded as UTF-8 cred = SHA-1 hash of bytes in step 2 You can use the sedona.util.UserUtil to programmatically compute credentials. Or you can use the command line: D: \\s edona>sedonac sedona.util.UserUtil brian secret User: brian:secret Digest: 0x [ 74091bc2a1f43108df56281b6a74975bab86236f ] Base64: dAkbwqH0MQjfVigbanSXW6uGI28 = Network protocols that support authentication should work as follows: Generate a random nonce to be used only one time Send the nonce to the client Client should generate its credentials from username and password Client creates digest by hashing the credentials from step 3 with the nonce Client sends digest from step 4 to server Server computes expected digest from nonce and known credentials If client's digest from step 5 matches server's digest from step 6 then client is authenticated If a protocol doesn't support authentication, then it should define a configuration property that references a user account to use for security checking.","title":"Authentication"},{"location":"apps/security/#groups","text":"Components are assigned into one or more security groups. There are four security groups indicated by the least significant nibble in the Component.meta property: Group Value Group 1 0x01 Group 2 0x02 Group 3 0x04 Group 4 0x08 Components can be in multiple groups. For example: to assign a component to groups 2 and 3, set the bottom nibble of Component.meta to 0x06 . If a component is not included in any groups, then that component is not network accessible.","title":"Groups"},{"location":"apps/security/#slots","text":"Every slot in a component is defined as operator level or admin level for security purposes. By default a slot is admin level. You can mark a slot operator level with the @operator facet. Use Slot.isOperator() to check a slot's level.","title":"Slots"},{"location":"apps/security/#permissions","text":"There are seven security permissions defined as a bitmask: User Permission Bitmask User.or operator read 0x01 User.ow operator write 0x02 User.oi operator invoke 0x04 User.ar admin read 0x08 User.aw admin write 0x10 User.ai admin invoke 0x20 User.ua user admin 0x40 Users are granted zero or more of each of these seven permissions for each user group via the User.perm property. Each group's permissions is stored in a byte: Group Byte Group 1 byte 0 Group 2 byte 1 Group 3 byte 2 Group 4 byte 3 For example to grant a user operator read and write in group 1 and full permissions in group 3: perm = (( or | ow | oi | ar | aw | ai | ua ) << 16 ) | (( or | ow ) << 0 )","title":"Permissions"},{"location":"apps/security/#permission-grants","text":"To compute the permissions a user has on a given component, we combine the user's configured permissions for each group the given component is a member of. Consider this example of a User's configured permissions: Groups or ow oi ar aw ai ua Group 1 x x - x - - - Group 2 x - x - - - - Group 3 x x x x x x x Group 4 - - - - - - - Some examples of what permissions this user would be granted: Permissions for component in group 1: or, ow, ar Permissions for component in group 2: or, oi Permissions for component in group 3: all Permissions for component in group 4: none Permissions for component in group 1 and 2: or, ow, oi, ar (union of 1 and 2)","title":"Permission Grants"},{"location":"apps/security/#access-control","text":"The previous sections explain how we compute the permissions granted to a user for a specific component. The following table defines what permissions are required for operations: Perm Operation or to read or subscribe to a component (1) or to read the current value of an operator property ow to modify the current value of an operator property oi to invoke an operator action ar to read the current value of an admin property (2) aw to modify the current value of an admin property ai to invoke an admin action aw on parent to add a child component aw on parent to reorder children components aw on component to rename aw on component to delete ar to read or subscribe to a components links ar/aw ar on \"from\" component and aw on \"to\" component to create link aw on \"to\" component to delete a link ua on User component to read, write, modify, delete Sox Implementation Notes: When reading a component's children via a tree update, unreadable children components are automatically omitted in the result When performing a property update or subscribe, admin properties are not serialized when not available","title":"Access Control"},{"location":"apps/security/#provisioning","text":"Each user is explicitly granted permissions to read and write the files associated with provisioning: Method Permission for file Byte User.provApp read/write \"app.sab\" 0x01 User.provKits read/write \"kits.scode\" 0x02 User.provSvm read/write \"svm.*\" 0x04","title":"Provisioning"},{"location":"deployment/kits/","text":"Kits \u00b6 Overview \u00b6 A kit is the basic unit of modularity in the Sedona Framework: Kits define a global name for identifying modules Kits define a global namespace for types and schemas Kits define code versioning Kits define the dependency graphs Kits encapsulate code, types, and meta-data Because kits define the top of the global namespace, each must have a globally unique name. The Sedona Framework requires kits to be prefixed with the vendor's name. See Vendors for the rules regarding vendor and kit naming. Versioning \u00b6 Version numbers are specified as a sequence of decimal numbers separated by the dot character. Convention is to use a four part version of major.minor.build[.patch] . The sedona.util.Version class provides a Java API for working with versions and doing comparisons. When a kit is compiled, sedonac uses the following rules to determine the version of the kit (from highest priority to lowest): If the -kitVersion switch appears on the command line, then that version is used If the version attribute in \"kit.xml\" explicitly defines a version, then that version is used Fallback is to use the \"buildVersion\" definition in \"lib/sedona.properties\" If the version is not specified in any of the above ways, a compile error occurs. Dependencies \u00b6 Dependencies identify a kit by name with a set of version constraints. Dependencies are used whenever the Sedona Framework tools need to resolve a specific kit version: Kits declare dependencies to use another kit's APIs ( kits.xml ). SCode images declare dependencies for the kits to link together ( scode ). Platform manifests declare dependencies on kits with native methods ( platform ). The sedona.Depend class provides a Java API for parsing and comparing dependencies: depend := name space* constraints constraints := constraint [space* \",\" space* constraint]* constraint := versionSimple | versionPlus | versionExact | versionRange | checksum versionSimple := version versionPlus := version space* \"+\" versionExact := version space* \"=\" versionRange := version space* \"-\" space* version version := digit [\".\" digit]* checksum := \"0x\" 8 hex digits digit := \"0\" - \"9\" Note that a simple version constraint such as foo 1.2 really means 1.2.* - it will match all build numbers and patch numbers within 1.2 . Likewise foo 1.2.64 will match all patch numbers within the 1.2.64 build. The + plus sign is used to specify a given version and anything greater. The = equals sign is used to specify an exact version match. Hence, foo 1.2.64= would match 1.2.64 but not 1.2 , or 1.2.64.1 . The - dash is used to specify an inclusive range. When using a range, then end version is matched using the same rules as a simple version. For example, not only 1.8 , 2.0.4 , and 3.1.1.1 , but also 4 , 4.2 , and 4.0.99 are all matches for foo 1.2-4 . You may also specify a list of constraints separated by commas. Multiple version dependencies are evaluated using a logical OR, i.e. any match is considered an overall match. A version constraint and a checksum constraint are evaluated using a logical AND, i.e. both must match. Examples: \"foo 1.2\" Any version of foo 1.2 with any build or patch number \"foo 1.2.64\" Any version of foo 1.2.64 with any patch number \"foo 0+\" Any version of foo - version wildcard \"foo 1.2+\" Any version of foo 1.2 or greater \"foo 1.2.64=\" Only foo version 1.2.64 \"foo 1.2.64=,0xaabbccdd\" Only foo version 1.2.64 with checksum 0xaabbccdd \"foo 1.2-1.4\" Any version between 1.2 and 1.4 inclusive \"foo 1.2,1.4\" Any version of 1.2 or 1.4 \"foo 0x1b02d4fc\" Any version of foo with a checksum of 0x1b02d4fc \"foo 1.0, 0x1b02d4fc\" Any version of foo 1.0 and a checksum of 0x1b02d4fc Vendors \u00b6 To avoid naming collisions, kits must be prepended by a vendor name. The vendor name is an alphanumeric text string and must be less than 32 characters. It is normally capitalized. Examples of valid vendor names: Acme Acme12 AcmeCompany Your kit names must be prepended with your vendor name. Kit names are alphanumeric and may contain the underscore ('_') character after the vendor prefix. The vendor name is treated as case-insensitive when it is verified, so a kit prefix need not have the same capitalization as the vendor name. All these are valid kit names for a kit owned by the Acme vendor: acme_control acmeControl Acmecontrol The prefix will also be checked against the vendor name specified in the kit manifest (again ignoring case); this will be handled at compile time by sedonac when it generates your kit manifest. <kitManifest name= \"acme_control\" vendor= \"Acme\" checksum= \"40464bf3\" hasNatives= \"false\" doc= \"false\" version= \"1.0.5\" description= \"Basic function block library\" > Visit http://sedonadev.org to register your vendor name.","title":"Kits"},{"location":"deployment/kits/#kits","text":"","title":"Kits"},{"location":"deployment/kits/#overview","text":"A kit is the basic unit of modularity in the Sedona Framework: Kits define a global name for identifying modules Kits define a global namespace for types and schemas Kits define code versioning Kits define the dependency graphs Kits encapsulate code, types, and meta-data Because kits define the top of the global namespace, each must have a globally unique name. The Sedona Framework requires kits to be prefixed with the vendor's name. See Vendors for the rules regarding vendor and kit naming.","title":"Overview"},{"location":"deployment/kits/#versioning","text":"Version numbers are specified as a sequence of decimal numbers separated by the dot character. Convention is to use a four part version of major.minor.build[.patch] . The sedona.util.Version class provides a Java API for working with versions and doing comparisons. When a kit is compiled, sedonac uses the following rules to determine the version of the kit (from highest priority to lowest): If the -kitVersion switch appears on the command line, then that version is used If the version attribute in \"kit.xml\" explicitly defines a version, then that version is used Fallback is to use the \"buildVersion\" definition in \"lib/sedona.properties\" If the version is not specified in any of the above ways, a compile error occurs.","title":"Versioning"},{"location":"deployment/kits/#dependencies","text":"Dependencies identify a kit by name with a set of version constraints. Dependencies are used whenever the Sedona Framework tools need to resolve a specific kit version: Kits declare dependencies to use another kit's APIs ( kits.xml ). SCode images declare dependencies for the kits to link together ( scode ). Platform manifests declare dependencies on kits with native methods ( platform ). The sedona.Depend class provides a Java API for parsing and comparing dependencies: depend := name space* constraints constraints := constraint [space* \",\" space* constraint]* constraint := versionSimple | versionPlus | versionExact | versionRange | checksum versionSimple := version versionPlus := version space* \"+\" versionExact := version space* \"=\" versionRange := version space* \"-\" space* version version := digit [\".\" digit]* checksum := \"0x\" 8 hex digits digit := \"0\" - \"9\" Note that a simple version constraint such as foo 1.2 really means 1.2.* - it will match all build numbers and patch numbers within 1.2 . Likewise foo 1.2.64 will match all patch numbers within the 1.2.64 build. The + plus sign is used to specify a given version and anything greater. The = equals sign is used to specify an exact version match. Hence, foo 1.2.64= would match 1.2.64 but not 1.2 , or 1.2.64.1 . The - dash is used to specify an inclusive range. When using a range, then end version is matched using the same rules as a simple version. For example, not only 1.8 , 2.0.4 , and 3.1.1.1 , but also 4 , 4.2 , and 4.0.99 are all matches for foo 1.2-4 . You may also specify a list of constraints separated by commas. Multiple version dependencies are evaluated using a logical OR, i.e. any match is considered an overall match. A version constraint and a checksum constraint are evaluated using a logical AND, i.e. both must match. Examples: \"foo 1.2\" Any version of foo 1.2 with any build or patch number \"foo 1.2.64\" Any version of foo 1.2.64 with any patch number \"foo 0+\" Any version of foo - version wildcard \"foo 1.2+\" Any version of foo 1.2 or greater \"foo 1.2.64=\" Only foo version 1.2.64 \"foo 1.2.64=,0xaabbccdd\" Only foo version 1.2.64 with checksum 0xaabbccdd \"foo 1.2-1.4\" Any version between 1.2 and 1.4 inclusive \"foo 1.2,1.4\" Any version of 1.2 or 1.4 \"foo 0x1b02d4fc\" Any version of foo with a checksum of 0x1b02d4fc \"foo 1.0, 0x1b02d4fc\" Any version of foo 1.0 and a checksum of 0x1b02d4fc","title":"Dependencies"},{"location":"deployment/kits/#vendors","text":"To avoid naming collisions, kits must be prepended by a vendor name. The vendor name is an alphanumeric text string and must be less than 32 characters. It is normally capitalized. Examples of valid vendor names: Acme Acme12 AcmeCompany Your kit names must be prepended with your vendor name. Kit names are alphanumeric and may contain the underscore ('_') character after the vendor prefix. The vendor name is treated as case-insensitive when it is verified, so a kit prefix need not have the same capitalization as the vendor name. All these are valid kit names for a kit owned by the Acme vendor: acme_control acmeControl Acmecontrol The prefix will also be checked against the vendor name specified in the kit manifest (again ignoring case); this will be handled at compile time by sedonac when it generates your kit manifest. <kitManifest name= \"acme_control\" vendor= \"Acme\" checksum= \"40464bf3\" hasNatives= \"false\" doc= \"false\" version= \"1.0.5\" description= \"Basic function block library\" > Visit http://sedonadev.org to register your vendor name.","title":"Vendors"},{"location":"deployment/schema/","text":"Schema \u00b6 Overview \u00b6 Because the Sedona Framework is designed to work in very constrained embedded environments, we have to make design tradeoffs. One of the biggest tradeoffs is using a low level binary format for Sedona Framework application files and the Sox protocol. This compact form requires out-of-band information for encoding and decoding. For example the binary format does not contain kit, type, or slot definitions, only their numeric ids. So in order to reconstruct the original app from its binary SAB file, we must have some external way to map those ids to the right definitions. Correct versioning is also important, since kits may evolve over time to include new types and new slots which could change their ids. The schema tells us how to create the right mapping for the app, by specifying the kit versions and checksums that were used to create the app. Kit Parts \u00b6 Every kit contains zero or more named types. Each type declares zero or more slots. For a given version of a kit, there is a fixed list of types and their declared slots. Each slot has a fixed name, flags, and type. When a kit is compiled from source into a kit zip file, the compiler generates a checksum for this fixed list of types and slots. The combination of a kit name and checksum is called a kit part . The kit meta-data, checksum, and list of types and slots is included in the kit file as an XML file called \"manifest.xml\". Here is an example manifest file: <?xml version='1.0'?> <kitManifest name= \"sysTest\" checksum= \"da52f78f\" version= \"1.0\" vendor= \"Tridium\" description= \"Test suite for core language and sys APIs\" buildHost= \"BLAZE\" buildTime= \"2007-05-17T16:21:08.030-04:00\" > <type id= \"0\" name= \"AbstractTestComp\" base= \"sys::Component\" > <slot id= \"0\" name= \"az\" type= \"bool\" /> <slot id= \"1\" name= \"ai\" type= \"int\" /> </type> <type id= \"1\" name= \"TestComp\" base= \"sysTest::AbstractTestComp\" > <slot id= \"0\" name= \"z1\" type= \"bool\" /> <slot id= \"1\" name= \"b1\" type= \"byte\" /> <slot id= \"2\" name= \"addF1\" type= \"float\" flags= \"a\" /> </type> <type id= \"2\" name= \"SubTestComp\" base= \"sysTest::TestComp\" > <slot id= \"0\" name= \"sb\" type= \"byte\" /> <slot id= \"1\" name= \"si\" type= \"int\" /> </type> </kitManifest> The checksum is based only on the kit's component types (those that subclass sys::Component ) and slots. The checksum is not based on variable meta-data such as the kit's version number, or on non-component types which could never appear in an app definition. This means that multiple versions of the same kit might share the same checksum if no component types or slots have been modified between versions. Don't confuse version with checksum . Version represents a revision of the whole kit including its code, algorithms, and when it was built; the version only changes when the developer chooses to specify a different version number. Checksum represents a revision of the declared types and slots, and it changes automatically whenever the type or slot definitions change. Kit Database \u00b6 Within a Sedona Framework installation we store all the local copies of kits with the file pattern: {Sedona home}/kits/{kit}/{kit}-{checksum}-{version}.kit For example: {Sedona home}/ kits/ control/ control-cdf5f0f0-1.0.28.kit control-cdf5f0f0-1.0.29.kit control-1239c0de-1.0.29.kit sys/ sys-ef94b11d-1.0.28.kit . . . We call this directory the kit database . It can store multiple versions of each kit with different checksums. The sedona.kit.* Java APIs can be used to work with the kit database. Manifest Database \u00b6 Kit files contain all the information we need when working with schema. However, to interface with a device that is using a kit we don't need the full kit file, only the XML manifest file that represents it. So in addition to the kit database, we also create a manifest database with the file pattern: {Sedona home}/manifests/{kit}/{kit}-{checksum}.xml For example: {Sedona home}/ manifests/ control/ control-cdf5f0f0.xml control-1239c0de.xml sys/ sys-ef94b11d.xml . . . By storing the manifests in a separate database, we don't need to use the kit files themselves to work with the kits' types. This is typically more efficient, and in addition it allows a vendor to publish just the manifests for their kits as opposed to entire kit files. Note, however, that manifests cannot be used to create an SCode image. Building an SCode image requires access to the actual kit files. The sedona.manifest.* APIs are used to work with manifests and the manifest database via the Java toolkit. The KitManifest class represents the information stored a kit manifest file and provides methods for encoding and decoding from XML. The ManifestDb class is used to load and save KitManifest s to the file system. Schemas \u00b6 A Sedona Framework application is composed of multiple kits. A specific list of kit parts (kits at a specific checksum revision) is called a schema . Matching schemas guarantee compatibility between the app running on the device and the app's representation elsewhere, such as in a PC-based tool. Only when a kit manifest is accessed for a specific schema can we correctly interpret binary information such as kit id and slot id. For example the kit id for the \"control\" kit might be 3 in one schema, but 5 in another schema that has a different list of kit parts. Slot ids for a given kit part can also change across schemas, if there are changes to slots inherited from base types. The Java API for working with schemas is in sedona.* . Schemas are built with the sedona.Schema class from a list of KitParts which are resolved against the manifest database. Assuming all the kit parts can be resolved to kit manifests, we can build a complete representation of the schema including the full list of kits, types, and slots along with their respective ids. The Schema is then used to work with binary formats such as \".sab\" files and Sox messages. Kits versus Manifests \u00b6 So when do you need a kit and when do you only need a manifest? This table helps summarize the differences: What Encapsulates Versioned By Uses Manifest type and slot schema checksum sax, sab, and sox Kit code version number compiling dependencies and scode images For example when working with an application file or Sox, only the type schemas are needed. No knowledge of the internal code is required. However when compiling, you need the full kit that contains the actual code. So a manifest is somewhat analogous to a C header file, which declares function prototypes but does not contain any code for the functions. Manifests are versioned with a checksum each time a type or slot definition is modified. Kits are versioned with a version number typically whenever code is modified. Resolving Manifests \u00b6 To fully connect to a remote Sedona device, there must be local copies of the kit manifests corresponding to the device's current schema. The recommended rules for locating each kit manifest are: Check the local manifest database first; if the manifest is found then use it Check the local kit database for the given kit, if found then extract the manifest file and store it in the local manifest database Download the manifest from sedonadev.org to the local manifest database These steps are automatically implemented by the Sedona ManifestDb API. If any manifests required by the schema are not found a MissingKitManifestException is thrown, which contains information about the specific manifests that are missing. This information can be used to compose a friendly error message to the user about why the connection failed, or to request the missing file(s) from the device itself (see next section). Kit Manifest Server \u00b6 Beginning with Sedona 1.2, the Sedona Sox Client supports retrieving missing manifest files from the remote Sedona device itself. If it detects the MissingKitManifestException when resolving the device's schema locally, it requests the missing manifests from the device. If the device is set up to serve the requested manifests it will send them. This feature can make it easier to deploy new devices, as they can be shipped with the necessary manifests installed on the device rather than requiring them to be installed separately in advance on the Sox Client host. Serving kit manifests is accomplished very simply, using a special filename prefix called a scheme to indicate to the device where to look for the file in its local file system. This allows the manifest retrieval to be accomplished using the regular Sox file transfer protocol. When the Sox Client detects that a manifest is not found by the usual rules described above, it sends a Sox \"get file\" request to the device using the filename of the missing manifest adding the appropriate scheme prefix. When the device receives the request, it recognizes by the prefix that this is a manifest file, and looks in its local database for the one requested. If the file is found, it sends it via Sox back to the requesting client. Implementation Details \u00b6 To make this feature work on a given Sedona platform, the following things must be true: The required manifest file(s) must be stored on the device The \" m: \" scheme must be implemented on the remote Sedona device (see below) The sedonadev.autodownload property in sedona.properties must be set to false, or omitted entirely A scheme is simply a prefix to the filename, such as \"m:\", which is translated on the remote device into a local path where the file should be located. There are two ways to implement a scheme: It can be implemented entirely at the native level, encapsulated in the appropriate sys::FileStore natives It can be implemented at the Sedona level using a platform-specific FileStore subclass. If it is implemented at the native level, then at the Sedona level the device treats the prefix as part of the actual filename. The native implementation of FileStore.doOpen() must then strip off the prefix and substitute the path to the local manifest database. The resulting full path to the file is then passed to the local file system and handled just like any other file transfer request. If it is implemented using a FileStore subclass, then the FileStore subclass should override the accept() method such that it returns true if the filename begins with the desired prefix. Then the open() method can be overridden to strip off the scheme prefix and substitute the desired path, or the FileStore subclass may have an additional native method that provides the appropriate path for all files in that scheme. The Sedona 1.2 open source includes a class in the 'win32' platform kit, called Win32ProvDbFileStore . This class demonstrates the second (Sedona-level) implementation strategy described above. N.B. An ambitious Sedona developer could use this same strategy to provide kit files and/or platform manifests as well as kit manifests. Review \u00b6 To summarize the schema pipeline: Checksum : Generated by the compiler when compiling a kit file from source, the checksum is based on the declared types and slots in the kit. Kit Part : The combination of kit name and kit checksum that uniquely identifies a kit for a specific schema revision. Kit Manifest : A file containing a kit's checksum and type definitions, stored as a zip archive entry named \"manifest.xml\". Kit Database : A local database of kit versions, created and maintained by the Sedona Framework Java toolkit. Manifest Database : A local database of all the kit manifests that have been accumulated, created, and maintained by the Sedona Framework Java toolkit. These manifests are XML files keyed by kit name and checksum. Schema : A list of kit parts aggregated by the Sedona Framework Java toolkit. A schema defines the full meta-data required to work with binary format entities with matching schemas. Each Sedona Framework runtime and application file has a single, fixed schema. The Java toolkit models schemas via the sedona.Schema API.","title":"Schema"},{"location":"deployment/schema/#schema","text":"","title":"Schema"},{"location":"deployment/schema/#overview","text":"Because the Sedona Framework is designed to work in very constrained embedded environments, we have to make design tradeoffs. One of the biggest tradeoffs is using a low level binary format for Sedona Framework application files and the Sox protocol. This compact form requires out-of-band information for encoding and decoding. For example the binary format does not contain kit, type, or slot definitions, only their numeric ids. So in order to reconstruct the original app from its binary SAB file, we must have some external way to map those ids to the right definitions. Correct versioning is also important, since kits may evolve over time to include new types and new slots which could change their ids. The schema tells us how to create the right mapping for the app, by specifying the kit versions and checksums that were used to create the app.","title":"Overview"},{"location":"deployment/schema/#kit-parts","text":"Every kit contains zero or more named types. Each type declares zero or more slots. For a given version of a kit, there is a fixed list of types and their declared slots. Each slot has a fixed name, flags, and type. When a kit is compiled from source into a kit zip file, the compiler generates a checksum for this fixed list of types and slots. The combination of a kit name and checksum is called a kit part . The kit meta-data, checksum, and list of types and slots is included in the kit file as an XML file called \"manifest.xml\". Here is an example manifest file: <?xml version='1.0'?> <kitManifest name= \"sysTest\" checksum= \"da52f78f\" version= \"1.0\" vendor= \"Tridium\" description= \"Test suite for core language and sys APIs\" buildHost= \"BLAZE\" buildTime= \"2007-05-17T16:21:08.030-04:00\" > <type id= \"0\" name= \"AbstractTestComp\" base= \"sys::Component\" > <slot id= \"0\" name= \"az\" type= \"bool\" /> <slot id= \"1\" name= \"ai\" type= \"int\" /> </type> <type id= \"1\" name= \"TestComp\" base= \"sysTest::AbstractTestComp\" > <slot id= \"0\" name= \"z1\" type= \"bool\" /> <slot id= \"1\" name= \"b1\" type= \"byte\" /> <slot id= \"2\" name= \"addF1\" type= \"float\" flags= \"a\" /> </type> <type id= \"2\" name= \"SubTestComp\" base= \"sysTest::TestComp\" > <slot id= \"0\" name= \"sb\" type= \"byte\" /> <slot id= \"1\" name= \"si\" type= \"int\" /> </type> </kitManifest> The checksum is based only on the kit's component types (those that subclass sys::Component ) and slots. The checksum is not based on variable meta-data such as the kit's version number, or on non-component types which could never appear in an app definition. This means that multiple versions of the same kit might share the same checksum if no component types or slots have been modified between versions. Don't confuse version with checksum . Version represents a revision of the whole kit including its code, algorithms, and when it was built; the version only changes when the developer chooses to specify a different version number. Checksum represents a revision of the declared types and slots, and it changes automatically whenever the type or slot definitions change.","title":"Kit Parts"},{"location":"deployment/schema/#kit-database","text":"Within a Sedona Framework installation we store all the local copies of kits with the file pattern: {Sedona home}/kits/{kit}/{kit}-{checksum}-{version}.kit For example: {Sedona home}/ kits/ control/ control-cdf5f0f0-1.0.28.kit control-cdf5f0f0-1.0.29.kit control-1239c0de-1.0.29.kit sys/ sys-ef94b11d-1.0.28.kit . . . We call this directory the kit database . It can store multiple versions of each kit with different checksums. The sedona.kit.* Java APIs can be used to work with the kit database.","title":"Kit Database"},{"location":"deployment/schema/#manifest-database","text":"Kit files contain all the information we need when working with schema. However, to interface with a device that is using a kit we don't need the full kit file, only the XML manifest file that represents it. So in addition to the kit database, we also create a manifest database with the file pattern: {Sedona home}/manifests/{kit}/{kit}-{checksum}.xml For example: {Sedona home}/ manifests/ control/ control-cdf5f0f0.xml control-1239c0de.xml sys/ sys-ef94b11d.xml . . . By storing the manifests in a separate database, we don't need to use the kit files themselves to work with the kits' types. This is typically more efficient, and in addition it allows a vendor to publish just the manifests for their kits as opposed to entire kit files. Note, however, that manifests cannot be used to create an SCode image. Building an SCode image requires access to the actual kit files. The sedona.manifest.* APIs are used to work with manifests and the manifest database via the Java toolkit. The KitManifest class represents the information stored a kit manifest file and provides methods for encoding and decoding from XML. The ManifestDb class is used to load and save KitManifest s to the file system.","title":"Manifest Database"},{"location":"deployment/schema/#schemas","text":"A Sedona Framework application is composed of multiple kits. A specific list of kit parts (kits at a specific checksum revision) is called a schema . Matching schemas guarantee compatibility between the app running on the device and the app's representation elsewhere, such as in a PC-based tool. Only when a kit manifest is accessed for a specific schema can we correctly interpret binary information such as kit id and slot id. For example the kit id for the \"control\" kit might be 3 in one schema, but 5 in another schema that has a different list of kit parts. Slot ids for a given kit part can also change across schemas, if there are changes to slots inherited from base types. The Java API for working with schemas is in sedona.* . Schemas are built with the sedona.Schema class from a list of KitParts which are resolved against the manifest database. Assuming all the kit parts can be resolved to kit manifests, we can build a complete representation of the schema including the full list of kits, types, and slots along with their respective ids. The Schema is then used to work with binary formats such as \".sab\" files and Sox messages.","title":"Schemas"},{"location":"deployment/schema/#kits-versus-manifests","text":"So when do you need a kit and when do you only need a manifest? This table helps summarize the differences: What Encapsulates Versioned By Uses Manifest type and slot schema checksum sax, sab, and sox Kit code version number compiling dependencies and scode images For example when working with an application file or Sox, only the type schemas are needed. No knowledge of the internal code is required. However when compiling, you need the full kit that contains the actual code. So a manifest is somewhat analogous to a C header file, which declares function prototypes but does not contain any code for the functions. Manifests are versioned with a checksum each time a type or slot definition is modified. Kits are versioned with a version number typically whenever code is modified.","title":"Kits versus Manifests"},{"location":"deployment/schema/#resolving-manifests","text":"To fully connect to a remote Sedona device, there must be local copies of the kit manifests corresponding to the device's current schema. The recommended rules for locating each kit manifest are: Check the local manifest database first; if the manifest is found then use it Check the local kit database for the given kit, if found then extract the manifest file and store it in the local manifest database Download the manifest from sedonadev.org to the local manifest database These steps are automatically implemented by the Sedona ManifestDb API. If any manifests required by the schema are not found a MissingKitManifestException is thrown, which contains information about the specific manifests that are missing. This information can be used to compose a friendly error message to the user about why the connection failed, or to request the missing file(s) from the device itself (see next section).","title":"Resolving Manifests"},{"location":"deployment/schema/#kit-manifest-server","text":"Beginning with Sedona 1.2, the Sedona Sox Client supports retrieving missing manifest files from the remote Sedona device itself. If it detects the MissingKitManifestException when resolving the device's schema locally, it requests the missing manifests from the device. If the device is set up to serve the requested manifests it will send them. This feature can make it easier to deploy new devices, as they can be shipped with the necessary manifests installed on the device rather than requiring them to be installed separately in advance on the Sox Client host. Serving kit manifests is accomplished very simply, using a special filename prefix called a scheme to indicate to the device where to look for the file in its local file system. This allows the manifest retrieval to be accomplished using the regular Sox file transfer protocol. When the Sox Client detects that a manifest is not found by the usual rules described above, it sends a Sox \"get file\" request to the device using the filename of the missing manifest adding the appropriate scheme prefix. When the device receives the request, it recognizes by the prefix that this is a manifest file, and looks in its local database for the one requested. If the file is found, it sends it via Sox back to the requesting client.","title":"Kit Manifest Server"},{"location":"deployment/schema/#implementation-details","text":"To make this feature work on a given Sedona platform, the following things must be true: The required manifest file(s) must be stored on the device The \" m: \" scheme must be implemented on the remote Sedona device (see below) The sedonadev.autodownload property in sedona.properties must be set to false, or omitted entirely A scheme is simply a prefix to the filename, such as \"m:\", which is translated on the remote device into a local path where the file should be located. There are two ways to implement a scheme: It can be implemented entirely at the native level, encapsulated in the appropriate sys::FileStore natives It can be implemented at the Sedona level using a platform-specific FileStore subclass. If it is implemented at the native level, then at the Sedona level the device treats the prefix as part of the actual filename. The native implementation of FileStore.doOpen() must then strip off the prefix and substitute the path to the local manifest database. The resulting full path to the file is then passed to the local file system and handled just like any other file transfer request. If it is implemented using a FileStore subclass, then the FileStore subclass should override the accept() method such that it returns true if the filename begins with the desired prefix. Then the open() method can be overridden to strip off the scheme prefix and substitute the desired path, or the FileStore subclass may have an additional native method that provides the appropriate path for all files in that scheme. The Sedona 1.2 open source includes a class in the 'win32' platform kit, called Win32ProvDbFileStore . This class demonstrates the second (Sedona-level) implementation strategy described above. N.B. An ambitious Sedona developer could use this same strategy to provide kit files and/or platform manifests as well as kit manifests.","title":"Implementation Details"},{"location":"deployment/schema/#review","text":"To summarize the schema pipeline: Checksum : Generated by the compiler when compiling a kit file from source, the checksum is based on the declared types and slots in the kit. Kit Part : The combination of kit name and kit checksum that uniquely identifies a kit for a specific schema revision. Kit Manifest : A file containing a kit's checksum and type definitions, stored as a zip archive entry named \"manifest.xml\". Kit Database : A local database of kit versions, created and maintained by the Sedona Framework Java toolkit. Manifest Database : A local database of all the kit manifests that have been accumulated, created, and maintained by the Sedona Framework Java toolkit. These manifests are XML files keyed by kit name and checksum. Schema : A list of kit parts aggregated by the Sedona Framework Java toolkit. A schema defines the full meta-data required to work with binary format entities with matching schemas. Each Sedona Framework runtime and application file has a single, fixed schema. The Java toolkit models schemas via the sedona.Schema API.","title":"Review"},{"location":"development/niagara/","text":"Niagara \u00b6 Overview \u00b6 This section covers integration of the Sedona Framework with the Niagara AX Framework. Sedona Framework components in Niagara Provisioning Sedona Framework-enabled devices from Niagara Sedona in Niagara \u00b6 This section details how to write Sedona Framework components in such a way that they can be easily integrated with the Niagara AX component architecture. This section will help developers familiar with the Niagara AX Framework to understand how Sedona idioms translate to Niagara idioms. In particular, this section will detail various aspects of programming Sedona Framework components so that the user experience inside Workbench is very similar to that of using standard BComponents in Niagara. How Niagara uses sys::Facets when modeling Sedona Framework Components Niagara Views on Sedona Framework Components In Niagara, all Sedona Framework components are modeled as a special kind of BComponent called BSedonaComponent. Regardless of your Sedona Framework component type, it will be modeled as a BSedonaComponent, which essentially wraps your sys::Component type. The primary means of communicating information about a Sedona Framework component type and its slots to Niagara is by using sys::Facets . The following tables detail which facets are recognized by Niagara, and how they are used when Niagara constructs a BSedonaComponent to model your sys::Component . Component Facets \u00b6 The following table lists the facets for a sys::Component type that Niagara will recognize. Facet Type Description niagaraIcon Str The Ord to the location of the icon to use for this component palette bool If set to false, then the type will not be displayed in the Sedona Palette. Otherwise, it will be shown in the palette Examples @niagaraIcon = \"module://icons/x16/control/math/add.png\" public class Add2 extends Component { ... } @palette = false public class CommonBase extends Component { ... } Slot Facets \u00b6 BComponent slot flags \u00b6 If you define a facet on your Sedona component slot that has the same name as a Niagara flag, and its value is true or false , then the corresponding slot in the BSedonaComponent will be likewise set; otherwise, the facet will simply be treated like all other facets (see BComponent facet list ). The most common slot flags to set are listed in the table below. Facet Description readonly The readonly flag is used to indicate slots that cannot be changed by the user. hidden Hidden slots are designed to be invisible to the user, and exist only for Java developers. User interfaces should rarely display hidden slots. summary Summary properties are the focal points of any given BComponent. This flag is used by user interface tools to indicate primary properties for display. This might be as a column in a table, or as a glyph in a graphical programming tool. confirmRequired When the action is invoked by a user, a confirmation dialog must be acknowledged before proceeding. operator This gives a slot an operator security level. By default when this flag is clear, the slot has an admin security level. noAudit Setting this flag prevents property changes and action invocations from being audited. Note All Sedona runtime slots are treated as summary unless the summary facet is explicitly set to false: @summary=false . Examples: public class Foo extends Component { ... // Require the user to confirm that they actually // want to reboot the system before executing the action. @confirmRequired action void reboot() { ... } // Don't want UI to allow user to edit password property @config @readonly @asStr property Buf(17) password // This slot we don't want displayed to users, but we // want operators to be allowed to change it. @hidden @operator property int debugLevel = 0 } Note See Component Properties for a discussion of @config and other Sedona-only facets. BComponent slot facets \u00b6 If a slot facet does not match a Niagara flag name, then it will stored as a a BFacet for the slot. Some BFacets have a special meaning in Niagara. This table lists some of the more common BFacets: Facet Type Description min number Used to specify the minimum value for a number, or the minimum number of characters in a Str. max number Used to specify the maximum value for a number, or the maximum number of characters in a Str. unit Str Display text that describes the property's units. precision int Used with floating point numbers to define the number of digits after the decimal point. radix int Used with integers to qualify base radix. showSeparators bool Used with numerics to enable/disable displaying of separators between every 3 digits (e.g. 10,000 vs. 10000). multiLine bool Used with Str to support a multiline editor. fieldWidth int Used with Str to specify the number of columns in a text field. allowNull bool Tells the field editor allow the value to be set to null. fieldEditor Str Indicates the BTypeSpec of the field editor to use for editing a property value. It overrides the default field editor registered for the property's value. trueText Str Display text to be used for a boolean property when true. falseText Str Display text to be used for a boolean property when false. nullText Str Display text to be used for a boolean property when null. Examples: public class Foo extends Component { ... // Property for password - must be at least 8 chars long // and no more than 16. @min=8 @max=16 @config @asStr property Buf(17) pwd // The debug level should be specified in base 16. @radix=16 @min=0 @config property int dbgLevel = 0x1234 } Niagara Views \u00b6 Normally in Niagara, views are registered on a BTypeSpec by using the <agent/> specification in the module-include.xml file of your module. However, since all Sedona Framework components are modeled as BSedonaComponents in Niagara, a different mechanism is used to register views on your Sedona Framework component. Namely, <def/> blocks are used to define agents on specific Sedona Framework component types. An example follows. Suppose you have developed a Service called MyService in kit foo . The qname for this type is foo::MyService . Suppose, further, that you have written a Niagara view BMyServiceView to manage this service and that it resides in module bar . The BTypeSpec for this service is bar:MyServiceView . To register your view on the MyService service, you would add the following lines to the module-include.xml for your module: <defs> <!-- This declares the agent on the foo::MyService service --> <def name= \"sedona.foo::MyService#agent\" value= \"bar:MyServiceView\" /> </def> <types> ... <!-- Declare the Niagara type as usual, but no agent block is required --> <type name= \"MyServiceView\" class= \"com.bar.BMyServiceView\" /> ... </types> When your view loads, a BISedonaComponent will be passed to the doLoadValue method of your view. protected void doLoadValue ( BObject value , Context cx ) throws Exception { BISedonaComponent myService = ( BISedonaComponent ) value ; // See the javax.baja.sedona.sys.BISedonaComponent interface // for more details. } Note The concrete class BSedonaComponent is deprecated as of the TXS 1.1 release. You should migrate your views to use the new BISedonaComponent interface instead. If you have questions about writing views for Sedona Framework components, ask them on one of the Sedona Framework forums on Niagara Central . Provisioning from Niagara \u00b6 When using Niagara tools to provision a Sedona Framework-enabled device, there are a few things to be aware of: File names : Niagara makes assumptions about the file names used to launch the remote platform. In particular, it assumes: the SVM is named \"svm.bin\" (or \"svm.exe\"), the kit bundle file is named \"kits.scode\", and the app binary is named \"app.sab\". File PUT : To be Sox compliant, Sedona Framework platforms must use app.sab as the file name of the app to run, and kits.scode as the file name of the scode image to run. Further, to be Sox compliant, a platform must look for an app.sab.stage and a kits.scode.stage file when starting and rename them to app.sab and kits.scode respectively before the SVM attempts to load the app and scode. Hence, when Niagara writes new app and scode files to the device, it does so in three stages: 1. Writes the app as `app.sab.writing` and the scode as `kits.scode.writing`. 2. Renames those files to `app.sab.stage` and `kits.scode.stage` respectively. 3. Restarts the device. File GET : A file GET operation from Sedona to Niagara should prompt the user for the path and filename to be used on the local host for the received file. The name of the file as it is being transferred is normally not visible (or relevant) to the user.","title":"Niagara"},{"location":"development/niagara/#niagara","text":"","title":"Niagara"},{"location":"development/niagara/#overview","text":"This section covers integration of the Sedona Framework with the Niagara AX Framework. Sedona Framework components in Niagara Provisioning Sedona Framework-enabled devices from Niagara","title":"Overview"},{"location":"development/niagara/#sedona-in-niagara","text":"This section details how to write Sedona Framework components in such a way that they can be easily integrated with the Niagara AX component architecture. This section will help developers familiar with the Niagara AX Framework to understand how Sedona idioms translate to Niagara idioms. In particular, this section will detail various aspects of programming Sedona Framework components so that the user experience inside Workbench is very similar to that of using standard BComponents in Niagara. How Niagara uses sys::Facets when modeling Sedona Framework Components Niagara Views on Sedona Framework Components In Niagara, all Sedona Framework components are modeled as a special kind of BComponent called BSedonaComponent. Regardless of your Sedona Framework component type, it will be modeled as a BSedonaComponent, which essentially wraps your sys::Component type. The primary means of communicating information about a Sedona Framework component type and its slots to Niagara is by using sys::Facets . The following tables detail which facets are recognized by Niagara, and how they are used when Niagara constructs a BSedonaComponent to model your sys::Component .","title":"Sedona in Niagara"},{"location":"development/niagara/#component-facets","text":"The following table lists the facets for a sys::Component type that Niagara will recognize. Facet Type Description niagaraIcon Str The Ord to the location of the icon to use for this component palette bool If set to false, then the type will not be displayed in the Sedona Palette. Otherwise, it will be shown in the palette Examples @niagaraIcon = \"module://icons/x16/control/math/add.png\" public class Add2 extends Component { ... } @palette = false public class CommonBase extends Component { ... }","title":"Component Facets"},{"location":"development/niagara/#slot-facets","text":"","title":"Slot Facets"},{"location":"development/niagara/#bcomponent-slot-flags","text":"If you define a facet on your Sedona component slot that has the same name as a Niagara flag, and its value is true or false , then the corresponding slot in the BSedonaComponent will be likewise set; otherwise, the facet will simply be treated like all other facets (see BComponent facet list ). The most common slot flags to set are listed in the table below. Facet Description readonly The readonly flag is used to indicate slots that cannot be changed by the user. hidden Hidden slots are designed to be invisible to the user, and exist only for Java developers. User interfaces should rarely display hidden slots. summary Summary properties are the focal points of any given BComponent. This flag is used by user interface tools to indicate primary properties for display. This might be as a column in a table, or as a glyph in a graphical programming tool. confirmRequired When the action is invoked by a user, a confirmation dialog must be acknowledged before proceeding. operator This gives a slot an operator security level. By default when this flag is clear, the slot has an admin security level. noAudit Setting this flag prevents property changes and action invocations from being audited. Note All Sedona runtime slots are treated as summary unless the summary facet is explicitly set to false: @summary=false . Examples: public class Foo extends Component { ... // Require the user to confirm that they actually // want to reboot the system before executing the action. @confirmRequired action void reboot() { ... } // Don't want UI to allow user to edit password property @config @readonly @asStr property Buf(17) password // This slot we don't want displayed to users, but we // want operators to be allowed to change it. @hidden @operator property int debugLevel = 0 } Note See Component Properties for a discussion of @config and other Sedona-only facets.","title":"BComponent slot flags"},{"location":"development/niagara/#bcomponent-slot-facets","text":"If a slot facet does not match a Niagara flag name, then it will stored as a a BFacet for the slot. Some BFacets have a special meaning in Niagara. This table lists some of the more common BFacets: Facet Type Description min number Used to specify the minimum value for a number, or the minimum number of characters in a Str. max number Used to specify the maximum value for a number, or the maximum number of characters in a Str. unit Str Display text that describes the property's units. precision int Used with floating point numbers to define the number of digits after the decimal point. radix int Used with integers to qualify base radix. showSeparators bool Used with numerics to enable/disable displaying of separators between every 3 digits (e.g. 10,000 vs. 10000). multiLine bool Used with Str to support a multiline editor. fieldWidth int Used with Str to specify the number of columns in a text field. allowNull bool Tells the field editor allow the value to be set to null. fieldEditor Str Indicates the BTypeSpec of the field editor to use for editing a property value. It overrides the default field editor registered for the property's value. trueText Str Display text to be used for a boolean property when true. falseText Str Display text to be used for a boolean property when false. nullText Str Display text to be used for a boolean property when null. Examples: public class Foo extends Component { ... // Property for password - must be at least 8 chars long // and no more than 16. @min=8 @max=16 @config @asStr property Buf(17) pwd // The debug level should be specified in base 16. @radix=16 @min=0 @config property int dbgLevel = 0x1234 }","title":"BComponent slot facets"},{"location":"development/niagara/#niagara-views","text":"Normally in Niagara, views are registered on a BTypeSpec by using the <agent/> specification in the module-include.xml file of your module. However, since all Sedona Framework components are modeled as BSedonaComponents in Niagara, a different mechanism is used to register views on your Sedona Framework component. Namely, <def/> blocks are used to define agents on specific Sedona Framework component types. An example follows. Suppose you have developed a Service called MyService in kit foo . The qname for this type is foo::MyService . Suppose, further, that you have written a Niagara view BMyServiceView to manage this service and that it resides in module bar . The BTypeSpec for this service is bar:MyServiceView . To register your view on the MyService service, you would add the following lines to the module-include.xml for your module: <defs> <!-- This declares the agent on the foo::MyService service --> <def name= \"sedona.foo::MyService#agent\" value= \"bar:MyServiceView\" /> </def> <types> ... <!-- Declare the Niagara type as usual, but no agent block is required --> <type name= \"MyServiceView\" class= \"com.bar.BMyServiceView\" /> ... </types> When your view loads, a BISedonaComponent will be passed to the doLoadValue method of your view. protected void doLoadValue ( BObject value , Context cx ) throws Exception { BISedonaComponent myService = ( BISedonaComponent ) value ; // See the javax.baja.sedona.sys.BISedonaComponent interface // for more details. } Note The concrete class BSedonaComponent is deprecated as of the TXS 1.1 release. You should migrate your views to use the new BISedonaComponent interface instead. If you have questions about writing views for Sedona Framework components, ask them on one of the Sedona Framework forums on Niagara Central .","title":"Niagara Views"},{"location":"development/niagara/#provisioning-from-niagara","text":"When using Niagara tools to provision a Sedona Framework-enabled device, there are a few things to be aware of: File names : Niagara makes assumptions about the file names used to launch the remote platform. In particular, it assumes: the SVM is named \"svm.bin\" (or \"svm.exe\"), the kit bundle file is named \"kits.scode\", and the app binary is named \"app.sab\". File PUT : To be Sox compliant, Sedona Framework platforms must use app.sab as the file name of the app to run, and kits.scode as the file name of the scode image to run. Further, to be Sox compliant, a platform must look for an app.sab.stage and a kits.scode.stage file when starting and rename them to app.sab and kits.scode respectively before the SVM attempts to load the app and scode. Hence, when Niagara writes new app and scode files to the device, it does so in three stages: 1. Writes the app as `app.sab.writing` and the scode as `kits.scode.writing`. 2. Renames those files to `app.sab.stage` and `kits.scode.stage` respectively. 3. Restarts the device. File GET : A file GET operation from Sedona to Niagara should prompt the user for the path and filename to be used on the local host for the received file. The name of the file as it is being transferred is normally not visible (or relevant) to the user.","title":"Provisioning from Niagara"},{"location":"development/porting/","text":"Porting \u00b6 Overview \u00b6 The SVM is designed to be easily ported to new hardware and OS platforms using the following steps: Add platform specific declarations to sedona.h Select the kits with native methods that you plan to support Write custom implementations for native methods where needed Write bootstrap code to start the SVM Stage the VM code and platform manifest using an XML build script Compile the C code using your platform's C compiler Run the test suite to verify a successful port sedona.h \u00b6 Porting to a new target platform begins with sedona.h which is located in the src/vm directory. This file is included by every native source file, and contains essential definitions required for building the native layer. It contains sections for major target platforms such as Win32, QNX, and UNIX. Each platform's section is wrapped by an #if defined() directive for the given target compiler/platform. If none of the existing sections is matched, the preprocessor will look for a file named sedona-local.h in the include path, and include its contents in place of the other target sections. Definitions for a new platform can be added in a new #elif defined() section in sedona.h , but the modified sedona.h will then need to be updated manually if any changes are made to the public version of the file. A simpler solution is to create a local sedona-local.h file to hold the definitions for the new platform. This file will then automatically be included in the build and can be maintained separately from the core Sedona Framework distribution. There are instructions at the top of sedona.h that describe the types and macros that must be defined for each platform, such as the ANSI C 99 integer types and macros for endianness and block sizes. Definitions for key types like Cell and SedonaVM are defined at the bottom of the file, as well as the function declarations for working with the VM. Natives \u00b6 Kits without native methods require no changes to run on a new target platform. For each kit with native methods, the existing code must first be examined to see what additional work needs to be done. As described in the Native Methods chapter, every native method must have an appropriately-named C function that implements that method for the target platform. However some C functions are more portable across platforms than others. For example a native method like sys::Sys.copy may be written in ANSI C and shared by many or perhaps all platforms. Other methods, such as sys::Sys.ticks , almost always require a custom implementation for each hardware or OS platform. All the native source code is organized under a directory called native in the kit directory. Native functions that are portable across all platforms should be contained in C files located directly in the native directory, one file per class using the naming convention \" {kit}_{class}.c \". Any native functions that are implemented separately for each platform should be located in sub-directories under native , one per platform. Code files under these directories are named using the convention \" {kit}_{type}_{platform}.c \". This helps avoid file name collisions. For example, given a kit myKit with one class MyClass that has native functions, some portable and some platform-specific, the code would be organized as follows: myKit/ +- kit.xml +- MyClass.sedona +- native/ | +- myKit_MyClass.c | +- qnx/ | | +- myKit_MyClass_qnx.c | +- win32/ | | +- myKit_MyClass_win32.c +- test/ | +- MyClassTest.sedona All the source code files for the native methods are stored under the folder myKit/native . Functions that can be shared across all platforms are in the file named myKit_MyClass.c , located in the native folder. These functions should not need to be implemented again when porting to a new platform. Source files for platform-specific implementations are located in a separate subfolder for each platform, and the platform name is appended to the source file name. When porting the kit to a new platform newPlat , simply create a new folder native/newPlat and put the native method implementations into a source file myKit_MyClass_newPlat.c under the new folder. Bootstrap \u00b6 In addition to the native methods for each kit, the new platform port will need some native bootstrapping code to start the SVM. For sophisticated devices with an OS and a file system (such as a PC), it may be sufficient to build and run the code provided in main.c , which is located in the src/vm directory. This function can be executed from the OS command line, providing on the command line the filenames for the scode image and the app to be run. (Even with platforms that cannot support main.c , it may still be useful as a guide for writing the new bootstrap code.) On smaller, simpler platforms, new bootstrap code will need to be written. Every platform will have a unique implementation, but at some point the SVM will need to be started by calling vmRun(SedonaVM*) . (Both vmRun() and the SedonaVM struct are defined in sedona.h .) Before calling vmRun() , a SedonaVM struct must be created and then initialized as follows: Configure codeBaseAddr and codeSize to point to the scode image. Typically the scode is stored in a disk file or in flash memory, and loaded into RAM at this point. If so then codeBaseAddr is simply a pointer to the scode image in RAM. Configure stackBaseAddr and stackMaxSize to point to an area of RAM that can be used for the stack. Most commonly this is a static or dynamically-allocated array of the desired size. Configure args and argsLen to pass in the arguments to the Sedona Framework main method. The args pointer should reference a normal array of C null terminated strings (just like a standard C main signature). Configure a callback function for onAssertFailure . This function is generally used in test code, and is called whenever an assert condition fails. More details on using the Sedona Framework test facility may be found in the Test chapter. Configure the call function pointer to point to vmCall . This indirection provides a hook for patching a ROM based VM. Configure a pointer to the nativeTable array generated automatically during the VM code generation stage. See the Native Methods chapter for more information. When the SedonaVM struct has been initialized, start the SVM by calling vmRun() and passing a pointer to the struct. Sedona VM Exit Values \u00b6 When the Sedona VM exits, the calling function must decide what to do next based on the return code. If the VM exits normally with a return code of 0 , it generally means the VM is not expecting to restart. The most common use of this is when running the test harness. If so, then the global variables assertSuccesses and assertFailures will contain the number of calls to assert that passed and failed, respectively. When the action App.restart() is invoked, the app stops running and sets the return code to Err.restart . On most platforms this leads to the SVM exiting with the value ERR_RESTART . If this value is received then the calling function should repeat the above steps to restart the SVM (possibly using different app.sab or kits.scode files if the device is restarting after being provisioned ). Note however that App.restart() also calls the platform service's restart() method, which could produce different behavior depending on how that method is implemented. For example, on a device with no OS it might issue a soft restart to the CPU, in which case there would be no return code to process. Some platforms may require the Sedona VM to yield execution control to allow other tasks to run. When vmRun() returns ERR_YIELD , the application is yielding CPU control. See the Yield section for more details. Each platform requires the implementation of an appropriate hibernation strategy. When vmRun() returns ERR_HIBERNATE then the application has requested that the platform go into a low-power or sleep state. Awakening from this state is under the control of the device, not the Sedona Framework application. Upon awaking, call the vmResume() function to start the SVM again from where it left off. See the Hibernation section for more details. If vmRun() returns a non-zero value other than ERR_RESTART , ERR_HIBERNATE , or ERR_YIELD , then there is a problem. Error codes generated in the scode image or the app are defined in src/sys/Err.sedona ; errors from the VM itself are usually indicated by an error code in src/vm/errorcodes.h . Staging \u00b6 Once the native code has been implemented, the next step is to stage the VM and native code. This copies the relevant native source files into a single directory in order to compile them using the appropriate native toolchain. Staging is accomplished by running sedonac with a platform definition file and specifying the output directory for the staged files. The platform definition lists all the directories containing C source files required to build the SVM for a target platform. (The platform toolchain may add additional non-Sedona files when it builds the final executable). See the platform definition section for more details and an example platform definition file. The platform definition file supplies some basic information about the platform, then lists the kits with native code that will be supported by the VM. Kits without native methods do not need to be mentioned in the platform XML. Finally it identifies the path to each directory containing native code that will be required by the VM at runtime. This includes not only the relevant Sedona native methods implementations, but also the source for the SVM itself. (On platforms where some portion of the VM is in ROM, only the RAM-based code may need to be included here.) Staging is performed by calling sedonac with the platform definition file, specifying the target directory via the -outDir option. For example, $ sedonac platforms/src/acme/basicPlatform-win32.xml -outDir tempStageDir This results in the following: All existing files are removed from the folder tempStageDir All source files are copied from the listed paths into tempStageDir The file nativetable.c is generated, which defines the native function lookup table If the platform id is known at staging time, a sedonaPlatform.h file is created, which contains the PLATFORM_ID macro. The platform manifest is staged in tempStageDir/.par/platformManifest.xml . The toolchain can later add the SVM binary to into the .par/svm/ directory (if desired) and then generate a PAR file . The PAR file could be uploaded to sedonadev.org or installed in the local platform database . Note Given that Tridium no longer supports Sedona, the par file can no longer be uploaded to sedonadev.org . Wrap Up \u00b6 Note that sedonac does not build the C code, it simply assembles the files together into a single directory. The C code must then be built with the appropriate toolchain for the target platform. Neither does sedonac generate an actual PAR file for you. It will help by staging a basic .par/ directory containing the platform manifest. However, the toolchain build process will need to include steps/scripts to generate the PAR file for local and/or public use. Once the VM executable has been built, a good next step is to run the test harness and verify the port was successful.","title":"Porting"},{"location":"development/porting/#porting","text":"","title":"Porting"},{"location":"development/porting/#overview","text":"The SVM is designed to be easily ported to new hardware and OS platforms using the following steps: Add platform specific declarations to sedona.h Select the kits with native methods that you plan to support Write custom implementations for native methods where needed Write bootstrap code to start the SVM Stage the VM code and platform manifest using an XML build script Compile the C code using your platform's C compiler Run the test suite to verify a successful port","title":"Overview"},{"location":"development/porting/#sedonah","text":"Porting to a new target platform begins with sedona.h which is located in the src/vm directory. This file is included by every native source file, and contains essential definitions required for building the native layer. It contains sections for major target platforms such as Win32, QNX, and UNIX. Each platform's section is wrapped by an #if defined() directive for the given target compiler/platform. If none of the existing sections is matched, the preprocessor will look for a file named sedona-local.h in the include path, and include its contents in place of the other target sections. Definitions for a new platform can be added in a new #elif defined() section in sedona.h , but the modified sedona.h will then need to be updated manually if any changes are made to the public version of the file. A simpler solution is to create a local sedona-local.h file to hold the definitions for the new platform. This file will then automatically be included in the build and can be maintained separately from the core Sedona Framework distribution. There are instructions at the top of sedona.h that describe the types and macros that must be defined for each platform, such as the ANSI C 99 integer types and macros for endianness and block sizes. Definitions for key types like Cell and SedonaVM are defined at the bottom of the file, as well as the function declarations for working with the VM.","title":"sedona.h"},{"location":"development/porting/#natives","text":"Kits without native methods require no changes to run on a new target platform. For each kit with native methods, the existing code must first be examined to see what additional work needs to be done. As described in the Native Methods chapter, every native method must have an appropriately-named C function that implements that method for the target platform. However some C functions are more portable across platforms than others. For example a native method like sys::Sys.copy may be written in ANSI C and shared by many or perhaps all platforms. Other methods, such as sys::Sys.ticks , almost always require a custom implementation for each hardware or OS platform. All the native source code is organized under a directory called native in the kit directory. Native functions that are portable across all platforms should be contained in C files located directly in the native directory, one file per class using the naming convention \" {kit}_{class}.c \". Any native functions that are implemented separately for each platform should be located in sub-directories under native , one per platform. Code files under these directories are named using the convention \" {kit}_{type}_{platform}.c \". This helps avoid file name collisions. For example, given a kit myKit with one class MyClass that has native functions, some portable and some platform-specific, the code would be organized as follows: myKit/ +- kit.xml +- MyClass.sedona +- native/ | +- myKit_MyClass.c | +- qnx/ | | +- myKit_MyClass_qnx.c | +- win32/ | | +- myKit_MyClass_win32.c +- test/ | +- MyClassTest.sedona All the source code files for the native methods are stored under the folder myKit/native . Functions that can be shared across all platforms are in the file named myKit_MyClass.c , located in the native folder. These functions should not need to be implemented again when porting to a new platform. Source files for platform-specific implementations are located in a separate subfolder for each platform, and the platform name is appended to the source file name. When porting the kit to a new platform newPlat , simply create a new folder native/newPlat and put the native method implementations into a source file myKit_MyClass_newPlat.c under the new folder.","title":"Natives"},{"location":"development/porting/#bootstrap","text":"In addition to the native methods for each kit, the new platform port will need some native bootstrapping code to start the SVM. For sophisticated devices with an OS and a file system (such as a PC), it may be sufficient to build and run the code provided in main.c , which is located in the src/vm directory. This function can be executed from the OS command line, providing on the command line the filenames for the scode image and the app to be run. (Even with platforms that cannot support main.c , it may still be useful as a guide for writing the new bootstrap code.) On smaller, simpler platforms, new bootstrap code will need to be written. Every platform will have a unique implementation, but at some point the SVM will need to be started by calling vmRun(SedonaVM*) . (Both vmRun() and the SedonaVM struct are defined in sedona.h .) Before calling vmRun() , a SedonaVM struct must be created and then initialized as follows: Configure codeBaseAddr and codeSize to point to the scode image. Typically the scode is stored in a disk file or in flash memory, and loaded into RAM at this point. If so then codeBaseAddr is simply a pointer to the scode image in RAM. Configure stackBaseAddr and stackMaxSize to point to an area of RAM that can be used for the stack. Most commonly this is a static or dynamically-allocated array of the desired size. Configure args and argsLen to pass in the arguments to the Sedona Framework main method. The args pointer should reference a normal array of C null terminated strings (just like a standard C main signature). Configure a callback function for onAssertFailure . This function is generally used in test code, and is called whenever an assert condition fails. More details on using the Sedona Framework test facility may be found in the Test chapter. Configure the call function pointer to point to vmCall . This indirection provides a hook for patching a ROM based VM. Configure a pointer to the nativeTable array generated automatically during the VM code generation stage. See the Native Methods chapter for more information. When the SedonaVM struct has been initialized, start the SVM by calling vmRun() and passing a pointer to the struct.","title":"Bootstrap"},{"location":"development/porting/#sedona-vm-exit-values","text":"When the Sedona VM exits, the calling function must decide what to do next based on the return code. If the VM exits normally with a return code of 0 , it generally means the VM is not expecting to restart. The most common use of this is when running the test harness. If so, then the global variables assertSuccesses and assertFailures will contain the number of calls to assert that passed and failed, respectively. When the action App.restart() is invoked, the app stops running and sets the return code to Err.restart . On most platforms this leads to the SVM exiting with the value ERR_RESTART . If this value is received then the calling function should repeat the above steps to restart the SVM (possibly using different app.sab or kits.scode files if the device is restarting after being provisioned ). Note however that App.restart() also calls the platform service's restart() method, which could produce different behavior depending on how that method is implemented. For example, on a device with no OS it might issue a soft restart to the CPU, in which case there would be no return code to process. Some platforms may require the Sedona VM to yield execution control to allow other tasks to run. When vmRun() returns ERR_YIELD , the application is yielding CPU control. See the Yield section for more details. Each platform requires the implementation of an appropriate hibernation strategy. When vmRun() returns ERR_HIBERNATE then the application has requested that the platform go into a low-power or sleep state. Awakening from this state is under the control of the device, not the Sedona Framework application. Upon awaking, call the vmResume() function to start the SVM again from where it left off. See the Hibernation section for more details. If vmRun() returns a non-zero value other than ERR_RESTART , ERR_HIBERNATE , or ERR_YIELD , then there is a problem. Error codes generated in the scode image or the app are defined in src/sys/Err.sedona ; errors from the VM itself are usually indicated by an error code in src/vm/errorcodes.h .","title":"Sedona VM Exit Values"},{"location":"development/porting/#staging","text":"Once the native code has been implemented, the next step is to stage the VM and native code. This copies the relevant native source files into a single directory in order to compile them using the appropriate native toolchain. Staging is accomplished by running sedonac with a platform definition file and specifying the output directory for the staged files. The platform definition lists all the directories containing C source files required to build the SVM for a target platform. (The platform toolchain may add additional non-Sedona files when it builds the final executable). See the platform definition section for more details and an example platform definition file. The platform definition file supplies some basic information about the platform, then lists the kits with native code that will be supported by the VM. Kits without native methods do not need to be mentioned in the platform XML. Finally it identifies the path to each directory containing native code that will be required by the VM at runtime. This includes not only the relevant Sedona native methods implementations, but also the source for the SVM itself. (On platforms where some portion of the VM is in ROM, only the RAM-based code may need to be included here.) Staging is performed by calling sedonac with the platform definition file, specifying the target directory via the -outDir option. For example, $ sedonac platforms/src/acme/basicPlatform-win32.xml -outDir tempStageDir This results in the following: All existing files are removed from the folder tempStageDir All source files are copied from the listed paths into tempStageDir The file nativetable.c is generated, which defines the native function lookup table If the platform id is known at staging time, a sedonaPlatform.h file is created, which contains the PLATFORM_ID macro. The platform manifest is staged in tempStageDir/.par/platformManifest.xml . The toolchain can later add the SVM binary to into the .par/svm/ directory (if desired) and then generate a PAR file . The PAR file could be uploaded to sedonadev.org or installed in the local platform database . Note Given that Tridium no longer supports Sedona, the par file can no longer be uploaded to sedonadev.org .","title":"Staging"},{"location":"development/porting/#wrap-up","text":"Note that sedonac does not build the C code, it simply assembles the files together into a single directory. The C code must then be built with the appropriate toolchain for the target platform. Neither does sedonac generate an actual PAR file for you. It will help by staging a basic .par/ directory containing the platform manifest. However, the toolchain build process will need to include steps/scripts to generate the PAR file for local and/or public use. Once the VM executable has been built, a good next step is to run the test harness and verify the port was successful.","title":"Wrap Up"},{"location":"development/sedonac/","text":"Sedonac \u00b6 Overview \u00b6 The sedonac tool is like a swiss army knife, it is used for the following tasks: Compile Kit : compile Sedona source code into a kit file. Compile Dir : compile a group of kits Compile Code : compile a set of kits into an scode file Compile Platform : stage the native code for a specific platform binary Compile App : convert between sax and sab formats Run : run an arbitrary class within \"sedona.jar\" or \"sedoanc.jar\". Build Docs : auto-generate HTML documentation Compile Kit \u00b6 Sedonac compiles Sedona source files into a kit file when run on a \"kit.xml\" file (or a directory that contains a \"kit.xml\" file). <sedonaKit name = \"serial\" vendor = \"Tridium\" description = \"Serial I/O support\" includeSource = \"true\" doc = \"true\" > <!-- Dependencies --> <depend on= \"sys 1.0\" /> <!-- Source Directories --> <source dir= \".\" /> <source dir= \"test\" testonly= \"true\" /> <!-- Natives --> <native qname= \"serial::SerialPort.doInit\" id= \"4::0\" /> <native qname= \"serial::SerialPort.doClose\" id= \"4::1\" /> <native qname= \"serial::SerialPort.doRead\" id= \"4::2\" /> <native qname= \"serial::SerialPort.doWrite\" id= \"4::3\" /> </sedonaKit> Specification of elements and attributes: <sedonaKit> top level element: name : (required) name of kit. See Vendors for rules on kit names. vendor : (required) name of vendor for kit description : (required) short description for kit includeSource : (optional) boolean indicates whether to include source in kit zip. Defaults to false. doc : (optional) boolean indicates whether to include this kit in API documentation. Defaults to false. version : (optional) version string. Supports variable substitution . See versioning <depend> specifies the dependencies of the kits on : (required) dependency as a kit name and version constraint. <source> specifies a directory of source code: dir : (required) directory path where \"kit.xml\" is located, relative to top directory testonly : (optional) boolean indicating whether the classes in the kit should be used in the test harness. If true, it infers the @testonly facet on all the classes in that directory. Default is false. <native> specifies a native method identifier: qname : qualified name of the native method id : qualified id of the native method Compile Dir \u00b6 If sedonac is run on a file containing a sedonaDir element (usually named \"dir.xml\"), it compiles all the kits named in the list: <sedonaDir> <target name= \"sys\" /> <target name= \"inet\" /> <target name= \"sox\" /> </sedonaDir> <target> specifies a child target: name : (required) name of child directory. The kits will be compiled separately; to assemble them into an scode image, see Compile Code below. Compile Code \u00b6 If sedonac is run on a file containing a sedonaCode element, it compiles the given set of kits into an scode image. The filename of the input XML file is used for the output scode file, e.g. if the input file is \"foo.xml\" sedonac will create a file called \"foo.scode\" in the same directory. <sedonaCode endian= \"little\" blockSize= \"4\" refSize= \"4\" main= \"sys::Sys.main\" debug= \"true\" test= \"true\" > <depend on= \"sys 1.0\" /> <depend on= \"sox 1.0\" /> <depend on= \"inet 1.0\" /> </sedonaCode> <sedonaCode> top level element for scode compile: endian : either \"little\" or \"big\" based on target processor. blockSize : size of a scode block in bytes (see \"sedona.h\") refSize : size of a memory pointer in bytes for target processor (4 for 32-bit processor). main : qualified method name of main method (typically sys::Sys.main ). debug : (optional) boolean to include debug meta-data in image. Defaults to false test : (optional) boolean to include test code in image. Defaults to false armDouble : (optional) set to true if using an ARM microprocessor where 64-bit doubles are stored using byte level little endian, word level big endian. <depend> specifies the kits to compile into the image: on : (required) dependency as a kit name and version constraint. test : (optional) boolean to include tests for this key. Defaults to value of sedonaCode.test if unspecified. Note that the test and debug flags may have a significant impact on scode size. Compile Platform \u00b6 Sedonac is used to stage the native code when compiling a binary image for a given platform. This happens when sedonac is run against an XML file with a sedonaPlatform root element. See Staging and Platform Definition for more details. Compile App \u00b6 If you run sedonac against a file with a \".sax\" extension it converts the application to a \".sab\" file, and vice versa. The output file is placed in the same directory as the input file: D: \\s edona \\p ub \\a pps>sedonac test.sax ConvertAppFile [ D: \\s edona \\p ub \\a pps \\t est.sax -> D: \\s edona \\p ub \\a pps \\t est.sab ] +---------------------------------- | RAM: 14 .2kb ( 14588 bytes ) | FLASH: 0 .4kb ( 382 bytes ) +---------------------------------- Running sedonac on an application file also prints a memory impact report. The RAM value is an estimate of how much memory the application consumes in RAM during runtime. FLASH is the size required to persist the application to durable storage like flash memory (always exactly the same as the size of the sab file). Also see the Apps and Memory chapters. Run \u00b6 If you pass a qualified Java classname to sedonac it will attempt to run that class's main() method: D: \\s edona>sedonac sedona.util.UserUtil brian pass User: brian:pass Digest: 0x [ ca4d1fd9a089ff9d50ab1f1dc4e4772a6b24c6bb ] Base64: yk0f2aCJ/51Qqx8dxOR3Kmskxrs = The class must be defined in \"sedona.jar\" or \"sedonac.jar\": Build Docs \u00b6 The -doc switch builds HTML documentation along with the scode. For example: D: \\s edona>sedonac -doc pub/src/sys Parse [ 44 files ] WriteKit [ D: \\s edona \\p ub \\k its \\s ys \\s ys-b0ce639-1.0.36.kit ] WriteDoc [ D: \\s edona \\p ub \\d oc \\s ys ] *** Success! *** D: \\s edona \\s edonac -doc pub/doc/toc.xml TableOfContents [ D: \\s edona \\p ub \\d oc -> D: \\s edona \\p ub \\d oc ] CheckHtmlLinks [ D: \\s edona \\p ub \\d oc ] *** Success! *** D: \\s edona \\s edonac If the input file is a directory of kit source folders, then it will build the kits and automatically generate HTML documentation for each class, as well as a summary page for each kit. All fields and methods for each class will be included in the documentation, and any ** style comments above a given field or method will be included with the entry for that field or method. If instead the input file to sedonac -doc is an XML file, it will be processed for information on generating a table of contents. See the file doc/toc.xml for an example. Variable Substitution \u00b6 Some attributes in the various input XML files allow for variable substitution. Such attributes will be read by sedonac, and any variables present in the attribute text will be replaced by the variable value. A variable is specified as ${variableName} . For example: <sedonaPlatform vendor=\"Tridium\" id=\"tridium-foo-${sedona.env.version}\" /> The id attribute above might end up being resolved as tridium-foo-1.0.38 . Sedonac will resolve variables according to the following rules: If the variable starts with os.env. then sedonac will attempt to resolve an environment variable. For example, ${os.env.USER} will cause sedonac to look in the environment for a variable called USER . If the variable starts with sedona.env. then sedonac will attempt to resolve a variable in the Sedona Framework environment (see sedona.Env.java). For example, ${sedona.env.buildVersion} will cause sedonac to try and resolve property buildVersion in the sedona environment. Note: as a convenience ${sedona.env.version} resolves to sedona.Env.version Otherwise, attempt to resolve the variable name against any variables that the compiler might set. For example, when compiling a platform definition file the compiler will set a variable called ${stage.nativeChecksum} . It is always a compiler error if a variable cannot be resolved. The most common place that variable substitution is used is in the platform definition file. The documentation for each XML file will explicitly indicate which elements and attributes support variable substitution (if any).","title":"Sedonac"},{"location":"development/sedonac/#sedonac","text":"","title":"Sedonac"},{"location":"development/sedonac/#overview","text":"The sedonac tool is like a swiss army knife, it is used for the following tasks: Compile Kit : compile Sedona source code into a kit file. Compile Dir : compile a group of kits Compile Code : compile a set of kits into an scode file Compile Platform : stage the native code for a specific platform binary Compile App : convert between sax and sab formats Run : run an arbitrary class within \"sedona.jar\" or \"sedoanc.jar\". Build Docs : auto-generate HTML documentation","title":"Overview"},{"location":"development/sedonac/#compile-kit","text":"Sedonac compiles Sedona source files into a kit file when run on a \"kit.xml\" file (or a directory that contains a \"kit.xml\" file). <sedonaKit name = \"serial\" vendor = \"Tridium\" description = \"Serial I/O support\" includeSource = \"true\" doc = \"true\" > <!-- Dependencies --> <depend on= \"sys 1.0\" /> <!-- Source Directories --> <source dir= \".\" /> <source dir= \"test\" testonly= \"true\" /> <!-- Natives --> <native qname= \"serial::SerialPort.doInit\" id= \"4::0\" /> <native qname= \"serial::SerialPort.doClose\" id= \"4::1\" /> <native qname= \"serial::SerialPort.doRead\" id= \"4::2\" /> <native qname= \"serial::SerialPort.doWrite\" id= \"4::3\" /> </sedonaKit> Specification of elements and attributes: <sedonaKit> top level element: name : (required) name of kit. See Vendors for rules on kit names. vendor : (required) name of vendor for kit description : (required) short description for kit includeSource : (optional) boolean indicates whether to include source in kit zip. Defaults to false. doc : (optional) boolean indicates whether to include this kit in API documentation. Defaults to false. version : (optional) version string. Supports variable substitution . See versioning <depend> specifies the dependencies of the kits on : (required) dependency as a kit name and version constraint. <source> specifies a directory of source code: dir : (required) directory path where \"kit.xml\" is located, relative to top directory testonly : (optional) boolean indicating whether the classes in the kit should be used in the test harness. If true, it infers the @testonly facet on all the classes in that directory. Default is false. <native> specifies a native method identifier: qname : qualified name of the native method id : qualified id of the native method","title":"Compile Kit"},{"location":"development/sedonac/#compile-dir","text":"If sedonac is run on a file containing a sedonaDir element (usually named \"dir.xml\"), it compiles all the kits named in the list: <sedonaDir> <target name= \"sys\" /> <target name= \"inet\" /> <target name= \"sox\" /> </sedonaDir> <target> specifies a child target: name : (required) name of child directory. The kits will be compiled separately; to assemble them into an scode image, see Compile Code below.","title":"Compile Dir"},{"location":"development/sedonac/#compile-code","text":"If sedonac is run on a file containing a sedonaCode element, it compiles the given set of kits into an scode image. The filename of the input XML file is used for the output scode file, e.g. if the input file is \"foo.xml\" sedonac will create a file called \"foo.scode\" in the same directory. <sedonaCode endian= \"little\" blockSize= \"4\" refSize= \"4\" main= \"sys::Sys.main\" debug= \"true\" test= \"true\" > <depend on= \"sys 1.0\" /> <depend on= \"sox 1.0\" /> <depend on= \"inet 1.0\" /> </sedonaCode> <sedonaCode> top level element for scode compile: endian : either \"little\" or \"big\" based on target processor. blockSize : size of a scode block in bytes (see \"sedona.h\") refSize : size of a memory pointer in bytes for target processor (4 for 32-bit processor). main : qualified method name of main method (typically sys::Sys.main ). debug : (optional) boolean to include debug meta-data in image. Defaults to false test : (optional) boolean to include test code in image. Defaults to false armDouble : (optional) set to true if using an ARM microprocessor where 64-bit doubles are stored using byte level little endian, word level big endian. <depend> specifies the kits to compile into the image: on : (required) dependency as a kit name and version constraint. test : (optional) boolean to include tests for this key. Defaults to value of sedonaCode.test if unspecified. Note that the test and debug flags may have a significant impact on scode size.","title":"Compile Code"},{"location":"development/sedonac/#compile-platform","text":"Sedonac is used to stage the native code when compiling a binary image for a given platform. This happens when sedonac is run against an XML file with a sedonaPlatform root element. See Staging and Platform Definition for more details.","title":"Compile Platform"},{"location":"development/sedonac/#compile-app","text":"If you run sedonac against a file with a \".sax\" extension it converts the application to a \".sab\" file, and vice versa. The output file is placed in the same directory as the input file: D: \\s edona \\p ub \\a pps>sedonac test.sax ConvertAppFile [ D: \\s edona \\p ub \\a pps \\t est.sax -> D: \\s edona \\p ub \\a pps \\t est.sab ] +---------------------------------- | RAM: 14 .2kb ( 14588 bytes ) | FLASH: 0 .4kb ( 382 bytes ) +---------------------------------- Running sedonac on an application file also prints a memory impact report. The RAM value is an estimate of how much memory the application consumes in RAM during runtime. FLASH is the size required to persist the application to durable storage like flash memory (always exactly the same as the size of the sab file). Also see the Apps and Memory chapters.","title":"Compile App"},{"location":"development/sedonac/#run","text":"If you pass a qualified Java classname to sedonac it will attempt to run that class's main() method: D: \\s edona>sedonac sedona.util.UserUtil brian pass User: brian:pass Digest: 0x [ ca4d1fd9a089ff9d50ab1f1dc4e4772a6b24c6bb ] Base64: yk0f2aCJ/51Qqx8dxOR3Kmskxrs = The class must be defined in \"sedona.jar\" or \"sedonac.jar\":","title":"Run"},{"location":"development/sedonac/#build-docs","text":"The -doc switch builds HTML documentation along with the scode. For example: D: \\s edona>sedonac -doc pub/src/sys Parse [ 44 files ] WriteKit [ D: \\s edona \\p ub \\k its \\s ys \\s ys-b0ce639-1.0.36.kit ] WriteDoc [ D: \\s edona \\p ub \\d oc \\s ys ] *** Success! *** D: \\s edona \\s edonac -doc pub/doc/toc.xml TableOfContents [ D: \\s edona \\p ub \\d oc -> D: \\s edona \\p ub \\d oc ] CheckHtmlLinks [ D: \\s edona \\p ub \\d oc ] *** Success! *** D: \\s edona \\s edonac If the input file is a directory of kit source folders, then it will build the kits and automatically generate HTML documentation for each class, as well as a summary page for each kit. All fields and methods for each class will be included in the documentation, and any ** style comments above a given field or method will be included with the entry for that field or method. If instead the input file to sedonac -doc is an XML file, it will be processed for information on generating a table of contents. See the file doc/toc.xml for an example.","title":"Build Docs"},{"location":"development/sedonac/#variable-substitution","text":"Some attributes in the various input XML files allow for variable substitution. Such attributes will be read by sedonac, and any variables present in the attribute text will be replaced by the variable value. A variable is specified as ${variableName} . For example: <sedonaPlatform vendor=\"Tridium\" id=\"tridium-foo-${sedona.env.version}\" /> The id attribute above might end up being resolved as tridium-foo-1.0.38 . Sedonac will resolve variables according to the following rules: If the variable starts with os.env. then sedonac will attempt to resolve an environment variable. For example, ${os.env.USER} will cause sedonac to look in the environment for a variable called USER . If the variable starts with sedona.env. then sedonac will attempt to resolve a variable in the Sedona Framework environment (see sedona.Env.java). For example, ${sedona.env.buildVersion} will cause sedonac to try and resolve property buildVersion in the sedona environment. Note: as a convenience ${sedona.env.version} resolves to sedona.Env.version Otherwise, attempt to resolve the variable name against any variables that the compiler might set. For example, when compiling a platform definition file the compiler will set a variable called ${stage.nativeChecksum} . It is always a compiler error if a variable cannot be resolved. The most common place that variable substitution is used is in the platform definition file. The documentation for each XML file will explicitly indicate which elements and attributes support variable substitution (if any).","title":"Variable Substitution"},{"location":"development/testing/","text":"Testing \u00b6 Overview \u00b6 We all love test driven development! The Sedona Framework comes with built-in support for writing and running unit tests. You won't have any excuses to skip unit testing. The test framework is based upon the following principles: Bundled with Kits : the goal of the test framework is to enable you to bundle unit tests for each kit with the kit itself Test Only Code : a set of classes within a kit is marked test only so that we can include or exclude test code easily Test Methods : classes that extend sys::Test are automatically scanned for test methods and added to the test harness Test Harness : the Sedona Framework runtime includes a harness to automatically run all the tests for a given scode image Test Only \u00b6 Because the Sedona Framework targets very resource constrained devices, we need to maximize every byte available. So the compiler lets you mark which classes are test code versus normal runtime code. The standard mechanism to do this is via the test attribute in your \"kit.xml\" build file: <source dir= \".\" /> <source dir= \"test\" testonly= \"true\" /> The XML above illustrates a kit build file that contains two source directories. The \".\" directory contains the normal runtime classes. On the other hand, all the classes defined in the \"test\" directory are automatically marked test only . If you look at the IR for these classes you will see each test class annotated with the @testonly facet. Convention is to place all test code in a subdirectory called \"test\" inside your source folder. Test Methods \u00b6 Tests are organized into test classes , which are classes that extend sys::Test . Every method inside a test class whose name starts with \"test\" is a test method . Test methods are the primary unit of test execution. Test methods must be public, static, non-native methods that return void and declare no parameters. Each test method should be designed to test a single feature or function of your kit's code. The test is implemented using one or more assert statements. This is an example test class for testing sys::Str : class StrTest extends Test { static void testEquals() { assert(\"a\".equals(\"a\")) assert(!\"a\".equals(\"x\")) } } Test Harness \u00b6 Follow these steps to run the test harness: Ensure that your scode image includes test code by setting the sedonaCode.test attribute to true in your scode XML build file. If you need to free up extra memory, or wish to narrow the tests to run, you can set the depend.test attribute on each kit element in your scode XML build file. This allows you to include or exclude test code on a kit by kit basis (if sedonaCode.test is false then these attributes are ignored). Ensure the main attribute is set to sys::Sys.main in your scode XML build file Build the test version of your scode Run the VM using the -test argument, which will execute all the test methods and report assert successes and failures: svm kits.scode -test","title":"Testing"},{"location":"development/testing/#testing","text":"","title":"Testing"},{"location":"development/testing/#overview","text":"We all love test driven development! The Sedona Framework comes with built-in support for writing and running unit tests. You won't have any excuses to skip unit testing. The test framework is based upon the following principles: Bundled with Kits : the goal of the test framework is to enable you to bundle unit tests for each kit with the kit itself Test Only Code : a set of classes within a kit is marked test only so that we can include or exclude test code easily Test Methods : classes that extend sys::Test are automatically scanned for test methods and added to the test harness Test Harness : the Sedona Framework runtime includes a harness to automatically run all the tests for a given scode image","title":"Overview"},{"location":"development/testing/#test-only","text":"Because the Sedona Framework targets very resource constrained devices, we need to maximize every byte available. So the compiler lets you mark which classes are test code versus normal runtime code. The standard mechanism to do this is via the test attribute in your \"kit.xml\" build file: <source dir= \".\" /> <source dir= \"test\" testonly= \"true\" /> The XML above illustrates a kit build file that contains two source directories. The \".\" directory contains the normal runtime classes. On the other hand, all the classes defined in the \"test\" directory are automatically marked test only . If you look at the IR for these classes you will see each test class annotated with the @testonly facet. Convention is to place all test code in a subdirectory called \"test\" inside your source folder.","title":"Test Only"},{"location":"development/testing/#test-methods","text":"Tests are organized into test classes , which are classes that extend sys::Test . Every method inside a test class whose name starts with \"test\" is a test method . Test methods are the primary unit of test execution. Test methods must be public, static, non-native methods that return void and declare no parameters. Each test method should be designed to test a single feature or function of your kit's code. The test is implemented using one or more assert statements. This is an example test class for testing sys::Str : class StrTest extends Test { static void testEquals() { assert(\"a\".equals(\"a\")) assert(!\"a\".equals(\"x\")) } }","title":"Test Methods"},{"location":"development/testing/#test-harness","text":"Follow these steps to run the test harness: Ensure that your scode image includes test code by setting the sedonaCode.test attribute to true in your scode XML build file. If you need to free up extra memory, or wish to narrow the tests to run, you can set the depend.test attribute on each kit element in your scode XML build file. This allows you to include or exclude test code on a kit by kit basis (if sedonaCode.test is false then these attributes are ignored). Ensure the main attribute is set to sys::Sys.main in your scode XML build file Build the test version of your scode Run the VM using the -test argument, which will execute all the test methods and report assert successes and failures: svm kits.scode -test","title":"Test Harness"},{"location":"language/arrays/","text":"Arrays \u00b6 Overview \u00b6 The Sedona Framework model for arrays is very similar to the C language. An array is just a block of memory large enough hold a declared number of items. Arrays do not store their own length, so bounds checking is up to the developer. The format of an array type declaration is: <Type>[<size>] // size is optional byte[10] buf // example of sized array type declaration Person[] people // example of unsized array type declaration If the size of the array is specified between the brackets we call it a sized array , otherwise we call it a unsized array . The Sedona Framework does not support multi-dimensional arrays. Memory Management \u00b6 Arrays are always passed by reference - the reference is just a pointer to the base address of the array. To actually allocate memory for an array, it must be declared as an inline field. For example: class Foo { static int[5] x static inline int[5] y } In the class above we declare two static fields. The field x is a reference to an array of five ints - so it allocates enough memory to store a pointer (typically 4 bytes on a 32-bit machine). The field y on the other hand is storage for five ints, so it allocates 20 bytes. In the example above Foo.x is just a pointer, so you can set x to any value that points to 5 ints. For example the assignment x=y updates x to point to the block of memory allocated by y . On the other hand, y actually allocates a block of memory to store 5 ints. You can pass y around as a pointer and index its values, but you cannot change what it points to. Like all inline fields, y can never be used as the left hand side of an assignment statement. Arrays of References \u00b6 An array of objects is stored as an array of references to those objects. On a machine with 32-bit pointers, this means that an array of 3 objects will always be 12 bytes no matter how big the objects themselves are. However, there is a special syntax for allocating enough memory to hold the objects too: class Point { int x int y } class Shape { static Point [] a static inline Point [ 3 ] b static inline Point [ 3 ] c = {...} } The Point class stores two ints, which means a single instance of Point is 8 bytes. Note the three different field declarations in Shape : Shape.a : The first field a declares a pointer to an array of Point s, so a is allocated enough memory to store a single pointer (most likely 4 bytes). Shape.b : The field Point.b allocates enough memory to store 3 references to Points , but doesn't allocate any memory for actual Point instances - so b would allocate 12 bytes on a 32-bit machine. The references don't point to anything yet; they must be initialized elsewhere to point to actual objects. Shape.c : The Point.c field uses the special syntax = {...} to allocate enough memory for an array of 3 references to Points and 3 instances of Points . So c will allocate 36 bytes of memory on a 32-bit machine: 12 for the array itself, plus 3*8 for the instances. The compiler auto-generates initialization code to assign the references to the instances. Unsized Classes \u00b6 Under most circumstances you must specify a size to declare an inline array. However a class may declare one instance field as an unsized inline array. We call these classes unsized classes because their size isn't fixed. To make this work, unsized classes have a few special rules: The class can have no more than one unsized inline array The unsized inline array must be an instance field (not static) The array length must be assigned in the constructor The length must be assigned directly from a constructor parameter The class must be declared final (true of all classes with constructor arguments) The sys::Buf class is a good example of an unsized class: final class Buf { Buf ( int maxBufLen ) { this . bytesLen = maxBufLen this . bytes . length = maxBufLen } inline byte [] bytes // raw byte array short bytesLen // length of bytes array } The code snippet above illustrates how to declare an unsized inline array. The constructor must have a statement that assigns the \"length field\" of the array. The right hand side of the assignment must be a parameter of the constructor (it can't be a calculated value). To declare an instance of a Buf we pass the length to the inline constructor: inline Buf(3) buf1st inline Buf(10) buf2nd In the example above we declared two instances of Buf . The first buffer allocates enough memory to store Buf 's fixed slots (such as bytesLen ) plus enough memory for 3 bytes. The second buffer allocates enough memory for Buf 's fixed slots plus 10 bytes. This feature is used extensively when working with the sys::Str class. Array Literals \u00b6 Some array types may be declared as literals in code: define Str[] colors = {\"red\", \"green\", \"blue\"} See Array Literals for more details.","title":"Arrays"},{"location":"language/arrays/#arrays","text":"","title":"Arrays"},{"location":"language/arrays/#overview","text":"The Sedona Framework model for arrays is very similar to the C language. An array is just a block of memory large enough hold a declared number of items. Arrays do not store their own length, so bounds checking is up to the developer. The format of an array type declaration is: <Type>[<size>] // size is optional byte[10] buf // example of sized array type declaration Person[] people // example of unsized array type declaration If the size of the array is specified between the brackets we call it a sized array , otherwise we call it a unsized array . The Sedona Framework does not support multi-dimensional arrays.","title":"Overview"},{"location":"language/arrays/#memory-management","text":"Arrays are always passed by reference - the reference is just a pointer to the base address of the array. To actually allocate memory for an array, it must be declared as an inline field. For example: class Foo { static int[5] x static inline int[5] y } In the class above we declare two static fields. The field x is a reference to an array of five ints - so it allocates enough memory to store a pointer (typically 4 bytes on a 32-bit machine). The field y on the other hand is storage for five ints, so it allocates 20 bytes. In the example above Foo.x is just a pointer, so you can set x to any value that points to 5 ints. For example the assignment x=y updates x to point to the block of memory allocated by y . On the other hand, y actually allocates a block of memory to store 5 ints. You can pass y around as a pointer and index its values, but you cannot change what it points to. Like all inline fields, y can never be used as the left hand side of an assignment statement.","title":"Memory Management"},{"location":"language/arrays/#arrays-of-references","text":"An array of objects is stored as an array of references to those objects. On a machine with 32-bit pointers, this means that an array of 3 objects will always be 12 bytes no matter how big the objects themselves are. However, there is a special syntax for allocating enough memory to hold the objects too: class Point { int x int y } class Shape { static Point [] a static inline Point [ 3 ] b static inline Point [ 3 ] c = {...} } The Point class stores two ints, which means a single instance of Point is 8 bytes. Note the three different field declarations in Shape : Shape.a : The first field a declares a pointer to an array of Point s, so a is allocated enough memory to store a single pointer (most likely 4 bytes). Shape.b : The field Point.b allocates enough memory to store 3 references to Points , but doesn't allocate any memory for actual Point instances - so b would allocate 12 bytes on a 32-bit machine. The references don't point to anything yet; they must be initialized elsewhere to point to actual objects. Shape.c : The Point.c field uses the special syntax = {...} to allocate enough memory for an array of 3 references to Points and 3 instances of Points . So c will allocate 36 bytes of memory on a 32-bit machine: 12 for the array itself, plus 3*8 for the instances. The compiler auto-generates initialization code to assign the references to the instances.","title":"Arrays of References"},{"location":"language/arrays/#unsized-classes","text":"Under most circumstances you must specify a size to declare an inline array. However a class may declare one instance field as an unsized inline array. We call these classes unsized classes because their size isn't fixed. To make this work, unsized classes have a few special rules: The class can have no more than one unsized inline array The unsized inline array must be an instance field (not static) The array length must be assigned in the constructor The length must be assigned directly from a constructor parameter The class must be declared final (true of all classes with constructor arguments) The sys::Buf class is a good example of an unsized class: final class Buf { Buf ( int maxBufLen ) { this . bytesLen = maxBufLen this . bytes . length = maxBufLen } inline byte [] bytes // raw byte array short bytesLen // length of bytes array } The code snippet above illustrates how to declare an unsized inline array. The constructor must have a statement that assigns the \"length field\" of the array. The right hand side of the assignment must be a parameter of the constructor (it can't be a calculated value). To declare an instance of a Buf we pass the length to the inline constructor: inline Buf(3) buf1st inline Buf(10) buf2nd In the example above we declared two instances of Buf . The first buffer allocates enough memory to store Buf 's fixed slots (such as bytesLen ) plus enough memory for 3 bytes. The second buffer allocates enough memory for Buf 's fixed slots plus 10 bytes. This feature is used extensively when working with the sys::Str class.","title":"Unsized Classes"},{"location":"language/arrays/#array-literals","text":"Some array types may be declared as literals in code: define Str[] colors = {\"red\", \"green\", \"blue\"} See Array Literals for more details.","title":"Array Literals"},{"location":"language/classes/","text":"Classes \u00b6 Overview \u00b6 Classes are the primary way you organize your code within kits. Classes are named containers for fields and methods. A field or method definition is called a slot and identified by a unique name within a given class. Slots may not be overloaded by name, which means you cannot declare a field and method to have the same name (allowed in Java). Nor can you declare multiple methods with the same name overloaded by parameters (allowed in both Java and C#). You can declare multiple classes in a single source file, although by convention each class is placed in its own source file with the same name. For example the class \"Thing\" would be declared in the file \"Thing.sedona\". Modifiers \u00b6 By default a class is public , or you can explicitly use the public keyword. Alternatively use the internal keyword to declare a class that only has visibility within its kit. The abstract keyword is used with classes that can never be instantiated directly. Any class that declares abstract methods must be marked abstract. Use the final class modifier to prevent a class from being subclassed. Inheritance \u00b6 The Sedona Framework supports inheritance much like Java or C#. However, there is no support for interfaces or any type of multiple inheritance. Similar to Java, all Sedona classes implicitly extend sys::Obj , a class with no fields or methods of its own. To support polymorphism and virtual methods, however, a Sedona class (or some class in its hierarchy) must explicitly extend sys::Virtual , which allocates space for the virtual table. The syntax for inheritance looks just like Java with the extends keyword: abstract class Shape extends Virtual { abstract int area () } class Square extends Shape { override int area () { return width * width } int width } Note that extending Virtual has some memory impact: In addition to the space required for the type's virtual table, it imposes a two byte overhead per class instance.","title":"Classes"},{"location":"language/classes/#classes","text":"","title":"Classes"},{"location":"language/classes/#overview","text":"Classes are the primary way you organize your code within kits. Classes are named containers for fields and methods. A field or method definition is called a slot and identified by a unique name within a given class. Slots may not be overloaded by name, which means you cannot declare a field and method to have the same name (allowed in Java). Nor can you declare multiple methods with the same name overloaded by parameters (allowed in both Java and C#). You can declare multiple classes in a single source file, although by convention each class is placed in its own source file with the same name. For example the class \"Thing\" would be declared in the file \"Thing.sedona\".","title":"Overview"},{"location":"language/classes/#modifiers","text":"By default a class is public , or you can explicitly use the public keyword. Alternatively use the internal keyword to declare a class that only has visibility within its kit. The abstract keyword is used with classes that can never be instantiated directly. Any class that declares abstract methods must be marked abstract. Use the final class modifier to prevent a class from being subclassed.","title":"Modifiers"},{"location":"language/classes/#inheritance","text":"The Sedona Framework supports inheritance much like Java or C#. However, there is no support for interfaces or any type of multiple inheritance. Similar to Java, all Sedona classes implicitly extend sys::Obj , a class with no fields or methods of its own. To support polymorphism and virtual methods, however, a Sedona class (or some class in its hierarchy) must explicitly extend sys::Virtual , which allocates space for the virtual table. The syntax for inheritance looks just like Java with the extends keyword: abstract class Shape extends Virtual { abstract int area () } class Square extends Shape { override int area () { return width * width } int width } Note that extending Virtual has some memory impact: In addition to the space required for the type's virtual table, it imposes a two byte overhead per class instance.","title":"Inheritance"},{"location":"language/components/","text":"Components \u00b6 Overview \u00b6 Sedona is a component oriented language, which means that programs are developed as reusable chunks of code designed to be snapped together much like Lego building blocks. This chapter discusses components themselves; the Apps chapter discusses how components are assembled into applications. A component is any class that extends sys::Component . Components include several features: Can define property fields Can define action methods Can be organized into a tree structure Can be given a human friendly name (up to 7 ASCII characters) Have a two byte identifier within an application Can be linked within an application Provides callback methods that can be overridden Component types have reflection capability Properties \u00b6 Properties are normal instance fields that are annotated with the property keyword. Properties are how components expose configuration and runtime state. Properties are restricted to the following types: bool byte short int long float double sys::Buf Note that you must use the := operator when assigning values to properties. See Assigning to Properties for details. Config vs Runtime \u00b6 Properties are either config or runtime . Config properties are persistent and typically are changed by the user. Runtime properties are transient and are changed by the component itself during runtime. Properties are runtime by default unless marked with the \"config\" facet. A simple example: class FooServer extends Component { @config property bool enabled @config property int port = 80 property int count // runtime prop } Buf Properties \u00b6 Properties typed as Buf are a bit special from the primitive property types. The biggest difference is that primitives are by-value and can't be changed without setting the field itself. However, buffer properties are always inlined and accessed by reference. When declaring a buffer property, the inline modifier is implied. The following example illustrates a buffer property with a total capacity of 8 bytes: class Foo extends Component { property Buf(8) blob } Because buffer properties are accessed by reference, the framework has no knowledge when the buffer is modified. So it is the developer's responsibility to notify the framework of a buffer change via the Component.changed method (typically using a slot literal): void updateBlob() { blob.copyFromStr(\"wow!\") changed(Foo.blob) } Note that changed is called automatically when setting primitive property types. You should only manually call changed for Buf properties. AsStr Properties \u00b6 Buf is the only non-primitive property type available. However, it is a common case to store a Str value in a Buf property. If you know that a buffer property will always store a null-terminated string, then you should mark the property with the \"asStr\" facet: class Foo extends Component { @config @asStr property Buf(8) descr } The Buf size is the total capacity including the null terminator - so in the example above we can store a string with a max of seven characters. The Buf class has convenience methods when storing a string such as toStr and copyFromStr . Marking a buffer property asStr has a couple of benefits: Buffer overruns are handled to ensure that there is always a null terminator during deserialization. It lets higher levels of the framework treat the buffer as more than raw binary data. For example, asStr properties are serialized as text rather than base64 in XML files. Actions \u00b6 Actions are normal instance methods that are annotated with the action keyword. Every action is implicitly defined to be virtual , so they can be overridden. Actions are typically used as commands on a component. As methods, actions \"do something\" rather than store or display a value. Actions methods must be declared to return void and must have zero or one parameter. If a parameter is specified then it must be one of the following types: bool int long float double sys::Buf Examples of \"actions in action\": class Foo extends Component { action void actionNoArg() { Sys.out.print(\"actionNoArg\").nl() } @asStr action void actionStr(Buf x) { Sys.out.print(x.toStr()).nl() } } class FooOverride extends Foo { override action void actionNoArg() { Sys.out.print(\"Override actionNoArg\").nl() } } Note that you can use the \"asStr\" facet to annotate an action that takes a Buf, if the argument should be a null-terminated string. Callbacks \u00b6 Any class that extends sys::Component includes the following virtual methods. Each is called automatically by the system at the appropriate time. These callback methods may be overridden by Component subclasses to change the behavior of the component. virtual void loaded() virtual void start() virtual void execute() virtual void changed(Slot slot) virtual void setToDefault(Slot slot) virtual int childEvent(int eType, Component child) virtual int parentEvent(int eType, Component parent) virtual int linkEvent(int eType, Link link) See the API documentation at sys::Component for details on how these methods are used.","title":"Components"},{"location":"language/components/#components","text":"","title":"Components"},{"location":"language/components/#overview","text":"Sedona is a component oriented language, which means that programs are developed as reusable chunks of code designed to be snapped together much like Lego building blocks. This chapter discusses components themselves; the Apps chapter discusses how components are assembled into applications. A component is any class that extends sys::Component . Components include several features: Can define property fields Can define action methods Can be organized into a tree structure Can be given a human friendly name (up to 7 ASCII characters) Have a two byte identifier within an application Can be linked within an application Provides callback methods that can be overridden Component types have reflection capability","title":"Overview"},{"location":"language/components/#properties","text":"Properties are normal instance fields that are annotated with the property keyword. Properties are how components expose configuration and runtime state. Properties are restricted to the following types: bool byte short int long float double sys::Buf Note that you must use the := operator when assigning values to properties. See Assigning to Properties for details.","title":"Properties"},{"location":"language/components/#config-vs-runtime","text":"Properties are either config or runtime . Config properties are persistent and typically are changed by the user. Runtime properties are transient and are changed by the component itself during runtime. Properties are runtime by default unless marked with the \"config\" facet. A simple example: class FooServer extends Component { @config property bool enabled @config property int port = 80 property int count // runtime prop }","title":"Config vs Runtime"},{"location":"language/components/#buf-properties","text":"Properties typed as Buf are a bit special from the primitive property types. The biggest difference is that primitives are by-value and can't be changed without setting the field itself. However, buffer properties are always inlined and accessed by reference. When declaring a buffer property, the inline modifier is implied. The following example illustrates a buffer property with a total capacity of 8 bytes: class Foo extends Component { property Buf(8) blob } Because buffer properties are accessed by reference, the framework has no knowledge when the buffer is modified. So it is the developer's responsibility to notify the framework of a buffer change via the Component.changed method (typically using a slot literal): void updateBlob() { blob.copyFromStr(\"wow!\") changed(Foo.blob) } Note that changed is called automatically when setting primitive property types. You should only manually call changed for Buf properties.","title":"Buf Properties"},{"location":"language/components/#asstr-properties","text":"Buf is the only non-primitive property type available. However, it is a common case to store a Str value in a Buf property. If you know that a buffer property will always store a null-terminated string, then you should mark the property with the \"asStr\" facet: class Foo extends Component { @config @asStr property Buf(8) descr } The Buf size is the total capacity including the null terminator - so in the example above we can store a string with a max of seven characters. The Buf class has convenience methods when storing a string such as toStr and copyFromStr . Marking a buffer property asStr has a couple of benefits: Buffer overruns are handled to ensure that there is always a null terminator during deserialization. It lets higher levels of the framework treat the buffer as more than raw binary data. For example, asStr properties are serialized as text rather than base64 in XML files.","title":"AsStr Properties"},{"location":"language/components/#actions","text":"Actions are normal instance methods that are annotated with the action keyword. Every action is implicitly defined to be virtual , so they can be overridden. Actions are typically used as commands on a component. As methods, actions \"do something\" rather than store or display a value. Actions methods must be declared to return void and must have zero or one parameter. If a parameter is specified then it must be one of the following types: bool int long float double sys::Buf Examples of \"actions in action\": class Foo extends Component { action void actionNoArg() { Sys.out.print(\"actionNoArg\").nl() } @asStr action void actionStr(Buf x) { Sys.out.print(x.toStr()).nl() } } class FooOverride extends Foo { override action void actionNoArg() { Sys.out.print(\"Override actionNoArg\").nl() } } Note that you can use the \"asStr\" facet to annotate an action that takes a Buf, if the argument should be a null-terminated string.","title":"Actions"},{"location":"language/components/#callbacks","text":"Any class that extends sys::Component includes the following virtual methods. Each is called automatically by the system at the appropriate time. These callback methods may be overridden by Component subclasses to change the behavior of the component. virtual void loaded() virtual void start() virtual void execute() virtual void changed(Slot slot) virtual void setToDefault(Slot slot) virtual int childEvent(int eType, Component child) virtual int parentEvent(int eType, Component parent) virtual int linkEvent(int eType, Link link) See the API documentation at sys::Component for details on how these methods are used.","title":"Callbacks"},{"location":"language/expr/","text":"Expressions \u00b6 Overview \u00b6 Expressions are almost identical to those found in C or Java. The same operator precedence rules apply: Expression(s) Operator(s) Accessors . ?. () [] Unary - ! ~ ++ -- (cast) Multiplicative * / % Additive + - Bitwise Shift >> << Elvis ?: Relational < <= > >= Equality == != Bitwise AND & Bitwise XOR ^ Bitwise OR | Logical AND && Logical OR || Ternary ? : Assignment = += -= *= /= |= ^= &= >>= <<= Arithmetic Operators \u00b6 The following arithmetic operators may be used with numeric primitives: Name Operator Multiplication x * y Division x / y Modulus (remainder) x % y Addition x + y Subtraction x - y Negation -x Prefix Increment ++x Prefix Decrement --x Postfix Increment x++ Postfix Decrement x-- The Modulus operator is only available for integer types, it may not be used with floats or doubles. The prefix/postfix operators work just like C and Java. If using the prefix operator the result of the expression is the new value. If using the postfix operator the result is the old value: int x = 4 // x == 4 int y = ++x // x == 5, y == 5 int z = x++ // x == 6, z == 5 Bitwise Operators \u00b6 The following bitwise operators may be used with integer primitives (byte, short, int, long): Name Operator Or x | y Xor x ^ y And x & y Left Shift x << y Right Shift x >> y Not ~x Logical Operators \u00b6 The following logical operators may be used with booleans: Name Operator Or x || y And x && y Not !x Both the Or and And operators are short circuiting. If the first term of Or evaluates to true, then the second term is not evaluated. If the first term of And evaluates to false, then the second term is not evaluated. Comparison \u00b6 The following operators are used for comparison: Name Operator Equal x == y Not Equal x != y Greater Than x > y Greater Than or Equal x >= y Less Than x < y Less Than or Equal x <= y Non-numeric types may only use the equality ( == and != ) operators. Reference types compare identity (pointer address). Assignment \u00b6 The = operator is used to assign the right hand side expression to the left hand side. The left hand side must be assignable . Assignable expressions are local variables, fields, and array indices. The compound assignment operators += -= *= /= |= ^= &= >>= <<= can be used to combine an arithmetic or bitwise operator with assignment: int x = 5 // x == 5 x += 3 // x == 8 Assigning to Properties \u00b6 If the left hand side of an assignment expression is a component property then you must use the := assignment operator instead of = . This highlights the fact that assigning a new value to a property results in more than just the storage of the new value; it also has potential side effects that may not always be visible to the user. Note that there are no compound property assignment operators; increment, decrement, etc must be spelled out explicitly in the expression. // Property px property int px // Non-property field ix int ix void myfunc () { // Use := when lhs is a property px : = 3 // Use = when lhs is a non-property ix = px // No compound assignment operators px : = px + 1 } Casting \u00b6 Sedona uses a syntax just like C or Java to perform a cast. Casts are required when the compiler cannot perform a static type check. For example, if you need to assign an Obj to a Component, then you must use a cast: c = (Component)obj . This type of cast is for compile time checking only, at runtime it is basically a no-op like C. Casts are also used with numeric types to perform a type conversion. For example to convert an int into a float: f = (float)i . Note that unlike C and Java, upcasts such as from an int to a long are not implicit - you must be explicitly use a cast. Safe Navigation \u00b6 Sedona supports Groovy's safe navigation operator: x?.slot . You can use the safe nav operator to access fields or call methods. If the target expression of a slot access is null, then the whole expression short circuits to evaluate to null. If the field or method returns a primitive then it short circuits to false/zero. Using the safe nav operator is a convenient and more efficient way than manually checking for null: // hard way DeviceNetwork net = null if (point != null) { Device dev = point.getDevice() if (dev != null) net = dev.getNetwork() } // easy way DeviceNetwork net = point?.getDevice()?.getNetwork() Elvis \u00b6 Sedona supports Groovy's elvis operator: lhs ?: rhs . If lhs evaluates to null, then the whole expression evaluates to rhs. If lhs is non-null, then the rhs is short circuited and the whole expression evaluates to lhs. The elvis operator is a convenient and more efficient way to write code where you might use the ternary operator: // hard way name != null ? name : \"unknown\" // easy way name ?: \"unknown\" Ternary \u00b6 Sedona supports the C/Java ternary operator: c ? t : f . The boolean expression c is evaluated. If true then the ternary expression evaluates to t , otherwise it evaluates to f : bool x = true Str msg = x ? \"On\" : \"Off\" // msg == \"On\" x = false msg = x ? \"On\" : \"Off\" // msg == \"Off\" String Interpolation \u00b6 Sedona supports string interpolation, which allows for concise string formatting. String interpolation can be used with any method that has one Str parameter and returns an OutStream . You may use the \"+\" operator to concatenate multiple expressions to a string literal: // using the + operator int x = 77 Sys.out.print(\"x=\" + x) // is equivalent to this statement Sys.out.print(\"x=\").printInt(x) The example above illustrates why interpolation is only used with methods that take a Str and return an OutStream . The compiler doesn't actually create a new string, rather it chains multiple print calls. Use of the \"+\" operator is allowed, but the preferred mechanism for string formatting is to embed the expressions directly into the string literal itself using the '$' character. You can embed any arbitrary expression into a string literal using the syntax \"${expr}\" . If the expression is a simple variable name or a variable name followed by a dot field access, then you can omit the curly braces. Use the '\\$' escape sequence to print the dollar sign itself. Some examples: // example from above Sys . out . print ( \"x=${x}\" ) // same but omitting the braces Sys . out . print ( \"x=$x\" ) // embedded expressions Sys . out . print ( \"x=0x${Sys.hexStr(x)}\" ) The following types are supported with string interpolation: Type Print Method Str OutStream.print bool OutStream.printBool int OutStream.printInt long OutStream.printLong float OutStream.printFloat double OutStream.printDouble","title":"Expressions"},{"location":"language/expr/#expressions","text":"","title":"Expressions"},{"location":"language/expr/#overview","text":"Expressions are almost identical to those found in C or Java. The same operator precedence rules apply: Expression(s) Operator(s) Accessors . ?. () [] Unary - ! ~ ++ -- (cast) Multiplicative * / % Additive + - Bitwise Shift >> << Elvis ?: Relational < <= > >= Equality == != Bitwise AND & Bitwise XOR ^ Bitwise OR | Logical AND && Logical OR || Ternary ? : Assignment = += -= *= /= |= ^= &= >>= <<=","title":"Overview"},{"location":"language/expr/#arithmetic-operators","text":"The following arithmetic operators may be used with numeric primitives: Name Operator Multiplication x * y Division x / y Modulus (remainder) x % y Addition x + y Subtraction x - y Negation -x Prefix Increment ++x Prefix Decrement --x Postfix Increment x++ Postfix Decrement x-- The Modulus operator is only available for integer types, it may not be used with floats or doubles. The prefix/postfix operators work just like C and Java. If using the prefix operator the result of the expression is the new value. If using the postfix operator the result is the old value: int x = 4 // x == 4 int y = ++x // x == 5, y == 5 int z = x++ // x == 6, z == 5","title":"Arithmetic Operators"},{"location":"language/expr/#bitwise-operators","text":"The following bitwise operators may be used with integer primitives (byte, short, int, long): Name Operator Or x | y Xor x ^ y And x & y Left Shift x << y Right Shift x >> y Not ~x","title":"Bitwise Operators"},{"location":"language/expr/#logical-operators","text":"The following logical operators may be used with booleans: Name Operator Or x || y And x && y Not !x Both the Or and And operators are short circuiting. If the first term of Or evaluates to true, then the second term is not evaluated. If the first term of And evaluates to false, then the second term is not evaluated.","title":"Logical Operators"},{"location":"language/expr/#comparison","text":"The following operators are used for comparison: Name Operator Equal x == y Not Equal x != y Greater Than x > y Greater Than or Equal x >= y Less Than x < y Less Than or Equal x <= y Non-numeric types may only use the equality ( == and != ) operators. Reference types compare identity (pointer address).","title":"Comparison"},{"location":"language/expr/#assignment","text":"The = operator is used to assign the right hand side expression to the left hand side. The left hand side must be assignable . Assignable expressions are local variables, fields, and array indices. The compound assignment operators += -= *= /= |= ^= &= >>= <<= can be used to combine an arithmetic or bitwise operator with assignment: int x = 5 // x == 5 x += 3 // x == 8","title":"Assignment"},{"location":"language/expr/#assigning-to-properties","text":"If the left hand side of an assignment expression is a component property then you must use the := assignment operator instead of = . This highlights the fact that assigning a new value to a property results in more than just the storage of the new value; it also has potential side effects that may not always be visible to the user. Note that there are no compound property assignment operators; increment, decrement, etc must be spelled out explicitly in the expression. // Property px property int px // Non-property field ix int ix void myfunc () { // Use := when lhs is a property px : = 3 // Use = when lhs is a non-property ix = px // No compound assignment operators px : = px + 1 }","title":"Assigning to Properties"},{"location":"language/expr/#casting","text":"Sedona uses a syntax just like C or Java to perform a cast. Casts are required when the compiler cannot perform a static type check. For example, if you need to assign an Obj to a Component, then you must use a cast: c = (Component)obj . This type of cast is for compile time checking only, at runtime it is basically a no-op like C. Casts are also used with numeric types to perform a type conversion. For example to convert an int into a float: f = (float)i . Note that unlike C and Java, upcasts such as from an int to a long are not implicit - you must be explicitly use a cast.","title":"Casting"},{"location":"language/expr/#safe-navigation","text":"Sedona supports Groovy's safe navigation operator: x?.slot . You can use the safe nav operator to access fields or call methods. If the target expression of a slot access is null, then the whole expression short circuits to evaluate to null. If the field or method returns a primitive then it short circuits to false/zero. Using the safe nav operator is a convenient and more efficient way than manually checking for null: // hard way DeviceNetwork net = null if (point != null) { Device dev = point.getDevice() if (dev != null) net = dev.getNetwork() } // easy way DeviceNetwork net = point?.getDevice()?.getNetwork()","title":"Safe Navigation"},{"location":"language/expr/#elvis","text":"Sedona supports Groovy's elvis operator: lhs ?: rhs . If lhs evaluates to null, then the whole expression evaluates to rhs. If lhs is non-null, then the rhs is short circuited and the whole expression evaluates to lhs. The elvis operator is a convenient and more efficient way to write code where you might use the ternary operator: // hard way name != null ? name : \"unknown\" // easy way name ?: \"unknown\"","title":"Elvis"},{"location":"language/expr/#ternary","text":"Sedona supports the C/Java ternary operator: c ? t : f . The boolean expression c is evaluated. If true then the ternary expression evaluates to t , otherwise it evaluates to f : bool x = true Str msg = x ? \"On\" : \"Off\" // msg == \"On\" x = false msg = x ? \"On\" : \"Off\" // msg == \"Off\"","title":"Ternary"},{"location":"language/expr/#string-interpolation","text":"Sedona supports string interpolation, which allows for concise string formatting. String interpolation can be used with any method that has one Str parameter and returns an OutStream . You may use the \"+\" operator to concatenate multiple expressions to a string literal: // using the + operator int x = 77 Sys.out.print(\"x=\" + x) // is equivalent to this statement Sys.out.print(\"x=\").printInt(x) The example above illustrates why interpolation is only used with methods that take a Str and return an OutStream . The compiler doesn't actually create a new string, rather it chains multiple print calls. Use of the \"+\" operator is allowed, but the preferred mechanism for string formatting is to embed the expressions directly into the string literal itself using the '$' character. You can embed any arbitrary expression into a string literal using the syntax \"${expr}\" . If the expression is a simple variable name or a variable name followed by a dot field access, then you can omit the curly braces. Use the '\\$' escape sequence to print the dollar sign itself. Some examples: // example from above Sys . out . print ( \"x=${x}\" ) // same but omitting the braces Sys . out . print ( \"x=$x\" ) // embedded expressions Sys . out . print ( \"x=0x${Sys.hexStr(x)}\" ) The following types are supported with string interpolation: Type Print Method Str OutStream.print bool OutStream.printBool int OutStream.printInt long OutStream.printLong float OutStream.printFloat double OutStream.printDouble","title":"String Interpolation"},{"location":"language/fields/","text":"Fields \u00b6 Overview \u00b6 Fields are storage locations used to store a class variable. The following keywords may be applied to a field declaration: static : class-based field (versus instance-based, see below) const : indicates a field is immutable inline : allocates memory for the variable instance define : used to declare a constant variable property : promotes a field to a component property In addition to the keywords above, a field may be annotated with a protection scope keyword . If no protection scope is specified, then public is assumed. Static versus Instance Fields \u00b6 If a field is marked with the static keyword, then the field is stored once for all instances of that class. Static fields are essentially global variables scoped within a class type. Instance fields on the other hand allocate storage for each instance of the declaring type: class Display { static int maxId = 5 int id = -1 int width int height } In the code above we declare a class called Display with three instance fields id , width , and height . Each instance of Display will store its own copies of these fields. The static field maxId has one fixed memory location for the whole Sedona VM. Field Access \u00b6 Access to instance fields is done through an implicit or explicit instance pointer. The keyword this may be used to reference the current instance inside an instance method. If no instance pointer is used, then this is implied (only available inside an instance method): int area () { return this . width * this . height // this keyword } int area () { return width * height // shortcut for above } static int area ( Display d ) { return d . width * d . height // explicit instance pointer } Access to static fields is done through an implicit or explicit type literal. Implicit static access (where the type name is not specified) is only available inside methods of the Display class: static bool isValidId ( int id ) { return id < maxId // implicit static field access } static bool isValidId ( int id ) { return id < Display . maxId // explicit static field access } Also see Safe Navigation for how to use the \"?.\" operator for field access. Field Defaults \u00b6 Fields of a primitive type can declare a default expression. For example in the Display class declared above, the maxId field defaults to 5 and the id field defaults to -1 . Static fields are initialized when the Sedona VM is booted. The compiler will automatically create a synthetic method called _sInit() , which executes the initialization code for static fields. Instance fields are initialized in the declaring class's constructor . Any field without a default value has its memory initialized to zero. In the case of bool fields it is false , for numeric fields it is 0, and for references it is null . Const Fields \u00b6 Some of the core types in the sys kit contain fields marked with the const keyword. This indicates that these fields are immutable, and are actually stored within the scode memory itself. On some platforms these fields may be stored in readonly memory such as ROM. Attempts to set a const field will result in a compiler error. You cannot create your own const fields directly - only the predefined sys types can use this keyword. However you can use the define keyword to declare user defined constants. Define Fields \u00b6 The define keyword is used to declare a named constant. Defines are like const fields - if you try to assign to a define field you will get a compiler error. Defines don't actually allocate memory, rather they are inlined at compile time. Because of this trait, the value of a define field must be expressed as a literal value: class Flags { define int tooBig = 0x01 define int tooSmall = 0x02 } Defines are accessed just like static fields: if (( f & tooBig ) != 0 ) return true // implicit access if (( f & Flags . tooBig ) != 0 ) return true // explicit access The following types are supported for defines: bool : true , false , or null int : 32-bit integer literal value long : 64-bit integer literal value (or time literal) float : 32-bit float literal value double : 64-bit float literal value sys::Str : null terminated string literal sys::Log : see Logging Array literals: see next section Array Literals \u00b6 The define keyword may be used to create constant array literals. This allows you to declare readonly data lookup tables that will be stored in scode. The following array literal types are supported: byte[] short[] int[] long[] float[] double[] Str[] Array literals are declared using curly braces with a comma separator. The values inside an array literal must be literals themselves (they cannot be expressions). Examples: define byte[] daysInMonths = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} define Str[] weekdays = {\"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\" } Array literals are treated like const structures and are read-only. It is a compile time error to assign to a array literal (or any define). Inline Fields \u00b6 A field with a non-primitive (i.e. object) type is normally a reference to a sys::Obj object. Inside the SVM, an object field is a pointer to an object. For example on a 32-bit machine, an object field would allocate 4 bytes for a pointer. The object itself resides elsewhere in memory. However, often we wish the field to contain an instance of the object. This is done with the inline keyword. Let's look at an example: class Point { int x ; int y } class Foo { Point a inline Point b } In this example Foo.a is a pointer field - it allocates just enough space to store a pointer to a Point instance (typically 4 bytes). However, Foo.b actually allocates memory to store the entire Point instance (8 bytes to store two 32-bit ints). Inline fields play an important role in the Sedona Framework's static memory management. They allow you to develop complex data structures where memory is laid out by the compiler. This makes it possible for tools to calculate ahead of time exactly how much memory a component requires, since they can assume the component will not be allocating any additional memory during runtime. Inline fields can be static or instance based. Inline fields use the same syntax as reference fields. However an inline field is not assignable. You cannot point the reference to another instance since the entire instance is already embedded (you will get a compiler error if you try). Property Fields \u00b6 Fields may be annotated with the property keyword to promote the field into a Component property. Properties must be instance fields on a subclass of sys::Component . See Component Properties for more details.","title":"Fields"},{"location":"language/fields/#fields","text":"","title":"Fields"},{"location":"language/fields/#overview","text":"Fields are storage locations used to store a class variable. The following keywords may be applied to a field declaration: static : class-based field (versus instance-based, see below) const : indicates a field is immutable inline : allocates memory for the variable instance define : used to declare a constant variable property : promotes a field to a component property In addition to the keywords above, a field may be annotated with a protection scope keyword . If no protection scope is specified, then public is assumed.","title":"Overview"},{"location":"language/fields/#static-versus-instance-fields","text":"If a field is marked with the static keyword, then the field is stored once for all instances of that class. Static fields are essentially global variables scoped within a class type. Instance fields on the other hand allocate storage for each instance of the declaring type: class Display { static int maxId = 5 int id = -1 int width int height } In the code above we declare a class called Display with three instance fields id , width , and height . Each instance of Display will store its own copies of these fields. The static field maxId has one fixed memory location for the whole Sedona VM.","title":"Static versus Instance Fields"},{"location":"language/fields/#field-access","text":"Access to instance fields is done through an implicit or explicit instance pointer. The keyword this may be used to reference the current instance inside an instance method. If no instance pointer is used, then this is implied (only available inside an instance method): int area () { return this . width * this . height // this keyword } int area () { return width * height // shortcut for above } static int area ( Display d ) { return d . width * d . height // explicit instance pointer } Access to static fields is done through an implicit or explicit type literal. Implicit static access (where the type name is not specified) is only available inside methods of the Display class: static bool isValidId ( int id ) { return id < maxId // implicit static field access } static bool isValidId ( int id ) { return id < Display . maxId // explicit static field access } Also see Safe Navigation for how to use the \"?.\" operator for field access.","title":"Field Access"},{"location":"language/fields/#field-defaults","text":"Fields of a primitive type can declare a default expression. For example in the Display class declared above, the maxId field defaults to 5 and the id field defaults to -1 . Static fields are initialized when the Sedona VM is booted. The compiler will automatically create a synthetic method called _sInit() , which executes the initialization code for static fields. Instance fields are initialized in the declaring class's constructor . Any field without a default value has its memory initialized to zero. In the case of bool fields it is false , for numeric fields it is 0, and for references it is null .","title":"Field Defaults"},{"location":"language/fields/#const-fields","text":"Some of the core types in the sys kit contain fields marked with the const keyword. This indicates that these fields are immutable, and are actually stored within the scode memory itself. On some platforms these fields may be stored in readonly memory such as ROM. Attempts to set a const field will result in a compiler error. You cannot create your own const fields directly - only the predefined sys types can use this keyword. However you can use the define keyword to declare user defined constants.","title":"Const Fields"},{"location":"language/fields/#define-fields","text":"The define keyword is used to declare a named constant. Defines are like const fields - if you try to assign to a define field you will get a compiler error. Defines don't actually allocate memory, rather they are inlined at compile time. Because of this trait, the value of a define field must be expressed as a literal value: class Flags { define int tooBig = 0x01 define int tooSmall = 0x02 } Defines are accessed just like static fields: if (( f & tooBig ) != 0 ) return true // implicit access if (( f & Flags . tooBig ) != 0 ) return true // explicit access The following types are supported for defines: bool : true , false , or null int : 32-bit integer literal value long : 64-bit integer literal value (or time literal) float : 32-bit float literal value double : 64-bit float literal value sys::Str : null terminated string literal sys::Log : see Logging Array literals: see next section","title":"Define Fields"},{"location":"language/fields/#array-literals","text":"The define keyword may be used to create constant array literals. This allows you to declare readonly data lookup tables that will be stored in scode. The following array literal types are supported: byte[] short[] int[] long[] float[] double[] Str[] Array literals are declared using curly braces with a comma separator. The values inside an array literal must be literals themselves (they cannot be expressions). Examples: define byte[] daysInMonths = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} define Str[] weekdays = {\"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\" } Array literals are treated like const structures and are read-only. It is a compile time error to assign to a array literal (or any define).","title":"Array Literals"},{"location":"language/fields/#inline-fields","text":"A field with a non-primitive (i.e. object) type is normally a reference to a sys::Obj object. Inside the SVM, an object field is a pointer to an object. For example on a 32-bit machine, an object field would allocate 4 bytes for a pointer. The object itself resides elsewhere in memory. However, often we wish the field to contain an instance of the object. This is done with the inline keyword. Let's look at an example: class Point { int x ; int y } class Foo { Point a inline Point b } In this example Foo.a is a pointer field - it allocates just enough space to store a pointer to a Point instance (typically 4 bytes). However, Foo.b actually allocates memory to store the entire Point instance (8 bytes to store two 32-bit ints). Inline fields play an important role in the Sedona Framework's static memory management. They allow you to develop complex data structures where memory is laid out by the compiler. This makes it possible for tools to calculate ahead of time exactly how much memory a component requires, since they can assume the component will not be allocating any additional memory during runtime. Inline fields can be static or instance based. Inline fields use the same syntax as reference fields. However an inline field is not assignable. You cannot point the reference to another instance since the entire instance is already embedded (you will get a compiler error if you try).","title":"Inline Fields"},{"location":"language/fields/#property-fields","text":"Fields may be annotated with the property keyword to promote the field into a Component property. Properties must be instance fields on a subclass of sys::Component . See Component Properties for more details.","title":"Property Fields"},{"location":"language/lang/","text":"Language \u00b6 Overview \u00b6 Sedona is a programming language based upon the following principles: Familiar Syntax : Reuses C, Java, and C# syntax where possible. Object Oriented : Includes the three pillars of OO: encapsulated classes, inheritance, and polymorphism. Component Oriented : Based on a development paradigm of reusable software components. Applications are assembled by wiring together pre-built components. Static Typing : Uses a static type system much like Java and C# with explicit typing of fields, methods, and local variables. This allows the compiler to perform type checking. Static Memory : Manages memory statically at compile time, making it ideal for embedded platforms with limited resources. Namespaces \u00b6 Sedona Framework code is organized into a three unit hierarchy: Kit : A module of deployment and versioning. Kits form the top of the namespace and must be globally unique. Kit names are required to be prefixed with the vendor's name. Class : An object oriented unit of organization. Classes are always scoped within a kit. Slot : Special fields and methods defined within a class are called slots . Slots are the externally visible \"wiring points\" on a component that can be linked to other components in a Sedona application. Kits are globally unique and used to scope classes which in turn scope slots. We use this structure to define globally unique qualified names or qnames for classes and slots. A Class qname consists of the kit name and class name joined by the \"::\" separator. A slot qname is the class's qname joined to the slot's simple name by the \".\" separator: control::Ramp // class qname control::Ramp.out // slot qname Structure \u00b6 Sedona Framework software is packaged up into modules called kits . The source code for a kit is managed as a set of text files with the \".sedona\" extension. A \"kit.xml\" file instructs the compiler how to compile the kit and what directories contain the source code. A typical source directory is structured as follows: myCoolKit/ // directory for myCoolKit +- kit.xml // kit build manifest +- CoolComp.sedona // source file +- AnotherCoolComp.sedona // source file +- test/ +- CoolCompTest.sedona // source file for tests You can then compile the kit using either the directory or \"kit.xml\" file. Assuming your current directory is the parent of \"myCoolKit\" you could use either of the following commands to compile: sedonac myCoolKit sedonac myCoolKit/kit.xml Each source file is called a compilation unit . Source text files must use UTF-8 encoding (7-bit ASCII is a clean subset of UTF-8). Each compilation unit can contain one or more classes . Sedona does not require any correlation between your source file names and class names. However, by convention each class is sourced in a file with the same name. For example CoolComp is stored in a text file called \"CoolComp.sedona\". Classes \u00b6 A kit contains one or more classes . A class is very similar to a Java or C# class. However, Sedona doesn't have the concept of interfaces - so everything is strictly based on single inheritance. A class is composed of zero or more named slots . There are two kinds of slots: Field : a memory location for storing a variable to manage state ; Method : an executable function to manage behavior ; All slots must be uniquely named. Sedona doesn't support method overloading by parameter types as you might find in Java or C#. Protection Scope \u00b6 The following keywords are used to annotate the protection scope of classes and slots: public : visible to everyone; this is the default scope if no keyword is specified [applies to classes and slots] internal : visible to classes in the same kit only [applies to classes and slots] protected : visible to subclasses only [applies to slots only] private : visible to declaring class only [applies to slots only]","title":"Language"},{"location":"language/lang/#language","text":"","title":"Language"},{"location":"language/lang/#overview","text":"Sedona is a programming language based upon the following principles: Familiar Syntax : Reuses C, Java, and C# syntax where possible. Object Oriented : Includes the three pillars of OO: encapsulated classes, inheritance, and polymorphism. Component Oriented : Based on a development paradigm of reusable software components. Applications are assembled by wiring together pre-built components. Static Typing : Uses a static type system much like Java and C# with explicit typing of fields, methods, and local variables. This allows the compiler to perform type checking. Static Memory : Manages memory statically at compile time, making it ideal for embedded platforms with limited resources.","title":"Overview"},{"location":"language/lang/#namespaces","text":"Sedona Framework code is organized into a three unit hierarchy: Kit : A module of deployment and versioning. Kits form the top of the namespace and must be globally unique. Kit names are required to be prefixed with the vendor's name. Class : An object oriented unit of organization. Classes are always scoped within a kit. Slot : Special fields and methods defined within a class are called slots . Slots are the externally visible \"wiring points\" on a component that can be linked to other components in a Sedona application. Kits are globally unique and used to scope classes which in turn scope slots. We use this structure to define globally unique qualified names or qnames for classes and slots. A Class qname consists of the kit name and class name joined by the \"::\" separator. A slot qname is the class's qname joined to the slot's simple name by the \".\" separator: control::Ramp // class qname control::Ramp.out // slot qname","title":"Namespaces"},{"location":"language/lang/#structure","text":"Sedona Framework software is packaged up into modules called kits . The source code for a kit is managed as a set of text files with the \".sedona\" extension. A \"kit.xml\" file instructs the compiler how to compile the kit and what directories contain the source code. A typical source directory is structured as follows: myCoolKit/ // directory for myCoolKit +- kit.xml // kit build manifest +- CoolComp.sedona // source file +- AnotherCoolComp.sedona // source file +- test/ +- CoolCompTest.sedona // source file for tests You can then compile the kit using either the directory or \"kit.xml\" file. Assuming your current directory is the parent of \"myCoolKit\" you could use either of the following commands to compile: sedonac myCoolKit sedonac myCoolKit/kit.xml Each source file is called a compilation unit . Source text files must use UTF-8 encoding (7-bit ASCII is a clean subset of UTF-8). Each compilation unit can contain one or more classes . Sedona does not require any correlation between your source file names and class names. However, by convention each class is sourced in a file with the same name. For example CoolComp is stored in a text file called \"CoolComp.sedona\".","title":"Structure"},{"location":"language/lang/#classes","text":"A kit contains one or more classes . A class is very similar to a Java or C# class. However, Sedona doesn't have the concept of interfaces - so everything is strictly based on single inheritance. A class is composed of zero or more named slots . There are two kinds of slots: Field : a memory location for storing a variable to manage state ; Method : an executable function to manage behavior ; All slots must be uniquely named. Sedona doesn't support method overloading by parameter types as you might find in Java or C#.","title":"Classes"},{"location":"language/lang/#protection-scope","text":"The following keywords are used to annotate the protection scope of classes and slots: public : visible to everyone; this is the default scope if no keyword is specified [applies to classes and slots] internal : visible to classes in the same kit only [applies to classes and slots] protected : visible to subclasses only [applies to slots only] private : visible to declaring class only [applies to slots only]","title":"Protection Scope"},{"location":"language/logging/","text":"Logging \u00b6 Overview \u00b6 The Sedona Framework includes a built-in logging facility with the following features: Simple syntax to embed logging in your source code Ability to selectively enable/disable logging at runtime Ability to selectively compile logging in or out of an scode image Log Levels \u00b6 There are five logging severity levels: Log.NONE : all logging is disabled Log.ERROR : indicates a failure condition Log.WARNING : indicates an unexpected condition Log.MESSAGE : indicates something of interest Log.TRACE : used to embed debug tracing Log Definition \u00b6 The sys::Log class is the primary API used for logging. The Log class is a const class like Type or Slot . This means you can't directly allocate instances yourself. Instead we use the define keyword to define a Log instance: class MyService { define Log log } Like other defines, the log is treated much like a static field. During compilation all the log instances are compiled into the scode as const data much like Kit instances. The APIs for log reflection follow a similar pattern to kit reflection: class Sys { define int logsLen const static Log[logsLen] logs static inline byte[logsLen] logLevels static Log log(int id) static Log findLog(Str qname) } const class Log { define int NONE = 0 define int ERROR = 1 define int WARNING = 2 define int MESSAGE = 3 define int TRACE = 4 int level() bool isError() bool isWarning() bool isMessage() bool isTrace() OutStream error(Str msg) OutStream warning(Str msg) OutStream message(Str msg) OutStream trace(Str msg) const short id const Str qname } Note that the logging levels are stored separately from the Log instances themselves. This is because the log objects are readonly and stored in the code section. The log levels must be in dynamic memory to allow runtime modification. Log Naming \u00b6 All logs are identified by a qname (qualified name), which is based on the define field's qname: If the define field is named \"log\", then the log qname is the qname of the declaring type If the define field ends in \"Log\", then the log qname is the field's qname minus the \"Log\" suffix If none of the above applies, then log's qname is the field's qname For example this class in a kit named \"acme\": class MyService { define Log log // log qname is \"acme::MyService\" define Log reqLog // log qname is \"acme::MyService.req\" define Log stuff // log qname is \"acme::MyService.stuff\" } By convention, your primary Log definition should be named \"log\" to match rule 1. Sub-logging for extra tracing should use names with a \"Log\" suffix. Logging \u00b6 To embed logging into your code, call one of following the logging methods : sys::Log.error sys::Log.warning sys::Log.message sys::Log.trace All of the logging methods take a Str and return an OutStream , which permits string interpolation : // these lines of code log.message(\"Started!\") log.error(\"Cannot open port=$port\") log.trace(\"Received $numBytes bytes from $addr\") // would print something like -- MESSAGE [acme::MyServer] Started! -- ERROR [acme::MyServer] Cannot open port 8080 -- TRACE [acme::MyServer] Received 5 bytes from 32 A few points to note: Don't add a trailing newline to your message, one will be added automatically Don't include any severity or log identity in your message string, this information is automatically included (the actual format is implementation specific) You are required to call the logging methods on the field define itself. For example you can't assign the log reference to a local variable, then use the local variable to call one of the logging methods - this will result in a compile time error. The reason for this restriction is that it enables the compiler to generate level checking and conditional compilation checking. Runtime Configuration \u00b6 Log levels are stored in the Sys.logLevels field. This array is indexed by Log.id and stores the current level as a number between 0 and 4 (Log.NONE to Log.TRACE): // change my logging level to trace Sys.logLevels[log.id] = Log.TRACE The current level defines the maximum severity that is logged. For example a level or WARNING will log calls to error and warning , but not calls to message and trace . All log levels default to MESSAGE on startup. The compiler automatically inserts code that jumps over a logging statement if the current log level is set lower. This means the method call and any embedded expressions are efficiently skipped: // this code log.trace(\"This is the ${count++} time\") // is semantically equivalent to if (log.isTrace()) log.trace(\"This is the ${count++} time\") WebService Spy Page \u00b6 If a Sedona device is running the web::WebService , then you can use the spy page at \"<device IP>/spy/logs\" to change the log levels for a SVM at runtime. Compile-time Configuration \u00b6 Note This feature is not implemented yet","title":"Logging"},{"location":"language/logging/#logging","text":"","title":"Logging"},{"location":"language/logging/#overview","text":"The Sedona Framework includes a built-in logging facility with the following features: Simple syntax to embed logging in your source code Ability to selectively enable/disable logging at runtime Ability to selectively compile logging in or out of an scode image","title":"Overview"},{"location":"language/logging/#log-levels","text":"There are five logging severity levels: Log.NONE : all logging is disabled Log.ERROR : indicates a failure condition Log.WARNING : indicates an unexpected condition Log.MESSAGE : indicates something of interest Log.TRACE : used to embed debug tracing","title":"Log Levels"},{"location":"language/logging/#log-definition","text":"The sys::Log class is the primary API used for logging. The Log class is a const class like Type or Slot . This means you can't directly allocate instances yourself. Instead we use the define keyword to define a Log instance: class MyService { define Log log } Like other defines, the log is treated much like a static field. During compilation all the log instances are compiled into the scode as const data much like Kit instances. The APIs for log reflection follow a similar pattern to kit reflection: class Sys { define int logsLen const static Log[logsLen] logs static inline byte[logsLen] logLevels static Log log(int id) static Log findLog(Str qname) } const class Log { define int NONE = 0 define int ERROR = 1 define int WARNING = 2 define int MESSAGE = 3 define int TRACE = 4 int level() bool isError() bool isWarning() bool isMessage() bool isTrace() OutStream error(Str msg) OutStream warning(Str msg) OutStream message(Str msg) OutStream trace(Str msg) const short id const Str qname } Note that the logging levels are stored separately from the Log instances themselves. This is because the log objects are readonly and stored in the code section. The log levels must be in dynamic memory to allow runtime modification.","title":"Log Definition"},{"location":"language/logging/#log-naming","text":"All logs are identified by a qname (qualified name), which is based on the define field's qname: If the define field is named \"log\", then the log qname is the qname of the declaring type If the define field ends in \"Log\", then the log qname is the field's qname minus the \"Log\" suffix If none of the above applies, then log's qname is the field's qname For example this class in a kit named \"acme\": class MyService { define Log log // log qname is \"acme::MyService\" define Log reqLog // log qname is \"acme::MyService.req\" define Log stuff // log qname is \"acme::MyService.stuff\" } By convention, your primary Log definition should be named \"log\" to match rule 1. Sub-logging for extra tracing should use names with a \"Log\" suffix.","title":"Log Naming"},{"location":"language/logging/#logging_1","text":"To embed logging into your code, call one of following the logging methods : sys::Log.error sys::Log.warning sys::Log.message sys::Log.trace All of the logging methods take a Str and return an OutStream , which permits string interpolation : // these lines of code log.message(\"Started!\") log.error(\"Cannot open port=$port\") log.trace(\"Received $numBytes bytes from $addr\") // would print something like -- MESSAGE [acme::MyServer] Started! -- ERROR [acme::MyServer] Cannot open port 8080 -- TRACE [acme::MyServer] Received 5 bytes from 32 A few points to note: Don't add a trailing newline to your message, one will be added automatically Don't include any severity or log identity in your message string, this information is automatically included (the actual format is implementation specific) You are required to call the logging methods on the field define itself. For example you can't assign the log reference to a local variable, then use the local variable to call one of the logging methods - this will result in a compile time error. The reason for this restriction is that it enables the compiler to generate level checking and conditional compilation checking.","title":"Logging"},{"location":"language/logging/#runtime-configuration","text":"Log levels are stored in the Sys.logLevels field. This array is indexed by Log.id and stores the current level as a number between 0 and 4 (Log.NONE to Log.TRACE): // change my logging level to trace Sys.logLevels[log.id] = Log.TRACE The current level defines the maximum severity that is logged. For example a level or WARNING will log calls to error and warning , but not calls to message and trace . All log levels default to MESSAGE on startup. The compiler automatically inserts code that jumps over a logging statement if the current log level is set lower. This means the method call and any embedded expressions are efficiently skipped: // this code log.trace(\"This is the ${count++} time\") // is semantically equivalent to if (log.isTrace()) log.trace(\"This is the ${count++} time\")","title":"Runtime Configuration"},{"location":"language/logging/#webservice-spy-page","text":"If a Sedona device is running the web::WebService , then you can use the spy page at \"<device IP>/spy/logs\" to change the log levels for a SVM at runtime.","title":"WebService Spy Page"},{"location":"language/logging/#compile-time-configuration","text":"Note This feature is not implemented yet","title":"Compile-time Configuration"},{"location":"language/memory/","text":"Memory \u00b6 Overview \u00b6 Utilizing memory as efficiently as possible is a core requirement for making the Sedona Framework run on small, embedded devices. We divide memory into the following sections: Stack : the call stack (RAM) Data : all the memory declared as static fields in the current scode (RAM) Sedona Framework App : the components that define the current application (RAM) Sedona Framework Code : the scode image for the installed kits (RAM, or possibly flash memory) SAB File : the compact binary representation of the application (usually stored in flash) C Code : native code and SVM executable (RAM, or possibly flash) C Data : native code data segment (RAM) C Stack : the C native call stack (RAM) We use the terms RAM and flash a bit loosely here: RAM must be high speed read/write memory, and flash is persistent memory (on a large device this could be a disk drive). If flash is high speed you might be able to run code directly out of flash, but normally those code segments will be loaded into RAM. While reading this topic you may find it useful to refer to the Sedona VM source code, located in the src/vm folder. Computing Memory Requirements \u00b6 So how do you figure out how much memory each of the sections declared above requires? Let's look at each section: C Code, C Data, and C Stack \u00b6 The C code, data, and stack segments will be determined by your development tools and C compiler. We use the term \"C Code\" to denote any non-Sedona code such as C, C++, or assembly. This code typically includes boot code, OS code (if your device has one), all your native method implementations, comm stacks, and the SVM itself. All this is normally lumped into a single binary executable file called \"svm\". The C Data segment includes all the memory buffers used by this code. Note: On some platforms, part of the SVM may already be in ROM or other permanent storage. In that case the \"svm\" executable created during compilation will contain only the portion of the SVM that is not in ROM, and its RAM footprint will be reduced. Stack \u00b6 The Sedona stack is defined by the stackBaseAddr and stackMaxSize fields of the SedonaVM struct when the VM is launched. Typically the size is one or two KB - you may wish to test your application to find the maximum call stack. Heavy use of recursion and methods with a large number of locals will affect your call stack size. Code and Data \u00b6 The sizes of the Sedona Code and Data segments are calculated when the scode image is compiled: D: \\s edona>sedonac scode \\x 86 -test.xml ReadKits [ 5 kits ] WriteImage [ D: \\s edona \\s code \\x 86 -test.scode ] ( 29632 bytes ) +---------------------------------- | Data: 0 .4kb ( 360 bytes ) | Code: 28 .9kb ( 29632 bytes ) | Total: 29 .3kb ( 29992 bytes ) +---------------------------------- These numbers are directly related to how many kits you include and the code size of those kits. Declaring static fields will consume memory in your Data segment; instance fields only affect the application size. If you are running your code out of RAM, then the Total size is what matters. If you can run your code out of flash, then the Code will not use any RAM but the Data segment must still be stored in RAM. Note that the scode flags test and debug can have a huge impact on scode size. The location of the Code is passed to the VM in the SedonaVM struct via the codeBaseAddr field. The Data section is allocated by the malloc macro - see \"sedona.h\" for details. Sedona Framework Application \u00b6 The Sedona Framework application itself is always run out of RAM. This is where we instantiate the components and links. Memory for components and links is allocated by the malloc macro. If components or links are removed during runtime, then the memory is freed by the free macro (if the platform supports it). The Sedona Framework application runs out of RAM, but has configuration data that must be persistent between power cycles. So we also store the application to flash as a SAB file . How this file is loaded on startup and stored back to flash on save is handled by the platform's implementation of the sys::FileStore native methods. Sedonac will report how much RAM and flash a given application consumes when you do a conversion between SAX or SAB: D: \\s edona>sedonac apps \\t est.sax ConvertAppFile [ D: \\s edona \\a pps \\t est.sax -> D: \\s edona \\a pps \\t est.sab ] +---------------------------------- | RAM: 14 .2kb ( 14588 bytes ) | FLASH: 0 .4kb ( 382 bytes ) +---------------------------------- See the Field Layout section to evaluate how much memory each component type consumes. Heap \u00b6 The memory for the Data section and for the components and links in the App is allocated using the malloc macro as defined in \"sedona.h\". If components or links are removed during runtime, then this memory is freed by the free macro. You can implement your \"heap management\" using three strategies: Stdlib : if you have the resources, you can just use C's built-in malloc and free. However if using a compiler like GCC this might require importing a huge chunk of library code into your native image. Custom Heap : if the stdlib implementation of malloc and free is too big, you might consider writing your own simple heap manager. Malloc Only : many devices might require only a static application in which case there is no requirement for freeing memory. In resource limited devices, the ability to free memory might be outweighed by the risk of heap fragmentation. In this case your heap management might be nothing more than a pointer to the next chunk of memory to allocate. A call to free would be a no-op. If objects are removed from the application the memory would not be recovered until the system is reset. Field Layout \u00b6 You can pass the -layout flag to sedonac when compiling your scode image to dump the memory layout of each type. This gives you exact details for how memory is being consumed: How many bytes each component type consumes in RAM Memory offset of every instance field against the object's base address Memory address of every static field against the Data base address A good rule of thumb is that each component averages between 50 and 100 bytes and each link consumes 16 bytes. A network protocol service will typically consume several KB since it must allocate buffers and internal data structures. However, you really must use the -layout flag to see exactly how many bytes each component will consume. Note that sedonac has no visibility into the behavior of native methods. Any dynamic memory allocation that occurs at the native level must be calculated separately and added manually to the totals provided by the -layout flag. Hibernation \u00b6 The Sedona Framework supports hibernation , which allows a device to enter a low power state. The Sedona Framework assumes that during hibernation its data section in RAM (managed by the heap malloc and free calls) will not be affected. The device can either maintain RAM during hibernation or save and restore to the same memory addresses. See Hibernation .","title":"Memory"},{"location":"language/memory/#memory","text":"","title":"Memory"},{"location":"language/memory/#overview","text":"Utilizing memory as efficiently as possible is a core requirement for making the Sedona Framework run on small, embedded devices. We divide memory into the following sections: Stack : the call stack (RAM) Data : all the memory declared as static fields in the current scode (RAM) Sedona Framework App : the components that define the current application (RAM) Sedona Framework Code : the scode image for the installed kits (RAM, or possibly flash memory) SAB File : the compact binary representation of the application (usually stored in flash) C Code : native code and SVM executable (RAM, or possibly flash) C Data : native code data segment (RAM) C Stack : the C native call stack (RAM) We use the terms RAM and flash a bit loosely here: RAM must be high speed read/write memory, and flash is persistent memory (on a large device this could be a disk drive). If flash is high speed you might be able to run code directly out of flash, but normally those code segments will be loaded into RAM. While reading this topic you may find it useful to refer to the Sedona VM source code, located in the src/vm folder.","title":"Overview"},{"location":"language/memory/#computing-memory-requirements","text":"So how do you figure out how much memory each of the sections declared above requires? Let's look at each section:","title":"Computing Memory Requirements"},{"location":"language/memory/#c-code-c-data-and-c-stack","text":"The C code, data, and stack segments will be determined by your development tools and C compiler. We use the term \"C Code\" to denote any non-Sedona code such as C, C++, or assembly. This code typically includes boot code, OS code (if your device has one), all your native method implementations, comm stacks, and the SVM itself. All this is normally lumped into a single binary executable file called \"svm\". The C Data segment includes all the memory buffers used by this code. Note: On some platforms, part of the SVM may already be in ROM or other permanent storage. In that case the \"svm\" executable created during compilation will contain only the portion of the SVM that is not in ROM, and its RAM footprint will be reduced.","title":"C Code, C Data, and C Stack"},{"location":"language/memory/#stack","text":"The Sedona stack is defined by the stackBaseAddr and stackMaxSize fields of the SedonaVM struct when the VM is launched. Typically the size is one or two KB - you may wish to test your application to find the maximum call stack. Heavy use of recursion and methods with a large number of locals will affect your call stack size.","title":"Stack"},{"location":"language/memory/#code-and-data","text":"The sizes of the Sedona Code and Data segments are calculated when the scode image is compiled: D: \\s edona>sedonac scode \\x 86 -test.xml ReadKits [ 5 kits ] WriteImage [ D: \\s edona \\s code \\x 86 -test.scode ] ( 29632 bytes ) +---------------------------------- | Data: 0 .4kb ( 360 bytes ) | Code: 28 .9kb ( 29632 bytes ) | Total: 29 .3kb ( 29992 bytes ) +---------------------------------- These numbers are directly related to how many kits you include and the code size of those kits. Declaring static fields will consume memory in your Data segment; instance fields only affect the application size. If you are running your code out of RAM, then the Total size is what matters. If you can run your code out of flash, then the Code will not use any RAM but the Data segment must still be stored in RAM. Note that the scode flags test and debug can have a huge impact on scode size. The location of the Code is passed to the VM in the SedonaVM struct via the codeBaseAddr field. The Data section is allocated by the malloc macro - see \"sedona.h\" for details.","title":"Code and Data"},{"location":"language/memory/#sedona-framework-application","text":"The Sedona Framework application itself is always run out of RAM. This is where we instantiate the components and links. Memory for components and links is allocated by the malloc macro. If components or links are removed during runtime, then the memory is freed by the free macro (if the platform supports it). The Sedona Framework application runs out of RAM, but has configuration data that must be persistent between power cycles. So we also store the application to flash as a SAB file . How this file is loaded on startup and stored back to flash on save is handled by the platform's implementation of the sys::FileStore native methods. Sedonac will report how much RAM and flash a given application consumes when you do a conversion between SAX or SAB: D: \\s edona>sedonac apps \\t est.sax ConvertAppFile [ D: \\s edona \\a pps \\t est.sax -> D: \\s edona \\a pps \\t est.sab ] +---------------------------------- | RAM: 14 .2kb ( 14588 bytes ) | FLASH: 0 .4kb ( 382 bytes ) +---------------------------------- See the Field Layout section to evaluate how much memory each component type consumes.","title":"Sedona Framework Application"},{"location":"language/memory/#heap","text":"The memory for the Data section and for the components and links in the App is allocated using the malloc macro as defined in \"sedona.h\". If components or links are removed during runtime, then this memory is freed by the free macro. You can implement your \"heap management\" using three strategies: Stdlib : if you have the resources, you can just use C's built-in malloc and free. However if using a compiler like GCC this might require importing a huge chunk of library code into your native image. Custom Heap : if the stdlib implementation of malloc and free is too big, you might consider writing your own simple heap manager. Malloc Only : many devices might require only a static application in which case there is no requirement for freeing memory. In resource limited devices, the ability to free memory might be outweighed by the risk of heap fragmentation. In this case your heap management might be nothing more than a pointer to the next chunk of memory to allocate. A call to free would be a no-op. If objects are removed from the application the memory would not be recovered until the system is reset.","title":"Heap"},{"location":"language/memory/#field-layout","text":"You can pass the -layout flag to sedonac when compiling your scode image to dump the memory layout of each type. This gives you exact details for how memory is being consumed: How many bytes each component type consumes in RAM Memory offset of every instance field against the object's base address Memory address of every static field against the Data base address A good rule of thumb is that each component averages between 50 and 100 bytes and each link consumes 16 bytes. A network protocol service will typically consume several KB since it must allocate buffers and internal data structures. However, you really must use the -layout flag to see exactly how many bytes each component will consume. Note that sedonac has no visibility into the behavior of native methods. Any dynamic memory allocation that occurs at the native level must be calculated separately and added manually to the totals provided by the -layout flag.","title":"Field Layout"},{"location":"language/memory/#hibernation","text":"The Sedona Framework supports hibernation , which allows a device to enter a low power state. The Sedona Framework assumes that during hibernation its data section in RAM (managed by the heap malloc and free calls) will not be affected. The device can either maintain RAM during hibernation or save and restore to the same memory addresses. See Hibernation .","title":"Hibernation"},{"location":"language/methods/","text":"Overview \u00b6 Methods are functions used to implement executable behavior. The following keywords may be applied to a method declaration: static : class based method versus instance based virtual : indicates method that may be polymorphically overridden abstract : indicates a pure virtual method override : required to indicate an override of an inherited method native : indicates a method implemented in native C code action : promotes a method to a component action In addition to the keywords above, a method may be annotated with a protection scope keyword. If no protection scope is specified, then public is assumed. Return Values \u00b6 If the method returns a value to the calling function, the return value type is included in the function definition. If the method does not return anything, the keyword void is used instead of a return type. class Example { void echo() { Sys.out.print(\"echo\").nl() } // returns nothing int add(int x, int y) { return x + y } // returns an int value } In Sedona, a method may return any primitive type, or a reference to any built-in or user-defined class type; the only exception is an action method, which always returns void . Static Methods \u00b6 Static methods are prefixed with the static keyword. Static methods are essentially global functions scoped within a class name. They are declared just like Java methods: class Example { static void echo() { Sys.out.print(\"echo\").nl() } static int add(int x, int y) { return x + y } } Static methods are called with an implict or explicit type literal: Example.echo() // explicit int five = add(2, 3) // implicit (only inside Example or subclasses) Instance Methods \u00b6 Instance methods are declared whenever the static keyword is omitted. Instance methods contain an implicit this parameter, which is the instance the method is called on: class Example { int add() { return x + y } int sub() { return this.x - this.y } int x int y } Note in the example, that every instance method has an implicit parameter accessed via the this keyword. Instance methods are called with an implict or explicit instance: add() // implicit against this this.sub() // explicit against this x.sub() // explicit against x x?.sub() // null safe call See Safe Navigation for how to use the \"?.\" operator. Virtual Methods \u00b6 Virtual methods are designed to be overridden by a subclass to enable polymorphism. Methods must be marked using the virtual keyword before they can be overridden by subclasses. Subclasses must declare they are overriding a method using the override keyword: class Animal extends Virtual { virtual void talk() { Sys.out.print(\"generic\\n\") } } class Cat extends Animal { override void talk() { Sys.out.print(\"meow\\n\") } } animal.talk() // prints generic cat.talk() // prints meow By default an overridden method cannot itself be overridden by a subsequent subclass. In order for Cat.talk() to be overridden by the subclass Kitten , it must include again the keyword virtual : class Cat extends Animal { override virtual void talk() { Sys.out.print(\"meow\\n\") } // override AND virtual } class Kitten extends Cat { override void talk() { Sys.out.print(\"mew!\\n\") } // this now compiles } kitten.talk() // prints mew! Classes that declare virtual methods must derive from sys::Virtual . Be aware that virtual classes have the overhead of an extra pointer for their vtable (typically 4 extra bytes). Abstract Methods \u00b6 Abstract methods are virtual methods without an implementation. They are declared using the abstract keyword. Abstract methods are implied to be virtual - it is an error to use both the abstract and virtual keyword. Abstract methods must not provide a method body. The containing class must also be declared abstract . Super \u00b6 By default any virtual method call with an implicit or explicit target of this invokes the most specific version of that method. You can use the super keyword to invoke the super class version of a method: class Kitten extends Cat { override void talk() { super.talk() } } kitten.talk() // now prints meow Constructors \u00b6 A class may have one constructor, which is compiled into a method called _iInit . Whenever a class declares instance fields with a default value , the compiler auto-generates a constructor for you. A class may declare an explicit constructor using a syntax similiar to Java: final class BufInStream extends InStream { BufInStream(Buf abuf) { this.buf = abuf } Buf buf } To keep Sedona lightweight and simple, the following rules apply to constructor methods: A class may only declare one explicit constructor (parameter overloading is not supported). A class with an explicit constructor must be marked final . Subclasses of sys::Component cannot declare a constructor with parameters. Declared constructors are used with unsized classes to specify an array length. The constructor method for a class is called whenever an object of that type is instantiated. For static inline fields, this happens as soon as the scode is loaded when the Sedona VM boots up. For instance inline fields, this happens when the Sedona VM loads the Sedona application and calls the constructors for the application's components as well as each component's inline object fields. If the running app is modified remotely, however, any new components will be instantiated immediately by App.add() , which will call the component's constructor (and all its non-static inline object fields) at that time. For example: class Foo { // static constructor calls static inline Buf(100) buf static inline BufInStream(buf) in static inline BufOutStream(buf) out static inline Foo inst // instance constructor calls inline Buf(20) ibuf } Inline static fields are initialized in declaration order on VM startup, which calls the appropriate constructors. These constructor calls often result in instance constructor calls, which in turn recursively chain for nested inline fields. For the example above, the compiler will create the following code; Foo._sInit is then automatically called when the VM boots: static void Foo . _sInit () { Foo . buf . _iInit ( 100 ) Foo . in . _iInit ( Foo . buf ) Foo . out . _iInit ( Foo . buf ) Foo . inst . _iInit () } void Foo . _iInit () { this . ibuf . _iInit ( 20 ) } Native Methods \u00b6 The native keyword is used on methods that are implemented in C code. Like abstract methods, native methods must not define a body. See Native Methods for more details. Action Methods \u00b6 Methods may be annotated with the action keyword to promote the method into a Component action. Actions must be instance methods on a subclass of sys::Component . See Component Actions for more details.","title":"Methods"},{"location":"language/methods/#overview","text":"Methods are functions used to implement executable behavior. The following keywords may be applied to a method declaration: static : class based method versus instance based virtual : indicates method that may be polymorphically overridden abstract : indicates a pure virtual method override : required to indicate an override of an inherited method native : indicates a method implemented in native C code action : promotes a method to a component action In addition to the keywords above, a method may be annotated with a protection scope keyword. If no protection scope is specified, then public is assumed.","title":"Overview"},{"location":"language/methods/#return-values","text":"If the method returns a value to the calling function, the return value type is included in the function definition. If the method does not return anything, the keyword void is used instead of a return type. class Example { void echo() { Sys.out.print(\"echo\").nl() } // returns nothing int add(int x, int y) { return x + y } // returns an int value } In Sedona, a method may return any primitive type, or a reference to any built-in or user-defined class type; the only exception is an action method, which always returns void .","title":"Return Values"},{"location":"language/methods/#static-methods","text":"Static methods are prefixed with the static keyword. Static methods are essentially global functions scoped within a class name. They are declared just like Java methods: class Example { static void echo() { Sys.out.print(\"echo\").nl() } static int add(int x, int y) { return x + y } } Static methods are called with an implict or explicit type literal: Example.echo() // explicit int five = add(2, 3) // implicit (only inside Example or subclasses)","title":"Static Methods"},{"location":"language/methods/#instance-methods","text":"Instance methods are declared whenever the static keyword is omitted. Instance methods contain an implicit this parameter, which is the instance the method is called on: class Example { int add() { return x + y } int sub() { return this.x - this.y } int x int y } Note in the example, that every instance method has an implicit parameter accessed via the this keyword. Instance methods are called with an implict or explicit instance: add() // implicit against this this.sub() // explicit against this x.sub() // explicit against x x?.sub() // null safe call See Safe Navigation for how to use the \"?.\" operator.","title":"Instance Methods"},{"location":"language/methods/#virtual-methods","text":"Virtual methods are designed to be overridden by a subclass to enable polymorphism. Methods must be marked using the virtual keyword before they can be overridden by subclasses. Subclasses must declare they are overriding a method using the override keyword: class Animal extends Virtual { virtual void talk() { Sys.out.print(\"generic\\n\") } } class Cat extends Animal { override void talk() { Sys.out.print(\"meow\\n\") } } animal.talk() // prints generic cat.talk() // prints meow By default an overridden method cannot itself be overridden by a subsequent subclass. In order for Cat.talk() to be overridden by the subclass Kitten , it must include again the keyword virtual : class Cat extends Animal { override virtual void talk() { Sys.out.print(\"meow\\n\") } // override AND virtual } class Kitten extends Cat { override void talk() { Sys.out.print(\"mew!\\n\") } // this now compiles } kitten.talk() // prints mew! Classes that declare virtual methods must derive from sys::Virtual . Be aware that virtual classes have the overhead of an extra pointer for their vtable (typically 4 extra bytes).","title":"Virtual Methods"},{"location":"language/methods/#abstract-methods","text":"Abstract methods are virtual methods without an implementation. They are declared using the abstract keyword. Abstract methods are implied to be virtual - it is an error to use both the abstract and virtual keyword. Abstract methods must not provide a method body. The containing class must also be declared abstract .","title":"Abstract Methods"},{"location":"language/methods/#super","text":"By default any virtual method call with an implicit or explicit target of this invokes the most specific version of that method. You can use the super keyword to invoke the super class version of a method: class Kitten extends Cat { override void talk() { super.talk() } } kitten.talk() // now prints meow","title":"Super"},{"location":"language/methods/#constructors","text":"A class may have one constructor, which is compiled into a method called _iInit . Whenever a class declares instance fields with a default value , the compiler auto-generates a constructor for you. A class may declare an explicit constructor using a syntax similiar to Java: final class BufInStream extends InStream { BufInStream(Buf abuf) { this.buf = abuf } Buf buf } To keep Sedona lightweight and simple, the following rules apply to constructor methods: A class may only declare one explicit constructor (parameter overloading is not supported). A class with an explicit constructor must be marked final . Subclasses of sys::Component cannot declare a constructor with parameters. Declared constructors are used with unsized classes to specify an array length. The constructor method for a class is called whenever an object of that type is instantiated. For static inline fields, this happens as soon as the scode is loaded when the Sedona VM boots up. For instance inline fields, this happens when the Sedona VM loads the Sedona application and calls the constructors for the application's components as well as each component's inline object fields. If the running app is modified remotely, however, any new components will be instantiated immediately by App.add() , which will call the component's constructor (and all its non-static inline object fields) at that time. For example: class Foo { // static constructor calls static inline Buf(100) buf static inline BufInStream(buf) in static inline BufOutStream(buf) out static inline Foo inst // instance constructor calls inline Buf(20) ibuf } Inline static fields are initialized in declaration order on VM startup, which calls the appropriate constructors. These constructor calls often result in instance constructor calls, which in turn recursively chain for nested inline fields. For the example above, the compiler will create the following code; Foo._sInit is then automatically called when the VM boots: static void Foo . _sInit () { Foo . buf . _iInit ( 100 ) Foo . in . _iInit ( Foo . buf ) Foo . out . _iInit ( Foo . buf ) Foo . inst . _iInit () } void Foo . _iInit () { this . ibuf . _iInit ( 20 ) }","title":"Constructors"},{"location":"language/methods/#native-methods","text":"The native keyword is used on methods that are implemented in C code. Like abstract methods, native methods must not define a body. See Native Methods for more details.","title":"Native Methods"},{"location":"language/methods/#action-methods","text":"Methods may be annotated with the action keyword to promote the method into a Component action. Actions must be instance methods on a subclass of sys::Component . See Component Actions for more details.","title":"Action Methods"},{"location":"language/nativeMethods/","text":"Native Methods \u00b6 Overview \u00b6 Native methods are used to create Sedona APIs that bind to native code written in the C programming language. The following steps are used to create a native method: Native Id : Every native method is assigned a unique two byte identifier in the kit's kit.xml file Stub : Every native method is declared in the Sedona code using the native modifier Native Implementation : Native methods are implemented as functions in the C programming language Native Tables : At staging, function pointers to the native implementations are mapped into tables for dispatch by the SVM at runtime Native Id \u00b6 Every native method is assigned a two byte identifier used to dispatch a call to the proper C function. The first byte is the kitId and the second byte is the methodId . Native ids are expressed as \"kitId::methodId\". Each kit that contains native methods should be assigned a unique kitId. Technically kitIds don't need to be globally unique, but they must be unique across all the kits that might be used together for a given platform. The range of kitIds from 0 to 99 is reserved for core Sedona Framework kits. Third parties should use kitIds from 100 to 255 (or contact the Sedona Framework development team). The sys kit itself is assigned the kitId of zero. Any platform service kit (i.e. a platform-specific kit containing a PlatformService subclass) can be given a kitId of 1, since there will never be more than one such kit loaded on a Sedona device at any given time. Within a kit, every native method is assigned a unique methodId. Because the methodId is only a byte, there can be at most 255 native methods in a single kit. The list of native ids for a kit is defined in the kit.xml file using the following XML format: <natives> <native qname= \"foo::Type1.method1\" id= \"6::0\" /> <native qname= \"foo::Type1.method2\" id= \"6::1\" /> <native qname= \"foo::Type2.method1\" id= \"6::2\" /> </natives> The natives element contains one or more native elements for each native method in the kit. The native element contains two required attributes: qname specifies the qualified name of the native method and id specifies the native id formatted as \"kitId::methodId\". In this example, the kitId for kit foo is 6, and the native method methodIds are 0, 1, and 2. Stubs \u00b6 Native methods are declared like normal methods but without a method body (just like abstract methods). Native methods must be flagged with the native keyword. Native methods cannot be abstract or virtual . For example: class Type2 { static native int add(int a, int b) static native void test(bool z, int i, float f) native float testf(int i, float f) } The compiler will perform a series of checks upon the native ids and native stubs when compiling source code into a kit file (in the ResolveNatives step). Unless errors are detected, the native ids are written into the appropriate IR files of the kit. If any native ids are modified, you must recompile from source. Native Implementation \u00b6 The SVM is stack based. Each item on the stack is called a Cell , which is a union of int32_t , float , and void* . Unless you are running on a 64-bit processor, a Cell is 32-bits wide. The definition of Cell in sedona.h is: typedef union { int32_t ival; // 32-bit signed int float fval; // 32-bit float void* aval; // address pointer } Cell; Every native method must be implemented in C as a function that takes two arguments: a SedonaVM_s pointer and a Cell pointer into the stack, and returns a Cell . (Native methods that return a long or a double require special handling, described in more detail below). The definition for SedonaVM_s is in sedona.h . The typedef for a native method pointer is: typedef Cell (*NativeMethod)(struct SedonaVM_s* vm, Cell* params); The method parameters are accessed from the stack via the Cell pointer params . You can manually extract the individual parameters using array indexing. If the native method is not static, then parameter 0 is always the implicit this pointer. It is important to note that all native method implementations return a Cell value even when the Sedona signature for the method returns void . You can use the constant nullCell to return from a method that returns void . Other predefined Cell constants are trueCell , falseCell , zeroCell , oneCell , and negOneCell . An example implementation of the foo::Type2.add method: Cell foo_Type2_add ( SedonaVM * vm , Cell * params ) { int32_t a = params [ 0 ]. ival ; int32_t b = params [ 1 ]. ival ; Cell result ; result . ival = a + b ; return result } An example implementation of the foo::Type2.test method: Cell foo_Type2_test ( SedonaVM * vm , Cell * params ) { int32_t z = params [ 0 ]. ival ; int32_t b = params [ 1 ]. ival ; float f = params [ 2 ]. fval ; printf ( \"test %d %d %f \\n \" , z , b , f ); return nullCell ; } An example implementation of the (non-static) foo::Type2.testf method: Cell foo_Type2_testf ( SedonaVM * vm , Cell * params ) { void * this = params [ 0 ]. aval ; /* 'this' pointer is implicit first element of params[] */ int32_t b = params [ 1 ]. ival ; float f = params [ 2 ]. fval ; Cell result ; result . fval = b * f ; printf ( \"test %d*%f=%f \\n \" , b , f , result . fval ); return result ; } Note in the examples above how each parameter is extracted using array indexing and the union member name. Pointers (including strings) should use the aval member, floats the fval member, and all other primitives are accessed using the ival member. Note that a Sedona bool maps into zero and non-zero for false and true respectively. Arrays of primitives are accessed like their C counterparts. Native methods that pass or return long or double are a bit trickier. A single long or double value requires two Cells to store the full 64-bits. To access a long or double function argument requires the use of pointer casting to access two consecutive elements of the parameter array. A native method that returns a long or double should declare the return type to be int64_t instead of Cell . The following is an example - note how each long parameter actually consumes two cells of the parameter list: native static long addTwoLongs ( long a , long b ) int64_t foo_Type3_addTwoLongs ( SedonaVM * vm , Cell * params ) { int64_t a = * ( int64_t * )( params + 0 ); // param 0+1 int64_t b = * ( int64_t * )( params + 2 ); // param 2+3 return a + b ; } A summary of common mappings from Sedona to their C equivalents: Sedona C Sedona C bool int32_t bool[] uint8_t* byte int32_t byte[] uint8_t* short int32_t short[] uint16_t* int int32_t int[] int32_t* long int64_t long[] int64_t* float float float[] float* double double double[] double* Obj void* Obj[] void** Str uint8_t* Str[] uint8_t** Note that strings can be used as a normal null terminated C string. Refer to the Porting chapter for how to structure your native C code. Native Tables \u00b6 When the SVM is compiled, the SVM is bound to a lookup table for all the native methods available. This lookup table is a two level array of function pointers. The first level of the array maps to the kitIds and the second level maps to the methodIds. For example the function pointer for the native id of \"2::7\" would be nativeTable[2][7] . The native lookup table is automatically generated as \"nativetable.c\" when sedonac is used to stage a VM . Additional Issues \u00b6 The existing native method facility provides low level hooks to bind Sedona Framework APIs into the native platform. However due to its low level nature it maps fairly closely to the stack architecture of the VM. This design has the major limitation that it only works well when accessing primitives off the stack. There is currently no safe mechanism to access individual fields of an Object within a native method, as you would need to know exactly how the compiler will layout the memory (even then it would be quite brittle). In the meantime the best practice is to pass only primitives (or arrays of primitives) as parameters. Predefined Kit Ids \u00b6 The following table shows some of the currently predefined native kit ids. All PlatformService kits use a native kit id of 1. Kit Id sys 0 platform svcs 1 inet 2 serial 3 basicio 4 bacnet 5 smbus 6 spibus 7 nrio 8 datetimeStd 9","title":"Native Methods"},{"location":"language/nativeMethods/#native-methods","text":"","title":"Native Methods"},{"location":"language/nativeMethods/#overview","text":"Native methods are used to create Sedona APIs that bind to native code written in the C programming language. The following steps are used to create a native method: Native Id : Every native method is assigned a unique two byte identifier in the kit's kit.xml file Stub : Every native method is declared in the Sedona code using the native modifier Native Implementation : Native methods are implemented as functions in the C programming language Native Tables : At staging, function pointers to the native implementations are mapped into tables for dispatch by the SVM at runtime","title":"Overview"},{"location":"language/nativeMethods/#native-id","text":"Every native method is assigned a two byte identifier used to dispatch a call to the proper C function. The first byte is the kitId and the second byte is the methodId . Native ids are expressed as \"kitId::methodId\". Each kit that contains native methods should be assigned a unique kitId. Technically kitIds don't need to be globally unique, but they must be unique across all the kits that might be used together for a given platform. The range of kitIds from 0 to 99 is reserved for core Sedona Framework kits. Third parties should use kitIds from 100 to 255 (or contact the Sedona Framework development team). The sys kit itself is assigned the kitId of zero. Any platform service kit (i.e. a platform-specific kit containing a PlatformService subclass) can be given a kitId of 1, since there will never be more than one such kit loaded on a Sedona device at any given time. Within a kit, every native method is assigned a unique methodId. Because the methodId is only a byte, there can be at most 255 native methods in a single kit. The list of native ids for a kit is defined in the kit.xml file using the following XML format: <natives> <native qname= \"foo::Type1.method1\" id= \"6::0\" /> <native qname= \"foo::Type1.method2\" id= \"6::1\" /> <native qname= \"foo::Type2.method1\" id= \"6::2\" /> </natives> The natives element contains one or more native elements for each native method in the kit. The native element contains two required attributes: qname specifies the qualified name of the native method and id specifies the native id formatted as \"kitId::methodId\". In this example, the kitId for kit foo is 6, and the native method methodIds are 0, 1, and 2.","title":"Native Id"},{"location":"language/nativeMethods/#stubs","text":"Native methods are declared like normal methods but without a method body (just like abstract methods). Native methods must be flagged with the native keyword. Native methods cannot be abstract or virtual . For example: class Type2 { static native int add(int a, int b) static native void test(bool z, int i, float f) native float testf(int i, float f) } The compiler will perform a series of checks upon the native ids and native stubs when compiling source code into a kit file (in the ResolveNatives step). Unless errors are detected, the native ids are written into the appropriate IR files of the kit. If any native ids are modified, you must recompile from source.","title":"Stubs"},{"location":"language/nativeMethods/#native-implementation","text":"The SVM is stack based. Each item on the stack is called a Cell , which is a union of int32_t , float , and void* . Unless you are running on a 64-bit processor, a Cell is 32-bits wide. The definition of Cell in sedona.h is: typedef union { int32_t ival; // 32-bit signed int float fval; // 32-bit float void* aval; // address pointer } Cell; Every native method must be implemented in C as a function that takes two arguments: a SedonaVM_s pointer and a Cell pointer into the stack, and returns a Cell . (Native methods that return a long or a double require special handling, described in more detail below). The definition for SedonaVM_s is in sedona.h . The typedef for a native method pointer is: typedef Cell (*NativeMethod)(struct SedonaVM_s* vm, Cell* params); The method parameters are accessed from the stack via the Cell pointer params . You can manually extract the individual parameters using array indexing. If the native method is not static, then parameter 0 is always the implicit this pointer. It is important to note that all native method implementations return a Cell value even when the Sedona signature for the method returns void . You can use the constant nullCell to return from a method that returns void . Other predefined Cell constants are trueCell , falseCell , zeroCell , oneCell , and negOneCell . An example implementation of the foo::Type2.add method: Cell foo_Type2_add ( SedonaVM * vm , Cell * params ) { int32_t a = params [ 0 ]. ival ; int32_t b = params [ 1 ]. ival ; Cell result ; result . ival = a + b ; return result } An example implementation of the foo::Type2.test method: Cell foo_Type2_test ( SedonaVM * vm , Cell * params ) { int32_t z = params [ 0 ]. ival ; int32_t b = params [ 1 ]. ival ; float f = params [ 2 ]. fval ; printf ( \"test %d %d %f \\n \" , z , b , f ); return nullCell ; } An example implementation of the (non-static) foo::Type2.testf method: Cell foo_Type2_testf ( SedonaVM * vm , Cell * params ) { void * this = params [ 0 ]. aval ; /* 'this' pointer is implicit first element of params[] */ int32_t b = params [ 1 ]. ival ; float f = params [ 2 ]. fval ; Cell result ; result . fval = b * f ; printf ( \"test %d*%f=%f \\n \" , b , f , result . fval ); return result ; } Note in the examples above how each parameter is extracted using array indexing and the union member name. Pointers (including strings) should use the aval member, floats the fval member, and all other primitives are accessed using the ival member. Note that a Sedona bool maps into zero and non-zero for false and true respectively. Arrays of primitives are accessed like their C counterparts. Native methods that pass or return long or double are a bit trickier. A single long or double value requires two Cells to store the full 64-bits. To access a long or double function argument requires the use of pointer casting to access two consecutive elements of the parameter array. A native method that returns a long or double should declare the return type to be int64_t instead of Cell . The following is an example - note how each long parameter actually consumes two cells of the parameter list: native static long addTwoLongs ( long a , long b ) int64_t foo_Type3_addTwoLongs ( SedonaVM * vm , Cell * params ) { int64_t a = * ( int64_t * )( params + 0 ); // param 0+1 int64_t b = * ( int64_t * )( params + 2 ); // param 2+3 return a + b ; } A summary of common mappings from Sedona to their C equivalents: Sedona C Sedona C bool int32_t bool[] uint8_t* byte int32_t byte[] uint8_t* short int32_t short[] uint16_t* int int32_t int[] int32_t* long int64_t long[] int64_t* float float float[] float* double double double[] double* Obj void* Obj[] void** Str uint8_t* Str[] uint8_t** Note that strings can be used as a normal null terminated C string. Refer to the Porting chapter for how to structure your native C code.","title":"Native Implementation"},{"location":"language/nativeMethods/#native-tables","text":"When the SVM is compiled, the SVM is bound to a lookup table for all the native methods available. This lookup table is a two level array of function pointers. The first level of the array maps to the kitIds and the second level maps to the methodIds. For example the function pointer for the native id of \"2::7\" would be nativeTable[2][7] . The native lookup table is automatically generated as \"nativetable.c\" when sedonac is used to stage a VM .","title":"Native Tables"},{"location":"language/nativeMethods/#additional-issues","text":"The existing native method facility provides low level hooks to bind Sedona Framework APIs into the native platform. However due to its low level nature it maps fairly closely to the stack architecture of the VM. This design has the major limitation that it only works well when accessing primitives off the stack. There is currently no safe mechanism to access individual fields of an Object within a native method, as you would need to know exactly how the compiler will layout the memory (even then it would be quite brittle). In the meantime the best practice is to pass only primitives (or arrays of primitives) as parameters.","title":"Additional Issues"},{"location":"language/nativeMethods/#predefined-kit-ids","text":"The following table shows some of the currently predefined native kit ids. All PlatformService kits use a native kit id of 1. Kit Id sys 0 platform svcs 1 inet 2 serial 3 basicio 4 bacnet 5 smbus 6 spibus 7 nrio 8 datetimeStd 9","title":"Predefined Kit Ids"},{"location":"language/primitives/","text":"Primitives \u00b6 Overview \u00b6 The Sedona programming language contains the following built-in primitive types: bool : boolean value byte : unsigned 8-bit integer (as field or array only) short : unsigned 16-bit integer (as field or array only) int : signed 32-bit integer long : signed 64-bit integer float : 32-bit floating point double : 64-bit floating point In addition to the primitive types, the following class types have special language support for literal representation: Str : string of ASCII characters terminated by 0 (like C string) Buf : chunk of bytes in memory These types are described in more detail below. Bool \u00b6 The bool type stores a boolean variable. Boolean literals are expressed using the true , false , and null keywords. Use null to indicate an invalid boolean value. If used in a boolean expression, null will evaluate to true (it is represented as 2 in memory). A bool is stored in fields and arrays as an unsigned 8-bit integer. During stack manipulation bool s are stored on the stack as signed 32-bit integers. The representation for booleans: Value Binary String false 0 \"false\" true 1 \"true\" null 2 \"null\" Integers \u00b6 There are four integer types of varying widths: byte : unsigned 8-bit integer (as field or array only) short : unsigned 16-bit integer (as field or array only) int : signed 32-bit integer long : signed 64-bit integer Both byte and short are special types that may only be used as fields or in arrays. Attempting to use byte or short as a return type, parameter type, or local variable type is a compiler error. Note that unlike Java both byte and short are unsigned . Currently there is no signed 8-bit or 16-bit integer type. All integer operations on the SVM stack are performed using signed 32-bit integers. When a byte or short is loaded from a field or array it is automatically expanded into a 32-bit signed value. Likewise when it is stored back into a field or array it is narrowed from a 32-bit signed value. Integer literals are decimal by default. If prefixed with \"0x\" they are hexadecimal. You may use the underbar \"_\" as separator in both decimal and hexadecimal formats. To specify a 64-bit long value, you must append an \"L\" to the number. Char escapes \u00b6 You may also use single quotes to specify a character as an integer literal. The following character escape sequences are supported: \\0 zero/null terminator \\n newline \\r carriage return \\t horizontal tab \\\" double quote \\' single quote \\\\ backslash \\$ dollar sign ($ is used for str interpolation) Examples of integer literals: 8 -78 0xABCD 10_000 0xffff_ffff 'x' '\\n' 0L 0x1234_5678_aabb_ccddL Floating Point \u00b6 The float type maps to a 32-bit floating point value and double to 64-bit floating point. Floating point literals are expressed in decimal format using a '.' dot as the decimal point. The 'F' or 'f' character may be used as a suffix (required if not using a decimal point). The 'D' or 'd' character is required as a suffix for a 64-bit double. You may use the '_' underbar as a separator. You can also specify floating point literals in scientific notation. All numbers given in scientific notation are of type float unless explicitly marked as a double using 'D' or 'd'. A floating-point literal has the following format: The keyword null is used to represent not-a-number for situations requiring indication of an invalid float or double. The string representation for null floats and doubles is always 'null'. The '==' operator will return true when comparing two null floating point values (this is different from Java and IEEE). The evaluation of arithmetic and comparison operations with null operands, however, is unspecified for the Sedona VM. 3f 3.0 40_000F -2.00D 0d 1e+5 5.86e12d 314159E-5 null Time \u00b6 The Sedona Framework represents time in nanosecond ticks, stored as a 64-bit long. When working with time, you can use a special literal representation for longs using the following suffixes on a decimal number: Suffix Unit Nanosecond Multiplier ns nanoseconds 1 ms milliseconds 1,000,000 sec seconds 1,000,000,000 min minutes 60,000,000,000 hr hours 3,600,000,000,000 days days 86,400,000,000,000 Examples of long time literals and what they represent: 5ns // 5L 1ms // 1_000_000L 10sec // 10_000_000_000L 3min // 180_000_000_000L 12hr // 43_200_000_000_000L 0.5ms // 500_000L 0.001sec // 1_000_000L 0.25min // 15_000_000_000L 0.5days // 43_200_000_000_000L 1days // 86_400_000_000_000L 36500days // 31_53_600_000_000_000_000L Str \u00b6 The sys::Str class models a string of ASCII characters. Strings are stored in memory like C strings using a null terminator (a byte with a value of zero). You should use only 7-bit ASCII characters (clear high bit) to allow future UTF-8 and Unicode support. In the SVM, the Str class makes use of the unsized class feature to create a byte[] of the correct length when the Str object is instantiated. No other fields are declared, so an instance of Str is stored in memory just like a byte[] . You can also treat a Str reference as a normal C string ( char* ) when writing native methods . Because Str is an unsized class, you must specify the length of the string when declaring a Str field. For example to declare a Str that can hold a max of 8 characters (including the null terminator): Str someStr // reference to Str stored elsewhere inline Str ( 8 ) myStr // storage allocated here for 8 byte Str Sedona also supports string interpolation when writing to an output stream. Str literals are written using double quotes. You may use supported escape sequences for special characters inside the quotes. All Str literals are interned when compiling a scode image - this means that all Str literals with the same sequence of characters will share the same reference. Str literals should be considered read-only memory - never try to change the contents of a Str literal. Examples of Str literals: \"hello\" \"Hi there.\\nHow are you?\" The compiler automatically adds the null terminator byte when interning the literal. For example a pointer to the literal \"abc\" is really a pointer to four bytes of memory containing \"abc\\0\" . Buf \u00b6 The sys::Buf class models a contiguous chunk of bytes in memory. Like sys::Str , it is an unsized class containing a byte[] that is allocated to the specified size when the Buf object is created. Unlike Str , however, Buf does not treat its contents as a string, so no null terminator is added. It also has fields that store the size of the buffer and the number of bytes used. The syntax for a Buf literal is 0x[hexDigits] . You can use whitespace (including newlines) between bytes. For example: static Buf literalA = 0x[cafe babe 03 dead beef] Just like Str literals, Buf literals are interned and stored in scode memory space. So you should never attempt to write into a Buf literal\\'s memory space - for example never try to set the bytesLen field or change the contents of the bytes field. Array Literals \u00b6 Although they are not free-form expressions, you can also declare array literals in code: define Str[] colors = {\"red\", \"green\", \"blue\"} See Array Literals for more details.","title":"Primitives"},{"location":"language/primitives/#primitives","text":"","title":"Primitives"},{"location":"language/primitives/#overview","text":"The Sedona programming language contains the following built-in primitive types: bool : boolean value byte : unsigned 8-bit integer (as field or array only) short : unsigned 16-bit integer (as field or array only) int : signed 32-bit integer long : signed 64-bit integer float : 32-bit floating point double : 64-bit floating point In addition to the primitive types, the following class types have special language support for literal representation: Str : string of ASCII characters terminated by 0 (like C string) Buf : chunk of bytes in memory These types are described in more detail below.","title":"Overview"},{"location":"language/primitives/#bool","text":"The bool type stores a boolean variable. Boolean literals are expressed using the true , false , and null keywords. Use null to indicate an invalid boolean value. If used in a boolean expression, null will evaluate to true (it is represented as 2 in memory). A bool is stored in fields and arrays as an unsigned 8-bit integer. During stack manipulation bool s are stored on the stack as signed 32-bit integers. The representation for booleans: Value Binary String false 0 \"false\" true 1 \"true\" null 2 \"null\"","title":"Bool"},{"location":"language/primitives/#integers","text":"There are four integer types of varying widths: byte : unsigned 8-bit integer (as field or array only) short : unsigned 16-bit integer (as field or array only) int : signed 32-bit integer long : signed 64-bit integer Both byte and short are special types that may only be used as fields or in arrays. Attempting to use byte or short as a return type, parameter type, or local variable type is a compiler error. Note that unlike Java both byte and short are unsigned . Currently there is no signed 8-bit or 16-bit integer type. All integer operations on the SVM stack are performed using signed 32-bit integers. When a byte or short is loaded from a field or array it is automatically expanded into a 32-bit signed value. Likewise when it is stored back into a field or array it is narrowed from a 32-bit signed value. Integer literals are decimal by default. If prefixed with \"0x\" they are hexadecimal. You may use the underbar \"_\" as separator in both decimal and hexadecimal formats. To specify a 64-bit long value, you must append an \"L\" to the number.","title":"Integers"},{"location":"language/primitives/#char-escapes","text":"You may also use single quotes to specify a character as an integer literal. The following character escape sequences are supported: \\0 zero/null terminator \\n newline \\r carriage return \\t horizontal tab \\\" double quote \\' single quote \\\\ backslash \\$ dollar sign ($ is used for str interpolation) Examples of integer literals: 8 -78 0xABCD 10_000 0xffff_ffff 'x' '\\n' 0L 0x1234_5678_aabb_ccddL","title":"Char escapes"},{"location":"language/primitives/#floating-point","text":"The float type maps to a 32-bit floating point value and double to 64-bit floating point. Floating point literals are expressed in decimal format using a '.' dot as the decimal point. The 'F' or 'f' character may be used as a suffix (required if not using a decimal point). The 'D' or 'd' character is required as a suffix for a 64-bit double. You may use the '_' underbar as a separator. You can also specify floating point literals in scientific notation. All numbers given in scientific notation are of type float unless explicitly marked as a double using 'D' or 'd'. A floating-point literal has the following format: The keyword null is used to represent not-a-number for situations requiring indication of an invalid float or double. The string representation for null floats and doubles is always 'null'. The '==' operator will return true when comparing two null floating point values (this is different from Java and IEEE). The evaluation of arithmetic and comparison operations with null operands, however, is unspecified for the Sedona VM. 3f 3.0 40_000F -2.00D 0d 1e+5 5.86e12d 314159E-5 null","title":"Floating Point"},{"location":"language/primitives/#time","text":"The Sedona Framework represents time in nanosecond ticks, stored as a 64-bit long. When working with time, you can use a special literal representation for longs using the following suffixes on a decimal number: Suffix Unit Nanosecond Multiplier ns nanoseconds 1 ms milliseconds 1,000,000 sec seconds 1,000,000,000 min minutes 60,000,000,000 hr hours 3,600,000,000,000 days days 86,400,000,000,000 Examples of long time literals and what they represent: 5ns // 5L 1ms // 1_000_000L 10sec // 10_000_000_000L 3min // 180_000_000_000L 12hr // 43_200_000_000_000L 0.5ms // 500_000L 0.001sec // 1_000_000L 0.25min // 15_000_000_000L 0.5days // 43_200_000_000_000L 1days // 86_400_000_000_000L 36500days // 31_53_600_000_000_000_000L","title":"Time"},{"location":"language/primitives/#str","text":"The sys::Str class models a string of ASCII characters. Strings are stored in memory like C strings using a null terminator (a byte with a value of zero). You should use only 7-bit ASCII characters (clear high bit) to allow future UTF-8 and Unicode support. In the SVM, the Str class makes use of the unsized class feature to create a byte[] of the correct length when the Str object is instantiated. No other fields are declared, so an instance of Str is stored in memory just like a byte[] . You can also treat a Str reference as a normal C string ( char* ) when writing native methods . Because Str is an unsized class, you must specify the length of the string when declaring a Str field. For example to declare a Str that can hold a max of 8 characters (including the null terminator): Str someStr // reference to Str stored elsewhere inline Str ( 8 ) myStr // storage allocated here for 8 byte Str Sedona also supports string interpolation when writing to an output stream. Str literals are written using double quotes. You may use supported escape sequences for special characters inside the quotes. All Str literals are interned when compiling a scode image - this means that all Str literals with the same sequence of characters will share the same reference. Str literals should be considered read-only memory - never try to change the contents of a Str literal. Examples of Str literals: \"hello\" \"Hi there.\\nHow are you?\" The compiler automatically adds the null terminator byte when interning the literal. For example a pointer to the literal \"abc\" is really a pointer to four bytes of memory containing \"abc\\0\" .","title":"Str"},{"location":"language/primitives/#buf","text":"The sys::Buf class models a contiguous chunk of bytes in memory. Like sys::Str , it is an unsized class containing a byte[] that is allocated to the specified size when the Buf object is created. Unlike Str , however, Buf does not treat its contents as a string, so no null terminator is added. It also has fields that store the size of the buffer and the number of bytes used. The syntax for a Buf literal is 0x[hexDigits] . You can use whitespace (including newlines) between bytes. For example: static Buf literalA = 0x[cafe babe 03 dead beef] Just like Str literals, Buf literals are interned and stored in scode memory space. So you should never attempt to write into a Buf literal\\'s memory space - for example never try to set the bytesLen field or change the contents of the bytes field.","title":"Buf"},{"location":"language/primitives/#array-literals","text":"Although they are not free-form expressions, you can also declare array literals in code: define Str[] colors = {\"red\", \"green\", \"blue\"} See Array Literals for more details.","title":"Array Literals"},{"location":"language/reflection/","text":"Reflection \u00b6 Overview \u00b6 Despite its tiny runtime footprint, the Sedona Framework has powerful reflection support for accessing kit, type, and slot meta-data at runtime. However unlike the general purpose reflection found in Java, Sedona reflection is only supported for Component types and Property/Action slots. Kits \u00b6 You can access the installed kits with the sys::Kit class: // iterate over the installed kits foreach (Kit kit : Sys.kits, Sys.kitsLen) Sys.out.print(\"$kit.name $kit.version ${Sys.hexStr(kit.checksum)}\").nl() // look up a kit by name Kit kit = Sys.findKit(\"sys\") Types \u00b6 The sys::Type API is used to reflectively work with types at runtime. Only types that extend from Component are available for reflection: // walk the types installed in a given kit Kit kit = Sys.findKit(\"control\") foreach (Type t : kit.types, kit.typesLen) Sys.out.print(\" ${kit.name}::${t.name}\").nl() // lookup a type by qname Type t = Sys.findType(\"control::Ramp\") // type literal for class User Type t = User.type If you know the type you need at compile time, you should use type literals since they are most efficient: UserService s = (UserService)Sys.app.lookupService(UserService.type) Slots \u00b6 The sys::Slot API is used to reflectively work with slots at runtime. Only the property and action slots of component types are available for reflection: // walk a type's slots Type t = App.type foreach (Slot slot : t.slots, t.slotsLen) Sys.out.print(\" ${slot.name}: $slot.type.name\").nl() // lookup a slot by name Slot restart = t.findSlot(\"restart\") // slot literal for the App action \"restart\" Slot restart = App.restart If you know the slot you need at compile time, you should use slot literals since they are most efficient. Ids \u00b6 Note that Kit , Type , and Slot each have an id field, which is a direct index into the corresponding array: Id Field Index Into Kit.id Sys.kits Type.id Kit.types Slot.id Type.slots This is an extremely efficient way to lookup kits, types, and slots. However, be aware that the id lookup only works within a specific schema. As soon you change the installed kits or the version of those kits, then all of the reflection ids will likely change. This trade-off between the efficiency of id based lookup versus the ability to version kits is the basis of Schemas .","title":"Reflection"},{"location":"language/reflection/#reflection","text":"","title":"Reflection"},{"location":"language/reflection/#overview","text":"Despite its tiny runtime footprint, the Sedona Framework has powerful reflection support for accessing kit, type, and slot meta-data at runtime. However unlike the general purpose reflection found in Java, Sedona reflection is only supported for Component types and Property/Action slots.","title":"Overview"},{"location":"language/reflection/#kits","text":"You can access the installed kits with the sys::Kit class: // iterate over the installed kits foreach (Kit kit : Sys.kits, Sys.kitsLen) Sys.out.print(\"$kit.name $kit.version ${Sys.hexStr(kit.checksum)}\").nl() // look up a kit by name Kit kit = Sys.findKit(\"sys\")","title":"Kits"},{"location":"language/reflection/#types","text":"The sys::Type API is used to reflectively work with types at runtime. Only types that extend from Component are available for reflection: // walk the types installed in a given kit Kit kit = Sys.findKit(\"control\") foreach (Type t : kit.types, kit.typesLen) Sys.out.print(\" ${kit.name}::${t.name}\").nl() // lookup a type by qname Type t = Sys.findType(\"control::Ramp\") // type literal for class User Type t = User.type If you know the type you need at compile time, you should use type literals since they are most efficient: UserService s = (UserService)Sys.app.lookupService(UserService.type)","title":"Types"},{"location":"language/reflection/#slots","text":"The sys::Slot API is used to reflectively work with slots at runtime. Only the property and action slots of component types are available for reflection: // walk a type's slots Type t = App.type foreach (Slot slot : t.slots, t.slotsLen) Sys.out.print(\" ${slot.name}: $slot.type.name\").nl() // lookup a slot by name Slot restart = t.findSlot(\"restart\") // slot literal for the App action \"restart\" Slot restart = App.restart If you know the slot you need at compile time, you should use slot literals since they are most efficient.","title":"Slots"},{"location":"language/reflection/#ids","text":"Note that Kit , Type , and Slot each have an id field, which is a direct index into the corresponding array: Id Field Index Into Kit.id Sys.kits Type.id Kit.types Slot.id Type.slots This is an extremely efficient way to lookup kits, types, and slots. However, be aware that the id lookup only works within a specific schema. As soon you change the installed kits or the version of those kits, then all of the reflection ids will likely change. This trade-off between the efficiency of id based lookup versus the ability to version kits is the basis of Schemas .","title":"Ids"},{"location":"language/stmt/","text":"Statements \u00b6 Overview \u00b6 Statements are very close to those found in C or Java: Expression : expression statement Locals : declare a local variable Return : exit from a method If/Else : conditional branching While : conditional looping For : just like C for statement Foreach : array iteration Goto : unconditional branching Switch : jump tables Assert : used for unit testing Unlike C or Java, statements are not required to be terminated with a semicolon. By convention they are terminated with a newline, although they can also be terminated with a semicolon or \"}\". All of these are valid statements: if ( c ) { doSomething () orAnother () } if ( c ) { doSomething (); orAnother (); } if ( c ) { doSomething (); orAnother () } Note that Sedona's grammar is not always unambiguous when terminating a statement with a newline. So on occasion you might be required to use a semicolon. If you get a weird compiler error you don't understand try sticking in a semicolon. This might happen if you have a statement that starts with a parenthesis such as ((Type)x).something() . Expression \u00b6 The most common type of statements are stand alone expressions. The following expressions can be used as a statement: Assignment: x = y, x++, x[i] = y, x.f += y Method calls: x() Local Variables \u00b6 Local variables are declared as follows: float f int i = 5 Component c = doSomething() Local variables are scoped within their block - they are not visible to parent blocks. A local variable must be definitely assigned before it is used or the compiler will generate an error. Sedona doesn't currently support declaring multiple local variables in one statement like C or Java. Return \u00b6 The return statement is used to exit a method. If a return is used in a non-void method, then it must specify the expression to return: // void return return // non-void return return expr If Else \u00b6 Sedona supports C style if/else statements: // if, no else if (cond) block // if-else if (cond) block else block // if, if-else, else if (cond) block else if (cond) block else block Like C/Java, each block may be a single statement, or a block of statements wrapped in \"{ }\" curly braces. Looping \u00b6 Sedona supports the traditional while, do-while, and for loops of C like languages. Sedona also has a foreach statement for iterating arrays. In each case, the repeated code can be a single statement or a sequence of statements wrapped in \"{ }\" curly braces. While \u00b6 The while statement is used to loop while a boolean expression evaluates to true: while (cond) block Do While \u00b6 The do-while statement works just like the while loop, except the condition is evaluated at the end of the block. It is typically used when you wish to guarantee the loops executes at least once: do block while (cond) For \u00b6 The for statement works like a while loop except it allows an initialization expression and an update expression that executes after each loop iteration: for (init; cond; update) block // example - prints 0 to 4 for (int i=0; i<5; ++i) Sys.out.print(\"i = $i\\n\") Any of the init, cond, or update expressions may be omitted. If the cond is omitted, then it defaults to true and the loop must be terminated with a break or return statement inside the block. Foreach \u00b6 Sedona provides the foreach statement to iterate through an array. Using the foreach statement is more efficient than using a for loop because is compiles into a specialized instruction. The foreach statement takes a local variable declaration, an array to iterate, and an optional array length: foreach (type var : array) block foreach (type var : array, length) block // example - prints each kit name and version foreach (Kit kit : Sys.kits, Sys.kitsLen) Sys.out.print(\"$kit.name $kit.version\").nl() The length may be omitted only if the compiler can infer the length of the array from its declaration. Break \u00b6 The break statement is used to exit a loop. It may be used with any looping statement (while, do-while, for, and foreach): // prints 0 to 3, then breaks for (int i=0; i<10; ++i) { if (i == 4) break Sys.out.print(\"i=$i\\n\") } If a break is used inside nested loops, it breaks from the inner-most loop. Labeled breaks are not supported. Continue \u00b6 The continue statement causes the next iteration of the containing loop to begin. For a while and do-while, the loop condition is executed immediately. For a for or foreach loop, control is passed to the increment step. // prints 0, 1, 3 (skips 2) for (int i=0; i<4; ++i) { if (i == 2) continue Sys.out.print(\"i=$i\\n\") } If a continue is used inside nested loops, it continues the inner-most loop. Labeled continues are not supported. Goto \u00b6 The goto statement performs an unconditional jump to a labeled statement within the same method: // this method always returns \"y\" static Str f() { goto foo return \"x\" foo: return \"y\" } Switch \u00b6 The switch statement works just like C and Java. It evaluates an integer expression and jumps to a cast label: Str s = null switch (i) { case 0: case 1: s = \"0 or 1\" break case 2: s = \"2\" break default: s = \"not 0, 1, or 2\" } Like C, case blocks fall through to the next case block - use a break statement to break out of the switch statement. The default block handles any value without an matching case label. The default block is optional; if omitted then unmatched values fall through to the next statement after the switch. However, if the default block exists, it must be the last label in the switch statement. If the last case statement does not break and there is a default block, the last case statement will fall through into the default block. switch(i) { case 0: reset() break case 1: init() // fall through to default block default: work() // whenever i is not zero } Limits on Case Values \u00b6 To reduce code size, case values must not be too widely spaced. For a difference delta between the minimum and maximum case values, and total number of case values num , at least one of the following must be true: delta <= 30 num*3 >= delta It is a compile time error if both conditions are false. If you get this compiler error, you should change your code to use the if/else if/.../else idiom. Assert \u00b6 The assert statement is used for unit testing . assert(cond) The condition must be a boolean expression. Failed assertions result in a call to the Sedona VM's onAssertFailure callback. On most platforms, this will print a message to stdout. See Porting for more details.","title":"Statements"},{"location":"language/stmt/#statements","text":"","title":"Statements"},{"location":"language/stmt/#overview","text":"Statements are very close to those found in C or Java: Expression : expression statement Locals : declare a local variable Return : exit from a method If/Else : conditional branching While : conditional looping For : just like C for statement Foreach : array iteration Goto : unconditional branching Switch : jump tables Assert : used for unit testing Unlike C or Java, statements are not required to be terminated with a semicolon. By convention they are terminated with a newline, although they can also be terminated with a semicolon or \"}\". All of these are valid statements: if ( c ) { doSomething () orAnother () } if ( c ) { doSomething (); orAnother (); } if ( c ) { doSomething (); orAnother () } Note that Sedona's grammar is not always unambiguous when terminating a statement with a newline. So on occasion you might be required to use a semicolon. If you get a weird compiler error you don't understand try sticking in a semicolon. This might happen if you have a statement that starts with a parenthesis such as ((Type)x).something() .","title":"Overview"},{"location":"language/stmt/#expression","text":"The most common type of statements are stand alone expressions. The following expressions can be used as a statement: Assignment: x = y, x++, x[i] = y, x.f += y Method calls: x()","title":"Expression"},{"location":"language/stmt/#local-variables","text":"Local variables are declared as follows: float f int i = 5 Component c = doSomething() Local variables are scoped within their block - they are not visible to parent blocks. A local variable must be definitely assigned before it is used or the compiler will generate an error. Sedona doesn't currently support declaring multiple local variables in one statement like C or Java.","title":"Local Variables"},{"location":"language/stmt/#return","text":"The return statement is used to exit a method. If a return is used in a non-void method, then it must specify the expression to return: // void return return // non-void return return expr","title":"Return"},{"location":"language/stmt/#if-else","text":"Sedona supports C style if/else statements: // if, no else if (cond) block // if-else if (cond) block else block // if, if-else, else if (cond) block else if (cond) block else block Like C/Java, each block may be a single statement, or a block of statements wrapped in \"{ }\" curly braces.","title":"If Else"},{"location":"language/stmt/#looping","text":"Sedona supports the traditional while, do-while, and for loops of C like languages. Sedona also has a foreach statement for iterating arrays. In each case, the repeated code can be a single statement or a sequence of statements wrapped in \"{ }\" curly braces.","title":"Looping"},{"location":"language/stmt/#while","text":"The while statement is used to loop while a boolean expression evaluates to true: while (cond) block","title":"While"},{"location":"language/stmt/#do-while","text":"The do-while statement works just like the while loop, except the condition is evaluated at the end of the block. It is typically used when you wish to guarantee the loops executes at least once: do block while (cond)","title":"Do While"},{"location":"language/stmt/#for","text":"The for statement works like a while loop except it allows an initialization expression and an update expression that executes after each loop iteration: for (init; cond; update) block // example - prints 0 to 4 for (int i=0; i<5; ++i) Sys.out.print(\"i = $i\\n\") Any of the init, cond, or update expressions may be omitted. If the cond is omitted, then it defaults to true and the loop must be terminated with a break or return statement inside the block.","title":"For"},{"location":"language/stmt/#foreach","text":"Sedona provides the foreach statement to iterate through an array. Using the foreach statement is more efficient than using a for loop because is compiles into a specialized instruction. The foreach statement takes a local variable declaration, an array to iterate, and an optional array length: foreach (type var : array) block foreach (type var : array, length) block // example - prints each kit name and version foreach (Kit kit : Sys.kits, Sys.kitsLen) Sys.out.print(\"$kit.name $kit.version\").nl() The length may be omitted only if the compiler can infer the length of the array from its declaration.","title":"Foreach"},{"location":"language/stmt/#break","text":"The break statement is used to exit a loop. It may be used with any looping statement (while, do-while, for, and foreach): // prints 0 to 3, then breaks for (int i=0; i<10; ++i) { if (i == 4) break Sys.out.print(\"i=$i\\n\") } If a break is used inside nested loops, it breaks from the inner-most loop. Labeled breaks are not supported.","title":"Break"},{"location":"language/stmt/#continue","text":"The continue statement causes the next iteration of the containing loop to begin. For a while and do-while, the loop condition is executed immediately. For a for or foreach loop, control is passed to the increment step. // prints 0, 1, 3 (skips 2) for (int i=0; i<4; ++i) { if (i == 2) continue Sys.out.print(\"i=$i\\n\") } If a continue is used inside nested loops, it continues the inner-most loop. Labeled continues are not supported.","title":"Continue"},{"location":"language/stmt/#goto","text":"The goto statement performs an unconditional jump to a labeled statement within the same method: // this method always returns \"y\" static Str f() { goto foo return \"x\" foo: return \"y\" }","title":"Goto"},{"location":"language/stmt/#switch","text":"The switch statement works just like C and Java. It evaluates an integer expression and jumps to a cast label: Str s = null switch (i) { case 0: case 1: s = \"0 or 1\" break case 2: s = \"2\" break default: s = \"not 0, 1, or 2\" } Like C, case blocks fall through to the next case block - use a break statement to break out of the switch statement. The default block handles any value without an matching case label. The default block is optional; if omitted then unmatched values fall through to the next statement after the switch. However, if the default block exists, it must be the last label in the switch statement. If the last case statement does not break and there is a default block, the last case statement will fall through into the default block. switch(i) { case 0: reset() break case 1: init() // fall through to default block default: work() // whenever i is not zero }","title":"Switch"},{"location":"language/stmt/#limits-on-case-values","text":"To reduce code size, case values must not be too widely spaced. For a difference delta between the minimum and maximum case values, and total number of case values num , at least one of the following must be true: delta <= 30 num*3 >= delta It is a compile time error if both conditions are false. If you get this compiler error, you should change your code to use the if/else if/.../else idiom.","title":"Limits on Case Values"},{"location":"language/stmt/#assert","text":"The assert statement is used for unit testing . assert(cond) The condition must be a boolean expression. Failed assertions result in a call to the Sedona VM's onAssertFailure callback. On most platforms, this will print a message to stdout. See Porting for more details.","title":"Assert"},{"location":"networking/dasp/","text":"DASP \u00b6 Introduction \u00b6 This document specifies the Datagram Authenticated Session Protocol or DASP. This protocol is designed to provide an unordered, reliable, secure session for full-duplex datagram exchange that can be implemented for low power wireless networks and low cost devices. Specifically we target networks that include 6LoWPAN. These networks are typically comprised of devices without the resources to run a protocol such as TCP and must implement their protocol stacks in under 100KB of memory. Requirements \u00b6 The following requirements dictate the design of DASP: DASP runs over an unordered, unreliable packet based transport layer, which is assumed to be UDP or provide the same functionality. DASP will be a datagram oriented protocol, not a stream oriented protocol. Datagram boundaries will be maintained. DASP will deliver datagrams reliably with associated retries. Datagrams are guaranteed to be delivered exactly once. DASP will not guarantee delivery of datagrams in order. Because DASP is designed to run on devices with limited RAM resources, we must assume that buffer space is extremely scarce. Any ordering of datagrams is the responsibility of the application layer. DASP datagrams are delivered within the context of a session. Sessions allow us to efficiently associate datagrams with application context. Application context might include user account privileges, eventing state, or the state associated with a file transfer. DASP sessions are full-duplex - either endpoint may initiate a datagram. DASP sessions are established by authenticating a username and password. However the term password is loosely defined to include any type of secret key. DASP session setup will include an extensible mechanism for negotiating the cryptography capabilities of the two endpoints. The protocol will support plugging in new cryptography standards, but standardizes on SHA-1 for message digest. Version 1.0 does not specify encryption, but could be added via new handshaking headers. DASP will provide flow control in the delivery of datagrams between the endpoints using a sliding window. For example, a session might span both a high speed network such as Ethernet and a low speed network such as 6LoWPAN running over 802.15.4. Compounding the problem is that low speed networks may have few memory resources to allocate to buffering and can quickly be overwhelmed by bursts of packets. Design \u00b6 A DASP session is established when a client initiates a connection to a server. The two endpoints exchange a set of messages called the handshake to establish or reject the session. Once a session is established it is assigned an unsigned 16-bit identifier called the sessionId . The sessionId is included in all subsequent messaging within the context of that session. Messages within the session are consecutively numbered with an unsigned 16-bit value, which we call the sequence number or seqNum . Each endpoint of the session maintains its own sequence and sliding window of outstanding datagrams. This sliding window is used to implement reliability and flow control. Sessions are terminated explicitly via a special control message, or may be timed out after a period where no messages have been received from the remote endpoint. Message Format \u00b6 DASP messages are described as a data structure using the following primitive types: u1 : an unsigned 8-bit integer u2 : an unsigned 16-bit integer in network byte order str : UTF-8 encoded text, followed by a null terminate (zero) byte bytes : an unsigned 8-bit length n, followed by n bytes x[ ] : an array of type x that contains zero or more elements All DASP messages are formatted as follows: message { u2 sessionId u2 seqNum u1 high 4 - bits msgType , low 4 - bits numFields field [] headerFields u1 [] payload } The data in the message is summarized: sessionId : identifies the session associated with the message. During the handshake before a sessionId is allocated, the value 0xffff is used. seqNum : used to sequence each DATAGRAM message for management of the sliding window and matching up requests/responses. Each endpoint maintains its own sequence numbers. msgType : 4-bits are used to identity how to handle the message from an DASP perspective. The list of message types are detailed in a separate section below. numFields : 4-bits specify how many header fields follow in the message. headerFields : a list of zero or more fields that carry additional data about the request much like HTTP header fields. Header fields are detailed in a separate section below. payload : zero or more bytes of message payload. A DASP message does not specify the payload size, but assumes that the underlying transport such as UDP provides the total size of the entire message from which payload size can be computed. Message Types \u00b6 The following table specifies the full list of message type identifiers: Id Name Description 0x0 discover Sent by client or server during device discovery process 0x1 hello Sent by client to initiate handshake 0x2 challenge Response to client's hello message 0x3 authenticate Sent by client to provide authentication credentials 0x4 welcome Response to client's authenticate message if successful 0x5 keepAlive Heartbeat message and message acknowledgements 0x6 datagram Indicates an application datagram message 0x7 close Close the session Header Fields \u00b6 Header fields define a generic way to include an arbitrary set of name/value pairs in an DASP header. They are used much like HTTP header fields - each message type defines required and optional header fields and how they are to be interpreted. Additional header fields can be added to future versions of this specification without breaking the generic processing of DASP messages. Header fields are prefixed with a one byte headerId. The headerId conveys the name of the header in the high 6 bits and the value type of the header in the bottom 2 bits. Implementations can always look at the least significant 2-bits of the headerIds to determine how to decode or skip the header value. Implementations must ignore unknown headers. The 2-bit value type identifiers: Id Name Encoding 0x0 nil The header has no value - the header itself indicates a boolean 0x1 u2 Unsigned 16-bit integer in network byte order 0x2 str UTF-8 encoded text string, followed by null terminator (zero) byte 0x3 bytes 8-bit length, followed by string of raw bytes The list of headerIds defined by this specification: Id (6b, 2b) Name Type Description (default) 0x05 (1,1) version u2 Version of the protocol to use 0x09 (2,1) remoteId u2 Remote endpoint's session id 0x0e (3,2) digestAlgorithm str Name of digest to use (\"SHA-1\") 0x13 (4,3) nonce bytes Nonce to use for digest hash 0x16 (5,2) username str Name of user to authenticate 0x1b (6,3) digest bytes Value of digest hash to authenticate 0x1d (7,1) idealMax u2 Ideal max size in bytes (512) 0x21 (8,1) absMax u2 Absolute max size in bytes (512) 0x25 (9,1) ack u2 Ack a single seqNum 0x2b (a, 3) ackMore bytes Ack a list of seqNums (0x01) 0x2d (b,1) receiveMax u2 Max size of receiving window in bytes (31) 0x31 (c, 1) receiveTimeout u2 Receive timeout in seconds (30sec) 0x35 (d,1) errorCode u2 One of the predefined error codes 0x3a (e,2) platformId str Device's platform ID string Header fields may be specified in any order. Implementations must never assume a specific order. Error Codes \u00b6 The following types defines the error codes to be used with the errorCode header field: Id Name Description 0xe1 incompatibleVersion Server doesn't support version specified by hello 0xe2 busy Server is too busy to allocate new session 0xe3 digestNotSupported Client does not support digest algorithm in challenge 0xe4 notAuthenticated Client supplied invalid credentials 0xe5 timeout Remote endpoint is timing out the session Handshake \u00b6 A session is established by a series of messages called the handshake: The client sends the server a hello message The server responds with the challenge, welcome, or close message The client responds with the authenticate or close message The server responds with either a welcome or close message Once the client receives the welcome message from either step 2 or step 4, then the session is established. An close message during any step terminates the handshake. Hello \u00b6 The hello message is sent by a client to initiate a session. The following header fields apply: version (required): specifies the protocol version to be used. The version of this specification is 1.0, which is represented as 0x0100 in a 16-bit unsigned integer. remoteId (required): the client side sessionId used for messages sent by the server to the client. idealMax (optional): the ideal maximum of bytes per message from the client perspective - see Tuning. If not specified 512 is assumed. absMax (optional): the absolute maximum of bytes per message from the client perspective - see Tuning. If not specified 512 is assumed. receiveMax (optional): the absolute maximum size of the client's receiving windowing (number of messages). If not specified, then a window size of 31 messages is assumed. receiveTimeout (optional): the number of seconds that may elapse without receiving a message before the session is timed out from client perspective; if not specified then a default of 30 seconds is assumed. The sessionId of a hello message must be set to 0xffff to indicate a new session from the server's perspective. The remoteId header specifies the client's sessionId, all messages back to the client will use this sessionId. The seqNum should be a randomly chosen number between 0 and 0xffff , which becomes the start of the client sending window - this sequence number must be the seqNum of the first datagram message sent by the client to server. Challenge \u00b6 Once a hello message has been received, the server assigns a randomly chosen, unused sessionId and then returns a challenge message. The remoteId header of the challenge contains the server side's newly assigned session identifier. The sessionId of the challenge message is the value of the hello's remoteId header. The seqNum should be randomly chosen between 0 and 0xffff - this becomes the start of the server's sending window - the first datagram sent by the server to the client must use this seqNum. The following header fields apply: remoteId (required): the server's sessionId to use for messages sent by the client to the server. digestAlgorithm (optional): this specifies the digest algorithm to use for hashing the username, password, and nonce returned by the authenticate message. If this field is unspecified, then \"SHA-1\" is assumed. Other values that might be used are \"MD5\", \"SHA-256\", \"SHA-384\", and \"SHA-512\". Implementations are only required to implement \"SHA-1\", so this field should only be used when knowledge of client capability is known. Values of this field should always use upper case. nonce (required): the challenge message is required to specify a nonce used to generate a secure hash of the username and password. This value should be randomly generated using a cryptographically strong algorithm. A nonce should only be used once to prevent replay attacks. If the server doesn't support the version specified by the client in the hello message, then it should send the close message with the incompatibleVersion error code. The close message returned should include the version header field, which tells the client which version the server does support. The client may then choose to retry the handshake if supports the server's version. If the server is too busy to allocate a new session, then it should send back a close with the busy error code. A server can by-pass authentication completely by directly sending back a welcome message. Authenticate \u00b6 Once the client receives the challenge message, it has enough information to generate the authenticate message. Clients never pass user credentials directly to the server over the network. Instead the client sends the server a digest of the username, password, and nonce. The algorithm to compute the digest is defined by the digestAlgorithm field defined in the challenge message (or if unspecified then SHA-1 is assumed). The following function is used to compute the digest: credentials = digestAlgorithm(username + \":\" + password) digest = digestAlgorithm(credentials + nonce) First we hash the UTF-8 encoded credentials string, which is the username and password separated by a single \":\" colon character. We call this hash the credentials. We then run the hash function against the credentials and the nonce, which produces a one-time use digest. This mechanism permits DASP enabled devices to avoid storing a password in plain text by storing the username and only the credentials hash. However a device could store the username and password directly and compute the credentials hash as needed. Once the client computes the digest, it sends the server the authenticate message. The authenticate message uses the sessionId specified in the challenge's remoteId header. The seqNum should be the same as that used by the hello message. The following header fields apply: username (required): the UTF-8 encoded string identifier of the user to authenticate. digest (required): the message digest hash computed from the algorithm described above. If using SHA-1, this will be list of 20 bytes (160-bit digest). If the client does not support the digest algorithm specified by the server's challenge message, then the client should immediately send the server a close message with the digestNotSupported error code. Welcome \u00b6 Once the server receives the authenticate message, it validates the username and digest against its user database. If the authentication is successful, then the server responds to the client with the welcome message type. The sessionId of the welcome is the remoteId specified by the client in its hello. The seqNum should be the same as that used by the server's challenge message. The following fields apply: idealMax (optional): the ideal maximum of bytes per message from the server perspective - see Tuning. If not specified 512 is assumed. absMax (optional): the absolute maximum of bytes per message from the server perspective - see Tuning. If not specified 512 is assumed. receiveMax (optional): the absolute maximum size of the server's receiving windowing (number of messages). If not specified, then a window size of 31 messages is assumed. receiveTimeout (optional): the number of seconds that may elapse without receiving a message before the session is timed out from server perspective; if not specified then a default of 30 seconds is assumed. remoteId : if we are skipping the challenge, then the server's sessionId must be returned in the welcome, otherwise this header must be omitted. If authentication fails, then the server sends the client back a close message with the notAuthenticated error code. Tuning \u00b6 The absMax and idealMax header fields are used to negotiate message sizes between the client and server. The absMax is the absolute maximum number of bytes that a message may contain including the DASP headers, but not the transport headers (such as the UDP headers themselves). Typically this value maps to the amount of buffer space a device can dedicate to processing DASP messages. For example a device that can only allocate 256 bytes to buffering an DASP message will not be able to handle larger messages. The idealMax header field specifies the ideal maximum number of bytes a message should contain including the DASP headers (not including the transport headers). Often DASP is running over a network like 6LoWPAN that can support UDP packets larger than the MTU of a 802.15.4 frame. However if implementing a protocol like file transfer, it is desirable to chunk the stream such that messages fit within individual 802.15.4 frames without additional fragmentation overhead. The idealMax header provides for this optimization. Both absMax and idealMax negotiation works the same way. The client specifies its absMax and idealMax fields in its hello message. If either of the header fields are omitted, then they are implied to be 512 bytes. The server has its own absMax and idealMax, which it returns in the welcome message (or else they default to 512). The actual absMax and idealMax used for the session is the minimum between the client and server. For example: client: absMax=512, idealMax=256 server: absMax=1024, idealMax=64 session: absMax=512, idealMax=64 Error Handling \u00b6 Because we assume DASP runs over an unreliable transport, implementations must be prepared to handle lost, delayed, or unordered messages during the handshake process. The following are specific conditions that may arise, and the recommended action for each: The client sends the hello, but does not receive the challenge. In this case, either the hello or the challenge may have been lost. In either case, a new hello request should be sent. If after three attempts fail, then the client should assume communication with the server is not available The server sends the challenge, but doesn't receive an authenticate message. In this case, either the challenge or the authenticate message might have been dropped. In either case the server should never attempt resending the challenge, but rather should time out the session if no authenticate is received. During the handshake process, the server should use a shortened time out period (compared to normal session communication). The client sends the authenticate, but does not receive the welcome. In this case, either the authenticate or the welcome message was lost. The client should resend the authenticate message two more times, before giving up. Servers should gracefully handle receiving multiple authenticate messages for the same session. Messaging \u00b6 Once the session has successfully been established, either end point may initiate application level messaging via the datagram message type. When an endpoint receives a datagram message it performs the following steps: Matches the sessionId to a valid session. If not a valid session, the request is ignored. Checks that the remote address matches the one used to setup the session. If not the request is ignored. Checks that the seqNum is within the valid receiving sliding window, otherwise it is ignored. Checks that the datagram hasn't already been processed, otherwise it is ignored. Each endpoint must keep track of messages it has already processed within its receiving window. Updates its receiving window Sends the datagram to the application layer for processing. Receiver eventually piggybacks an ack on an outgoing message Acks \u00b6 In order to provide reliability, datagrams have to be acknowledged. If there are outgoing messages, then the ack header should be piggybacked to avoid extra messaging. Otherwise a keepAlive message with an ack header is sent back to the remote endpoint to acknowledge the datagrams received so far. The ack header specifies the most recent seqNum successfully received. When an ack header is received, an endpoint can assume that all seqNums <= ackNum have been successfully received and that ackNum + 1 has not been received yet by the remote endpoint. If an endpoint has received messages with gaps in the sequence numbering, it can use the ackMore header to enumerate the seqNums it has received. This allows us to avoid resending those messages just because we've had partial failures. The ackMore is encoded as a list of bits that indicate messages received (bit is set), and messages not received (bit is zero). The least significant bit corresponds to the seqNum in the ack header, and the most significant bit n corresponds to ackNum + n . The ackMore header must always be accompanied by the ack header. By definition the least significant bit of the bitmask must always be one since it corresponds to ackNum itself. Some examples: ack=10 ackMore=15 -> 0x21 ack=10 ackMore=12, 13 -> 0x0d ack=10 ackMore=15, 18, 19 -> 0x03 0x21 Retries \u00b6 Note The following behavior is not currently implemented in the opensource Sedona Framework implementations of DASP. Once an endpoint has sent a datagram message, it should wait for a period of time called the sendRetry (default = 1 sec) (see Flow Control for details). If no acknowledgement has been received for the datagram's seqNum, then one of two things has happened: the original datagram was lost or the acknowledgement was lost. The endpoint should resend the datagram message with the original sequence number, then wait again for sendRetry period. This process should be repeated until the datagram has been sent the number of times specified by the maxSend (default = 3) parameter. If the maxSend attempt fails, then the session should be timed out and the close message sent to the remote endpoint with the timeout error code. Sliding Window \u00b6 DASP supports full duplex messaging - either side may initiate application messages, which are identified with a 16-bit sequence number. An endpoint can have multiple outstanding messages that have not been acknowledged. The sequence of unacknowledged messages sent is called the sending window . Each endpoint also maintains a receiving window , which is the sequence of messages it is prepared to receive. Any messages outside of the receiving window are ignored. The receiveMax header is used to communicate the maximum size of receiving window so that the remote endpoint can tune its sending window. The receiveMax header of the client is specified in its hello message, and the receiveMax of the server is specified in the welcome message. Once receiveMax is established during the handshake, it cannot be changed. The receiveMax header specifies the maximum size of the sliding window, since any messages outside of that window will be ignored. An endpoint should never use a sending window size greater than the remote endpoint's receiving window. However, often the sending window is smaller than the remote's receive window. The sending window is grown and shrunk during the lifetime of the session to allow dynamic optimization of the session's throughput. Tuning the size of the sending window is the basis for flow control and congestion control. Since seqNum is stored in an unsigned 16-bit integer, implementations must handle rollover. The seqNum 65535 is followed by the sequence number 0. For example given lower bound of 65530 and a window size of 10, then the window wraps from 65530 to 3 inclusively. Sequence numbers and the sliding window are only used for datagram messages. The client's handshake hello and authenticate messages define the client's starting sequence number, which is the seqNum of the client's first datagram. The server's handshake challenge and welcome define the sequence number of the server's first datagram. The close and keepAlive messages should always use a sequence number of 0xffff. Flow Control \u00b6 A primary goal for DASP is to provide communication for traffic spanning networks and devices of varying capabilities. For example a common use case is a PC on an Ethernet network communicating to a low cost device on a 6LoWPAN network. The ability to tune a session's communication rates based on the capability of the endpoints is called flow control . It is also common for traffic on networks to vary over time during the course of a session. Tuning the session to handle varying network loads is called congestion control . For practical purposes, flow control and congestion control are handled using the same mechanisms - so we will use the term flow control generically. Flow control in DASP is always managed on the sending side by dynamically tuning the size of the sending window and the sendRetry time. These values are tuned based on analysis of the session's recent past performance. Keep Alive and Termination \u00b6 A session is terminated via one of the following conditions: One endpoint sends the close message No packets are received after a timeout period Close \u00b6 If possible, sessions should be gracefully shutdown using the close message type. If the failure is in the DASP layer (as opposed to the application layer), then the errorCode header should be specified. If an endpoint receives either the close or error message types, then the session is immediately terminated and the sessionId invalidated. No acknowledgement is sent on close messages. It is recommended that close messages be sent twice - endpoints should automatically ignore duplicate close/errors because the sessionId will be invalid. Errors during the handshake should only be sent once. However, since there is no acknowledgment, we can never guarantee that both endpoints are aware of the session termination (in which case we must rely on timeouts). Timeout \u00b6 We can never assume that sessions are closed gracefully, because real-world applications and networks can't be trusted. If an endpoint has not received any messages after a period of time, then the session is timed out. A timed out session is terminated and the sessionId is invalidated. The endpoint should send the remote endpoint an close message with the timeout error code - this error should only be sent once since there is a good chance the remote endpoint is no longer available. Each endpoint specifies its configured timeout via the receiveTimeout header. The client specifies receiveTimeout in its hello message, and the server in the welcome message. If the receiveTimeout is omitted during the handshake, then 30 sec should be assumed. Once the session is established the overall timeout of the session is the maximum timeout between the client and the server. Both endpoints must then use the longer timeout. Because the timeout must be negotiated between the endpoints, care should be taken with using very long time outs. The longer timeout is used because we assume the less capable endpoint's network or device drives overall reliability and speed. However longer timeouts also mean longer periods where the critical memory resources of session state are tied up waiting for a session timeout. keepAlives \u00b6 The keepAlive message type is used to prevent session timeouts and carry acknowledgments when there are no outgoing application messages. If there are no outgoing datagram messages to piggyback an ack header, then an endpoint should sent a keepAlive to acknowledge received messages. Implementations can send these acknowledgements immediately or may use a small delay called the ackDelay . The ackDelay provides a period of time to coalesce multiple acknowledgements and wait for an outgoing datagram message to be generated. Even if all received messages have been acknowledged, then an endpoint still needs to send keepAlive messages to ensure that the remote endpoint doesn't timeout the session. In the absence of other messaging, an endpoint should send keepAlives three times as fast as the timeout period. For example if the negotiated timeout is 30 sec, then keepAlives should be sent every 10 sec. Keep alives should only be used when no application datagrams are being transmitted. KeepAlives are themselves never part of the sliding window. The seqNum of a keepAlives should be 0xffff. When a keep alive is received, it is never checked against the receiving window and is never acknowledged. An endpoint that sends a keepAlive should never attempt to retry the keepAlive, since no acknowledgement is expected. Device Discovery \u00b6 DASP supports device discovery with the following sequence: The client sends a discover request to all listening Sedona servers Any server that receives the discover request opens a Sox session The server then sends a discover response containing its platform ID The server closes the Sox session immediately Each discover response the client receives is added to a list of discovered nodes. Discover \u00b6 A discover message may be sent by a client or a server. The client sends a discover message with no header fields. The server's response message is identical except that it adds a single header field containing its platform ID. platformId (response only): a string containing the platform ID of the responding device. How the discovered devices are collected and processed is not specified.","title":"DASP"},{"location":"networking/dasp/#dasp","text":"","title":"DASP"},{"location":"networking/dasp/#introduction","text":"This document specifies the Datagram Authenticated Session Protocol or DASP. This protocol is designed to provide an unordered, reliable, secure session for full-duplex datagram exchange that can be implemented for low power wireless networks and low cost devices. Specifically we target networks that include 6LoWPAN. These networks are typically comprised of devices without the resources to run a protocol such as TCP and must implement their protocol stacks in under 100KB of memory.","title":"Introduction"},{"location":"networking/dasp/#requirements","text":"The following requirements dictate the design of DASP: DASP runs over an unordered, unreliable packet based transport layer, which is assumed to be UDP or provide the same functionality. DASP will be a datagram oriented protocol, not a stream oriented protocol. Datagram boundaries will be maintained. DASP will deliver datagrams reliably with associated retries. Datagrams are guaranteed to be delivered exactly once. DASP will not guarantee delivery of datagrams in order. Because DASP is designed to run on devices with limited RAM resources, we must assume that buffer space is extremely scarce. Any ordering of datagrams is the responsibility of the application layer. DASP datagrams are delivered within the context of a session. Sessions allow us to efficiently associate datagrams with application context. Application context might include user account privileges, eventing state, or the state associated with a file transfer. DASP sessions are full-duplex - either endpoint may initiate a datagram. DASP sessions are established by authenticating a username and password. However the term password is loosely defined to include any type of secret key. DASP session setup will include an extensible mechanism for negotiating the cryptography capabilities of the two endpoints. The protocol will support plugging in new cryptography standards, but standardizes on SHA-1 for message digest. Version 1.0 does not specify encryption, but could be added via new handshaking headers. DASP will provide flow control in the delivery of datagrams between the endpoints using a sliding window. For example, a session might span both a high speed network such as Ethernet and a low speed network such as 6LoWPAN running over 802.15.4. Compounding the problem is that low speed networks may have few memory resources to allocate to buffering and can quickly be overwhelmed by bursts of packets.","title":"Requirements"},{"location":"networking/dasp/#design","text":"A DASP session is established when a client initiates a connection to a server. The two endpoints exchange a set of messages called the handshake to establish or reject the session. Once a session is established it is assigned an unsigned 16-bit identifier called the sessionId . The sessionId is included in all subsequent messaging within the context of that session. Messages within the session are consecutively numbered with an unsigned 16-bit value, which we call the sequence number or seqNum . Each endpoint of the session maintains its own sequence and sliding window of outstanding datagrams. This sliding window is used to implement reliability and flow control. Sessions are terminated explicitly via a special control message, or may be timed out after a period where no messages have been received from the remote endpoint.","title":"Design"},{"location":"networking/dasp/#message-format","text":"DASP messages are described as a data structure using the following primitive types: u1 : an unsigned 8-bit integer u2 : an unsigned 16-bit integer in network byte order str : UTF-8 encoded text, followed by a null terminate (zero) byte bytes : an unsigned 8-bit length n, followed by n bytes x[ ] : an array of type x that contains zero or more elements All DASP messages are formatted as follows: message { u2 sessionId u2 seqNum u1 high 4 - bits msgType , low 4 - bits numFields field [] headerFields u1 [] payload } The data in the message is summarized: sessionId : identifies the session associated with the message. During the handshake before a sessionId is allocated, the value 0xffff is used. seqNum : used to sequence each DATAGRAM message for management of the sliding window and matching up requests/responses. Each endpoint maintains its own sequence numbers. msgType : 4-bits are used to identity how to handle the message from an DASP perspective. The list of message types are detailed in a separate section below. numFields : 4-bits specify how many header fields follow in the message. headerFields : a list of zero or more fields that carry additional data about the request much like HTTP header fields. Header fields are detailed in a separate section below. payload : zero or more bytes of message payload. A DASP message does not specify the payload size, but assumes that the underlying transport such as UDP provides the total size of the entire message from which payload size can be computed.","title":"Message Format"},{"location":"networking/dasp/#message-types","text":"The following table specifies the full list of message type identifiers: Id Name Description 0x0 discover Sent by client or server during device discovery process 0x1 hello Sent by client to initiate handshake 0x2 challenge Response to client's hello message 0x3 authenticate Sent by client to provide authentication credentials 0x4 welcome Response to client's authenticate message if successful 0x5 keepAlive Heartbeat message and message acknowledgements 0x6 datagram Indicates an application datagram message 0x7 close Close the session","title":"Message Types"},{"location":"networking/dasp/#header-fields","text":"Header fields define a generic way to include an arbitrary set of name/value pairs in an DASP header. They are used much like HTTP header fields - each message type defines required and optional header fields and how they are to be interpreted. Additional header fields can be added to future versions of this specification without breaking the generic processing of DASP messages. Header fields are prefixed with a one byte headerId. The headerId conveys the name of the header in the high 6 bits and the value type of the header in the bottom 2 bits. Implementations can always look at the least significant 2-bits of the headerIds to determine how to decode or skip the header value. Implementations must ignore unknown headers. The 2-bit value type identifiers: Id Name Encoding 0x0 nil The header has no value - the header itself indicates a boolean 0x1 u2 Unsigned 16-bit integer in network byte order 0x2 str UTF-8 encoded text string, followed by null terminator (zero) byte 0x3 bytes 8-bit length, followed by string of raw bytes The list of headerIds defined by this specification: Id (6b, 2b) Name Type Description (default) 0x05 (1,1) version u2 Version of the protocol to use 0x09 (2,1) remoteId u2 Remote endpoint's session id 0x0e (3,2) digestAlgorithm str Name of digest to use (\"SHA-1\") 0x13 (4,3) nonce bytes Nonce to use for digest hash 0x16 (5,2) username str Name of user to authenticate 0x1b (6,3) digest bytes Value of digest hash to authenticate 0x1d (7,1) idealMax u2 Ideal max size in bytes (512) 0x21 (8,1) absMax u2 Absolute max size in bytes (512) 0x25 (9,1) ack u2 Ack a single seqNum 0x2b (a, 3) ackMore bytes Ack a list of seqNums (0x01) 0x2d (b,1) receiveMax u2 Max size of receiving window in bytes (31) 0x31 (c, 1) receiveTimeout u2 Receive timeout in seconds (30sec) 0x35 (d,1) errorCode u2 One of the predefined error codes 0x3a (e,2) platformId str Device's platform ID string Header fields may be specified in any order. Implementations must never assume a specific order.","title":"Header Fields"},{"location":"networking/dasp/#error-codes","text":"The following types defines the error codes to be used with the errorCode header field: Id Name Description 0xe1 incompatibleVersion Server doesn't support version specified by hello 0xe2 busy Server is too busy to allocate new session 0xe3 digestNotSupported Client does not support digest algorithm in challenge 0xe4 notAuthenticated Client supplied invalid credentials 0xe5 timeout Remote endpoint is timing out the session","title":"Error Codes"},{"location":"networking/dasp/#handshake","text":"A session is established by a series of messages called the handshake: The client sends the server a hello message The server responds with the challenge, welcome, or close message The client responds with the authenticate or close message The server responds with either a welcome or close message Once the client receives the welcome message from either step 2 or step 4, then the session is established. An close message during any step terminates the handshake.","title":"Handshake"},{"location":"networking/dasp/#hello","text":"The hello message is sent by a client to initiate a session. The following header fields apply: version (required): specifies the protocol version to be used. The version of this specification is 1.0, which is represented as 0x0100 in a 16-bit unsigned integer. remoteId (required): the client side sessionId used for messages sent by the server to the client. idealMax (optional): the ideal maximum of bytes per message from the client perspective - see Tuning. If not specified 512 is assumed. absMax (optional): the absolute maximum of bytes per message from the client perspective - see Tuning. If not specified 512 is assumed. receiveMax (optional): the absolute maximum size of the client's receiving windowing (number of messages). If not specified, then a window size of 31 messages is assumed. receiveTimeout (optional): the number of seconds that may elapse without receiving a message before the session is timed out from client perspective; if not specified then a default of 30 seconds is assumed. The sessionId of a hello message must be set to 0xffff to indicate a new session from the server's perspective. The remoteId header specifies the client's sessionId, all messages back to the client will use this sessionId. The seqNum should be a randomly chosen number between 0 and 0xffff , which becomes the start of the client sending window - this sequence number must be the seqNum of the first datagram message sent by the client to server.","title":"Hello"},{"location":"networking/dasp/#challenge","text":"Once a hello message has been received, the server assigns a randomly chosen, unused sessionId and then returns a challenge message. The remoteId header of the challenge contains the server side's newly assigned session identifier. The sessionId of the challenge message is the value of the hello's remoteId header. The seqNum should be randomly chosen between 0 and 0xffff - this becomes the start of the server's sending window - the first datagram sent by the server to the client must use this seqNum. The following header fields apply: remoteId (required): the server's sessionId to use for messages sent by the client to the server. digestAlgorithm (optional): this specifies the digest algorithm to use for hashing the username, password, and nonce returned by the authenticate message. If this field is unspecified, then \"SHA-1\" is assumed. Other values that might be used are \"MD5\", \"SHA-256\", \"SHA-384\", and \"SHA-512\". Implementations are only required to implement \"SHA-1\", so this field should only be used when knowledge of client capability is known. Values of this field should always use upper case. nonce (required): the challenge message is required to specify a nonce used to generate a secure hash of the username and password. This value should be randomly generated using a cryptographically strong algorithm. A nonce should only be used once to prevent replay attacks. If the server doesn't support the version specified by the client in the hello message, then it should send the close message with the incompatibleVersion error code. The close message returned should include the version header field, which tells the client which version the server does support. The client may then choose to retry the handshake if supports the server's version. If the server is too busy to allocate a new session, then it should send back a close with the busy error code. A server can by-pass authentication completely by directly sending back a welcome message.","title":"Challenge"},{"location":"networking/dasp/#authenticate","text":"Once the client receives the challenge message, it has enough information to generate the authenticate message. Clients never pass user credentials directly to the server over the network. Instead the client sends the server a digest of the username, password, and nonce. The algorithm to compute the digest is defined by the digestAlgorithm field defined in the challenge message (or if unspecified then SHA-1 is assumed). The following function is used to compute the digest: credentials = digestAlgorithm(username + \":\" + password) digest = digestAlgorithm(credentials + nonce) First we hash the UTF-8 encoded credentials string, which is the username and password separated by a single \":\" colon character. We call this hash the credentials. We then run the hash function against the credentials and the nonce, which produces a one-time use digest. This mechanism permits DASP enabled devices to avoid storing a password in plain text by storing the username and only the credentials hash. However a device could store the username and password directly and compute the credentials hash as needed. Once the client computes the digest, it sends the server the authenticate message. The authenticate message uses the sessionId specified in the challenge's remoteId header. The seqNum should be the same as that used by the hello message. The following header fields apply: username (required): the UTF-8 encoded string identifier of the user to authenticate. digest (required): the message digest hash computed from the algorithm described above. If using SHA-1, this will be list of 20 bytes (160-bit digest). If the client does not support the digest algorithm specified by the server's challenge message, then the client should immediately send the server a close message with the digestNotSupported error code.","title":"Authenticate"},{"location":"networking/dasp/#welcome","text":"Once the server receives the authenticate message, it validates the username and digest against its user database. If the authentication is successful, then the server responds to the client with the welcome message type. The sessionId of the welcome is the remoteId specified by the client in its hello. The seqNum should be the same as that used by the server's challenge message. The following fields apply: idealMax (optional): the ideal maximum of bytes per message from the server perspective - see Tuning. If not specified 512 is assumed. absMax (optional): the absolute maximum of bytes per message from the server perspective - see Tuning. If not specified 512 is assumed. receiveMax (optional): the absolute maximum size of the server's receiving windowing (number of messages). If not specified, then a window size of 31 messages is assumed. receiveTimeout (optional): the number of seconds that may elapse without receiving a message before the session is timed out from server perspective; if not specified then a default of 30 seconds is assumed. remoteId : if we are skipping the challenge, then the server's sessionId must be returned in the welcome, otherwise this header must be omitted. If authentication fails, then the server sends the client back a close message with the notAuthenticated error code.","title":"Welcome"},{"location":"networking/dasp/#tuning","text":"The absMax and idealMax header fields are used to negotiate message sizes between the client and server. The absMax is the absolute maximum number of bytes that a message may contain including the DASP headers, but not the transport headers (such as the UDP headers themselves). Typically this value maps to the amount of buffer space a device can dedicate to processing DASP messages. For example a device that can only allocate 256 bytes to buffering an DASP message will not be able to handle larger messages. The idealMax header field specifies the ideal maximum number of bytes a message should contain including the DASP headers (not including the transport headers). Often DASP is running over a network like 6LoWPAN that can support UDP packets larger than the MTU of a 802.15.4 frame. However if implementing a protocol like file transfer, it is desirable to chunk the stream such that messages fit within individual 802.15.4 frames without additional fragmentation overhead. The idealMax header provides for this optimization. Both absMax and idealMax negotiation works the same way. The client specifies its absMax and idealMax fields in its hello message. If either of the header fields are omitted, then they are implied to be 512 bytes. The server has its own absMax and idealMax, which it returns in the welcome message (or else they default to 512). The actual absMax and idealMax used for the session is the minimum between the client and server. For example: client: absMax=512, idealMax=256 server: absMax=1024, idealMax=64 session: absMax=512, idealMax=64","title":"Tuning"},{"location":"networking/dasp/#error-handling","text":"Because we assume DASP runs over an unreliable transport, implementations must be prepared to handle lost, delayed, or unordered messages during the handshake process. The following are specific conditions that may arise, and the recommended action for each: The client sends the hello, but does not receive the challenge. In this case, either the hello or the challenge may have been lost. In either case, a new hello request should be sent. If after three attempts fail, then the client should assume communication with the server is not available The server sends the challenge, but doesn't receive an authenticate message. In this case, either the challenge or the authenticate message might have been dropped. In either case the server should never attempt resending the challenge, but rather should time out the session if no authenticate is received. During the handshake process, the server should use a shortened time out period (compared to normal session communication). The client sends the authenticate, but does not receive the welcome. In this case, either the authenticate or the welcome message was lost. The client should resend the authenticate message two more times, before giving up. Servers should gracefully handle receiving multiple authenticate messages for the same session.","title":"Error Handling"},{"location":"networking/dasp/#messaging","text":"Once the session has successfully been established, either end point may initiate application level messaging via the datagram message type. When an endpoint receives a datagram message it performs the following steps: Matches the sessionId to a valid session. If not a valid session, the request is ignored. Checks that the remote address matches the one used to setup the session. If not the request is ignored. Checks that the seqNum is within the valid receiving sliding window, otherwise it is ignored. Checks that the datagram hasn't already been processed, otherwise it is ignored. Each endpoint must keep track of messages it has already processed within its receiving window. Updates its receiving window Sends the datagram to the application layer for processing. Receiver eventually piggybacks an ack on an outgoing message","title":"Messaging"},{"location":"networking/dasp/#acks","text":"In order to provide reliability, datagrams have to be acknowledged. If there are outgoing messages, then the ack header should be piggybacked to avoid extra messaging. Otherwise a keepAlive message with an ack header is sent back to the remote endpoint to acknowledge the datagrams received so far. The ack header specifies the most recent seqNum successfully received. When an ack header is received, an endpoint can assume that all seqNums <= ackNum have been successfully received and that ackNum + 1 has not been received yet by the remote endpoint. If an endpoint has received messages with gaps in the sequence numbering, it can use the ackMore header to enumerate the seqNums it has received. This allows us to avoid resending those messages just because we've had partial failures. The ackMore is encoded as a list of bits that indicate messages received (bit is set), and messages not received (bit is zero). The least significant bit corresponds to the seqNum in the ack header, and the most significant bit n corresponds to ackNum + n . The ackMore header must always be accompanied by the ack header. By definition the least significant bit of the bitmask must always be one since it corresponds to ackNum itself. Some examples: ack=10 ackMore=15 -> 0x21 ack=10 ackMore=12, 13 -> 0x0d ack=10 ackMore=15, 18, 19 -> 0x03 0x21","title":"Acks"},{"location":"networking/dasp/#retries","text":"Note The following behavior is not currently implemented in the opensource Sedona Framework implementations of DASP. Once an endpoint has sent a datagram message, it should wait for a period of time called the sendRetry (default = 1 sec) (see Flow Control for details). If no acknowledgement has been received for the datagram's seqNum, then one of two things has happened: the original datagram was lost or the acknowledgement was lost. The endpoint should resend the datagram message with the original sequence number, then wait again for sendRetry period. This process should be repeated until the datagram has been sent the number of times specified by the maxSend (default = 3) parameter. If the maxSend attempt fails, then the session should be timed out and the close message sent to the remote endpoint with the timeout error code.","title":"Retries"},{"location":"networking/dasp/#sliding-window","text":"DASP supports full duplex messaging - either side may initiate application messages, which are identified with a 16-bit sequence number. An endpoint can have multiple outstanding messages that have not been acknowledged. The sequence of unacknowledged messages sent is called the sending window . Each endpoint also maintains a receiving window , which is the sequence of messages it is prepared to receive. Any messages outside of the receiving window are ignored. The receiveMax header is used to communicate the maximum size of receiving window so that the remote endpoint can tune its sending window. The receiveMax header of the client is specified in its hello message, and the receiveMax of the server is specified in the welcome message. Once receiveMax is established during the handshake, it cannot be changed. The receiveMax header specifies the maximum size of the sliding window, since any messages outside of that window will be ignored. An endpoint should never use a sending window size greater than the remote endpoint's receiving window. However, often the sending window is smaller than the remote's receive window. The sending window is grown and shrunk during the lifetime of the session to allow dynamic optimization of the session's throughput. Tuning the size of the sending window is the basis for flow control and congestion control. Since seqNum is stored in an unsigned 16-bit integer, implementations must handle rollover. The seqNum 65535 is followed by the sequence number 0. For example given lower bound of 65530 and a window size of 10, then the window wraps from 65530 to 3 inclusively. Sequence numbers and the sliding window are only used for datagram messages. The client's handshake hello and authenticate messages define the client's starting sequence number, which is the seqNum of the client's first datagram. The server's handshake challenge and welcome define the sequence number of the server's first datagram. The close and keepAlive messages should always use a sequence number of 0xffff.","title":"Sliding Window"},{"location":"networking/dasp/#flow-control","text":"A primary goal for DASP is to provide communication for traffic spanning networks and devices of varying capabilities. For example a common use case is a PC on an Ethernet network communicating to a low cost device on a 6LoWPAN network. The ability to tune a session's communication rates based on the capability of the endpoints is called flow control . It is also common for traffic on networks to vary over time during the course of a session. Tuning the session to handle varying network loads is called congestion control . For practical purposes, flow control and congestion control are handled using the same mechanisms - so we will use the term flow control generically. Flow control in DASP is always managed on the sending side by dynamically tuning the size of the sending window and the sendRetry time. These values are tuned based on analysis of the session's recent past performance.","title":"Flow Control"},{"location":"networking/dasp/#keep-alive-and-termination","text":"A session is terminated via one of the following conditions: One endpoint sends the close message No packets are received after a timeout period","title":"Keep Alive and Termination"},{"location":"networking/dasp/#close","text":"If possible, sessions should be gracefully shutdown using the close message type. If the failure is in the DASP layer (as opposed to the application layer), then the errorCode header should be specified. If an endpoint receives either the close or error message types, then the session is immediately terminated and the sessionId invalidated. No acknowledgement is sent on close messages. It is recommended that close messages be sent twice - endpoints should automatically ignore duplicate close/errors because the sessionId will be invalid. Errors during the handshake should only be sent once. However, since there is no acknowledgment, we can never guarantee that both endpoints are aware of the session termination (in which case we must rely on timeouts).","title":"Close"},{"location":"networking/dasp/#timeout","text":"We can never assume that sessions are closed gracefully, because real-world applications and networks can't be trusted. If an endpoint has not received any messages after a period of time, then the session is timed out. A timed out session is terminated and the sessionId is invalidated. The endpoint should send the remote endpoint an close message with the timeout error code - this error should only be sent once since there is a good chance the remote endpoint is no longer available. Each endpoint specifies its configured timeout via the receiveTimeout header. The client specifies receiveTimeout in its hello message, and the server in the welcome message. If the receiveTimeout is omitted during the handshake, then 30 sec should be assumed. Once the session is established the overall timeout of the session is the maximum timeout between the client and the server. Both endpoints must then use the longer timeout. Because the timeout must be negotiated between the endpoints, care should be taken with using very long time outs. The longer timeout is used because we assume the less capable endpoint's network or device drives overall reliability and speed. However longer timeouts also mean longer periods where the critical memory resources of session state are tied up waiting for a session timeout.","title":"Timeout"},{"location":"networking/dasp/#keepalives","text":"The keepAlive message type is used to prevent session timeouts and carry acknowledgments when there are no outgoing application messages. If there are no outgoing datagram messages to piggyback an ack header, then an endpoint should sent a keepAlive to acknowledge received messages. Implementations can send these acknowledgements immediately or may use a small delay called the ackDelay . The ackDelay provides a period of time to coalesce multiple acknowledgements and wait for an outgoing datagram message to be generated. Even if all received messages have been acknowledged, then an endpoint still needs to send keepAlive messages to ensure that the remote endpoint doesn't timeout the session. In the absence of other messaging, an endpoint should send keepAlives three times as fast as the timeout period. For example if the negotiated timeout is 30 sec, then keepAlives should be sent every 10 sec. Keep alives should only be used when no application datagrams are being transmitted. KeepAlives are themselves never part of the sliding window. The seqNum of a keepAlives should be 0xffff. When a keep alive is received, it is never checked against the receiving window and is never acknowledged. An endpoint that sends a keepAlive should never attempt to retry the keepAlive, since no acknowledgement is expected.","title":"keepAlives"},{"location":"networking/dasp/#device-discovery","text":"DASP supports device discovery with the following sequence: The client sends a discover request to all listening Sedona servers Any server that receives the discover request opens a Sox session The server then sends a discover response containing its platform ID The server closes the Sox session immediately Each discover response the client receives is added to a list of discovered nodes.","title":"Device Discovery"},{"location":"networking/dasp/#discover","text":"A discover message may be sent by a client or a server. The client sends a discover message with no header fields. The server's response message is identical except that it adds a single header field containing its platform ID. platformId (response only): a string containing the platform ID of the responding device. How the discovered devices are collected and processed is not specified.","title":"Discover"},{"location":"networking/discover/","text":"Device Discovery \u00b6 Introduction \u00b6 Sedona Framework (starting with version 1.2) provides a mechanism for performing Sedona device discovery using a special DASP message directed to a multicast address. Any Sedona device on the network that has joined the multicast group then responds to the message with its platform ID and IP address. Basic Operation \u00b6 Join : Each Sedona device that supports DASP device discovery joins a specific IP multicast group at startup. Discover : The Sox client kicks off a device discovery process by sending a DASP DISCOVER request to the multicast group address. Respond : When a device receives the DISCOVER message, it sends a response containing its address and platform ID. Process : The client processes any DISCOVER responses it receives, and maintains a cached list of devices that responded. Porting Tips \u00b6 When porting Sedona to a new platform, the native method inet::UdpSocket.join() must be implemented with the target OS function calls to join the socket to a specified multicast group address. UdpSocket.join() will be called by the Sox service when it opens the socket. The multicast address to use is defined in the inet::UdpSocket native code. Do not change the multicast group address definition in the inet natives unless you also change the corresponding definition in DaspConst.java Whatever address you select, it must be the same in both locations. On the client side, the discover functionality is in sedona.dasp.DaspSocket . Invoking DaspSocket.discover() begins a DASP discovery operation. This clears the current cached list of discovered devices and sends the DASP DISCOVER message to the multicast group address. Call DaspSocket.getDiscovered() to access the list of discovered devices; it returns an array of DiscoveredNode objects. Limitations \u00b6 DASP device discovery cannot be implemented on platforms that do not support multicast addressing on either IPv4 or IPv6. By default the open source code uses IPv4 multicast addressing. (IPv6 addressing is not officially supported for Sedona 1.2.) The specific multicast group address used by this feature is currently not configurable at runtime. It is hardcoded for the Sedona VM within the inet natives, and for the Java side as a DASP constant. To use a different address, it must be changed in both source locations and both the SVM and the sedona.jar module must be rebuilt and deployed. Caution : For DASP Discovery to work, the IP settings for the host's network interface(s) must be correct, including netmask and gateway address. Also, some networks may filter multicast messages, or prohibit them altogether.","title":"Device Discovery"},{"location":"networking/discover/#device-discovery","text":"","title":"Device Discovery"},{"location":"networking/discover/#introduction","text":"Sedona Framework (starting with version 1.2) provides a mechanism for performing Sedona device discovery using a special DASP message directed to a multicast address. Any Sedona device on the network that has joined the multicast group then responds to the message with its platform ID and IP address.","title":"Introduction"},{"location":"networking/discover/#basic-operation","text":"Join : Each Sedona device that supports DASP device discovery joins a specific IP multicast group at startup. Discover : The Sox client kicks off a device discovery process by sending a DASP DISCOVER request to the multicast group address. Respond : When a device receives the DISCOVER message, it sends a response containing its address and platform ID. Process : The client processes any DISCOVER responses it receives, and maintains a cached list of devices that responded.","title":"Basic Operation"},{"location":"networking/discover/#porting-tips","text":"When porting Sedona to a new platform, the native method inet::UdpSocket.join() must be implemented with the target OS function calls to join the socket to a specified multicast group address. UdpSocket.join() will be called by the Sox service when it opens the socket. The multicast address to use is defined in the inet::UdpSocket native code. Do not change the multicast group address definition in the inet natives unless you also change the corresponding definition in DaspConst.java Whatever address you select, it must be the same in both locations. On the client side, the discover functionality is in sedona.dasp.DaspSocket . Invoking DaspSocket.discover() begins a DASP discovery operation. This clears the current cached list of discovered devices and sends the DASP DISCOVER message to the multicast group address. Call DaspSocket.getDiscovered() to access the list of discovered devices; it returns an array of DiscoveredNode objects.","title":"Porting Tips"},{"location":"networking/discover/#limitations","text":"DASP device discovery cannot be implemented on platforms that do not support multicast addressing on either IPv4 or IPv6. By default the open source code uses IPv4 multicast addressing. (IPv6 addressing is not officially supported for Sedona 1.2.) The specific multicast group address used by this feature is currently not configurable at runtime. It is hardcoded for the Sedona VM within the inet natives, and for the Java side as a DASP constant. To use a different address, it must be changed in both source locations and both the SVM and the sedona.jar module must be rebuilt and deployed. Caution : For DASP Discovery to work, the IP settings for the host's network interface(s) must be correct, including netmask and gateway address. Also, some networks may filter multicast messages, or prohibit them altogether.","title":"Limitations"},{"location":"networking/networking/","text":"Networking \u00b6 Overview \u00b6 The Sedona Framework is designed from the ground up to make building smart, networked devices easy. The key networking concepts: Networking APIs: the inet and serial APIs Driver API: framework building your own drivers Sox/Dasp Protocols: the standard protocol stack for provisioning Sedona Framework-enabled devices. APIs \u00b6 The lowest levels of the networking stack are the inet and serial kits. The inet kit specifies the set of APIs used to work with TCP and UDP sockets. These APIs are all designed to be non-blocking to work within the Sedona Framework's single threaded main loop. In order to use the inet API you will need to ensure that your target platform has implemented all the inet native methods. The open source distribution provides an implementation that uses the WinSock and Berkeley socket APIs. The serial kit specifies the set of APIs used to perform serial port communications. The main goal for the serial APIs is to insulate application code from the operating system or hardware's serial port interface. Drivers should use the serial API whenever possible to ensure portability across devices. In order to use the serial API you will need to ensure a port of the native methods is available for your platform. The open source distribution provides a Win32 implementation of the serial natives. Driver Framework \u00b6 You can build your own device/IO drivers for the Sedona Framework. Typically you will use the inet or serial APIs to interface with the network. The driver kit provides a mini-framework used to standardize how custom drivers are built for the Sedona Framework platform. Drivers are structured using the component tree: DeviceNetwork : models the driver's network connectivity and is the container for the devices. Device : is the Sedona Framework representation for an external device. Point : is the Sedona Framework representation for a data point in the external device. Sox Protocol \u00b6 The Sox protocol is the standard protocol used to communicate with Sedona Framework-enabled devices. Sox provides the following services: Version Info : ability to query current version of software. Polling : ability to poll for current values. COV : ability to subscribe to change of value events. RPC : ability to invoke component actions remotely. Programming : ability to add/remove/rename/link/unlink components. File Transfer : ability to get or put arbitrary streams of bytes. Provisioning : ability to backup/upgrade the SVM, kits, or app thru file transfers. The Sox protocol is designed to efficiently enable \"live programming\" of the component model over the network. The Sox protocol itself is run over the Dasp protocol, which provides session based security and reliability over UDP. See Sox and Dasp to learn more about these protocols.","title":"Networking"},{"location":"networking/networking/#networking","text":"","title":"Networking"},{"location":"networking/networking/#overview","text":"The Sedona Framework is designed from the ground up to make building smart, networked devices easy. The key networking concepts: Networking APIs: the inet and serial APIs Driver API: framework building your own drivers Sox/Dasp Protocols: the standard protocol stack for provisioning Sedona Framework-enabled devices.","title":"Overview"},{"location":"networking/networking/#apis","text":"The lowest levels of the networking stack are the inet and serial kits. The inet kit specifies the set of APIs used to work with TCP and UDP sockets. These APIs are all designed to be non-blocking to work within the Sedona Framework's single threaded main loop. In order to use the inet API you will need to ensure that your target platform has implemented all the inet native methods. The open source distribution provides an implementation that uses the WinSock and Berkeley socket APIs. The serial kit specifies the set of APIs used to perform serial port communications. The main goal for the serial APIs is to insulate application code from the operating system or hardware's serial port interface. Drivers should use the serial API whenever possible to ensure portability across devices. In order to use the serial API you will need to ensure a port of the native methods is available for your platform. The open source distribution provides a Win32 implementation of the serial natives.","title":"APIs"},{"location":"networking/networking/#driver-framework","text":"You can build your own device/IO drivers for the Sedona Framework. Typically you will use the inet or serial APIs to interface with the network. The driver kit provides a mini-framework used to standardize how custom drivers are built for the Sedona Framework platform. Drivers are structured using the component tree: DeviceNetwork : models the driver's network connectivity and is the container for the devices. Device : is the Sedona Framework representation for an external device. Point : is the Sedona Framework representation for a data point in the external device.","title":"Driver Framework"},{"location":"networking/networking/#sox-protocol","text":"The Sox protocol is the standard protocol used to communicate with Sedona Framework-enabled devices. Sox provides the following services: Version Info : ability to query current version of software. Polling : ability to poll for current values. COV : ability to subscribe to change of value events. RPC : ability to invoke component actions remotely. Programming : ability to add/remove/rename/link/unlink components. File Transfer : ability to get or put arbitrary streams of bytes. Provisioning : ability to backup/upgrade the SVM, kits, or app thru file transfers. The Sox protocol is designed to efficiently enable \"live programming\" of the component model over the network. The Sox protocol itself is run over the Dasp protocol, which provides session based security and reliability over UDP. See Sox and Dasp to learn more about these protocols.","title":"Sox Protocol"},{"location":"networking/sox/","text":"Sox \u00b6 Overview \u00b6 Sox is the standard protocol used to communicate with Sedona Framework-enabled devices. Sox provides the following services: Version Info : ability to query current version of software. Polling : ability to poll for current values. COV : ability to subscribe to change of value events. RPC : ability to invoke component actions remotely. Programming : ability to add/remove/rename/link/unlink components. File Transfer : ability to get or put arbitrary streams of bytes. Provisioning : ability to backup/upgrade the SVM, kits, or app via file transfers. Dasp \u00b6 Sox is designed to be run over UDP via the Dasp protocol. Dasp handles a lot of complexity for networking: Dasp manages authenticated sessions, so that we can associate incoming Sox messages against a user account. Dasp manages reliability. When Sox sends a message, it doesn't have to worry about retries - Dasp ensures the message gets delivered. Dasp manages flow control. Communication such as a file transfer that creates bursts of packets is automatically throttled to the network's capacity by Dasp. Dasp is full duplex - once a session is established, either side may initiate a message send. Dasp also defines some restrictions that Sox must take into consideration: Dasp is packet based, so Sox must design messages to fit within the maximum packet size (typically around 500 bytes). Dasp is reliable, but unordered, so Sox cannot assume that messages are processed in order. Design \u00b6 Sox has a very basic design. All sox messages are formatted with a standard two byte header: u1 cmd u1 replyNum u1[] payload Every request is assigned a command identifier, which is a lower case ASCII letter. For example 'r' indicates a read property request. Responses to a request use a capitalized ASCII letter, for example a read property response has a cmd identifier of 'R' . Every request is tagged with a one byte replyNum. The replyNum is used to associate requests with their responses. Because the replyNum is only byte, there can only 255 outstanding requests (although it is quite likely Dasp will restrict flow control to a much smaller number of requests). Each specific command has a predefined payload structure . Sedona Framework APIs \u00b6 There is a server side Sox implementation written in 100% Sedona code and deployed in the sox kit. The sox kit includes both the Sox and Dasp protocol stack and depends on inet kit for the IP stack. You must have a port of the inet kit available for your platform in order to run Sox. Most often you will put an instance of the SoxService in your application. The SoxService opens a configured UDP port (default is 1876). The SoxService manages authenticating incoming sessions, handling all the sox commands, and ensuring that sessions are timed out and cleaned up properly. Java APIs \u00b6 The open source distribution also includes a full Java implementation of the Dasp/Sox protocol stacks. These stacks include both a client and service side implementation (although typically you will only use the client side). The Java APIs are designed to \"Sedona Framework enable\" your tools and supervisor applications. The sedona.dasp package implements the lower level Dasp protocol stack. This code is cleanly separated from Sox and may be used stand alone if desired. The sedona.sox package implements the Sox protocol stack and provides a light weight Java model for Sedona Framework components. The SoxClient class provides a Sox aware wrapper around DaspSession for sending/receiving the set of sox commands. Many of the commands use SoxComponent as the Java side representation of Sedona Framework components. The SoxClient class is also used to initiate get/put file transfers. You will use these APIs if implementing your own provisioning strategy. Messages \u00b6 The following Sox message commands are defined: Id Command Description a add Add a new component to the application b fileRename Rename or move a file c readComp Read a component in the application d delete Delete an component and its children from the application e event COV event for a subscribed component f fileOpen Begin a get or put file transfer operation i invoke Invoke a component action k fileChunk Receive or send a chunk during a file transfer l link Add or delete a link n rename Rename a component o reorder Reorder a component's children q query Query installed services r readProp Read a single property from a component s subscribe Subscribe to a component for COV events u unsubscribe Unsubscribe from a component for COV events v version Query for the kits installed w write Write the value of a single component property y versionMore Query for additional version meta-data z fileClose Close a file transfer operation ! error Response id for a command that could not be processed add \u00b6 The add command is used to add a new component to the application. The configProps must match the schema definition for the type. req { u1 'a' u1 replyNum u2 parentId u1 kitId u1 typeId str name val[] configProps } res { u1 'A' u1 replyNum u2 compId } fileRename \u00b6 Rename a file from one path to another path. Also see the sys::File API. req { u1 'b' u1 replyNum str from str to } res { u1 'B' u1 replyNum } readComp \u00b6 Read a given component's state. Component state is broken up into four sections: tree: the component's id, name, parent, and children config: all the persistent properties (marked with @config facet) runtime: all the transient properties (not marked with @config facet) links: all the links to and from the component req { u1 'c' u1 replyNum u2 componentId u1 what: 't', 'c', 'r', 'l' (tree, config, runtime, links) } res { u1 'C' u1 replyNum u2 componentId compTree | compProps | compLinks } compTree { u1 't' u1 kitId u1 typeId str name u2 parent u1 permissions u1 numKids u2[numKids] kidIds } compProps { u1 'c' or 'r' for config or runtime, 'C'/'R' if operator only val[] propValues } compLinks { u1 'l' Link[] links u2 0xffff end marker } delete \u00b6 Delete a component from the application. This command automatically deletes any child components as well as any links to or from the deleted components. req { u1 'd' u1 replyNum u2 compId } res { u1 'D' u1 replyNum } event \u00b6 The event command packages up a COV event and is pushed asynchronously from the server to client periodically for subscribed components. It uses the same component state model as readComp . Events don't have responses, but rather rely on Dasp's acknowledgements to guarantee delivery. req { u1 'e' u1 replyNum u2 componentId compTree | compProps | compLinks } fileOpen \u00b6 The fileOpen command is used to initiate a get or put file transfer. The chunk size is negotiated such that chunk messages fit within the underlying transport's packet size (for example if running over 6LoWPAN we want to fit each chunk into a single 802.15.4 packet). On a put, the fileSize is the number of bytes that will be written. On a get, the fileSize is the maximum number of bytes to read. The actual number of bytes read might be less if there are not fileSize bytes available (taking into account the size of the actual file, and the potential offset). req { u1 'f' u1 replyNum str method (\"g\" for get, \"p\" for put) str uri u4 fileSize u2 suggestedChunkSize (suggested by client) headers[] { str name str value } u1 end of headers '\\0' } res { u1 'F' u1 replyNum u4 fileSize u2 actualChunkSize headers[] { str name str value } u1 end of headers '\\0' } Supported Headers \u00b6 Name Value Method Default Description offset int get, put 0 Byte offset to use when reading/writing the uri mode w, m put w File mode to use on a put. 'w' opens the file and truncates it if the file already exists. 'm' opens the file for random access invoke \u00b6 Invoke an action on a component. This command can be used as an RPC mechanism. Note that the action is executed synchronously; the Sox server blocks until the action completes and returns. req { u1 'i' u1 replyNum u2 componentId u1 slotId val argument } res { u1 'I' u1 replyNum } fileChunk \u00b6 The fileChunk command transfers a single chunk within a file transfer operation. The same message structure is used for both get and put operations. Because Sox is run over Dasp, it is quite possible for chunks to be received out of order. req { u1 'k' u1 replyNum (ignored) u2 chunkNum u2 chunkSize u1[chunkSize] chunk } link \u00b6 The link command is used to add or delete a link between two Component slots in the application. req { u1 'l' u1 replyNum u1 'a' | 'd' (add/delete) u2 fromCompId u1 fromSlotId u2 toCompId u1 toSlotId } res { u1 'L' u1 replyNum } rename \u00b6 Rename is used to change a Component's name. req { u1 'n' u1 replyNum u2 compId str newName } res { u1 'N' u1 replyNum } reorder \u00b6 Reorder a component's child components. req { u1 'o' u1 replyNum u2 compId u1 numChildren u2[] childrenIds } res { u1 'O' u1 replyNum } readProp \u00b6 Read a single property value from a component. req { u1 'r' u1 replyNum u2 compId u1 propId } res { u1 'R' u1 replyNum u1 any code var propValue } subscribe \u00b6 The subscribe command allows you to subscribe to multiple components by registering for a set of change events . The subscribe command will return the number of components that were actually subscribed. This number may be less than the number of components requested if the user does not have permissions on a component, or if the component does not exist anymore You can also subscribe to all tree events (instead of subscribing to individual component tree events). In this case, the response contains no payload. req { u1 's' u1 replyNum u1 whatMask: tree=0x1 config=0x2 rt=0x4 links=0x8 0xff all tree u1 num: u2[] compIds: The ids of all the components to subscribe to } res { u1 'S' u1 replyNum u1 numSubscribed: The actual number of components that were subscribed } unsubscribe \u00b6 Unregister a subscription . The client will stop receiving change events for the set of components specified. req { u1 'u' u1 replyNum u1 whatMask: tree=0x1 config=0x2 rt=0x4 links=0x8 0xff all tree u1 num u2[] compIds } res { u1 'U' u1 replyNum } version \u00b6 Get the list of installed kits and their checksums, which defines the schema . versionReq { u1 'v' u1 replyNum } versionRes { u1 'V' u1 replyNum u1 kitCount kits[kitCount] { str name i4 checksum } } write \u00b6 Set a component property value to a specific value. req { u1 'w' u1 replyNum u2 componentId u1 slotId val value } res { u1 'W' u1 replyNum } versionMore \u00b6 Get extra version information, which includes the version of the installed kits plus platform specific name/value pairs. Name/Value pairs \u00b6 Name Value Notes soxVer Sox protocol version Introduced in build 1.0.45 (see discussion below) All builds of the Sedona Framework prior to 1.0.45 will return null for the sox protocol version. Starting in build 1.0.45 the sox protocol was changed to allow batch subscription , to components. If the sox protocol supports batch subscription, then it will return a soxVer of 1.1 (or higher). req { u1 'y' u1 replyNum } res { u1 'Y' u1 replyNum str platformId u1 scodeFlags kitVersions[kitCount] { str version } u1 pairs pairs { str key str val } } query \u00b6 Perform a query for a set of components. Currently you can only query for a service type using queryType of 's'. But the message is designed to be enhanced thru additional queryTypes. req { u1 'q' u1 replyNum u1 queryType u1[] queryReq } queryType 's': query service req-service { u1 kitId u1 typeId } res { u1 'Q' u1 replyNum u1[] queryRes } queryType 's': query service res-service { u2[num] compIds u2 0xffff end marker } fileClose \u00b6 Terminates a file transfer operation. req { u1 'z' u1 replyNum } res { u1 'Z' u1 replyNum } error \u00b6 The error response may sent back as a response to any request. It indicates to the client that the request could not be processed. The cause of failure is returned as a short string in the message. res { u1 '!' u1 replyNum str cause }","title":"Sox"},{"location":"networking/sox/#sox","text":"","title":"Sox"},{"location":"networking/sox/#overview","text":"Sox is the standard protocol used to communicate with Sedona Framework-enabled devices. Sox provides the following services: Version Info : ability to query current version of software. Polling : ability to poll for current values. COV : ability to subscribe to change of value events. RPC : ability to invoke component actions remotely. Programming : ability to add/remove/rename/link/unlink components. File Transfer : ability to get or put arbitrary streams of bytes. Provisioning : ability to backup/upgrade the SVM, kits, or app via file transfers.","title":"Overview"},{"location":"networking/sox/#dasp","text":"Sox is designed to be run over UDP via the Dasp protocol. Dasp handles a lot of complexity for networking: Dasp manages authenticated sessions, so that we can associate incoming Sox messages against a user account. Dasp manages reliability. When Sox sends a message, it doesn't have to worry about retries - Dasp ensures the message gets delivered. Dasp manages flow control. Communication such as a file transfer that creates bursts of packets is automatically throttled to the network's capacity by Dasp. Dasp is full duplex - once a session is established, either side may initiate a message send. Dasp also defines some restrictions that Sox must take into consideration: Dasp is packet based, so Sox must design messages to fit within the maximum packet size (typically around 500 bytes). Dasp is reliable, but unordered, so Sox cannot assume that messages are processed in order.","title":"Dasp"},{"location":"networking/sox/#design","text":"Sox has a very basic design. All sox messages are formatted with a standard two byte header: u1 cmd u1 replyNum u1[] payload Every request is assigned a command identifier, which is a lower case ASCII letter. For example 'r' indicates a read property request. Responses to a request use a capitalized ASCII letter, for example a read property response has a cmd identifier of 'R' . Every request is tagged with a one byte replyNum. The replyNum is used to associate requests with their responses. Because the replyNum is only byte, there can only 255 outstanding requests (although it is quite likely Dasp will restrict flow control to a much smaller number of requests). Each specific command has a predefined payload structure .","title":"Design"},{"location":"networking/sox/#sedona-framework-apis","text":"There is a server side Sox implementation written in 100% Sedona code and deployed in the sox kit. The sox kit includes both the Sox and Dasp protocol stack and depends on inet kit for the IP stack. You must have a port of the inet kit available for your platform in order to run Sox. Most often you will put an instance of the SoxService in your application. The SoxService opens a configured UDP port (default is 1876). The SoxService manages authenticating incoming sessions, handling all the sox commands, and ensuring that sessions are timed out and cleaned up properly.","title":"Sedona Framework APIs"},{"location":"networking/sox/#java-apis","text":"The open source distribution also includes a full Java implementation of the Dasp/Sox protocol stacks. These stacks include both a client and service side implementation (although typically you will only use the client side). The Java APIs are designed to \"Sedona Framework enable\" your tools and supervisor applications. The sedona.dasp package implements the lower level Dasp protocol stack. This code is cleanly separated from Sox and may be used stand alone if desired. The sedona.sox package implements the Sox protocol stack and provides a light weight Java model for Sedona Framework components. The SoxClient class provides a Sox aware wrapper around DaspSession for sending/receiving the set of sox commands. Many of the commands use SoxComponent as the Java side representation of Sedona Framework components. The SoxClient class is also used to initiate get/put file transfers. You will use these APIs if implementing your own provisioning strategy.","title":"Java APIs"},{"location":"networking/sox/#messages","text":"The following Sox message commands are defined: Id Command Description a add Add a new component to the application b fileRename Rename or move a file c readComp Read a component in the application d delete Delete an component and its children from the application e event COV event for a subscribed component f fileOpen Begin a get or put file transfer operation i invoke Invoke a component action k fileChunk Receive or send a chunk during a file transfer l link Add or delete a link n rename Rename a component o reorder Reorder a component's children q query Query installed services r readProp Read a single property from a component s subscribe Subscribe to a component for COV events u unsubscribe Unsubscribe from a component for COV events v version Query for the kits installed w write Write the value of a single component property y versionMore Query for additional version meta-data z fileClose Close a file transfer operation ! error Response id for a command that could not be processed","title":"Messages"},{"location":"networking/sox/#add","text":"The add command is used to add a new component to the application. The configProps must match the schema definition for the type. req { u1 'a' u1 replyNum u2 parentId u1 kitId u1 typeId str name val[] configProps } res { u1 'A' u1 replyNum u2 compId }","title":"add"},{"location":"networking/sox/#filerename","text":"Rename a file from one path to another path. Also see the sys::File API. req { u1 'b' u1 replyNum str from str to } res { u1 'B' u1 replyNum }","title":"fileRename"},{"location":"networking/sox/#readcomp","text":"Read a given component's state. Component state is broken up into four sections: tree: the component's id, name, parent, and children config: all the persistent properties (marked with @config facet) runtime: all the transient properties (not marked with @config facet) links: all the links to and from the component req { u1 'c' u1 replyNum u2 componentId u1 what: 't', 'c', 'r', 'l' (tree, config, runtime, links) } res { u1 'C' u1 replyNum u2 componentId compTree | compProps | compLinks } compTree { u1 't' u1 kitId u1 typeId str name u2 parent u1 permissions u1 numKids u2[numKids] kidIds } compProps { u1 'c' or 'r' for config or runtime, 'C'/'R' if operator only val[] propValues } compLinks { u1 'l' Link[] links u2 0xffff end marker }","title":"readComp"},{"location":"networking/sox/#delete","text":"Delete a component from the application. This command automatically deletes any child components as well as any links to or from the deleted components. req { u1 'd' u1 replyNum u2 compId } res { u1 'D' u1 replyNum }","title":"delete"},{"location":"networking/sox/#event","text":"The event command packages up a COV event and is pushed asynchronously from the server to client periodically for subscribed components. It uses the same component state model as readComp . Events don't have responses, but rather rely on Dasp's acknowledgements to guarantee delivery. req { u1 'e' u1 replyNum u2 componentId compTree | compProps | compLinks }","title":"event"},{"location":"networking/sox/#fileopen","text":"The fileOpen command is used to initiate a get or put file transfer. The chunk size is negotiated such that chunk messages fit within the underlying transport's packet size (for example if running over 6LoWPAN we want to fit each chunk into a single 802.15.4 packet). On a put, the fileSize is the number of bytes that will be written. On a get, the fileSize is the maximum number of bytes to read. The actual number of bytes read might be less if there are not fileSize bytes available (taking into account the size of the actual file, and the potential offset). req { u1 'f' u1 replyNum str method (\"g\" for get, \"p\" for put) str uri u4 fileSize u2 suggestedChunkSize (suggested by client) headers[] { str name str value } u1 end of headers '\\0' } res { u1 'F' u1 replyNum u4 fileSize u2 actualChunkSize headers[] { str name str value } u1 end of headers '\\0' }","title":"fileOpen"},{"location":"networking/sox/#supported-headers","text":"Name Value Method Default Description offset int get, put 0 Byte offset to use when reading/writing the uri mode w, m put w File mode to use on a put. 'w' opens the file and truncates it if the file already exists. 'm' opens the file for random access","title":"Supported Headers"},{"location":"networking/sox/#invoke","text":"Invoke an action on a component. This command can be used as an RPC mechanism. Note that the action is executed synchronously; the Sox server blocks until the action completes and returns. req { u1 'i' u1 replyNum u2 componentId u1 slotId val argument } res { u1 'I' u1 replyNum }","title":"invoke"},{"location":"networking/sox/#filechunk","text":"The fileChunk command transfers a single chunk within a file transfer operation. The same message structure is used for both get and put operations. Because Sox is run over Dasp, it is quite possible for chunks to be received out of order. req { u1 'k' u1 replyNum (ignored) u2 chunkNum u2 chunkSize u1[chunkSize] chunk }","title":"fileChunk"},{"location":"networking/sox/#link","text":"The link command is used to add or delete a link between two Component slots in the application. req { u1 'l' u1 replyNum u1 'a' | 'd' (add/delete) u2 fromCompId u1 fromSlotId u2 toCompId u1 toSlotId } res { u1 'L' u1 replyNum }","title":"link"},{"location":"networking/sox/#rename","text":"Rename is used to change a Component's name. req { u1 'n' u1 replyNum u2 compId str newName } res { u1 'N' u1 replyNum }","title":"rename"},{"location":"networking/sox/#reorder","text":"Reorder a component's child components. req { u1 'o' u1 replyNum u2 compId u1 numChildren u2[] childrenIds } res { u1 'O' u1 replyNum }","title":"reorder"},{"location":"networking/sox/#readprop","text":"Read a single property value from a component. req { u1 'r' u1 replyNum u2 compId u1 propId } res { u1 'R' u1 replyNum u1 any code var propValue }","title":"readProp"},{"location":"networking/sox/#subscribe","text":"The subscribe command allows you to subscribe to multiple components by registering for a set of change events . The subscribe command will return the number of components that were actually subscribed. This number may be less than the number of components requested if the user does not have permissions on a component, or if the component does not exist anymore You can also subscribe to all tree events (instead of subscribing to individual component tree events). In this case, the response contains no payload. req { u1 's' u1 replyNum u1 whatMask: tree=0x1 config=0x2 rt=0x4 links=0x8 0xff all tree u1 num: u2[] compIds: The ids of all the components to subscribe to } res { u1 'S' u1 replyNum u1 numSubscribed: The actual number of components that were subscribed }","title":"subscribe"},{"location":"networking/sox/#unsubscribe","text":"Unregister a subscription . The client will stop receiving change events for the set of components specified. req { u1 'u' u1 replyNum u1 whatMask: tree=0x1 config=0x2 rt=0x4 links=0x8 0xff all tree u1 num u2[] compIds } res { u1 'U' u1 replyNum }","title":"unsubscribe"},{"location":"networking/sox/#version","text":"Get the list of installed kits and their checksums, which defines the schema . versionReq { u1 'v' u1 replyNum } versionRes { u1 'V' u1 replyNum u1 kitCount kits[kitCount] { str name i4 checksum } }","title":"version"},{"location":"networking/sox/#write","text":"Set a component property value to a specific value. req { u1 'w' u1 replyNum u2 componentId u1 slotId val value } res { u1 'W' u1 replyNum }","title":"write"},{"location":"networking/sox/#versionmore","text":"Get extra version information, which includes the version of the installed kits plus platform specific name/value pairs.","title":"versionMore"},{"location":"networking/sox/#namevalue-pairs","text":"Name Value Notes soxVer Sox protocol version Introduced in build 1.0.45 (see discussion below) All builds of the Sedona Framework prior to 1.0.45 will return null for the sox protocol version. Starting in build 1.0.45 the sox protocol was changed to allow batch subscription , to components. If the sox protocol supports batch subscription, then it will return a soxVer of 1.1 (or higher). req { u1 'y' u1 replyNum } res { u1 'Y' u1 replyNum str platformId u1 scodeFlags kitVersions[kitCount] { str version } u1 pairs pairs { str key str val } }","title":"Name/Value pairs"},{"location":"networking/sox/#query","text":"Perform a query for a set of components. Currently you can only query for a service type using queryType of 's'. But the message is designed to be enhanced thru additional queryTypes. req { u1 'q' u1 replyNum u1 queryType u1[] queryReq } queryType 's': query service req-service { u1 kitId u1 typeId } res { u1 'Q' u1 replyNum u1[] queryRes } queryType 's': query service res-service { u2[num] compIds u2 0xffff end marker }","title":"query"},{"location":"networking/sox/#fileclose","text":"Terminates a file transfer operation. req { u1 'z' u1 replyNum } res { u1 'Z' u1 replyNum }","title":"fileClose"},{"location":"networking/sox/#error","text":"The error response may sent back as a response to any request. It indicates to the client that the request could not be processed. The cause of failure is returned as a short string in the message. res { u1 '!' u1 replyNum str cause }","title":"error"},{"location":"platforms/deviceSim/","text":"Device Simulator \u00b6 Overview \u00b6 A Sedona Device Simulator allows an app designed for a specific Sedona platform to run on another platform. The Simulator consists of a simulator Sedona VM plus a special scode file and platform manifest that allow the app to run as if it were on the original device. In a simulator Sedona VM, the native methods for the original platform are replaced with functions compatible with the simulator platform. The new functions may supply functionality equivalent to the originals, or they may be stubs, depending on how the simulator SVM is built. The degree to which a given Device Simulator will mimic the actual device is largely a function of the effort level put into creating it. Example : The native code for DigitalIo.gpioGet() in the SVM for a specific hardware platform reads an actual GPIO input on the device. In a simulator SVM designed to run apps for that platform on Windows, the DigitalIo.gpioGet() native table entry might simply point to a stub function that always returns 0. Or, it may point instead to an implementation that returns a calculated value that simulates a particular behavior. In either case the native function pointer is valid, and an app designed to run on the original platform should also run successfully on the simulator SVM. The Sedona compiler sedonac provides some functionality to aid in the creation of a simulator SVM. In particular, it can automatically create empty stub functions for any native methods that have not already been supplied by the developer. These source stubs can then be edited to add the desired functionality, or can simply be left as-is to create a limited (but usable) simulator SVM. Build Steps \u00b6 The following instructions will help you create a Sedona device simulator SVM for your own device. (It is usually convenient to bundle these operations into a script that can be run as needed.) Step 1 : Create a platform XML file for the simulator SVM Step 2 : Stage the Device Simulator SVM source files Step 3 : Build the simulator SVM Step 4 : Build scode for the Device Simulator Step 5 : Include an app for the Device Simulator Step 6 : Package and install the Device Simulator Step 7 : Run the Device Simulator Create platDef file \u00b6 The first step in creating a Device Simulator is setting up a simulator version of the platform XML file. By convention, the new file should have the same name as the original, with -sim inserted just before the extension. Example : the simulator version of generic-unix.xml would be generic-unix-sim.xml . Platform ID \u00b6 Inside the new XML file, the platform ID should be modified in the same way as the filename. Example : generic-unix-sim-${sedona.env.version} Simulator platform compile attributes \u00b6 Next, the attributes of the <compile> tag should modified to match the simulator platform rather than the original target platform. Example : For a Device Simulator that will run on Windows, set endian=\"little\" and blockSize=\"4\" . Native kits \u00b6 The list of <nativeKit> tags requires no modification. Native source paths \u00b6 The list of <nativeSource> tags must be modified to reflect the location of the native method implementations for the simulator platform. If any native methods are not supplied in the paths provided here, sedonac will create empty stubs for them at staging time. This is also where any simulator-specific native method implementations will be included - just provide the path to the desired source code in a <nativeSource> tag like the others. Example : to create a Device Simulator to simulate a unix platform on Windows, modify the <nativeSource> tags as follows: <nativeSource path= \"/src/sys/native/unix\" /> <nativeSource path= \"/platforms/src/generic/unix/native\" /> should become <nativeSource path= \"/src/sys/native/win32\" /> <nativeSource path= \"/platforms/src/generic/win32/native\" /> If there is a native method for the original platform that must return a specific value (or must not return 0), the developer can provide source code for a substitute that returns the desired value. The native source code file containing the substitute can be stored anywhere, as long as there is a <nativeSource> tag in the sim platform XML file that points to its location. At the other end of the simplicity spectrum, it is also possible to develop a more elaborate Device Simulator. For example one could provide a graphical representation for digital outputs on the simulator platform. The native code that generates the graphics, as well as the native method implementations that control them, would similarly be located and staged via one or more <nativeSource> tags. Tip If you are creating a device simulator for a device running Sedona 1.0 / TXS 1.1, native source must be provided for whatever methods the simulated platform uses to populate the platformId , platformVer , and memAvailable slots. These slots are often used by provisioning tools, and must have valid values for the tools to work. (Beginning with 1.2, there are native methods of sys::PlatformService so that sedonac can provide them automatically. Pre-1.2 however, they were unique to each platform.) Native patches \u00b6 Any native patches required for the Simulator SVM need to be accounted for in <nativePatch> tags. Note: The set of patches for the Device Simulator SVM may not be the same as the set for the original platform. In fact, since native patches are generally created only for SVMs that cannot be rebuilt easily, it is unlikely any will be needed in a simulator SVM. Manifest includes \u00b6 If the platform definition file uses the <manifestInclude> tag, the developer should judiciously consider whether it can remain as-is or needs to be modified for the simulator SVM. In particular, depending on how (or if) the original platform supports the Manifest Server feature then it may need to be omitted or re-implemented for the simulator. Stage source files \u00b6 When the platform XML file for the simulator SVM is complete, run sedonac on the new file using the option -stageSim . Specify the location to be used for the staging area via the -outDir option. Example : sedonac -stageSim -outDir temp generic-unix-sim.xml Sedonac will collect the files from all the <nativeSource> paths and store them in the staging area, and then scan the source code to identify any missing native method implementations. It will then create empty stubs for the missing methods. It will also create a .par folder in the staging directory to hold the platform archive (generated later), and create the platform manifest file for the simulator platform. Example : After running the above command, the directory temp has the following contents: win32> ls -A temp .par/ inet_util_std.c sys_FileStore_std.c datetimeStd_DateTimeServiceStd.c inet_util_std.h sys_File_std.c errorcodes.h main.c sys_StdOutStream_std.c inet_Crypto_sha1.c nativetable.c sys_Str.c inet_TcpServerSocket_std.c platUnix_native_stubs.c sys_Sys.c inet_TcpSocket_std.c platWin32_Win32PlatformService_win32.c sys_Sys_std.c inet_UdpSocket_std.c scode.h sys_Sys_win32.c inet_sha1.c sedona.h sys_Test.c inet_sha1.h sedonaPlatform.h sys_Type.c inet_util.h sys_Component.c vm.c And the subfolder .par contains: win32>ls -A temp/.par platformManifest.xml svm/ At this time, the source code for the Simulator's SVM is ready for building. If desired, any stub functions created by sedonac may be edited now to add functionality. Tip If you are creating a device simulator for a device running Sedona 1.0 / TXS 1.1, you will need to use sedonac.exe and sedonac.jar from a 1.2 installation for this step, since the pre-1.2 versions do not have the simulator feature. Build simulator SVM \u00b6 The next step is to compile the source code into an SVM executable. Use any toolchain that is appropriate for the simulator platform. When the executable has been created, copy it into the .par/svm folder inside the staging folder. Build scode file \u00b6 The Device Simulator requires a specially built scode file, so that the scode will run on the simulator platform. To do this, simply copy a basic scode XML file (such as one that is normally used for building scode for the original platform) and change the platform-specific parameters in the <sedonaCode> tag to match the simulator platform. This is the same as what was done earlier for the platform definition XML, e.g. to run on Windows set endian=\"little\" and blockSize=\"4\" . The list of kits requires no modifications. Run sedonac on the new scode file, and place it in .par/svm with the SVM executable. (Name it kits.scode for later convenience.) Build test app \u00b6 Finally, find or create a basic app with a schema that matches the scode built in the previous step. It does not require any modification. Simply build it and place the .sab file into .par/svm with the SVM and scode files. (Name it app.sab for later convenience.) Package and install \u00b6 Install the simulator platform into the platform database using the platArchive tool, as follows: platArchive --stage [path to .par folder] --svm --db Example : platArchive --stage temp/.par --svm --db This will also package the .par folder into a zip archive (in this example, the archive would be named tridium-generic-unix-sim-1.2.2.par ), which is a convenient way to distribute the Device Simulator with its associated files. Run Simulator \u00b6 To run the simulator SVM from the command line, simply navigate to the svm/ folder on the simulator host and run the SVM executable, e.g. svm>svm --plat kits.scode app.sab Sedona VM 2 .1.28-sim buildDate: Jan 14 2013 10 :01:34 endian: little blockSize: 4 refSize: 4 Running SVM in Platform Mode -- MESSAGE [ sys::App ] starting -- MESSAGE [ sox::SoxService ] started port = 1876 -- MESSAGE [ sox::SoxService ] DASP Discovery enabled -- MESSAGE [ sys::App ] running Make sure you are running the SVM executable in the svm/ folder, and not the one in {Sedona home}/bin . (You may need to modify your path variable to pick up the current directory first.) The simulator SVM is now running on the simulator host. It is a real Sedona VM and can be discovered and connected to by any Sox client on the same network. Any Sedona app that was designed to run on the original hardware platform should run successfully on this SVM as well. The main difference is that any native methods that are stubbed out in the simulator SVM will offer only their stubbed behavior to the app. The simulator SVM will be as realistic as the implementations of its native methods will allow. Note The svm/ folder is probably not the best location for running the simulator SVM, since it is likely just a temporary directory. This example is just a way to demonstrate the simulator SVM functionality.","title":"Device Simulator"},{"location":"platforms/deviceSim/#device-simulator","text":"","title":"Device Simulator"},{"location":"platforms/deviceSim/#overview","text":"A Sedona Device Simulator allows an app designed for a specific Sedona platform to run on another platform. The Simulator consists of a simulator Sedona VM plus a special scode file and platform manifest that allow the app to run as if it were on the original device. In a simulator Sedona VM, the native methods for the original platform are replaced with functions compatible with the simulator platform. The new functions may supply functionality equivalent to the originals, or they may be stubs, depending on how the simulator SVM is built. The degree to which a given Device Simulator will mimic the actual device is largely a function of the effort level put into creating it. Example : The native code for DigitalIo.gpioGet() in the SVM for a specific hardware platform reads an actual GPIO input on the device. In a simulator SVM designed to run apps for that platform on Windows, the DigitalIo.gpioGet() native table entry might simply point to a stub function that always returns 0. Or, it may point instead to an implementation that returns a calculated value that simulates a particular behavior. In either case the native function pointer is valid, and an app designed to run on the original platform should also run successfully on the simulator SVM. The Sedona compiler sedonac provides some functionality to aid in the creation of a simulator SVM. In particular, it can automatically create empty stub functions for any native methods that have not already been supplied by the developer. These source stubs can then be edited to add the desired functionality, or can simply be left as-is to create a limited (but usable) simulator SVM.","title":"Overview"},{"location":"platforms/deviceSim/#build-steps","text":"The following instructions will help you create a Sedona device simulator SVM for your own device. (It is usually convenient to bundle these operations into a script that can be run as needed.) Step 1 : Create a platform XML file for the simulator SVM Step 2 : Stage the Device Simulator SVM source files Step 3 : Build the simulator SVM Step 4 : Build scode for the Device Simulator Step 5 : Include an app for the Device Simulator Step 6 : Package and install the Device Simulator Step 7 : Run the Device Simulator","title":"Build Steps"},{"location":"platforms/deviceSim/#create-platdef-file","text":"The first step in creating a Device Simulator is setting up a simulator version of the platform XML file. By convention, the new file should have the same name as the original, with -sim inserted just before the extension. Example : the simulator version of generic-unix.xml would be generic-unix-sim.xml .","title":"Create platDef file"},{"location":"platforms/deviceSim/#platform-id","text":"Inside the new XML file, the platform ID should be modified in the same way as the filename. Example : generic-unix-sim-${sedona.env.version}","title":"Platform ID"},{"location":"platforms/deviceSim/#simulator-platform-compile-attributes","text":"Next, the attributes of the <compile> tag should modified to match the simulator platform rather than the original target platform. Example : For a Device Simulator that will run on Windows, set endian=\"little\" and blockSize=\"4\" .","title":"Simulator platform compile attributes"},{"location":"platforms/deviceSim/#native-kits","text":"The list of <nativeKit> tags requires no modification.","title":"Native kits"},{"location":"platforms/deviceSim/#native-source-paths","text":"The list of <nativeSource> tags must be modified to reflect the location of the native method implementations for the simulator platform. If any native methods are not supplied in the paths provided here, sedonac will create empty stubs for them at staging time. This is also where any simulator-specific native method implementations will be included - just provide the path to the desired source code in a <nativeSource> tag like the others. Example : to create a Device Simulator to simulate a unix platform on Windows, modify the <nativeSource> tags as follows: <nativeSource path= \"/src/sys/native/unix\" /> <nativeSource path= \"/platforms/src/generic/unix/native\" /> should become <nativeSource path= \"/src/sys/native/win32\" /> <nativeSource path= \"/platforms/src/generic/win32/native\" /> If there is a native method for the original platform that must return a specific value (or must not return 0), the developer can provide source code for a substitute that returns the desired value. The native source code file containing the substitute can be stored anywhere, as long as there is a <nativeSource> tag in the sim platform XML file that points to its location. At the other end of the simplicity spectrum, it is also possible to develop a more elaborate Device Simulator. For example one could provide a graphical representation for digital outputs on the simulator platform. The native code that generates the graphics, as well as the native method implementations that control them, would similarly be located and staged via one or more <nativeSource> tags. Tip If you are creating a device simulator for a device running Sedona 1.0 / TXS 1.1, native source must be provided for whatever methods the simulated platform uses to populate the platformId , platformVer , and memAvailable slots. These slots are often used by provisioning tools, and must have valid values for the tools to work. (Beginning with 1.2, there are native methods of sys::PlatformService so that sedonac can provide them automatically. Pre-1.2 however, they were unique to each platform.)","title":"Native source paths"},{"location":"platforms/deviceSim/#native-patches","text":"Any native patches required for the Simulator SVM need to be accounted for in <nativePatch> tags. Note: The set of patches for the Device Simulator SVM may not be the same as the set for the original platform. In fact, since native patches are generally created only for SVMs that cannot be rebuilt easily, it is unlikely any will be needed in a simulator SVM.","title":"Native patches"},{"location":"platforms/deviceSim/#manifest-includes","text":"If the platform definition file uses the <manifestInclude> tag, the developer should judiciously consider whether it can remain as-is or needs to be modified for the simulator SVM. In particular, depending on how (or if) the original platform supports the Manifest Server feature then it may need to be omitted or re-implemented for the simulator.","title":"Manifest includes"},{"location":"platforms/deviceSim/#stage-source-files","text":"When the platform XML file for the simulator SVM is complete, run sedonac on the new file using the option -stageSim . Specify the location to be used for the staging area via the -outDir option. Example : sedonac -stageSim -outDir temp generic-unix-sim.xml Sedonac will collect the files from all the <nativeSource> paths and store them in the staging area, and then scan the source code to identify any missing native method implementations. It will then create empty stubs for the missing methods. It will also create a .par folder in the staging directory to hold the platform archive (generated later), and create the platform manifest file for the simulator platform. Example : After running the above command, the directory temp has the following contents: win32> ls -A temp .par/ inet_util_std.c sys_FileStore_std.c datetimeStd_DateTimeServiceStd.c inet_util_std.h sys_File_std.c errorcodes.h main.c sys_StdOutStream_std.c inet_Crypto_sha1.c nativetable.c sys_Str.c inet_TcpServerSocket_std.c platUnix_native_stubs.c sys_Sys.c inet_TcpSocket_std.c platWin32_Win32PlatformService_win32.c sys_Sys_std.c inet_UdpSocket_std.c scode.h sys_Sys_win32.c inet_sha1.c sedona.h sys_Test.c inet_sha1.h sedonaPlatform.h sys_Type.c inet_util.h sys_Component.c vm.c And the subfolder .par contains: win32>ls -A temp/.par platformManifest.xml svm/ At this time, the source code for the Simulator's SVM is ready for building. If desired, any stub functions created by sedonac may be edited now to add functionality. Tip If you are creating a device simulator for a device running Sedona 1.0 / TXS 1.1, you will need to use sedonac.exe and sedonac.jar from a 1.2 installation for this step, since the pre-1.2 versions do not have the simulator feature.","title":"Stage source files"},{"location":"platforms/deviceSim/#build-simulator-svm","text":"The next step is to compile the source code into an SVM executable. Use any toolchain that is appropriate for the simulator platform. When the executable has been created, copy it into the .par/svm folder inside the staging folder.","title":"Build simulator SVM"},{"location":"platforms/deviceSim/#build-scode-file","text":"The Device Simulator requires a specially built scode file, so that the scode will run on the simulator platform. To do this, simply copy a basic scode XML file (such as one that is normally used for building scode for the original platform) and change the platform-specific parameters in the <sedonaCode> tag to match the simulator platform. This is the same as what was done earlier for the platform definition XML, e.g. to run on Windows set endian=\"little\" and blockSize=\"4\" . The list of kits requires no modifications. Run sedonac on the new scode file, and place it in .par/svm with the SVM executable. (Name it kits.scode for later convenience.)","title":"Build scode file"},{"location":"platforms/deviceSim/#build-test-app","text":"Finally, find or create a basic app with a schema that matches the scode built in the previous step. It does not require any modification. Simply build it and place the .sab file into .par/svm with the SVM and scode files. (Name it app.sab for later convenience.)","title":"Build test app"},{"location":"platforms/deviceSim/#package-and-install","text":"Install the simulator platform into the platform database using the platArchive tool, as follows: platArchive --stage [path to .par folder] --svm --db Example : platArchive --stage temp/.par --svm --db This will also package the .par folder into a zip archive (in this example, the archive would be named tridium-generic-unix-sim-1.2.2.par ), which is a convenient way to distribute the Device Simulator with its associated files.","title":"Package and install"},{"location":"platforms/deviceSim/#run-simulator","text":"To run the simulator SVM from the command line, simply navigate to the svm/ folder on the simulator host and run the SVM executable, e.g. svm>svm --plat kits.scode app.sab Sedona VM 2 .1.28-sim buildDate: Jan 14 2013 10 :01:34 endian: little blockSize: 4 refSize: 4 Running SVM in Platform Mode -- MESSAGE [ sys::App ] starting -- MESSAGE [ sox::SoxService ] started port = 1876 -- MESSAGE [ sox::SoxService ] DASP Discovery enabled -- MESSAGE [ sys::App ] running Make sure you are running the SVM executable in the svm/ folder, and not the one in {Sedona home}/bin . (You may need to modify your path variable to pick up the current directory first.) The simulator SVM is now running on the simulator host. It is a real Sedona VM and can be discovered and connected to by any Sox client on the same network. Any Sedona app that was designed to run on the original hardware platform should run successfully on this SVM as well. The main difference is that any native methods that are stubbed out in the simulator SVM will offer only their stubbed behavior to the app. The simulator SVM will be as realistic as the implementations of its native methods will allow. Note The svm/ folder is probably not the best location for running the simulator SVM, since it is likely just a temporary directory. This example is just a way to demonstrate the simulator SVM functionality.","title":"Run Simulator"},{"location":"platforms/par/","text":"Platform Archive \u00b6 PAR file \u00b6 A Platform Archive, or PAR file, provides a way of organizing various files and metadata about a platform into a single entity. A PAR file is a zip file with a .par extension. All paths and filenames within the PAR file are reserved by the Sedona Framework, except the vendor folder where vendor-specific files may be stored. The following filenames and paths are currently defined by the Sedona Framework: <myplatform>.par/ /platformManifest.xml /svm/<svm binary> /vendor/* platformManifest.xml : (required) Must be in the root of the PAR file. If the PAR file does not have a platformManifest.xml, then it is not a valid PAR file. Invalid PAR files will not be accepted by the sedonadev.org database. In addition, the manifest must set the id attribute to match the platform id. svm/<svm binary> : (optional) If you wish to package the svm binary for the platform, it should be placed in the /svm directory. It can have any name, as long as it does not have one of the scode or app extensions: xml , scode , sax , or sab . An scode and app file may also be included in this directory with the svm. vendor/ : (optional) The vendor may put any arbitrary contents in this location. The PAR file may have any name, but it must have a .par extension. The PAR file should be created as part of the vendor's build toolchain. sedonac will facilitate this by staging the platform manifest in stageDir.par , but ultimately each vendor must create the full contents of the PAR. You should create a PAR file if you want information about a platform to be available to Sedona Framework tools, or if you want to submit your platform for Sedona Framework certification. If a vendor is registered with sedonadev.org, the PAR file can be uploaded to sedonadev.org so that tools can retrieve them based on the platform id returned by the platform service running in the app. Platform Database \u00b6 When PAR files are stored locally, they are stored in the platform database. The platform database resides on the local filesystem at sedona_home/platforms/db/ When a PAR file is stored in the platform database, it is unzipped and stored in a directory called .par . The location of this directory is based on the platform id specified in the platform manifest. The platform database interprets every '-' character in the platform id as a directory separator. For example, if the platform id is acme-basicPlatform-win32-1.0.38 the unzipped PAR file contents can be found in the platform database at sedona_home/platforms/db/ +- acme/ | +- basicPlatform/ | | +- win32/ | | | +- .par/ | | | | +- platformManifest.xml | | | +- 1.0.37/ | | | +- 1.0.38/ | | | | +- .par/ | | | | | +- platformManifest.xml | | | | | +- svm/ | | | | | | +- <svm binary> +- tridium/ | +- <etc> You can use the sedona_home/adm/platformdb.py script to view and administrate your local platform database. When looking up a platform manifest or SVM for a given platform id, the platform database will use a \"best match\" algorithm. It begins by looking for a platform with the exact same id. If one cannot be found, it \"backs up\" one directory level in the platform database and searches for a platform manifest there. If one still cannot be found, it backs up again until it hits the root directory of the platform database, or finds a platform manifest. For example, suppose the platform database looks like the example above. If a Sedona Framework tool requests the platform manifest for a platform with id acme-basicPlatform-win32-1.0.39 , the sedona_home/platforms/db/acme/basicPlatform/win32/.par/platformManifest.xml manifest is the best match. Note The Sedona Framework API contains a PlatformDb object in sedona.jar for working with the local platform database. See sedona.PlatformDb .","title":"Platform Archive"},{"location":"platforms/par/#platform-archive","text":"","title":"Platform Archive"},{"location":"platforms/par/#par-file","text":"A Platform Archive, or PAR file, provides a way of organizing various files and metadata about a platform into a single entity. A PAR file is a zip file with a .par extension. All paths and filenames within the PAR file are reserved by the Sedona Framework, except the vendor folder where vendor-specific files may be stored. The following filenames and paths are currently defined by the Sedona Framework: <myplatform>.par/ /platformManifest.xml /svm/<svm binary> /vendor/* platformManifest.xml : (required) Must be in the root of the PAR file. If the PAR file does not have a platformManifest.xml, then it is not a valid PAR file. Invalid PAR files will not be accepted by the sedonadev.org database. In addition, the manifest must set the id attribute to match the platform id. svm/<svm binary> : (optional) If you wish to package the svm binary for the platform, it should be placed in the /svm directory. It can have any name, as long as it does not have one of the scode or app extensions: xml , scode , sax , or sab . An scode and app file may also be included in this directory with the svm. vendor/ : (optional) The vendor may put any arbitrary contents in this location. The PAR file may have any name, but it must have a .par extension. The PAR file should be created as part of the vendor's build toolchain. sedonac will facilitate this by staging the platform manifest in stageDir.par , but ultimately each vendor must create the full contents of the PAR. You should create a PAR file if you want information about a platform to be available to Sedona Framework tools, or if you want to submit your platform for Sedona Framework certification. If a vendor is registered with sedonadev.org, the PAR file can be uploaded to sedonadev.org so that tools can retrieve them based on the platform id returned by the platform service running in the app.","title":"PAR file"},{"location":"platforms/par/#platform-database","text":"When PAR files are stored locally, they are stored in the platform database. The platform database resides on the local filesystem at sedona_home/platforms/db/ When a PAR file is stored in the platform database, it is unzipped and stored in a directory called .par . The location of this directory is based on the platform id specified in the platform manifest. The platform database interprets every '-' character in the platform id as a directory separator. For example, if the platform id is acme-basicPlatform-win32-1.0.38 the unzipped PAR file contents can be found in the platform database at sedona_home/platforms/db/ +- acme/ | +- basicPlatform/ | | +- win32/ | | | +- .par/ | | | | +- platformManifest.xml | | | +- 1.0.37/ | | | +- 1.0.38/ | | | | +- .par/ | | | | | +- platformManifest.xml | | | | | +- svm/ | | | | | | +- <svm binary> +- tridium/ | +- <etc> You can use the sedona_home/adm/platformdb.py script to view and administrate your local platform database. When looking up a platform manifest or SVM for a given platform id, the platform database will use a \"best match\" algorithm. It begins by looking for a platform with the exact same id. If one cannot be found, it \"backs up\" one directory level in the platform database and searches for a platform manifest there. If one still cannot be found, it backs up again until it hits the root directory of the platform database, or finds a platform manifest. For example, suppose the platform database looks like the example above. If a Sedona Framework tool requests the platform manifest for a platform with id acme-basicPlatform-win32-1.0.39 , the sedona_home/platforms/db/acme/basicPlatform/win32/.par/platformManifest.xml manifest is the best match. Note The Sedona Framework API contains a PlatformDb object in sedona.jar for working with the local platform database. See sedona.PlatformDb .","title":"Platform Database"},{"location":"platforms/platCertified/","text":"Certified Platforms \u00b6 Info Given that Tridium no longer supports Sedona directly, the certification program may have been discontinued. This page is preserved for historical reasons only. Please check Sedona Alliance for background. Overview \u00b6 One of the steps involved in getting your platform Sedona Framework certified is that it must pass all tests when run against the sedonacert test suite. The sedonacert program verifies that 1) your platform is compliant with the Sox protocol and 2) your platform can be provisioned in a standard way. In order for your platform to pass the tests for provisioning, it must implement the following requirements: Requirements \u00b6 App and Scode naming requirements \u00b6 a Sox get file request for a file with URI app.sab must return the currently running app.sab file. a Sox get file request for a file with URI kits.scode must return the currently running kits.scode file. Standard provisioning process requirements \u00b6 A Sox client must be able to provision a new app.sab and kits.scode on your device by executing these steps: Write the new app.sab with URI app.sab.writing using a Sox put file request. Write the new kits.scode with URI kits.scode.writing using a Sox put file request. Rename URI app.sab.writing to URI app.sab.stage using a Sox file rename request. Rename URI kits.scode.writing to URI kits.scode.stage using a Sox file rename request. Invoke the restart() action on the device's platform service to restart the SVM. When the SVM restarts, it must use the newly staged app and scode files to run the application. See the section on bootstrapping for more details.","title":"Certified Platforms"},{"location":"platforms/platCertified/#certified-platforms","text":"Info Given that Tridium no longer supports Sedona directly, the certification program may have been discontinued. This page is preserved for historical reasons only. Please check Sedona Alliance for background.","title":"Certified Platforms"},{"location":"platforms/platCertified/#overview","text":"One of the steps involved in getting your platform Sedona Framework certified is that it must pass all tests when run against the sedonacert test suite. The sedonacert program verifies that 1) your platform is compliant with the Sox protocol and 2) your platform can be provisioned in a standard way. In order for your platform to pass the tests for provisioning, it must implement the following requirements:","title":"Overview"},{"location":"platforms/platCertified/#requirements","text":"","title":"Requirements"},{"location":"platforms/platCertified/#app-and-scode-naming-requirements","text":"a Sox get file request for a file with URI app.sab must return the currently running app.sab file. a Sox get file request for a file with URI kits.scode must return the currently running kits.scode file.","title":"App and Scode naming requirements"},{"location":"platforms/platCertified/#standard-provisioning-process-requirements","text":"A Sox client must be able to provision a new app.sab and kits.scode on your device by executing these steps: Write the new app.sab with URI app.sab.writing using a Sox put file request. Write the new kits.scode with URI kits.scode.writing using a Sox put file request. Rename URI app.sab.writing to URI app.sab.stage using a Sox file rename request. Rename URI kits.scode.writing to URI kits.scode.stage using a Sox file rename request. Invoke the restart() action on the device's platform service to restart the SVM. When the SVM restarts, it must use the newly staged app and scode files to run the application. See the section on bootstrapping for more details.","title":"Standard provisioning process requirements"},{"location":"platforms/platDef/","text":"Platform Definition \u00b6 Overview \u00b6 One of Sedona Framework's strengths is the portability of Sedona apps across different hardware platforms. This is accomplished by building a custom version of the SVM for each supported platform, tailored to the specific underlying architecture. Details on the customization of the SVM will be covered in the Porting chapter. Here we cover how that process is streamlined, by encapsulating platform-specific information into a platform definition file. When you run sedonac on a platform definition file, it will do the following: Stage the native method source code so that a native toolchain can be used to build the SVM. Produce a platform manifest and stage it for later packaging into a PAR file . Note sedonac does not actually build the SVM, it merely stages the native source files for convenient building with the native toolchain. See the Staging section for more details about how sedonac uses the platform definition to stage native source code and the platform manifest. Platform Definition XML \u00b6 The platform definition file is an XML file created by a Sedona platform developer. It serves three major purposes: Specifies a unique platform id that will be reported by platforms using this SVM. Declares properties needed for building the SVM, such as endianness, block size, and pointer size. If you want your SVM to support a kit that contains native methods, you must declare that dependency as well, and specify the location of the source code for the native methods . Declares arbitrary metadata about the platform. Sedona Framework tools can use this metadata to enhance the experience of working with a specific platform. The following is an example platform definition file for a win32 platform. <sedonaPlatform vendor= \"Acme\" id= \"acme-basicPlatform-win32-${sedona.env.version}\" > <compile endian= \"little\" blockSize= \"4\" refSize= \"4\" debug= \"true\" test= \"true\" > <!-- Native Kits --> <nativeKit depend= \"sys 1.0\" /> <nativeKit depend= \"inet 1.0\" /> <nativeKit depend= \"datetimeStd 1.0\" /> <nativeKit depend= \"acmePlatform 1.0\" /> <!-- Native Sources --> <nativeSource path= \"/src/vm\" /> <nativeSource path= \"/src/sys/native\" /> <nativeSource path= \"/src/sys/native/std\" /> <nativeSource path= \"/src/sys/native/win32\" /> <nativeSource path= \"/src/inet/native\" /> <nativeSource path= \"/src/inet/native/std\" /> <nativeSource path= \"/src/inet/native/sha1\" /> <nativeSource path= \"/src/datetimeStd/native/std\" /> <nativeSource path= \"/../acme/src/platforms/acmePlatform/native/win32\" /> </compile> <manifestInclude path= \"more_metadata.xml\" /> <manifestInclude> <contact email= \"jdoe@acme.com\" url= \"http://www.acme.com/sedona/help.html\" /> <schemes> <!-- this platform implements the manifest transfer scheme \"m:\" --> <scheme id= \"m\" /> </schemes> </manifestInclude> </sedonaPlatform> <sedonaPlatform> top level element for the platform definition: vendor : (required) The vendor owning this platform. id : (optional)The id that uniquely identifies this platform. This id must be prefixed with the string \" vendor- \". In the example above the vendor is \"Acme\" and the id is prefixed with \"acme-\". sedonac will generate a C header file sedonaPlatform.h in the stage directory containing a macro PLATFORM_ID with the value of the resolved id. The resolved platform id must be returned by the corresponding platform's implementation of sys::PlatformService.platformId() . The generated header file is intended to help facilitate this. The platform id can generally have any format, but the '-' character in the platform id will be interpreted as a directory separator when storing the PAR file for that platform into the platform database. See the section on the Platform Database for more details. If the id is omitted, no sedonaPlatform.h will be generated, and the platform manifest generated by sedonac will not contain an id. The platform manifest is not valid when an id is missing. That is, a PAR file containing a platform manifest with no id will be rejected by sedonadev.org when an upload is attempted. It becomes the responsibility of the build toolchain to insert the appropriate id attribute into the platform manifest before generating a PAR file. For this reason, it is better to try and specify an id variable pattern in your platform definition. This attribute supports variable substitution . There are a number of variables that sedonac will recognize when compiling a platform definition. These two are the most commonly used: ${stage.nativeChecksum} : sedonac will calculate a native checksum for all native methods that are supported by this platform SVM. This variable represents that checksum value. Note This is NOT the same as a kit checksum . Kit checksums are used for checking component-level compatibility when connecting to a Sedona device. The native checksum is used when provisioning a device, to check native compatibility of a kit on a given platform; if the SVM doesn't support the kit's native methods then the kit shouldn't be loaded on that device. ${sedona.env.version} : sedonac will look up the value of the environment variable sedona.env.version and substitute it wherever it occurs in the platform definition XML. See the section on Variable Substitution for other variables sedonac will recognize. <compile> provides platform-specific parameters: endian : (required) either \"little\" or \"big\" based on target processor. blockSize : (required) size of a scode block in bytes (see the source for src/vm/sedona.h ) refSize : (required) size of a memory pointer in bytes for target processor (4 for 32-bit processor). debug : (optional) boolean to include debug meta-data in image. Defaults to false test : (optional) boolean to include test code in image. Defaults to false armDouble : (optional) set to true if using an ARM microprocessor where 64-bit doubles are stored using byte level little endian, word level big endian. <nativeKit> indicates that this platform SVM implements the native methods from the specified kit. depend : (required) dependency as a kit name and version constraint. <nativeSource> designates a source path to native code: path : (required) path to a folder with native code that must be built into the SVM image. The path must start with \"/\" and be relative to sedona_home . This attribute supports variable substitution . <manifestInclude> (optional) is used to include arbitrary XML metadata in the generated platform manifest file. All XML elements that are children of the manifest include will be copied into the platform manifest. Note All XML namespace URIs that begin with http://sedonadev.org/ns are reserved by the Sedona Framework. Vendor specific XML elements should not use any such namespace URI. path : (optional) specifies the path to an external XML file to be included. The entire XML contents of that file will be copied into the platform manifest. (This could be used to include time-varying metadata into a platform definition file that stays fixed, or to include common metadata, such as contact info, shared by several related platforms.) If the path starts with \"/\" then the path is relative to sedona_home . Otherwise, the path is relative to the directory containing the platform definition. <schemes> (optional) The schemes child of the manifest include can be used to explicitly declare what schemes the platform supports. Each implemented scheme has the format <scheme id=\"scheme\"/> . See the examples below for more details. Platform Manifest \u00b6 In addition to staging the native source code, sedonac will stage a platform manifest XML file. This file will eventually be packaged into a PAR file for upload to sedonadev.org or installation into the local platform database. The following is an abridged version of the platformManifest.xml that might be generated for the platform definition above. <?xml version='1.0'?> <platformManifest platformId= \"acme-basicPlatform-win32-1.0.38\" vendor= \"Acme\" endian= \"little\" blockSize= \"4\" refSize= \"4\" armDouble= \"false\" debug= \"true\" test= \"true\" > <!-- Natives --> <natives> <nativeKit depend= \"sys 1.0\" /> <nativeKit depend= \"inet 1.0\" /> <nativeKit depend= \"datetimeStd 1.0\" /> <nativeKit depend= \"acmeBasicPlatform 1.0\" /> <nativeMethod qname= \"sys::Sys.platformType\" id= \"0::0\" /> <nativeMethod qname= \"sys::Sys.copy\" id= \"0::1\" /> <!-- ... --> <nativeMethod qname= \"acmeBasicPlatform::BasicPlatform.doPlatformId\" id= \"1::0\" /> <nativeMethod qname= \"inet::TcpSocket.connect\" id= \"2::0\" /> <nativeMethod qname= \"inet::TcpSocket.finishConnect\" id= \"2::1\" /> <!-- ... --> </natives> <!-- Manifest Includes --> <manifestIncludes> <metadata foo= \"bar\" /> <contact email= \"jdoe@acme.com\" url= \"http://www.acme.com/sedona/help.html\" /> <schemes> <!-- this platform implements the manifest transfer scheme --> <!-- If the packed attribute is 'true' (default), then all the kit manifests will be sent in a single zip file. If the packed attribute is anything else then each manifest will be zipped and sent one at a time.--> <scheme id= \"m\" packed= \"true\" /> </schemes> </manifestIncludes> </platformManifest> <platformManifest> top level element for the platform manifest. It contains all attributes from the platform definition root element and <compile> element. The id is the resolved platform id. Note The qname attribute of the <nativeMethod> is for reference - tools should typically compare scode compatibility with a given platform SVM by comparing the native method id, not the qname . <manifestIncludes> this element contains all the manifest include XML from the platform definition.","title":"Platform Definition"},{"location":"platforms/platDef/#platform-definition","text":"","title":"Platform Definition"},{"location":"platforms/platDef/#overview","text":"One of Sedona Framework's strengths is the portability of Sedona apps across different hardware platforms. This is accomplished by building a custom version of the SVM for each supported platform, tailored to the specific underlying architecture. Details on the customization of the SVM will be covered in the Porting chapter. Here we cover how that process is streamlined, by encapsulating platform-specific information into a platform definition file. When you run sedonac on a platform definition file, it will do the following: Stage the native method source code so that a native toolchain can be used to build the SVM. Produce a platform manifest and stage it for later packaging into a PAR file . Note sedonac does not actually build the SVM, it merely stages the native source files for convenient building with the native toolchain. See the Staging section for more details about how sedonac uses the platform definition to stage native source code and the platform manifest.","title":"Overview"},{"location":"platforms/platDef/#platform-definition-xml","text":"The platform definition file is an XML file created by a Sedona platform developer. It serves three major purposes: Specifies a unique platform id that will be reported by platforms using this SVM. Declares properties needed for building the SVM, such as endianness, block size, and pointer size. If you want your SVM to support a kit that contains native methods, you must declare that dependency as well, and specify the location of the source code for the native methods . Declares arbitrary metadata about the platform. Sedona Framework tools can use this metadata to enhance the experience of working with a specific platform. The following is an example platform definition file for a win32 platform. <sedonaPlatform vendor= \"Acme\" id= \"acme-basicPlatform-win32-${sedona.env.version}\" > <compile endian= \"little\" blockSize= \"4\" refSize= \"4\" debug= \"true\" test= \"true\" > <!-- Native Kits --> <nativeKit depend= \"sys 1.0\" /> <nativeKit depend= \"inet 1.0\" /> <nativeKit depend= \"datetimeStd 1.0\" /> <nativeKit depend= \"acmePlatform 1.0\" /> <!-- Native Sources --> <nativeSource path= \"/src/vm\" /> <nativeSource path= \"/src/sys/native\" /> <nativeSource path= \"/src/sys/native/std\" /> <nativeSource path= \"/src/sys/native/win32\" /> <nativeSource path= \"/src/inet/native\" /> <nativeSource path= \"/src/inet/native/std\" /> <nativeSource path= \"/src/inet/native/sha1\" /> <nativeSource path= \"/src/datetimeStd/native/std\" /> <nativeSource path= \"/../acme/src/platforms/acmePlatform/native/win32\" /> </compile> <manifestInclude path= \"more_metadata.xml\" /> <manifestInclude> <contact email= \"jdoe@acme.com\" url= \"http://www.acme.com/sedona/help.html\" /> <schemes> <!-- this platform implements the manifest transfer scheme \"m:\" --> <scheme id= \"m\" /> </schemes> </manifestInclude> </sedonaPlatform> <sedonaPlatform> top level element for the platform definition: vendor : (required) The vendor owning this platform. id : (optional)The id that uniquely identifies this platform. This id must be prefixed with the string \" vendor- \". In the example above the vendor is \"Acme\" and the id is prefixed with \"acme-\". sedonac will generate a C header file sedonaPlatform.h in the stage directory containing a macro PLATFORM_ID with the value of the resolved id. The resolved platform id must be returned by the corresponding platform's implementation of sys::PlatformService.platformId() . The generated header file is intended to help facilitate this. The platform id can generally have any format, but the '-' character in the platform id will be interpreted as a directory separator when storing the PAR file for that platform into the platform database. See the section on the Platform Database for more details. If the id is omitted, no sedonaPlatform.h will be generated, and the platform manifest generated by sedonac will not contain an id. The platform manifest is not valid when an id is missing. That is, a PAR file containing a platform manifest with no id will be rejected by sedonadev.org when an upload is attempted. It becomes the responsibility of the build toolchain to insert the appropriate id attribute into the platform manifest before generating a PAR file. For this reason, it is better to try and specify an id variable pattern in your platform definition. This attribute supports variable substitution . There are a number of variables that sedonac will recognize when compiling a platform definition. These two are the most commonly used: ${stage.nativeChecksum} : sedonac will calculate a native checksum for all native methods that are supported by this platform SVM. This variable represents that checksum value. Note This is NOT the same as a kit checksum . Kit checksums are used for checking component-level compatibility when connecting to a Sedona device. The native checksum is used when provisioning a device, to check native compatibility of a kit on a given platform; if the SVM doesn't support the kit's native methods then the kit shouldn't be loaded on that device. ${sedona.env.version} : sedonac will look up the value of the environment variable sedona.env.version and substitute it wherever it occurs in the platform definition XML. See the section on Variable Substitution for other variables sedonac will recognize. <compile> provides platform-specific parameters: endian : (required) either \"little\" or \"big\" based on target processor. blockSize : (required) size of a scode block in bytes (see the source for src/vm/sedona.h ) refSize : (required) size of a memory pointer in bytes for target processor (4 for 32-bit processor). debug : (optional) boolean to include debug meta-data in image. Defaults to false test : (optional) boolean to include test code in image. Defaults to false armDouble : (optional) set to true if using an ARM microprocessor where 64-bit doubles are stored using byte level little endian, word level big endian. <nativeKit> indicates that this platform SVM implements the native methods from the specified kit. depend : (required) dependency as a kit name and version constraint. <nativeSource> designates a source path to native code: path : (required) path to a folder with native code that must be built into the SVM image. The path must start with \"/\" and be relative to sedona_home . This attribute supports variable substitution . <manifestInclude> (optional) is used to include arbitrary XML metadata in the generated platform manifest file. All XML elements that are children of the manifest include will be copied into the platform manifest. Note All XML namespace URIs that begin with http://sedonadev.org/ns are reserved by the Sedona Framework. Vendor specific XML elements should not use any such namespace URI. path : (optional) specifies the path to an external XML file to be included. The entire XML contents of that file will be copied into the platform manifest. (This could be used to include time-varying metadata into a platform definition file that stays fixed, or to include common metadata, such as contact info, shared by several related platforms.) If the path starts with \"/\" then the path is relative to sedona_home . Otherwise, the path is relative to the directory containing the platform definition. <schemes> (optional) The schemes child of the manifest include can be used to explicitly declare what schemes the platform supports. Each implemented scheme has the format <scheme id=\"scheme\"/> . See the examples below for more details.","title":"Platform Definition XML"},{"location":"platforms/platDef/#platform-manifest","text":"In addition to staging the native source code, sedonac will stage a platform manifest XML file. This file will eventually be packaged into a PAR file for upload to sedonadev.org or installation into the local platform database. The following is an abridged version of the platformManifest.xml that might be generated for the platform definition above. <?xml version='1.0'?> <platformManifest platformId= \"acme-basicPlatform-win32-1.0.38\" vendor= \"Acme\" endian= \"little\" blockSize= \"4\" refSize= \"4\" armDouble= \"false\" debug= \"true\" test= \"true\" > <!-- Natives --> <natives> <nativeKit depend= \"sys 1.0\" /> <nativeKit depend= \"inet 1.0\" /> <nativeKit depend= \"datetimeStd 1.0\" /> <nativeKit depend= \"acmeBasicPlatform 1.0\" /> <nativeMethod qname= \"sys::Sys.platformType\" id= \"0::0\" /> <nativeMethod qname= \"sys::Sys.copy\" id= \"0::1\" /> <!-- ... --> <nativeMethod qname= \"acmeBasicPlatform::BasicPlatform.doPlatformId\" id= \"1::0\" /> <nativeMethod qname= \"inet::TcpSocket.connect\" id= \"2::0\" /> <nativeMethod qname= \"inet::TcpSocket.finishConnect\" id= \"2::1\" /> <!-- ... --> </natives> <!-- Manifest Includes --> <manifestIncludes> <metadata foo= \"bar\" /> <contact email= \"jdoe@acme.com\" url= \"http://www.acme.com/sedona/help.html\" /> <schemes> <!-- this platform implements the manifest transfer scheme --> <!-- If the packed attribute is 'true' (default), then all the kit manifests will be sent in a single zip file. If the packed attribute is anything else then each manifest will be zipped and sent one at a time.--> <scheme id= \"m\" packed= \"true\" /> </schemes> </manifestIncludes> </platformManifest> <platformManifest> top level element for the platform manifest. It contains all attributes from the platform definition root element and <compile> element. The id is the resolved platform id. Note The qname attribute of the <nativeMethod> is for reference - tools should typically compare scode compatibility with a given platform SVM by comparing the native method id, not the qname . <manifestIncludes> this element contains all the manifest include XML from the platform definition.","title":"Platform Manifest"},{"location":"platforms/platTutorial/","text":"Platform Tutorial \u00b6 Introduction \u00b6 A Sedona Framework platform is simply any device running an SVM. The platform is uniquely identified by the platformId property of the platform service running in the app on that device. This section presents a high-level, step-by-step guide to creating a Sedona Framework platform for your own device. We will use the Win32 platform provided in the open source distribution as a case study in creating a new Sedona Framework platform. Step 1: Create a kit for your platform service Step 2: Implement PlatformService native methods Step 3: Create a platform definition file Step 4: Port the SVM Step 5: Build the SVM Step 6: Create a PAR file Step 7: SAX and Scode setup for your platform Create Kit \u00b6 Every app must have a sys::PlatformService component running in it. A platform service encapsulates the behavior of that specific OS/Hardware platform. The sys::PlatformService class itself is generic, so some key methods do nothing. To implement a real Sedona platform, it must be subclassed so that platform-specific behavior can be implemented. The first step in porting Sedona to a new platform is the creation of a PlatformService subclass for the platform. As an example, the win32 platform service is defined in a kit called \"platWin32\" and the kit definition file is in sedona_home/platforms/src/generic/win32/kit.xml Implement Native Methods \u00b6 The base class sys::PlatformService defines three native methods that must be implemented for every platform. They are called by PlatformService as needed to populate the corresponding properties. doPlatformId() : returns platform ID string getPlatVersion() : returns platform version string getNativeMemAvailable() : returns number of bytes of physical memory available The open source includes win32 natives as an example, see sedona_home/src/sys/native/win32 . doPlatformId() \u00b6 One of the most important properties on the platform service is the platformId property. This property uniquely identifies your platform, and maps to a platform manifest stored in the platform database. The native method doPlatformId() provides a means for Sedona to access this native property. The native implementation of doPlatformId() for the win32 platform is #include \"sedona.h\" #include \"sedonaPlatform.h\" #include <windows.h> // Str PlatformService.doPlatformId() Cell sys_PlatformService_doPlatformId(SedonaVM* vm, Cell* params) { Cell result; result.aval = PLATFORM_ID; return result; } The value of PLATFORM_ID is defined in the header file sedonaPlatform.h , which is generated automatically from the platform definition XML file. So the next step is to create one. Create platDef file \u00b6 Please refer to the section on platform definition for an in depth discussion of this file and all its sections and attributes. The platform definition for the win32 platform is located in sedona_home/platforms/src/generic/win32/generic-win32.xml . (This file can be located anywhere, but the convention is to put it under sedona_home/platforms/src/ .) <sedonaPlatform vendor= \"Tridium\" id= \"tridium-generic-win32-${sedona.env.version}\" > <compile endian= \"little\" blockSize= \"4\" refSize= \"4\" debug= \"true\" test= \"true\" > <!-- Native Kits --> <nativeKit depend= \"sys 1.0\" /> <nativeKit depend= \"inet 1.0\" /> <nativeKit depend= \"datetimeStd 1.0\" /> <nativeKit depend= \"platWin32 1.0\" /> <!-- Native Sources --> <nativeSource path= \"/src/vm\" /> <nativeSource path= \"/src/sys/native\" /> <nativeSource path= \"/src/sys/native/std\" /> <nativeSource path= \"/src/sys/native/win32\" /> <nativeSource path= \"/src/inet/native\" /> <nativeSource path= \"/src/inet/native/std\" /> <nativeSource path= \"/src/inet/native/sha1\" /> <nativeSource path= \"/src/datetimeStd/native/std\" /> <nativeSource path= \"/platforms/src/generic/win32/native\" /> </compile> </sedonaPlatform> There are a few things to note about this platform definition. It specifies the id attribute for the platform. Later, when we run sedonac on this file to stage the source, it will generate the header file sedonaPlatform.h based on this file. That header file will contain the PLATFORM_ID definition required by the doPlatformId() native code. The SVM created from this platform definition will only support the native methods from the sys, inet, datetimeStd, and platWin32 kits because those are the only kits included in <nativeKit> declarations. In order to support other kits with native methods, they will have to be added to the platform definition. Port SVM \u00b6 This process is already described in detail in the porting section. We specified in the platform definition file where all the native source code is located. If the native source file locations change at any time during the platform development process, the platform definition will need to be updated accordingly. Refer to the win32 platform definition to see where all the native code for the win32 SVM resides. Build SVM \u00b6 Once the native source code is written and the platform definition file is correct, we are ready to build the SVM. As described in the staging section, we use sedonac to stage all native source files in one directory. Then we use the appropriate native tool-chain to actually build the SVM. The open source distribution includes a makewinvm.py script that will build the win32 platform SVM. It runs sedonac on the generic-win32.xml platform definition file to stage all the source code for the SVM, and then it compiles the source code into a binary. This is the same svm.exe that appears in the bin/ directory of the open source distribution. To run makewinvm.py you must first have set up your environment for Windows 32-bit development. You must provide your own native tool-chain to accomplish the same tasks for a different platform. Create PAR file \u00b6 Refer to the section on PAR files for a more in-depth discussion on PAR files. When we staged the native source by running sedonac on the platform definition file, it also created a .par/ directory containing a valid platformManifest.xml file for the platform. Therefore, all we need to do is zip up the contents of that directory and use the platformdb.py script to install it in our platform database. The makewinvm.py script does the database installation step automatically for the open source win32 platform. If you issue the platformdb.py --list command you should see output similar to the following sedona> platformdb.py --list tridium-generic-win32-1.0.46 This output indicates that the we have successfully installed the win32 platform into the platform database. The toolchain steps you perform for another platform will need to do the same thing for that platform. You can use the platformdb -i <par file> command to install a PAR file into the platform database. Note The path within the platform database where the .par folder will be located must match the platform ID exactly. For example, the win32 platform definition file defines the platform ID as tridium-generic-win32-${sedona.env.version} . When we ran sedonac on the platform definition file it substituted an actual version number, so the resulting platform manifest file contains a specific definition, for example tridium-generic-win32-1.2.29 . Sedona would then expect to find the manifest file for this platform in the platform database under sedona_home/platforms/db/tridium/generic/win32/1.2.29/.par/ . Test Platform \u00b6 To use your new platform service, you will need to create an application (SAX) that uses your platform service. There is an example SAX file that uses the Win32PlatformService at sedona_home/apps/platWin32.sax . You can use this file as a template and make the following modifications to use it for your platform: In the <schema> section, remove the platWin32 kit and add the kit for your platform service. In the <app> section there is a component called \"plat\". Change the type of that component from \"platWin32::Win32PlatformService\" to the type of your platform service. After you have made these changes you can run sedonac on your new SAX file to create an binary application (SAB) that your SVM can run. Finally, you will need to create a scode image corresponding to the kits in your SAX. There is an example scode configuration file in sedona_home/scode/platWin32.xml . You can use this file as a template and make the following modifications for your platform: Modify the <sedonaCode> elements to match the settings for your device. For example, make sure the blockSize, refSize, endian, etc. are correct. Remove the dependency on \"platWin32 1.0\" and add a dependency for the kit containing your platform service. After you have made these changes you an run sedonac on your new scode XML file to produce an scode image that your SVM can run.","title":"Platform Tutorial"},{"location":"platforms/platTutorial/#platform-tutorial","text":"","title":"Platform Tutorial"},{"location":"platforms/platTutorial/#introduction","text":"A Sedona Framework platform is simply any device running an SVM. The platform is uniquely identified by the platformId property of the platform service running in the app on that device. This section presents a high-level, step-by-step guide to creating a Sedona Framework platform for your own device. We will use the Win32 platform provided in the open source distribution as a case study in creating a new Sedona Framework platform. Step 1: Create a kit for your platform service Step 2: Implement PlatformService native methods Step 3: Create a platform definition file Step 4: Port the SVM Step 5: Build the SVM Step 6: Create a PAR file Step 7: SAX and Scode setup for your platform","title":"Introduction"},{"location":"platforms/platTutorial/#create-kit","text":"Every app must have a sys::PlatformService component running in it. A platform service encapsulates the behavior of that specific OS/Hardware platform. The sys::PlatformService class itself is generic, so some key methods do nothing. To implement a real Sedona platform, it must be subclassed so that platform-specific behavior can be implemented. The first step in porting Sedona to a new platform is the creation of a PlatformService subclass for the platform. As an example, the win32 platform service is defined in a kit called \"platWin32\" and the kit definition file is in sedona_home/platforms/src/generic/win32/kit.xml","title":"Create Kit"},{"location":"platforms/platTutorial/#implement-native-methods","text":"The base class sys::PlatformService defines three native methods that must be implemented for every platform. They are called by PlatformService as needed to populate the corresponding properties. doPlatformId() : returns platform ID string getPlatVersion() : returns platform version string getNativeMemAvailable() : returns number of bytes of physical memory available The open source includes win32 natives as an example, see sedona_home/src/sys/native/win32 .","title":"Implement Native Methods"},{"location":"platforms/platTutorial/#doplatformid","text":"One of the most important properties on the platform service is the platformId property. This property uniquely identifies your platform, and maps to a platform manifest stored in the platform database. The native method doPlatformId() provides a means for Sedona to access this native property. The native implementation of doPlatformId() for the win32 platform is #include \"sedona.h\" #include \"sedonaPlatform.h\" #include <windows.h> // Str PlatformService.doPlatformId() Cell sys_PlatformService_doPlatformId(SedonaVM* vm, Cell* params) { Cell result; result.aval = PLATFORM_ID; return result; } The value of PLATFORM_ID is defined in the header file sedonaPlatform.h , which is generated automatically from the platform definition XML file. So the next step is to create one.","title":"doPlatformId()"},{"location":"platforms/platTutorial/#create-platdef-file","text":"Please refer to the section on platform definition for an in depth discussion of this file and all its sections and attributes. The platform definition for the win32 platform is located in sedona_home/platforms/src/generic/win32/generic-win32.xml . (This file can be located anywhere, but the convention is to put it under sedona_home/platforms/src/ .) <sedonaPlatform vendor= \"Tridium\" id= \"tridium-generic-win32-${sedona.env.version}\" > <compile endian= \"little\" blockSize= \"4\" refSize= \"4\" debug= \"true\" test= \"true\" > <!-- Native Kits --> <nativeKit depend= \"sys 1.0\" /> <nativeKit depend= \"inet 1.0\" /> <nativeKit depend= \"datetimeStd 1.0\" /> <nativeKit depend= \"platWin32 1.0\" /> <!-- Native Sources --> <nativeSource path= \"/src/vm\" /> <nativeSource path= \"/src/sys/native\" /> <nativeSource path= \"/src/sys/native/std\" /> <nativeSource path= \"/src/sys/native/win32\" /> <nativeSource path= \"/src/inet/native\" /> <nativeSource path= \"/src/inet/native/std\" /> <nativeSource path= \"/src/inet/native/sha1\" /> <nativeSource path= \"/src/datetimeStd/native/std\" /> <nativeSource path= \"/platforms/src/generic/win32/native\" /> </compile> </sedonaPlatform> There are a few things to note about this platform definition. It specifies the id attribute for the platform. Later, when we run sedonac on this file to stage the source, it will generate the header file sedonaPlatform.h based on this file. That header file will contain the PLATFORM_ID definition required by the doPlatformId() native code. The SVM created from this platform definition will only support the native methods from the sys, inet, datetimeStd, and platWin32 kits because those are the only kits included in <nativeKit> declarations. In order to support other kits with native methods, they will have to be added to the platform definition.","title":"Create platDef file"},{"location":"platforms/platTutorial/#port-svm","text":"This process is already described in detail in the porting section. We specified in the platform definition file where all the native source code is located. If the native source file locations change at any time during the platform development process, the platform definition will need to be updated accordingly. Refer to the win32 platform definition to see where all the native code for the win32 SVM resides.","title":"Port SVM"},{"location":"platforms/platTutorial/#build-svm","text":"Once the native source code is written and the platform definition file is correct, we are ready to build the SVM. As described in the staging section, we use sedonac to stage all native source files in one directory. Then we use the appropriate native tool-chain to actually build the SVM. The open source distribution includes a makewinvm.py script that will build the win32 platform SVM. It runs sedonac on the generic-win32.xml platform definition file to stage all the source code for the SVM, and then it compiles the source code into a binary. This is the same svm.exe that appears in the bin/ directory of the open source distribution. To run makewinvm.py you must first have set up your environment for Windows 32-bit development. You must provide your own native tool-chain to accomplish the same tasks for a different platform.","title":"Build SVM"},{"location":"platforms/platTutorial/#create-par-file","text":"Refer to the section on PAR files for a more in-depth discussion on PAR files. When we staged the native source by running sedonac on the platform definition file, it also created a .par/ directory containing a valid platformManifest.xml file for the platform. Therefore, all we need to do is zip up the contents of that directory and use the platformdb.py script to install it in our platform database. The makewinvm.py script does the database installation step automatically for the open source win32 platform. If you issue the platformdb.py --list command you should see output similar to the following sedona> platformdb.py --list tridium-generic-win32-1.0.46 This output indicates that the we have successfully installed the win32 platform into the platform database. The toolchain steps you perform for another platform will need to do the same thing for that platform. You can use the platformdb -i <par file> command to install a PAR file into the platform database. Note The path within the platform database where the .par folder will be located must match the platform ID exactly. For example, the win32 platform definition file defines the platform ID as tridium-generic-win32-${sedona.env.version} . When we ran sedonac on the platform definition file it substituted an actual version number, so the resulting platform manifest file contains a specific definition, for example tridium-generic-win32-1.2.29 . Sedona would then expect to find the manifest file for this platform in the platform database under sedona_home/platforms/db/tridium/generic/win32/1.2.29/.par/ .","title":"Create PAR file"},{"location":"platforms/platTutorial/#test-platform","text":"To use your new platform service, you will need to create an application (SAX) that uses your platform service. There is an example SAX file that uses the Win32PlatformService at sedona_home/apps/platWin32.sax . You can use this file as a template and make the following modifications to use it for your platform: In the <schema> section, remove the platWin32 kit and add the kit for your platform service. In the <app> section there is a component called \"plat\". Change the type of that component from \"platWin32::Win32PlatformService\" to the type of your platform service. After you have made these changes you can run sedonac on your new SAX file to create an binary application (SAB) that your SVM can run. Finally, you will need to create a scode image corresponding to the kits in your SAX. There is an example scode configuration file in sedona_home/scode/platWin32.xml . You can use this file as a template and make the following modifications for your platform: Modify the <sedonaCode> elements to match the settings for your device. For example, make sure the blockSize, refSize, endian, etc. are correct. Remove the dependency on \"platWin32 1.0\" and add a dependency for the kit containing your platform service. After you have made these changes you an run sedonac on your new scode XML file to produce an scode image that your SVM can run.","title":"Test Platform"},{"location":"quickstart/architecture/","text":"Architecture \u00b6 Actors \u00b6 One of the goals of the Sedona Framework is to empower non-programmers to graphically assemble applications by wiring together predefined components. It is useful to consider two primary actors involved in building Sedona Framework applications: Developers are software engineers who write components using the Sedona programming language. These components include function blocks, I/O drivers, and packaged applications. Components are then bundled into modules and deployed as kits Integrators are typically domain experts who use graphical tools to assemble applications from the components written by developers. Components are configured via their properties and wired together with links In the real world, users don't fit into these two buckets so cleanly - many belong to both camps. But characterizing users according to these two actors is useful for discussion. Sedona Language \u00b6 Sedona Framework applications all start with software written in the Sedona programming language . The Sedona language is based on Java and C# - so if you are familiar with those languages then you should have no problem learning Sedona. Key characteristics of the Sedona language include: Familiar Java/C# syntax Object oriented (inheritance, polymorphism, all that good stuff) Component oriented (first class properties and actions, reflection, graphical assembly) Single inheritance only (no interfaces) Static memory model (components cannot create new objects at runtime) Semicolons are optional as statement separator Components \u00b6 The Sedona Framework's standard API includes a special class called Component . Classes that extend Component are designed to be used by integrators to assemble applications. All components have the following characteristics designed to enable component-oriented application assembly: Two byte component id for identity and naming inside an application A short ASCII character name as a human label Designed to be organized into a tree structure similar to your file system Reflective type Named set of reflective slots Slots are the members of a component class that specify how the component is exposed to an integrator during the assembly process. There are two types of slots: property defines a configuration or runtime variable and action defines a command that can be invoked. Kits \u00b6 Developers write software organized into classes much like C++, Java, or C#. These classes are then packaged up into a kit . A kit is the primary unit of deployment, versioning, and naming in the Sedona Framework. A kit is like a Java JAR file or a .NET DLL. Kits are stored as a single file that ends with the \".kit\" extension. The file itself is a standard archive file you can open using your favorite 'zip' tool. Inside the kit file is an XML manifest file that specifies meta-data about the kit such as its name, version, vendor, and description. The manifest also enumerates all the kit's component types that are available for constructing applications. Kits are compiled from Sedona language source code using the sedonac compiler. During compilation, all the classes in the kit are checked for validity and compiled into a special format called IR for intermediate representation . The IR format is a text based \"assembly language\". IR code is portable, which means one kit file can be deployed for all platforms. SCode \u00b6 Sedona Framework software deployed as kits still isn't quite ready for execution. Even though we've compiled source language down to IR, we still don't have a format suitable for machine execution. The next step is to compile a set of kits into a single file called an scode image . SCode is a very compact, binary representation of the code, designed to be executed directly by the Sedona VM. The sedonac compiler is used to compile a set of kits into a binary \".scode\" file. During this compilation process the following tasks are performed: Layout method code in memory Layout fields in memory Layout reflection meta-data in memory Optimize for big-endian or little-endian Optimize for native platform pointer size Link method calls to their memory locations To maximize performance, sedonac optimizes the scode for a specific platform's endianness and pointer size; this means that an scode image is not portable to other platforms. Sedona Virtual Machine \u00b6 Once a set of kits has been compiled into an scode file, we can run the scode using the Sedona Virtual Machine , or SVM for short. The SVM interprets the scode and brings Sedona programs to life! The SVM itself is written in ANSI C and compiled for a target hardware platform. See the Porting chapter for instructions to get the SVM running on your target device. Sedona Framework Applications \u00b6 Writing code in the Sedona programming language and building kits is the domain of developers. Developers build libraries of ready-to-use components deployed as kits. Integrators can then use graphical programming tools to design applications by assembling and linking component instances. Due to their dynamic nature, Sedona Framework applications are modeled and persisted differently from kits and scode. A Sedona Framework application is modeled as a tree of components. Each component is assigned a unique two byte identifier and a custom name. Components instances may also be customized via their configuration properties. Links are used to establish relationships between components to specify data and event flow within the application. Sedona Framework applications may be stored in two different file formats. The Sedona Application XML format uses the \".sax\" file extension, and is a human-readable XML file. The Sedona Application Binary format uses the \".sab\" file extension and is a compact binary representation of the application. The binary format is the one used at runtime on Sedona Framework-enabled devices. The sedonac tool can be used to convert between the file formats. Sedona Framework Devices \u00b6 Of course the end goal of the Sedona Framework is to create programmable smart devices. This is where everything comes together. The typical process of Sedona Framework-enabling a device: Port the SVM to the device's hardware platform Run the SVM on the device (typically loaded or run from flash memory on startup) Commission the device with an scode image. This allows integrators to pick their own kits to use for applications. In devices with limited resources the scode may be fixed or even in ROM. More typically, the scode is stored in flash memory and the location of the image passed to the VM at boot time Load the sab application file. The integrator may write a complete application to the device; applications can also be modified dynamically on the device while it is running. At the other extreme, such as for a small, dedicated device, the application might be fixed or stored in ROM Workflow \u00b6 The diagram below illustrates the workflow for building and deploying Sedona Framework applications to devices. The Sedona developer workflow typically involves these steps: Build library of components in the Sedona programming language Components are compiled into kits using sedonac Developers or integrators will choose which kits to install onto a device, and then sedonac is used to link the kits into a binary scode image (this step is often done under the covers by a high level tool) The SVM and scode are loaded onto the device. These files may be predefined such as in ROM, or may be dynamically provisioned over the network using the Sox protocol System integrators are usually domain experts who build Sedona applications by \"wiring together\" the components provided by developers. These users typically use graphical tools to assemble applications. Applications may be modified remotely on a running device using the Sox protocol, or they may be built offline and stored in a \"sax\" file. If the app is built offline, then it compiled into a \"sab\" file with sedonac and installed on the device at commissioning time using the Sox protocol.","title":"Architecture"},{"location":"quickstart/architecture/#architecture","text":"","title":"Architecture"},{"location":"quickstart/architecture/#actors","text":"One of the goals of the Sedona Framework is to empower non-programmers to graphically assemble applications by wiring together predefined components. It is useful to consider two primary actors involved in building Sedona Framework applications: Developers are software engineers who write components using the Sedona programming language. These components include function blocks, I/O drivers, and packaged applications. Components are then bundled into modules and deployed as kits Integrators are typically domain experts who use graphical tools to assemble applications from the components written by developers. Components are configured via their properties and wired together with links In the real world, users don't fit into these two buckets so cleanly - many belong to both camps. But characterizing users according to these two actors is useful for discussion.","title":"Actors"},{"location":"quickstart/architecture/#sedona-language","text":"Sedona Framework applications all start with software written in the Sedona programming language . The Sedona language is based on Java and C# - so if you are familiar with those languages then you should have no problem learning Sedona. Key characteristics of the Sedona language include: Familiar Java/C# syntax Object oriented (inheritance, polymorphism, all that good stuff) Component oriented (first class properties and actions, reflection, graphical assembly) Single inheritance only (no interfaces) Static memory model (components cannot create new objects at runtime) Semicolons are optional as statement separator","title":"Sedona Language"},{"location":"quickstart/architecture/#components","text":"The Sedona Framework's standard API includes a special class called Component . Classes that extend Component are designed to be used by integrators to assemble applications. All components have the following characteristics designed to enable component-oriented application assembly: Two byte component id for identity and naming inside an application A short ASCII character name as a human label Designed to be organized into a tree structure similar to your file system Reflective type Named set of reflective slots Slots are the members of a component class that specify how the component is exposed to an integrator during the assembly process. There are two types of slots: property defines a configuration or runtime variable and action defines a command that can be invoked.","title":"Components"},{"location":"quickstart/architecture/#kits","text":"Developers write software organized into classes much like C++, Java, or C#. These classes are then packaged up into a kit . A kit is the primary unit of deployment, versioning, and naming in the Sedona Framework. A kit is like a Java JAR file or a .NET DLL. Kits are stored as a single file that ends with the \".kit\" extension. The file itself is a standard archive file you can open using your favorite 'zip' tool. Inside the kit file is an XML manifest file that specifies meta-data about the kit such as its name, version, vendor, and description. The manifest also enumerates all the kit's component types that are available for constructing applications. Kits are compiled from Sedona language source code using the sedonac compiler. During compilation, all the classes in the kit are checked for validity and compiled into a special format called IR for intermediate representation . The IR format is a text based \"assembly language\". IR code is portable, which means one kit file can be deployed for all platforms.","title":"Kits"},{"location":"quickstart/architecture/#scode","text":"Sedona Framework software deployed as kits still isn't quite ready for execution. Even though we've compiled source language down to IR, we still don't have a format suitable for machine execution. The next step is to compile a set of kits into a single file called an scode image . SCode is a very compact, binary representation of the code, designed to be executed directly by the Sedona VM. The sedonac compiler is used to compile a set of kits into a binary \".scode\" file. During this compilation process the following tasks are performed: Layout method code in memory Layout fields in memory Layout reflection meta-data in memory Optimize for big-endian or little-endian Optimize for native platform pointer size Link method calls to their memory locations To maximize performance, sedonac optimizes the scode for a specific platform's endianness and pointer size; this means that an scode image is not portable to other platforms.","title":"SCode"},{"location":"quickstart/architecture/#sedona-virtual-machine","text":"Once a set of kits has been compiled into an scode file, we can run the scode using the Sedona Virtual Machine , or SVM for short. The SVM interprets the scode and brings Sedona programs to life! The SVM itself is written in ANSI C and compiled for a target hardware platform. See the Porting chapter for instructions to get the SVM running on your target device.","title":"Sedona Virtual Machine"},{"location":"quickstart/architecture/#sedona-framework-applications","text":"Writing code in the Sedona programming language and building kits is the domain of developers. Developers build libraries of ready-to-use components deployed as kits. Integrators can then use graphical programming tools to design applications by assembling and linking component instances. Due to their dynamic nature, Sedona Framework applications are modeled and persisted differently from kits and scode. A Sedona Framework application is modeled as a tree of components. Each component is assigned a unique two byte identifier and a custom name. Components instances may also be customized via their configuration properties. Links are used to establish relationships between components to specify data and event flow within the application. Sedona Framework applications may be stored in two different file formats. The Sedona Application XML format uses the \".sax\" file extension, and is a human-readable XML file. The Sedona Application Binary format uses the \".sab\" file extension and is a compact binary representation of the application. The binary format is the one used at runtime on Sedona Framework-enabled devices. The sedonac tool can be used to convert between the file formats.","title":"Sedona Framework Applications"},{"location":"quickstart/architecture/#sedona-framework-devices","text":"Of course the end goal of the Sedona Framework is to create programmable smart devices. This is where everything comes together. The typical process of Sedona Framework-enabling a device: Port the SVM to the device's hardware platform Run the SVM on the device (typically loaded or run from flash memory on startup) Commission the device with an scode image. This allows integrators to pick their own kits to use for applications. In devices with limited resources the scode may be fixed or even in ROM. More typically, the scode is stored in flash memory and the location of the image passed to the VM at boot time Load the sab application file. The integrator may write a complete application to the device; applications can also be modified dynamically on the device while it is running. At the other extreme, such as for a small, dedicated device, the application might be fixed or stored in ROM","title":"Sedona Framework Devices"},{"location":"quickstart/architecture/#workflow","text":"The diagram below illustrates the workflow for building and deploying Sedona Framework applications to devices. The Sedona developer workflow typically involves these steps: Build library of components in the Sedona programming language Components are compiled into kits using sedonac Developers or integrators will choose which kits to install onto a device, and then sedonac is used to link the kits into a binary scode image (this step is often done under the covers by a high level tool) The SVM and scode are loaded onto the device. These files may be predefined such as in ROM, or may be dynamically provisioned over the network using the Sox protocol System integrators are usually domain experts who build Sedona applications by \"wiring together\" the components provided by developers. These users typically use graphical tools to assemble applications. Applications may be modified remotely on a running device using the Sox protocol, or they may be built offline and stored in a \"sax\" file. If the app is built offline, then it compiled into a \"sab\" file with sedonac and installed on the device at commissioning time using the Sox protocol.","title":"Workflow"},{"location":"quickstart/intro/","text":"Introduction \u00b6 Overview \u00b6 The Sedona Framework is a software framework designed to make it easy to build smart, networked embedded devices. Some of the Sedona Framework highlights: Sedona Language : This is a general purpose component-oriented programming language very similar to Java or C#. The Sedona language is used to write your own custom functionality Sedona Virtual Machine : The virtual machine is a small interpreter written in ANSI C and designed for portability. It allows code written in the Sedona programming language to be written once, but run on any Sedona Framework-enabled device. The VM itself is designed to be highly portable to new microprocessors and operating systems Small Devices : The Sedona Framework is ideal for very small embedded devices. It can run on platforms with less than 100KB of memory! Component Oriented Programming : The Sedona Framework enables a style of programming where pre-built components are assembled into applications. Components can act as services or be explicitly linked together to create data and control flow. This model is especially suited to graphical programming tools Networking : Several protocols are bundled with the Sedona Framework to provision, program, and communicate with Sedona Framework-enabled devices over various network topologies. You can remotely add, remove, and modify the components in your application in real-time. You can even upgrade the firmware itself over the network. Sedona Framework networking is designed to work over any IP network, including 6LoWPAN Open Source Ecosystem : The core Sedona Framework technology uses a flexible academic styled license. This makes it easy for manufacturers to Sedona Framework-enable their devices. Tools and applications written in Sedona are guaranteed portable to any Sedona Framework device","title":"Introduction"},{"location":"quickstart/intro/#introduction","text":"","title":"Introduction"},{"location":"quickstart/intro/#overview","text":"The Sedona Framework is a software framework designed to make it easy to build smart, networked embedded devices. Some of the Sedona Framework highlights: Sedona Language : This is a general purpose component-oriented programming language very similar to Java or C#. The Sedona language is used to write your own custom functionality Sedona Virtual Machine : The virtual machine is a small interpreter written in ANSI C and designed for portability. It allows code written in the Sedona programming language to be written once, but run on any Sedona Framework-enabled device. The VM itself is designed to be highly portable to new microprocessors and operating systems Small Devices : The Sedona Framework is ideal for very small embedded devices. It can run on platforms with less than 100KB of memory! Component Oriented Programming : The Sedona Framework enables a style of programming where pre-built components are assembled into applications. Components can act as services or be explicitly linked together to create data and control flow. This model is especially suited to graphical programming tools Networking : Several protocols are bundled with the Sedona Framework to provision, program, and communicate with Sedona Framework-enabled devices over various network topologies. You can remotely add, remove, and modify the components in your application in real-time. You can even upgrade the firmware itself over the network. Sedona Framework networking is designed to work over any IP network, including 6LoWPAN Open Source Ecosystem : The core Sedona Framework technology uses a flexible academic styled license. This makes it easy for manufacturers to Sedona Framework-enable their devices. Tools and applications written in Sedona are guaranteed portable to any Sedona Framework device","title":"Overview"},{"location":"quickstart/setup/","text":"Setup \u00b6 Overview \u00b6 The root directory of your Sedona Framework installation or development environment is referred to as Sedona home . Relative paths in this documentation always start from the Sedona home directory. Sedona home is organized into the following sub directories: adm : administration scripts used to build and test apps : Sedona application files (.sab and .sax formats) bin : Win32 binaries and some Unix shell scripts doc : documentation kits : directory for kit database lib : Java jar files and properties files manifests : directory for manifest database platforms : directory for platform database; also contains source files for Sedona Framework platforms scode : scode images, and linker files for creating them src : directory tree for Java, C, and Sedona source code Sedonac \u00b6 Sedona Framework development primarily centers around the tool sedonac . It functions as a compiler for Sedona applications as well as Sedona kits (library modules); its behavior depends on the input file it is processing. Windows \u00b6 For Windows you will be using the sedonac.exe launcher executable, located in the bin directory. If you are developing at the command line, make sure that bin is in your path. The compiler requires a Java Runtime of 1.4 or greater. sedonac will look in the registry to find the path to your current Java VM. For more details about how sedonac starts up, use the --v command line switch (that's two dashes before the 'v'), which will trace the registry access and jvm.dll load. To verify sedonac is correctly installed, run with the -ver switch: D: \\s edona>sedonac -ver Sedona Compiler 1 .2.28 Copyright ( c ) 2007 -2013 Tridium, Inc. sedona.version = 1 .2.28 sedona.home = D: \\s edona java.home = C: \\P rogram Files ( x86 ) \\J ava \\j re7 java.version = 1 .7.0_13 Unix \u00b6 There is a bash shell script in adm/unix called init.sh that initializes your Sedona Framework development environment. In order to use this script, you must first export JAVA_HOME in your login script create a symbolic link in your home directory called sedonadev that points to your actual Sedona home directory. For example, ~/sedonadev > ~/repos/sedona-1.0/pub If you don't want to use this symbolic link, edit init.sh to explicitly set the sedona_home environment variable After doing the above configuration, change your login script to run init.sh . This script will make sure some key programs are in your path, check that all the python scripts have executable permissions, and create some useful aliases. There are two Unix specific commands that you should use for building in a Unix environment: makeunixvm.py : Compiles the Sedona VM (SVM) for Unix using gcc. Run makeunixvm -h for more details makeunixdev.py : Builds sedona.jar, sedonac.jar, all opensource kits, and makes the Unix SVM Java Command Line \u00b6 If you need to invoke Sedonac directly you can launch it directly with Java: Put lib/sedona.jar and lib/sedonac.jar in the classpath Pass the installation directory to the \"sedona.home\" system property Run the \"sedonac.Main\" class with the desired arguments For example: java -cp { lib } sedona.jar: { lib } sedonac.jar -Dsedona.home ={ home } sedonac.Main src/sox Environment \u00b6 You can rebuild from source using the python scripts in the adm directory (or adm/unix ). These scripts are used to rebuild the compiler itself and the SVM. In order to use the python scripts, you will need to install Python (version 2.7 or better). Also the following environment variables must be defined: sedona_home : directory of your Sedona Framework installation (the parent directory of adm, bin, lib, etc) java_home : directory of the Java JDK (1.4 or later). Note: the scripts use adm/jikes.exe to compile Java code, but still require the JDK for bin/jar.exe and jre/lib/rt.jar win_sdk : if you wish to compile the VM using the Visual Studio C compiler then win_sdk should reference your Windows development kit. Also make sure you have run the vcvars32.bat script included in your Visual Studio installation. Many users can skip this step, though, and just use the pre-built Win32 svm.exe provided in the bin directory To verify your environment you can run the adm/env.py script, which will print all the files and directories being used with your current setup. Common commands \u00b6 The following commands are commonly used when building and running the Sedona Framework: Command Outcome makesedona.py compile sedona runtime Java source into sedona.jar makesedonac.py compile sedonac Java source into sedonac.jar (depends on sedona.jar) makewinvm.py recompile svm.exe for Win32 using Visual Studio compiler sedonac src\\zoo\\kit.xml compile Sedona source for kit zoo into a kit file (you can also specify just src\\zoo ) sedonac scode\\zdevice.xml link Sedona kits specified by zdevice.xml into zdevice.scode image file sedonac apps\\bar.sax compile a SAX (application XML) file into a SAB (binary) file svm scode\\zdevice.scode apps\\bar.sab run Win32 SVM with the specified scode and app file svm scode\\zdevice.scode -test run test suite with the Win32 SVM and the specified scode file svm --plat For the open source Win32 and Unix SVM implementations, this allows you to run the SVM in platform mode . Running in platform mode allows the SVM to handle restart commands, and it will handle loading staged scode and sab files. The SVM must be running in platform mode to pass the certification test suite makedev.py recompile all the commonly used targets and run tests with the Win32 SVM Note Any command that builds the SVM will need to have the appropriate target toolchain set up first.","title":"Setup"},{"location":"quickstart/setup/#setup","text":"","title":"Setup"},{"location":"quickstart/setup/#overview","text":"The root directory of your Sedona Framework installation or development environment is referred to as Sedona home . Relative paths in this documentation always start from the Sedona home directory. Sedona home is organized into the following sub directories: adm : administration scripts used to build and test apps : Sedona application files (.sab and .sax formats) bin : Win32 binaries and some Unix shell scripts doc : documentation kits : directory for kit database lib : Java jar files and properties files manifests : directory for manifest database platforms : directory for platform database; also contains source files for Sedona Framework platforms scode : scode images, and linker files for creating them src : directory tree for Java, C, and Sedona source code","title":"Overview"},{"location":"quickstart/setup/#sedonac","text":"Sedona Framework development primarily centers around the tool sedonac . It functions as a compiler for Sedona applications as well as Sedona kits (library modules); its behavior depends on the input file it is processing.","title":"Sedonac"},{"location":"quickstart/setup/#windows","text":"For Windows you will be using the sedonac.exe launcher executable, located in the bin directory. If you are developing at the command line, make sure that bin is in your path. The compiler requires a Java Runtime of 1.4 or greater. sedonac will look in the registry to find the path to your current Java VM. For more details about how sedonac starts up, use the --v command line switch (that's two dashes before the 'v'), which will trace the registry access and jvm.dll load. To verify sedonac is correctly installed, run with the -ver switch: D: \\s edona>sedonac -ver Sedona Compiler 1 .2.28 Copyright ( c ) 2007 -2013 Tridium, Inc. sedona.version = 1 .2.28 sedona.home = D: \\s edona java.home = C: \\P rogram Files ( x86 ) \\J ava \\j re7 java.version = 1 .7.0_13","title":"Windows"},{"location":"quickstart/setup/#unix","text":"There is a bash shell script in adm/unix called init.sh that initializes your Sedona Framework development environment. In order to use this script, you must first export JAVA_HOME in your login script create a symbolic link in your home directory called sedonadev that points to your actual Sedona home directory. For example, ~/sedonadev > ~/repos/sedona-1.0/pub If you don't want to use this symbolic link, edit init.sh to explicitly set the sedona_home environment variable After doing the above configuration, change your login script to run init.sh . This script will make sure some key programs are in your path, check that all the python scripts have executable permissions, and create some useful aliases. There are two Unix specific commands that you should use for building in a Unix environment: makeunixvm.py : Compiles the Sedona VM (SVM) for Unix using gcc. Run makeunixvm -h for more details makeunixdev.py : Builds sedona.jar, sedonac.jar, all opensource kits, and makes the Unix SVM","title":"Unix"},{"location":"quickstart/setup/#java-command-line","text":"If you need to invoke Sedonac directly you can launch it directly with Java: Put lib/sedona.jar and lib/sedonac.jar in the classpath Pass the installation directory to the \"sedona.home\" system property Run the \"sedonac.Main\" class with the desired arguments For example: java -cp { lib } sedona.jar: { lib } sedonac.jar -Dsedona.home ={ home } sedonac.Main src/sox","title":"Java Command Line"},{"location":"quickstart/setup/#environment","text":"You can rebuild from source using the python scripts in the adm directory (or adm/unix ). These scripts are used to rebuild the compiler itself and the SVM. In order to use the python scripts, you will need to install Python (version 2.7 or better). Also the following environment variables must be defined: sedona_home : directory of your Sedona Framework installation (the parent directory of adm, bin, lib, etc) java_home : directory of the Java JDK (1.4 or later). Note: the scripts use adm/jikes.exe to compile Java code, but still require the JDK for bin/jar.exe and jre/lib/rt.jar win_sdk : if you wish to compile the VM using the Visual Studio C compiler then win_sdk should reference your Windows development kit. Also make sure you have run the vcvars32.bat script included in your Visual Studio installation. Many users can skip this step, though, and just use the pre-built Win32 svm.exe provided in the bin directory To verify your environment you can run the adm/env.py script, which will print all the files and directories being used with your current setup.","title":"Environment"},{"location":"quickstart/setup/#common-commands","text":"The following commands are commonly used when building and running the Sedona Framework: Command Outcome makesedona.py compile sedona runtime Java source into sedona.jar makesedonac.py compile sedonac Java source into sedonac.jar (depends on sedona.jar) makewinvm.py recompile svm.exe for Win32 using Visual Studio compiler sedonac src\\zoo\\kit.xml compile Sedona source for kit zoo into a kit file (you can also specify just src\\zoo ) sedonac scode\\zdevice.xml link Sedona kits specified by zdevice.xml into zdevice.scode image file sedonac apps\\bar.sax compile a SAX (application XML) file into a SAB (binary) file svm scode\\zdevice.scode apps\\bar.sab run Win32 SVM with the specified scode and app file svm scode\\zdevice.scode -test run test suite with the Win32 SVM and the specified scode file svm --plat For the open source Win32 and Unix SVM implementations, this allows you to run the SVM in platform mode . Running in platform mode allows the SVM to handle restart commands, and it will handle loading staged scode and sab files. The SVM must be running in platform mode to pass the certification test suite makedev.py recompile all the commonly used targets and run tests with the Win32 SVM Note Any command that builds the SVM will need to have the appropriate target toolchain set up first.","title":"Common commands"},{"location":"quickstart/tutorial/","text":"Tutorial \u00b6 Overview \u00b6 This tutorial takes you through the various development steps involved in building Sedona Framework applications: Build a new kit and component Build a new scode image Build an application Run the application It is recommended that you read the Architecture chapter before exploring this tutorial. Refer to the diagram , which illustrates the work flow this tutorial will take. Also make sure you have your Sedona Framework environment setup correctly before. Build New Kit \u00b6 Kits are modules used to organize Sedona code. For this example we will create a new kit called tutorial . In our kit we will create a component called Add , which adds two inputs together. First let's create a directory under src called \"tutorial\", with two text files: src/ tutorial/ +- kit.xml +- Add.sedona For more information see Structure to see how kits are organized. The kit.xml file is used to define the kit's meta-data for the compiler: <sedonaKit name= \"tutorial\" vendor= \"Tridium\" description= \"blah\" > <depend on= \"sys 1.2+\" /> <source dir= \".\" /> </sedonaKit> The kit.xml file specifies the name of our kit, a short description, dependencies, and the directories of source code. (The vendor attribute specifies the company that developed the kit - for the purposes of the tutorial leave this as \"Tridium\" because otherwise the kit name must be prefixed with the vendor name.) For more information see Kits and Compile Kit . The \"Add.sedona\" file defines the source code for our new component: public class Add extends Component { property float out property float in1 property float in2 override void execute () { out : = in1 + in2 } } The Add component is pretty simple - it declares two inputs and an output. When the component is \"executed\" we add the two inputs and update the output. For more information see Components To compile our new kit we just need to run sedonac against our directory or the kit.xml file: C: \\S edona \\S edona-1.2.27 \\s rc \\t utorial>dir Volume in drive C has no label. Volume Serial Number is 50BC-4286 Directory of C: \\S edona \\S edona-1.2.27 \\s rc \\t utorial 02 /25/2013 09 :57 AM <DIR> . 02 /25/2013 09 :57 AM <DIR> .. 02 /25/2013 09 :52 AM 160 Add.sedona 02 /25/2013 09 :55 AM 131 kit.xml 2 File ( s ) 291 bytes 2 Dir ( s ) 170 ,500,431,872 bytes free C: \\S edona \\S edona-1.2.27 \\s rc \\t utorial>sedonac kit.xml Parse [ 1 files ] WriteKit [ C: \\S edona \\S edona-1.2.27 \\k its \\t utorial \\t utorial-89858e3e-1.2.27.kit ] WriteManifest [ C: \\S edona \\S edona-1.2.27 \\m anifests \\t utorial \\t utorial-89858e3e.xml ] *** Success! *** If successful, you should have a new kit file in your kits/tutorial directory. You can open this file in a tool like WinZip to explore the compiler's output. For more information see Sedonac . If you have trouble running sedonac, then see Setup . Build New SCode Image \u00b6 Kits are units of deployment, but are not run directly by the SVM. First we have to compile a set of kits into an scode image that can be run directly by the SVM. Create a new directory called tutorialApp with one file: tutorialApp/ +- kits.xml The \"kits.xml\" file specifies the kits we wish to compile into an image: <sedonaCode endian= \"little\" blockSize= \"4\" refSize= \"4\" main= \"sys::Sys.main\" debug= \"true\" test= \"true\" > <depend on= \"sys 1.2+\" /> <depend on= \"sox 1.2+\" /> <depend on= \"inet 1.2+\" /> <depend on= \"web 1.2+\" /> <depend on= \"func 1.2+\" /> <depend on= \"platWin32 1.2+\" /> <depend on= \"tutorial 1.2+\" /> </sedonaCode> Info See Sedonac for more information on these settings. Run sedonac on this file to produce an scode image: C: \\S edona \\S edona-1.2.27 \\t utorialApp>sedonac kits.xml ReadKits [ 7 kits ] WriteImage [ C: \\S edona \\S edona-1.2.27 \\t utorialApp \\k its.scode ] ( 89088 bytes ) +---------------------------------- | Data: 7 .8kb ( 8020 bytes ) | Code: 87kb ( 89088 bytes ) | Total: 94 .8kb ( 97108 bytes ) +---------------------------------- *** Success! *** C: \\S edona \\S edona-1.2.27 \\t utorialApp>dir Volume in drive C has no label. Volume Serial Number is 50BC-4286 Directory of C: \\S edona \\S edona-1.2.27 \\t utorialApp 02 /25/2013 10 :30 AM <DIR> . 02 /25/2013 10 :30 AM <DIR> .. 02 /25/2013 10 :30 AM 89 ,088 kits.scode 02 /25/2013 09 :57 AM 336 kits.xml 2 File ( s ) 89 ,424 bytes 2 Dir ( s ) 170 ,506,817,536 bytes free If successful, then you should have now have a kits.scode file. Build New App \u00b6 Sedona is a component oriented language that enables you to build new applications by assembling components. The application file stores a tree of components, their configuration properties, and how they are linked together. Typically applications are built with graphical tools. For this tutorial we will hand code an application file using XML. In the tutorialApp directory let's create a new app.sax file: <sedonaApp> <schema> <kit name= 'sys' /> <kit name= 'sox' /> <kit name= 'inet' /> <kit name= 'web' /> <kit name= 'func' /> <kit name= 'platWin32' /> <kit name= 'tutorial' /> </schema> <app> <comp name= \"plat\" type= \"platWin32::Win32PlatformService\" /> <comp name= \"users\" type= \"sys::UserService\" > <comp name= \"admin\" type= \"sys::User\" > <prop name= \"cred\" val= \"hE49ksThgAeLkWB3NUU1NWeDO54=\" /> <prop name= \"perm\" val= \"2147483647\" /> <prop name= \"prov\" val= \"255\" /> </comp> </comp> <comp name= \"sox\" type= \"sox::SoxService\" /> <comp name= \"web\" type= \"web::WebService\" > <prop name= \"port\" val= \"8080\" /> </comp> <comp name= \"rampA\" type= \"func::Ramp\" /> <comp name= \"rampB\" type= \"func::Ramp\" /> <comp name= \"add\" type= \"tutorial::Add\" id= \"12\" /> </app> <links> <link from= \"/rampA.out\" to= \"/add.in1\" /> <link from= \"/rampB.out\" to= \"/add.in2\" /> </links> </sedonaApp> The file above declares four Service components: The Win32PlatformService component provides access to platform properties and other platform-specific features. It is a subclass of sys::PlatformService class which provides generic platform functionality. Sedona running on another platform would need a different PlatformService subclass designed for that platform. The UserService component contains an entry for each authorized user, specifying the user's credentials and privileges. The properties here set up a user named \"admin\" with a blank password. (Using a blank password for 'admin' should NOT be done on real Sedona devices! We only do it here to simplify the tutorial.) The SoxService component is required in order to create and use a Sox connection to or from the device The WebService component will run an HTTP server so we can use a browser for debugging. The web server's port is set to 8080 Note Platforms with limited resources may not be able to run a web server. We then declare two func::Ramp components, which are used to generate dummy data. Finally we declare a tutorial::Add component, which is the component we built ourselves in the step above. In the links section we create links between the Ramp component outputs and the inputs to our Add block to create control flow. Sedona Framework-enabled devices don't run the XML file directly, so now we need to compile the XML into a binary format that the SVM can use directly. Do this by running sedonac on app.sax : C: \\S edona \\S edona-1.2.27 \\t utorialApp>sedonac app.sax ConvertAppFile [ C: \\S edona \\S edona-1.2.27 \\t utorialApp \\a pp.sax -> C: \\S edona \\S edona-1.2.27 \\t utorialApp \\a pp.sab ] +---------------------------------- | RAM: 14 .5kb ( 14848 bytes ) | FLASH: 0 .3kb ( 356 bytes ) +---------------------------------- *** Success! *** Now we should have a file called app.sab . See Apps for more information. Run App \u00b6 If you have followed the steps above, we have: Built a new kit called tutorial with a component called Add Compiled our new kit into an scode image called kits.scode Defined and compiled an app into a file called app.sab At this point we can run our application using the SVM. Assuming we are running on Windows we can run our application as follows: C: \\S edona \\S edona-1.2.27 \\t utorialApp>svm kits.scode app.sab Sedona VM 1 .2.27 buildDate: Oct 17 2012 08 :40:10 endian: little blockSize: 4 refSize: 4 -- MESSAGE [ sys::App ] starting -- MESSAGE [ sox::SoxService ] started port = 1876 -- MESSAGE [ sox::SoxService ] DASP Discovery enabled -- MESSAGE [ web::WebService ] started port = 8080 -- MESSAGE [ sys::App ] running Here we just pass our code and application filenames to the prebuilt Win32 \"svm.exe\" executable included with the Sedona open source. If you are running on a different platform you will need an SVM executable designed for that platform - see Porting . Note that if you plan to restart or reboot the Sedona VM remotely, you should start the Sedona VM with the --plat option to run it in \"platform mode\". (See Common Commands for more details.) Now that the SVM is running the application, you should be able to access it with your browser at http://localhost:8080/ . You can use the spy URL http://localhost:8080/spy/app/12 to view the current values of your tutorial::Add component. Hit refresh a couple times to see how the inputs and output change in real-time. If you have a remote administration tool such as the Sedona Framework Workbench, you should now be able to connect to Sox port 1876 with the username \"admin\" and empty password. Refer to your Sedona Framework tool documentation for more information. Success! \u00b6 Congratulations, you've just built and deployed your first Sedona Framework application! This tutorial illustrates just the very basics of Sedona, using only the command line tools. Continue to explore sedonadev.org to learn more about Sedona and the tools available for managing Sedona devices. Info As of summer of 2018, SedonaDev website was taken down by Tridium.","title":"Tutorial"},{"location":"quickstart/tutorial/#tutorial","text":"","title":"Tutorial"},{"location":"quickstart/tutorial/#overview","text":"This tutorial takes you through the various development steps involved in building Sedona Framework applications: Build a new kit and component Build a new scode image Build an application Run the application It is recommended that you read the Architecture chapter before exploring this tutorial. Refer to the diagram , which illustrates the work flow this tutorial will take. Also make sure you have your Sedona Framework environment setup correctly before.","title":"Overview"},{"location":"quickstart/tutorial/#build-new-kit","text":"Kits are modules used to organize Sedona code. For this example we will create a new kit called tutorial . In our kit we will create a component called Add , which adds two inputs together. First let's create a directory under src called \"tutorial\", with two text files: src/ tutorial/ +- kit.xml +- Add.sedona For more information see Structure to see how kits are organized. The kit.xml file is used to define the kit's meta-data for the compiler: <sedonaKit name= \"tutorial\" vendor= \"Tridium\" description= \"blah\" > <depend on= \"sys 1.2+\" /> <source dir= \".\" /> </sedonaKit> The kit.xml file specifies the name of our kit, a short description, dependencies, and the directories of source code. (The vendor attribute specifies the company that developed the kit - for the purposes of the tutorial leave this as \"Tridium\" because otherwise the kit name must be prefixed with the vendor name.) For more information see Kits and Compile Kit . The \"Add.sedona\" file defines the source code for our new component: public class Add extends Component { property float out property float in1 property float in2 override void execute () { out : = in1 + in2 } } The Add component is pretty simple - it declares two inputs and an output. When the component is \"executed\" we add the two inputs and update the output. For more information see Components To compile our new kit we just need to run sedonac against our directory or the kit.xml file: C: \\S edona \\S edona-1.2.27 \\s rc \\t utorial>dir Volume in drive C has no label. Volume Serial Number is 50BC-4286 Directory of C: \\S edona \\S edona-1.2.27 \\s rc \\t utorial 02 /25/2013 09 :57 AM <DIR> . 02 /25/2013 09 :57 AM <DIR> .. 02 /25/2013 09 :52 AM 160 Add.sedona 02 /25/2013 09 :55 AM 131 kit.xml 2 File ( s ) 291 bytes 2 Dir ( s ) 170 ,500,431,872 bytes free C: \\S edona \\S edona-1.2.27 \\s rc \\t utorial>sedonac kit.xml Parse [ 1 files ] WriteKit [ C: \\S edona \\S edona-1.2.27 \\k its \\t utorial \\t utorial-89858e3e-1.2.27.kit ] WriteManifest [ C: \\S edona \\S edona-1.2.27 \\m anifests \\t utorial \\t utorial-89858e3e.xml ] *** Success! *** If successful, you should have a new kit file in your kits/tutorial directory. You can open this file in a tool like WinZip to explore the compiler's output. For more information see Sedonac . If you have trouble running sedonac, then see Setup .","title":"Build New Kit"},{"location":"quickstart/tutorial/#build-new-scode-image","text":"Kits are units of deployment, but are not run directly by the SVM. First we have to compile a set of kits into an scode image that can be run directly by the SVM. Create a new directory called tutorialApp with one file: tutorialApp/ +- kits.xml The \"kits.xml\" file specifies the kits we wish to compile into an image: <sedonaCode endian= \"little\" blockSize= \"4\" refSize= \"4\" main= \"sys::Sys.main\" debug= \"true\" test= \"true\" > <depend on= \"sys 1.2+\" /> <depend on= \"sox 1.2+\" /> <depend on= \"inet 1.2+\" /> <depend on= \"web 1.2+\" /> <depend on= \"func 1.2+\" /> <depend on= \"platWin32 1.2+\" /> <depend on= \"tutorial 1.2+\" /> </sedonaCode> Info See Sedonac for more information on these settings. Run sedonac on this file to produce an scode image: C: \\S edona \\S edona-1.2.27 \\t utorialApp>sedonac kits.xml ReadKits [ 7 kits ] WriteImage [ C: \\S edona \\S edona-1.2.27 \\t utorialApp \\k its.scode ] ( 89088 bytes ) +---------------------------------- | Data: 7 .8kb ( 8020 bytes ) | Code: 87kb ( 89088 bytes ) | Total: 94 .8kb ( 97108 bytes ) +---------------------------------- *** Success! *** C: \\S edona \\S edona-1.2.27 \\t utorialApp>dir Volume in drive C has no label. Volume Serial Number is 50BC-4286 Directory of C: \\S edona \\S edona-1.2.27 \\t utorialApp 02 /25/2013 10 :30 AM <DIR> . 02 /25/2013 10 :30 AM <DIR> .. 02 /25/2013 10 :30 AM 89 ,088 kits.scode 02 /25/2013 09 :57 AM 336 kits.xml 2 File ( s ) 89 ,424 bytes 2 Dir ( s ) 170 ,506,817,536 bytes free If successful, then you should have now have a kits.scode file.","title":"Build New SCode Image"},{"location":"quickstart/tutorial/#build-new-app","text":"Sedona is a component oriented language that enables you to build new applications by assembling components. The application file stores a tree of components, their configuration properties, and how they are linked together. Typically applications are built with graphical tools. For this tutorial we will hand code an application file using XML. In the tutorialApp directory let's create a new app.sax file: <sedonaApp> <schema> <kit name= 'sys' /> <kit name= 'sox' /> <kit name= 'inet' /> <kit name= 'web' /> <kit name= 'func' /> <kit name= 'platWin32' /> <kit name= 'tutorial' /> </schema> <app> <comp name= \"plat\" type= \"platWin32::Win32PlatformService\" /> <comp name= \"users\" type= \"sys::UserService\" > <comp name= \"admin\" type= \"sys::User\" > <prop name= \"cred\" val= \"hE49ksThgAeLkWB3NUU1NWeDO54=\" /> <prop name= \"perm\" val= \"2147483647\" /> <prop name= \"prov\" val= \"255\" /> </comp> </comp> <comp name= \"sox\" type= \"sox::SoxService\" /> <comp name= \"web\" type= \"web::WebService\" > <prop name= \"port\" val= \"8080\" /> </comp> <comp name= \"rampA\" type= \"func::Ramp\" /> <comp name= \"rampB\" type= \"func::Ramp\" /> <comp name= \"add\" type= \"tutorial::Add\" id= \"12\" /> </app> <links> <link from= \"/rampA.out\" to= \"/add.in1\" /> <link from= \"/rampB.out\" to= \"/add.in2\" /> </links> </sedonaApp> The file above declares four Service components: The Win32PlatformService component provides access to platform properties and other platform-specific features. It is a subclass of sys::PlatformService class which provides generic platform functionality. Sedona running on another platform would need a different PlatformService subclass designed for that platform. The UserService component contains an entry for each authorized user, specifying the user's credentials and privileges. The properties here set up a user named \"admin\" with a blank password. (Using a blank password for 'admin' should NOT be done on real Sedona devices! We only do it here to simplify the tutorial.) The SoxService component is required in order to create and use a Sox connection to or from the device The WebService component will run an HTTP server so we can use a browser for debugging. The web server's port is set to 8080 Note Platforms with limited resources may not be able to run a web server. We then declare two func::Ramp components, which are used to generate dummy data. Finally we declare a tutorial::Add component, which is the component we built ourselves in the step above. In the links section we create links between the Ramp component outputs and the inputs to our Add block to create control flow. Sedona Framework-enabled devices don't run the XML file directly, so now we need to compile the XML into a binary format that the SVM can use directly. Do this by running sedonac on app.sax : C: \\S edona \\S edona-1.2.27 \\t utorialApp>sedonac app.sax ConvertAppFile [ C: \\S edona \\S edona-1.2.27 \\t utorialApp \\a pp.sax -> C: \\S edona \\S edona-1.2.27 \\t utorialApp \\a pp.sab ] +---------------------------------- | RAM: 14 .5kb ( 14848 bytes ) | FLASH: 0 .3kb ( 356 bytes ) +---------------------------------- *** Success! *** Now we should have a file called app.sab . See Apps for more information.","title":"Build New App"},{"location":"quickstart/tutorial/#run-app","text":"If you have followed the steps above, we have: Built a new kit called tutorial with a component called Add Compiled our new kit into an scode image called kits.scode Defined and compiled an app into a file called app.sab At this point we can run our application using the SVM. Assuming we are running on Windows we can run our application as follows: C: \\S edona \\S edona-1.2.27 \\t utorialApp>svm kits.scode app.sab Sedona VM 1 .2.27 buildDate: Oct 17 2012 08 :40:10 endian: little blockSize: 4 refSize: 4 -- MESSAGE [ sys::App ] starting -- MESSAGE [ sox::SoxService ] started port = 1876 -- MESSAGE [ sox::SoxService ] DASP Discovery enabled -- MESSAGE [ web::WebService ] started port = 8080 -- MESSAGE [ sys::App ] running Here we just pass our code and application filenames to the prebuilt Win32 \"svm.exe\" executable included with the Sedona open source. If you are running on a different platform you will need an SVM executable designed for that platform - see Porting . Note that if you plan to restart or reboot the Sedona VM remotely, you should start the Sedona VM with the --plat option to run it in \"platform mode\". (See Common Commands for more details.) Now that the SVM is running the application, you should be able to access it with your browser at http://localhost:8080/ . You can use the spy URL http://localhost:8080/spy/app/12 to view the current values of your tutorial::Add component. Hit refresh a couple times to see how the inputs and output change in real-time. If you have a remote administration tool such as the Sedona Framework Workbench, you should now be able to connect to Sox port 1876 with the username \"admin\" and empty password. Refer to your Sedona Framework tool documentation for more information.","title":"Run App"},{"location":"quickstart/tutorial/#success","text":"Congratulations, you've just built and deployed your first Sedona Framework application! This tutorial illustrates just the very basics of Sedona, using only the command line tools. Continue to explore sedonadev.org to learn more about Sedona and the tools available for managing Sedona devices. Info As of summer of 2018, SedonaDev website was taken down by Tridium.","title":"Success!"},{"location":"releases/newFor12/","text":"New for v1.2 \u00b6 Highlights \u00b6 With the release of Sedona Framework 1.2 a number of features have been added. Versioning : You didn't miss anything, the Sedona open source version skipped from 1.0 straight to 1.2 Kit and Platform Manifest Server : Kit and platform manifest files can now be stored directly on the Sedona device, if desired, and served automatically to Sox clients as needed. See the section Manifest Server to learn how to implement it on your platform Device Discovery : Sedona devices can now be discovered automatically using IP multicast. Details can be found in the section on Device Discovery Multi-rate App Components : Components now have some control over when the App cycle executes their child components. This can be used, for example, to have certain child components execute at a lower rate than the App cycle rate. See the Apps chapter for more details Device Simulation : New capability has been added to sedonac to make it easy to create a simulator version of any Sedona VM. Apps that depend on kits with platform-specific native methods can now be run on a different host platform using a simulator SVM. Detailed instructions on how to create a simulator SVM will be presented in the Sedona Device Simulator chapter Refactored Control Kit : The control kit has been split into several smaller kits, organized roughly by functionality. This should make it easier to use the control components on resource-limited devices Prioritized Array Components : A new kit pricomp offers components with prioritized inputs, including override capability: Each component in the pricomp kit uses a 16-level priority scheme, with inputs in1 (highest) through in16 (lowest) plus a fallback property, and a single output out . It also has override actions that explicitly set certain input slots. The value of out is determined by a priority scan of the inputs, looking for a valid value at in1 first, then each of the other inputs in turn, all the way down to in16 and then fallback . (A \"valid\" value is one that is not set to null , or its equivalent for that property's type.) The highest priority valid input propagates to the out slot. Most of the component inputs are linkable, with the few exceptions being inputs that can be set only via right-click override actions. Overridden inputs are evaluated along with the linkable ones, using the same priority scheme. PrioritizedBoolean components also offer built-in timers for minimum on and/or off times to protect sensitive equipment. See the pricomp kit docs for more about these components.","title":"v1.2"},{"location":"releases/newFor12/#new-for-v12","text":"","title":"New for v1.2"},{"location":"releases/newFor12/#highlights","text":"With the release of Sedona Framework 1.2 a number of features have been added. Versioning : You didn't miss anything, the Sedona open source version skipped from 1.0 straight to 1.2 Kit and Platform Manifest Server : Kit and platform manifest files can now be stored directly on the Sedona device, if desired, and served automatically to Sox clients as needed. See the section Manifest Server to learn how to implement it on your platform Device Discovery : Sedona devices can now be discovered automatically using IP multicast. Details can be found in the section on Device Discovery Multi-rate App Components : Components now have some control over when the App cycle executes their child components. This can be used, for example, to have certain child components execute at a lower rate than the App cycle rate. See the Apps chapter for more details Device Simulation : New capability has been added to sedonac to make it easy to create a simulator version of any Sedona VM. Apps that depend on kits with platform-specific native methods can now be run on a different host platform using a simulator SVM. Detailed instructions on how to create a simulator SVM will be presented in the Sedona Device Simulator chapter Refactored Control Kit : The control kit has been split into several smaller kits, organized roughly by functionality. This should make it easier to use the control components on resource-limited devices Prioritized Array Components : A new kit pricomp offers components with prioritized inputs, including override capability: Each component in the pricomp kit uses a 16-level priority scheme, with inputs in1 (highest) through in16 (lowest) plus a fallback property, and a single output out . It also has override actions that explicitly set certain input slots. The value of out is determined by a priority scan of the inputs, looking for a valid value at in1 first, then each of the other inputs in turn, all the way down to in16 and then fallback . (A \"valid\" value is one that is not set to null , or its equivalent for that property's type.) The highest priority valid input propagates to the out slot. Most of the component inputs are linkable, with the few exceptions being inputs that can be set only via right-click override actions. Overridden inputs are evaluated along with the linkable ones, using the same priority scheme. PrioritizedBoolean components also offer built-in timers for minimum on and/or off times to protect sensitive equipment. See the pricomp kit docs for more about these components.","title":"Highlights"}]}