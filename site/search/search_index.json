{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sedona Documentation \u00b6 Disclaimer \u00b6 Tridium no longer hosts Sedona documentation, therefore, this is the hosted/ maintained version of the original documentation contributed by Tridium under APL (Academic Public License v3.0) . Please check Sedona Alliance for background. Note All the older doc pages carry the 'Sedona Framework' Logo on top, which is copyright and trademarked by Tridium. Getting Started \u00b6 Introduction : introduction to the Sedona Framework Setup : getting your development environment setup Architecture : the big picture Tutorial : step by step walk thru example Sedona Language \u00b6 Language : overview of the Sedona language Primitives : basic built-in types Expressions : review of expression constructs Statements : review of statement constructs Classes : class types Fields : field slots Methods : method slots Components : the Sedona Framework component model Reflection : the Sedona Framework reflection APIs Arrays : how arrays work Memory : how memory is laid out and utilized Native Methods : binding APIs to native implementations written in C Logging : how to embed logging into Sedona code Apps \u00b6 Apps : the Sedona Framework application model Security : the Sedona Framework's security model Deployment \u00b6 Kits : unit of modularity, versioning, and dependencies Schema : manifests: type meta-data and schemas Sedona Framework Platforms \u00b6 Platform Definition : the platform definition XML file Platform Archive : metadata about a unique Sedona Framework platform Platform Tutorial : how to create a Sedona platform Sedona Device Simulator : creating special Sedona VMs that run apps for other platforms Sedona Framework Certified Platforms : creating platforms that pass Sedona Framework certification Development \u00b6 Sedonac : command line sedonac tool Testing : how to use the built-in test harness Porting : how to port the SVM to new platforms Niagara AX : how to integrate Sedona components with the Niagara AX Framework Networking \u00b6 Networking : Overview of network communications DASP : Datagram Authenticated Session Protocol Sox : Sox protocol: provisioning and configuration Device Discovery : Sedona device discovery using DASP Appendix \u00b6 License : Academic Free License 3.0 Conventions : Coding conventions SCode Format : reference for scode image binary format Sedona Grammar : Sedona language grammar Release Notes \u00b6 New for 1.2 : New features in Sedona Framework 1.2 APIs \u00b6 API Index : API Index for all available Sedona kits","title":"Index"},{"location":"#sedona-documentation","text":"","title":"Sedona Documentation"},{"location":"#disclaimer","text":"Tridium no longer hosts Sedona documentation, therefore, this is the hosted/ maintained version of the original documentation contributed by Tridium under APL (Academic Public License v3.0) . Please check Sedona Alliance for background. Note All the older doc pages carry the 'Sedona Framework' Logo on top, which is copyright and trademarked by Tridium.","title":"Disclaimer"},{"location":"#getting-started","text":"Introduction : introduction to the Sedona Framework Setup : getting your development environment setup Architecture : the big picture Tutorial : step by step walk thru example","title":"Getting Started"},{"location":"#sedona-language","text":"Language : overview of the Sedona language Primitives : basic built-in types Expressions : review of expression constructs Statements : review of statement constructs Classes : class types Fields : field slots Methods : method slots Components : the Sedona Framework component model Reflection : the Sedona Framework reflection APIs Arrays : how arrays work Memory : how memory is laid out and utilized Native Methods : binding APIs to native implementations written in C Logging : how to embed logging into Sedona code","title":"Sedona Language"},{"location":"#apps","text":"Apps : the Sedona Framework application model Security : the Sedona Framework's security model","title":"Apps"},{"location":"#deployment","text":"Kits : unit of modularity, versioning, and dependencies Schema : manifests: type meta-data and schemas","title":"Deployment"},{"location":"#sedona-framework-platforms","text":"Platform Definition : the platform definition XML file Platform Archive : metadata about a unique Sedona Framework platform Platform Tutorial : how to create a Sedona platform Sedona Device Simulator : creating special Sedona VMs that run apps for other platforms Sedona Framework Certified Platforms : creating platforms that pass Sedona Framework certification","title":"Sedona Framework Platforms"},{"location":"#development","text":"Sedonac : command line sedonac tool Testing : how to use the built-in test harness Porting : how to port the SVM to new platforms Niagara AX : how to integrate Sedona components with the Niagara AX Framework","title":"Development"},{"location":"#networking","text":"Networking : Overview of network communications DASP : Datagram Authenticated Session Protocol Sox : Sox protocol: provisioning and configuration Device Discovery : Sedona device discovery using DASP","title":"Networking"},{"location":"#appendix","text":"License : Academic Free License 3.0 Conventions : Coding conventions SCode Format : reference for scode image binary format Sedona Grammar : Sedona language grammar","title":"Appendix"},{"location":"#release-notes","text":"New for 1.2 : New features in Sedona Framework 1.2","title":"Release Notes"},{"location":"#apis","text":"API Index : API Index for all available Sedona kits","title":"APIs"},{"location":"api/api/","text":"API \u00b6 Doc Home > API Index Kits Description basicSchedule basic schedule functions control Basic function block library datetime date time functions datetimeStd date time OS service using stdlib driver general driver func Basic function block library hvac HVAC function block library inet IP and UDP/TCP Socket APIs logManager Support for managing logs logic Logic function block library math Math function block library platUnix Platform support for Unix based devices platWin32 Platform support for Windows based devices pricomp Priority array component pstore Persistent random access, block storage for app data serial Serial I/O support sox Sox service for remote management soxcert Kit for use in sox certification tests sys Sedona core system module timing Timing function block library types Basic types and constants web Web service and servlet engine Doc Home > API Index","title":"API"},{"location":"api/api/#api","text":"Doc Home > API Index Kits Description basicSchedule basic schedule functions control Basic function block library datetime date time functions datetimeStd date time OS service using stdlib driver general driver func Basic function block library hvac HVAC function block library inet IP and UDP/TCP Socket APIs logManager Support for managing logs logic Logic function block library math Math function block library platUnix Platform support for Unix based devices platWin32 Platform support for Windows based devices pricomp Priority array component pstore Persistent random access, block storage for app data serial Serial I/O support sox Sox service for remote management soxcert Kit for use in sox certification tests sys Sedona core system module timing Timing function block library types Basic types and constants web Web service and servlet engine Doc Home > API Index","title":"API"},{"location":"api/basicSchedule/","text":"basicSchedule \u00b6 Doc Home > API Index > basicSchedule basic schedule functions DailySchedule \u00b6 DailyScheduleBool \u00b6 DailyScheduleFloat \u00b6 Doc Home > API Index > basicSchedule","title":"Index"},{"location":"api/basicSchedule/#basicschedule","text":"Doc Home > API Index > basicSchedule basic schedule functions","title":"basicSchedule"},{"location":"api/basicSchedule/#dailyschedule","text":"","title":"DailySchedule"},{"location":"api/basicSchedule/#dailyschedulebool","text":"","title":"DailyScheduleBool"},{"location":"api/basicSchedule/#dailyschedulefloat","text":"Doc Home > API Index > basicSchedule","title":"DailyScheduleFloat"},{"location":"api/basicSchedule/DailySchedule/","text":"DailySchedule \u00b6 Doc Home > API Index > basicSchedule > DailySchedule Inheritance \u00b6 sys::Obj sys::Virtual sys::Component basicSchedule::DailySchedule public abstract class DailySchedule DailySchedule represents a simple daily schedule with up to two active periods. Each active period is defined by a start time and duration. If the duration is zero, the period is disabled. If the periods overlap, then first period (defined by start1 and dur1) take precedence. If the duration extends past midnight, then the active period will span two separate calendar days. Fields \u00b6 dtSrvc \u00b6 public DateTimeService dtSrvc dur1 \u00b6 public property short dur1 [unit=\"minute\", min=0, max=1440, config] Duration for first active period, expressed in minutes after midnight dur2 \u00b6 public property short dur2 [unit=\"minute\", min=0, max=1440, config] Duration for the second active period, expressed in minutes after midnight minsInDay \u00b6 public static const define int minsInDay output1 \u00b6 public static const define int output1 output2 \u00b6 public static const define int output2 outputDefault \u00b6 public static const define int outputDefault start1 \u00b6 public property short start1 [unit=\"minute\", config] Start time for first active period, expressed in minutes after midnight start2 \u00b6 public property short start2 [unit=\"minute\", config] Start time for second active period, expressed in minutes after midnight Methods \u00b6 execute \u00b6 public virtual override void execute() setOutValue \u00b6 public virtual void setOutValue(int activeVal) Subclasses of DailySchedule must implement this to set the proper output value based on current time and schedule configuration start \u00b6 public virtual override void start() Doc Home > API Index > basicSchedule > DailySchedule","title":"DailySchedule"},{"location":"api/basicSchedule/DailySchedule/#dailyschedule","text":"Doc Home > API Index > basicSchedule > DailySchedule","title":"DailySchedule"},{"location":"api/basicSchedule/DailySchedule/#inheritance","text":"sys::Obj sys::Virtual sys::Component basicSchedule::DailySchedule public abstract class DailySchedule DailySchedule represents a simple daily schedule with up to two active periods. Each active period is defined by a start time and duration. If the duration is zero, the period is disabled. If the periods overlap, then first period (defined by start1 and dur1) take precedence. If the duration extends past midnight, then the active period will span two separate calendar days.","title":"Inheritance"},{"location":"api/basicSchedule/DailySchedule/#fields","text":"","title":"Fields"},{"location":"api/basicSchedule/DailySchedule/#dtsrvc","text":"public DateTimeService dtSrvc","title":"dtSrvc"},{"location":"api/basicSchedule/DailySchedule/#dur1","text":"public property short dur1 [unit=\"minute\", min=0, max=1440, config] Duration for first active period, expressed in minutes after midnight","title":"dur1"},{"location":"api/basicSchedule/DailySchedule/#dur2","text":"public property short dur2 [unit=\"minute\", min=0, max=1440, config] Duration for the second active period, expressed in minutes after midnight","title":"dur2"},{"location":"api/basicSchedule/DailySchedule/#minsinday","text":"public static const define int minsInDay","title":"minsInDay"},{"location":"api/basicSchedule/DailySchedule/#output1","text":"public static const define int output1","title":"output1"},{"location":"api/basicSchedule/DailySchedule/#output2","text":"public static const define int output2","title":"output2"},{"location":"api/basicSchedule/DailySchedule/#outputdefault","text":"public static const define int outputDefault","title":"outputDefault"},{"location":"api/basicSchedule/DailySchedule/#start1","text":"public property short start1 [unit=\"minute\", config] Start time for first active period, expressed in minutes after midnight","title":"start1"},{"location":"api/basicSchedule/DailySchedule/#start2","text":"public property short start2 [unit=\"minute\", config] Start time for second active period, expressed in minutes after midnight","title":"start2"},{"location":"api/basicSchedule/DailySchedule/#methods","text":"","title":"Methods"},{"location":"api/basicSchedule/DailySchedule/#execute","text":"public virtual override void execute()","title":"execute"},{"location":"api/basicSchedule/DailySchedule/#setoutvalue","text":"public virtual void setOutValue(int activeVal) Subclasses of DailySchedule must implement this to set the proper output value based on current time and schedule configuration","title":"setOutValue"},{"location":"api/basicSchedule/DailySchedule/#start","text":"public virtual override void start() Doc Home > API Index > basicSchedule > DailySchedule","title":"start"},{"location":"api/basicSchedule/DailyScheduleBool/","text":"DailyScheduleBool \u00b6 Doc Home > API Index > basicSchedule > DailyScheduleBool Inheritance \u00b6 sys::Obj sys::Virtual sys::Component basicSchedule::DailySchedule basicSchedule::DailyScheduleBool public class DailyScheduleBool DailyScheduleBool extends DailySchedule to provide a boolean output Fields \u00b6 defVal \u00b6 public property bool defVal [config] Output value for periods other than active1 / active2 out \u00b6 public property bool out Current schedule output val1 \u00b6 public property bool val1 [config] Output value for active period 1 val2 \u00b6 public property bool val2 [config] Output value for active period 2 Methods \u00b6 setOutValue \u00b6 public override void setOutValue(int activeVal) Doc Home > API Index > basicSchedule > DailyScheduleBool","title":"DailyScheduleBool"},{"location":"api/basicSchedule/DailyScheduleBool/#dailyschedulebool","text":"Doc Home > API Index > basicSchedule > DailyScheduleBool","title":"DailyScheduleBool"},{"location":"api/basicSchedule/DailyScheduleBool/#inheritance","text":"sys::Obj sys::Virtual sys::Component basicSchedule::DailySchedule basicSchedule::DailyScheduleBool public class DailyScheduleBool DailyScheduleBool extends DailySchedule to provide a boolean output","title":"Inheritance"},{"location":"api/basicSchedule/DailyScheduleBool/#fields","text":"","title":"Fields"},{"location":"api/basicSchedule/DailyScheduleBool/#defval","text":"public property bool defVal [config] Output value for periods other than active1 / active2","title":"defVal"},{"location":"api/basicSchedule/DailyScheduleBool/#out","text":"public property bool out Current schedule output","title":"out"},{"location":"api/basicSchedule/DailyScheduleBool/#val1","text":"public property bool val1 [config] Output value for active period 1","title":"val1"},{"location":"api/basicSchedule/DailyScheduleBool/#val2","text":"public property bool val2 [config] Output value for active period 2","title":"val2"},{"location":"api/basicSchedule/DailyScheduleBool/#methods","text":"","title":"Methods"},{"location":"api/basicSchedule/DailyScheduleBool/#setoutvalue","text":"public override void setOutValue(int activeVal) Doc Home > API Index > basicSchedule > DailyScheduleBool","title":"setOutValue"},{"location":"api/basicSchedule/DailyScheduleFloat/","text":"DailyScheduleFloat \u00b6 Doc Home > API Index > basicSchedule > DailyScheduleFloat Inheritance \u00b6 sys::Obj sys::Virtual sys::Component basicSchedule::DailySchedule basicSchedule::DailyScheduleFloat public class DailyScheduleFloat DailyScheduleFloat extends DailySchedule to provide a float output Fields \u00b6 defVal \u00b6 public property float defVal [config] Output value for periods other than active1 / active2 out \u00b6 public property float out Current schedule output val1 \u00b6 public property float val1 [config] Output value for active period 1 val2 \u00b6 public property float val2 [config] Output value for active period 2 Methods \u00b6 setOutValue \u00b6 public override void setOutValue(int activeVal) Doc Home > API Index > basicSchedule > DailyScheduleFloat","title":"DailyScheduleFloat"},{"location":"api/basicSchedule/DailyScheduleFloat/#dailyschedulefloat","text":"Doc Home > API Index > basicSchedule > DailyScheduleFloat","title":"DailyScheduleFloat"},{"location":"api/basicSchedule/DailyScheduleFloat/#inheritance","text":"sys::Obj sys::Virtual sys::Component basicSchedule::DailySchedule basicSchedule::DailyScheduleFloat public class DailyScheduleFloat DailyScheduleFloat extends DailySchedule to provide a float output","title":"Inheritance"},{"location":"api/basicSchedule/DailyScheduleFloat/#fields","text":"","title":"Fields"},{"location":"api/basicSchedule/DailyScheduleFloat/#defval","text":"public property float defVal [config] Output value for periods other than active1 / active2","title":"defVal"},{"location":"api/basicSchedule/DailyScheduleFloat/#out","text":"public property float out Current schedule output","title":"out"},{"location":"api/basicSchedule/DailyScheduleFloat/#val1","text":"public property float val1 [config] Output value for active period 1","title":"val1"},{"location":"api/basicSchedule/DailyScheduleFloat/#val2","text":"public property float val2 [config] Output value for active period 2","title":"val2"},{"location":"api/basicSchedule/DailyScheduleFloat/#methods","text":"","title":"Methods"},{"location":"api/basicSchedule/DailyScheduleFloat/#setoutvalue","text":"public override void setOutValue(int activeVal) Doc Home > API Index > basicSchedule > DailyScheduleFloat","title":"setOutValue"},{"location":"api/control/","text":"control \u00b6 Doc Home > API Index > control Basic function block library ADemux2 \u00b6 ASW \u00b6 ASW4 \u00b6 Add2 \u00b6 Add4 \u00b6 And2 \u00b6 And4 \u00b6 Avg10 \u00b6 AvgN \u00b6 B2F \u00b6 B2P \u00b6 BSW \u00b6 Cmpr \u00b6 ConstBool \u00b6 ConstFloat \u00b6 ConstInt \u00b6 Count \u00b6 DemuxI2B4 \u00b6 Div2 \u00b6 DlyOff \u00b6 DlyOn \u00b6 F2B \u00b6 F2I \u00b6 FloatOffset \u00b6 Freq \u00b6 Hysteresis \u00b6 I2F \u00b6 IRamp \u00b6 ISW \u00b6 L2F \u00b6 LP \u00b6 LSeq \u00b6 Limiter \u00b6 Linearize \u00b6 Max \u00b6 Min \u00b6 MinMax \u00b6 Mul2 \u00b6 Mul4 \u00b6 Neg \u00b6 Not \u00b6 OneShot \u00b6 Or2 \u00b6 Or4 \u00b6 Ramp \u00b6 ReheatSeq \u00b6 Reset \u00b6 Round \u00b6 SRLatch \u00b6 Sub2 \u00b6 Sub4 \u00b6 TickTock \u00b6 TimeAvg \u00b6 Timer \u00b6 Tstat \u00b6 UpDn \u00b6 WriteBool \u00b6 WriteFloat \u00b6 WriteInt \u00b6 Xor \u00b6 Doc Home > API Index > control","title":"Index"},{"location":"api/control/#control","text":"Doc Home > API Index > control Basic function block library","title":"control"},{"location":"api/control/#ademux2","text":"","title":"ADemux2"},{"location":"api/control/#asw","text":"","title":"ASW"},{"location":"api/control/#asw4","text":"","title":"ASW4"},{"location":"api/control/#add2","text":"","title":"Add2"},{"location":"api/control/#add4","text":"","title":"Add4"},{"location":"api/control/#and2","text":"","title":"And2"},{"location":"api/control/#and4","text":"","title":"And4"},{"location":"api/control/#avg10","text":"","title":"Avg10"},{"location":"api/control/#avgn","text":"","title":"AvgN"},{"location":"api/control/#b2f","text":"","title":"B2F"},{"location":"api/control/#b2p","text":"","title":"B2P"},{"location":"api/control/#bsw","text":"","title":"BSW"},{"location":"api/control/#cmpr","text":"","title":"Cmpr"},{"location":"api/control/#constbool","text":"","title":"ConstBool"},{"location":"api/control/#constfloat","text":"","title":"ConstFloat"},{"location":"api/control/#constint","text":"","title":"ConstInt"},{"location":"api/control/#count","text":"","title":"Count"},{"location":"api/control/#demuxi2b4","text":"","title":"DemuxI2B4"},{"location":"api/control/#div2","text":"","title":"Div2"},{"location":"api/control/#dlyoff","text":"","title":"DlyOff"},{"location":"api/control/#dlyon","text":"","title":"DlyOn"},{"location":"api/control/#f2b","text":"","title":"F2B"},{"location":"api/control/#f2i","text":"","title":"F2I"},{"location":"api/control/#floatoffset","text":"","title":"FloatOffset"},{"location":"api/control/#freq","text":"","title":"Freq"},{"location":"api/control/#hysteresis","text":"","title":"Hysteresis"},{"location":"api/control/#i2f","text":"","title":"I2F"},{"location":"api/control/#iramp","text":"","title":"IRamp"},{"location":"api/control/#isw","text":"","title":"ISW"},{"location":"api/control/#l2f","text":"","title":"L2F"},{"location":"api/control/#lp","text":"","title":"LP"},{"location":"api/control/#lseq","text":"","title":"LSeq"},{"location":"api/control/#limiter","text":"","title":"Limiter"},{"location":"api/control/#linearize","text":"","title":"Linearize"},{"location":"api/control/#max","text":"","title":"Max"},{"location":"api/control/#min","text":"","title":"Min"},{"location":"api/control/#minmax","text":"","title":"MinMax"},{"location":"api/control/#mul2","text":"","title":"Mul2"},{"location":"api/control/#mul4","text":"","title":"Mul4"},{"location":"api/control/#neg","text":"","title":"Neg"},{"location":"api/control/#not","text":"","title":"Not"},{"location":"api/control/#oneshot","text":"","title":"OneShot"},{"location":"api/control/#or2","text":"","title":"Or2"},{"location":"api/control/#or4","text":"","title":"Or4"},{"location":"api/control/#ramp","text":"","title":"Ramp"},{"location":"api/control/#reheatseq","text":"","title":"ReheatSeq"},{"location":"api/control/#reset","text":"","title":"Reset"},{"location":"api/control/#round","text":"","title":"Round"},{"location":"api/control/#srlatch","text":"","title":"SRLatch"},{"location":"api/control/#sub2","text":"","title":"Sub2"},{"location":"api/control/#sub4","text":"","title":"Sub4"},{"location":"api/control/#ticktock","text":"","title":"TickTock"},{"location":"api/control/#timeavg","text":"","title":"TimeAvg"},{"location":"api/control/#timer","text":"","title":"Timer"},{"location":"api/control/#tstat","text":"","title":"Tstat"},{"location":"api/control/#updn","text":"","title":"UpDn"},{"location":"api/control/#writebool","text":"","title":"WriteBool"},{"location":"api/control/#writefloat","text":"","title":"WriteFloat"},{"location":"api/control/#writeint","text":"","title":"WriteInt"},{"location":"api/control/#xor","text":"Doc Home > API Index > control","title":"Xor"},{"location":"api/control/ADemux2/","text":"ADemux2 \u00b6 Doc Home > API Index > control > ADemux2 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::ADemux2 public class ADemux2 [niagaraIcon=\"module://icons/x16/control/util/split.png\"] ADemux2 object selects one of two outputs to receive the input value, depending on the value of boolean switch input. The value of the other output remains unchanged. If s1 is false, then out1 is updated with in, and out2 value remains constant at previous value If s2 is true, then out2 is updated with in, and out1 value remains constant at previous value Fields \u00b6 in \u00b6 public property float in value to get routed to out1 or out2 out1 \u00b6 public property float out1 [readonly] output 1 out2 \u00b6 public property float out2 [readonly] output 2 s1 \u00b6 public property bool s1 s1 selects whether 'in' gets routed to 'out1' (if false) or 'out2' (if true) Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > ADemux2","title":"ADemux2"},{"location":"api/control/ADemux2/#ademux2","text":"Doc Home > API Index > control > ADemux2","title":"ADemux2"},{"location":"api/control/ADemux2/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::ADemux2 public class ADemux2 [niagaraIcon=\"module://icons/x16/control/util/split.png\"] ADemux2 object selects one of two outputs to receive the input value, depending on the value of boolean switch input. The value of the other output remains unchanged. If s1 is false, then out1 is updated with in, and out2 value remains constant at previous value If s2 is true, then out2 is updated with in, and out1 value remains constant at previous value","title":"Inheritance"},{"location":"api/control/ADemux2/#fields","text":"","title":"Fields"},{"location":"api/control/ADemux2/#in","text":"public property float in value to get routed to out1 or out2","title":"in"},{"location":"api/control/ADemux2/#out1","text":"public property float out1 [readonly] output 1","title":"out1"},{"location":"api/control/ADemux2/#out2","text":"public property float out2 [readonly] output 2","title":"out2"},{"location":"api/control/ADemux2/#s1","text":"public property bool s1 s1 selects whether 'in' gets routed to 'out1' (if false) or 'out2' (if true)","title":"s1"},{"location":"api/control/ADemux2/#methods","text":"","title":"Methods"},{"location":"api/control/ADemux2/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > ADemux2","title":"execute"},{"location":"api/control/ASW/","text":"ASW \u00b6 Doc Home > API Index > control > ASW Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::ASW public class ASW [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] ASW Analog Switch object switches one of two inputs to the output out = s1 ? in2 : in1 Fields \u00b6 in1 \u00b6 public property float in1 input 1 in2 \u00b6 public property float in2 input 2 out \u00b6 public property float out [readonly] output s1 \u00b6 public property bool s1 s1 switches in1 or in2 to out Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > ASW","title":"ASW"},{"location":"api/control/ASW/#asw","text":"Doc Home > API Index > control > ASW","title":"ASW"},{"location":"api/control/ASW/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::ASW public class ASW [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] ASW Analog Switch object switches one of two inputs to the output out = s1 ? in2 : in1","title":"Inheritance"},{"location":"api/control/ASW/#fields","text":"","title":"Fields"},{"location":"api/control/ASW/#in1","text":"public property float in1 input 1","title":"in1"},{"location":"api/control/ASW/#in2","text":"public property float in2 input 2","title":"in2"},{"location":"api/control/ASW/#out","text":"public property float out [readonly] output","title":"out"},{"location":"api/control/ASW/#s1","text":"public property bool s1 s1 switches in1 or in2 to out","title":"s1"},{"location":"api/control/ASW/#methods","text":"","title":"Methods"},{"location":"api/control/ASW/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > ASW","title":"execute"},{"location":"api/control/ASW4/","text":"ASW4 \u00b6 Doc Home > API Index > control > ASW4 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::ASW4 public class ASW4 [niagaraIcon=\"module://icons/x16/control/util/select.png\"] Selects 1 of 4 inputs to route to output based on selector value if (sel - startsAt) <= 0, out = in1 if (sel - startsAt) == 1, out = in2 if (sel - startsAt) == 2, out = in3 if (sel - startsAt) >= 3, out = in4 Fields \u00b6 in1 \u00b6 public property float in1 input 1 in2 \u00b6 public property float in2 input 2 in3 \u00b6 public property float in3 input 3 in4 \u00b6 public property float in4 input 4 out \u00b6 public property float out [readonly] output sel \u00b6 public property int sel sel, the difference of sel - startsAt is used to select the output startsAt \u00b6 public property int startsAt [config] startsAt, the difference of sel - startsAt is used to select the output Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > ASW4","title":"ASW4"},{"location":"api/control/ASW4/#asw4","text":"Doc Home > API Index > control > ASW4","title":"ASW4"},{"location":"api/control/ASW4/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::ASW4 public class ASW4 [niagaraIcon=\"module://icons/x16/control/util/select.png\"] Selects 1 of 4 inputs to route to output based on selector value if (sel - startsAt) <= 0, out = in1 if (sel - startsAt) == 1, out = in2 if (sel - startsAt) == 2, out = in3 if (sel - startsAt) >= 3, out = in4","title":"Inheritance"},{"location":"api/control/ASW4/#fields","text":"","title":"Fields"},{"location":"api/control/ASW4/#in1","text":"public property float in1 input 1","title":"in1"},{"location":"api/control/ASW4/#in2","text":"public property float in2 input 2","title":"in2"},{"location":"api/control/ASW4/#in3","text":"public property float in3 input 3","title":"in3"},{"location":"api/control/ASW4/#in4","text":"public property float in4 input 4","title":"in4"},{"location":"api/control/ASW4/#out","text":"public property float out [readonly] output","title":"out"},{"location":"api/control/ASW4/#sel","text":"public property int sel sel, the difference of sel - startsAt is used to select the output","title":"sel"},{"location":"api/control/ASW4/#startsat","text":"public property int startsAt [config] startsAt, the difference of sel - startsAt is used to select the output","title":"startsAt"},{"location":"api/control/ASW4/#methods","text":"","title":"Methods"},{"location":"api/control/ASW4/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > ASW4","title":"execute"},{"location":"api/control/Add2/","text":"Add2 \u00b6 Doc Home > API Index > control > Add2 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Add2 public class Add2 [niagaraIcon=\"module://icons/x16/control/math/add.png\"] Add2 adds two float inputs and writes the results to a float output out = in1 + in2 Fields \u00b6 in1 \u00b6 public property float in1 input 1 in2 \u00b6 public property float in2 input 2 out \u00b6 public property float out [readonly] out is the sum of all inputs Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Add2","title":"Add2"},{"location":"api/control/Add2/#add2","text":"Doc Home > API Index > control > Add2","title":"Add2"},{"location":"api/control/Add2/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Add2 public class Add2 [niagaraIcon=\"module://icons/x16/control/math/add.png\"] Add2 adds two float inputs and writes the results to a float output out = in1 + in2","title":"Inheritance"},{"location":"api/control/Add2/#fields","text":"","title":"Fields"},{"location":"api/control/Add2/#in1","text":"public property float in1 input 1","title":"in1"},{"location":"api/control/Add2/#in2","text":"public property float in2 input 2","title":"in2"},{"location":"api/control/Add2/#out","text":"public property float out [readonly] out is the sum of all inputs","title":"out"},{"location":"api/control/Add2/#methods","text":"","title":"Methods"},{"location":"api/control/Add2/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Add2","title":"execute"},{"location":"api/control/Add4/","text":"Add4 \u00b6 Doc Home > API Index > control > Add4 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Add2 control::Add4 public class Add4 Add4 adds four float inputs and writes the results to a float output out = in1 + in2 + in3 + in4 Fields \u00b6 in3 \u00b6 public property float in3 input 3 in4 \u00b6 public property float in4 input 4 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Add4","title":"Add4"},{"location":"api/control/Add4/#add4","text":"Doc Home > API Index > control > Add4","title":"Add4"},{"location":"api/control/Add4/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Add2 control::Add4 public class Add4 Add4 adds four float inputs and writes the results to a float output out = in1 + in2 + in3 + in4","title":"Inheritance"},{"location":"api/control/Add4/#fields","text":"","title":"Fields"},{"location":"api/control/Add4/#in3","text":"public property float in3 input 3","title":"in3"},{"location":"api/control/Add4/#in4","text":"public property float in4 input 4","title":"in4"},{"location":"api/control/Add4/#methods","text":"","title":"Methods"},{"location":"api/control/Add4/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Add4","title":"execute"},{"location":"api/control/And2/","text":"And2 \u00b6 Doc Home > API Index > control > And2 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::And2 public class And2 [niagaraIcon=\"module://icons/x16/control/logic/and.png\"] And2 And logic object Ignores null inputs. If both inputs are null output is null. out = in1 && in2 Fields \u00b6 in1 \u00b6 public property bool in1 input 1 in2 \u00b6 public property bool in2 input 2 out \u00b6 public property bool out [readonly] output Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > And2","title":"And2"},{"location":"api/control/And2/#and2","text":"Doc Home > API Index > control > And2","title":"And2"},{"location":"api/control/And2/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::And2 public class And2 [niagaraIcon=\"module://icons/x16/control/logic/and.png\"] And2 And logic object Ignores null inputs. If both inputs are null output is null. out = in1 && in2","title":"Inheritance"},{"location":"api/control/And2/#fields","text":"","title":"Fields"},{"location":"api/control/And2/#in1","text":"public property bool in1 input 1","title":"in1"},{"location":"api/control/And2/#in2","text":"public property bool in2 input 2","title":"in2"},{"location":"api/control/And2/#out","text":"public property bool out [readonly] output","title":"out"},{"location":"api/control/And2/#methods","text":"","title":"Methods"},{"location":"api/control/And2/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > And2","title":"execute"},{"location":"api/control/And4/","text":"And4 \u00b6 Doc Home > API Index > control > And4 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::And2 control::And4 public class And4 And4 4 input AND logic object Null inputs are ignored. If all inputs are null output is null out = in1 && in2 && in3 && in4 Fields \u00b6 in3 \u00b6 public property bool in3 input 3 in4 \u00b6 public property bool in4 input 4 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > And4","title":"And4"},{"location":"api/control/And4/#and4","text":"Doc Home > API Index > control > And4","title":"And4"},{"location":"api/control/And4/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::And2 control::And4 public class And4 And4 4 input AND logic object Null inputs are ignored. If all inputs are null output is null out = in1 && in2 && in3 && in4","title":"Inheritance"},{"location":"api/control/And4/#fields","text":"","title":"Fields"},{"location":"api/control/And4/#in3","text":"public property bool in3 input 3","title":"in3"},{"location":"api/control/And4/#in4","text":"public property bool in4 input 4","title":"in4"},{"location":"api/control/And4/#methods","text":"","title":"Methods"},{"location":"api/control/And4/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > And4","title":"execute"},{"location":"api/control/Avg10/","text":"Avg10 \u00b6 Doc Home > API Index > control > Avg10 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Avg10 public class Avg10 [niagaraIcon=\"module://icons/x16/control/math/average.png\"] Avg Running Average math object out = (sum last 10 value)/10 Samples current value again if value has not changed in maxTime msec. For first ten samples, averages only the samples recd. Fields \u00b6 in \u00b6 public property float in input value to be averaged maxTime \u00b6 public property int maxTime [unit=\"millisecond\", config] if maxTime == 0, then average every scan if maxTime > 0, then average a new sample every maxTime milliseconds or every scan, whichever is greater. out \u00b6 public property float out [readonly] averaged output Methods \u00b6 changed \u00b6 public override void changed( Slot slot) Behavior to execute when a property is changed externally execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app, before the first call to propagateLinksTo() or execute(). Doc Home > API Index > control > Avg10","title":"Avg10"},{"location":"api/control/Avg10/#avg10","text":"Doc Home > API Index > control > Avg10","title":"Avg10"},{"location":"api/control/Avg10/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Avg10 public class Avg10 [niagaraIcon=\"module://icons/x16/control/math/average.png\"] Avg Running Average math object out = (sum last 10 value)/10 Samples current value again if value has not changed in maxTime msec. For first ten samples, averages only the samples recd.","title":"Inheritance"},{"location":"api/control/Avg10/#fields","text":"","title":"Fields"},{"location":"api/control/Avg10/#in","text":"public property float in input value to be averaged","title":"in"},{"location":"api/control/Avg10/#maxtime","text":"public property int maxTime [unit=\"millisecond\", config] if maxTime == 0, then average every scan if maxTime > 0, then average a new sample every maxTime milliseconds or every scan, whichever is greater.","title":"maxTime"},{"location":"api/control/Avg10/#out","text":"public property float out [readonly] averaged output","title":"out"},{"location":"api/control/Avg10/#methods","text":"","title":"Methods"},{"location":"api/control/Avg10/#changed","text":"public override void changed( Slot slot) Behavior to execute when a property is changed externally","title":"changed"},{"location":"api/control/Avg10/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/Avg10/#start","text":"public virtual override void start() Callback when component is first started in an app, before the first call to propagateLinksTo() or execute(). Doc Home > API Index > control > Avg10","title":"start"},{"location":"api/control/AvgN/","text":"AvgN \u00b6 Doc Home > API Index > control > AvgN Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::AvgN public class AvgN [niagaraIcon=\"module://icons/x16/control/math/average.png\"] Modified Moving Average math object out = [(n-1)*out + in]/n = (total + in - avg)/n where total = approx. running total of last n samples avg = last computed average = total/n Note: 1) the \"avg\" value is \"seeded\" with the \"in\" value at startup or whenever \"n\" changes 2) the \"total\" value is \"seeded\" with (in * n) at startup or whenever \"n\" changes 3) boolean input \"reset\" resets the object to return to first execute cycle state, and avg and total are re \"seeded\". This may be useful to invoke in an application where large step changes of \"in\" are expected and \"n\" is a high value, to prevent output lag of the input. For large step changes in values, the \"out\" value will asymptotically approach the \"in\" value. Fields \u00b6 in \u00b6 public property float in value of in is added to average computation every execute cycle numSamplesToAvg \u00b6 public property int numSamplesToAvg [min=1, config] number of samples to average. One new sample is read every execute cycle. out \u00b6 public property float out [readonly] the average value updated every execute cycle reset \u00b6 public property bool reset [readonly] reset is invoked to re-initialize the averaging Methods \u00b6 changed \u00b6 public virtual override void changed( Slot slot) Behavior to execute when a property is changed externally computeAverage \u00b6 public void computeAverage() average in a new sample execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app, before the first call to propagateLinksTo() or execute(). Doc Home > API Index > control > AvgN","title":"AvgN"},{"location":"api/control/AvgN/#avgn","text":"Doc Home > API Index > control > AvgN","title":"AvgN"},{"location":"api/control/AvgN/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::AvgN public class AvgN [niagaraIcon=\"module://icons/x16/control/math/average.png\"] Modified Moving Average math object out = [(n-1)*out + in]/n = (total + in - avg)/n where total = approx. running total of last n samples avg = last computed average = total/n Note: 1) the \"avg\" value is \"seeded\" with the \"in\" value at startup or whenever \"n\" changes 2) the \"total\" value is \"seeded\" with (in * n) at startup or whenever \"n\" changes 3) boolean input \"reset\" resets the object to return to first execute cycle state, and avg and total are re \"seeded\". This may be useful to invoke in an application where large step changes of \"in\" are expected and \"n\" is a high value, to prevent output lag of the input. For large step changes in values, the \"out\" value will asymptotically approach the \"in\" value.","title":"Inheritance"},{"location":"api/control/AvgN/#fields","text":"","title":"Fields"},{"location":"api/control/AvgN/#in","text":"public property float in value of in is added to average computation every execute cycle","title":"in"},{"location":"api/control/AvgN/#numsamplestoavg","text":"public property int numSamplesToAvg [min=1, config] number of samples to average. One new sample is read every execute cycle.","title":"numSamplesToAvg"},{"location":"api/control/AvgN/#out","text":"public property float out [readonly] the average value updated every execute cycle","title":"out"},{"location":"api/control/AvgN/#reset","text":"public property bool reset [readonly] reset is invoked to re-initialize the averaging","title":"reset"},{"location":"api/control/AvgN/#methods","text":"","title":"Methods"},{"location":"api/control/AvgN/#changed","text":"public virtual override void changed( Slot slot) Behavior to execute when a property is changed externally","title":"changed"},{"location":"api/control/AvgN/#computeaverage","text":"public void computeAverage() average in a new sample","title":"computeAverage"},{"location":"api/control/AvgN/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/AvgN/#start","text":"public virtual override void start() Callback when component is first started in an app, before the first call to propagateLinksTo() or execute(). Doc Home > API Index > control > AvgN","title":"start"},{"location":"api/control/B2F/","text":"B2F \u00b6 Doc Home > API Index > control > B2F Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::B2F public class B2F [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] B2F 16 bit binary to float encoder object out = encoded value of inputs, with in16 the MSB and in1 as the LSB. count = sum of the inputs that are active. Fields \u00b6 count \u00b6 public property float count [readonly] count = sum of the inputs that are active. in1 \u00b6 public property bool in1 in1 in10 \u00b6 public property bool in10 in10 in11 \u00b6 public property bool in11 in11 in12 \u00b6 public property bool in12 in12 in13 \u00b6 public property bool in13 in13 in14 \u00b6 public property bool in14 in14 in15 \u00b6 public property bool in15 in15 in16 \u00b6 public property bool in16 in16 in2 \u00b6 public property bool in2 in2 in3 \u00b6 public property bool in3 in3 in4 \u00b6 public property bool in4 in4 in5 \u00b6 public property bool in5 in5 in6 \u00b6 public property bool in6 in6 in7 \u00b6 public property bool in7 in7 in8 \u00b6 public property bool in8 in8 in9 \u00b6 public property bool in9 in9 out \u00b6 public property float out [readonly] out = encoded value of inputs, with in16 the MSB and in1 as the LSB. Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > B2F","title":"B2F"},{"location":"api/control/B2F/#b2f","text":"Doc Home > API Index > control > B2F","title":"B2F"},{"location":"api/control/B2F/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::B2F public class B2F [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] B2F 16 bit binary to float encoder object out = encoded value of inputs, with in16 the MSB and in1 as the LSB. count = sum of the inputs that are active.","title":"Inheritance"},{"location":"api/control/B2F/#fields","text":"","title":"Fields"},{"location":"api/control/B2F/#count","text":"public property float count [readonly] count = sum of the inputs that are active.","title":"count"},{"location":"api/control/B2F/#in1","text":"public property bool in1 in1","title":"in1"},{"location":"api/control/B2F/#in10","text":"public property bool in10 in10","title":"in10"},{"location":"api/control/B2F/#in11","text":"public property bool in11 in11","title":"in11"},{"location":"api/control/B2F/#in12","text":"public property bool in12 in12","title":"in12"},{"location":"api/control/B2F/#in13","text":"public property bool in13 in13","title":"in13"},{"location":"api/control/B2F/#in14","text":"public property bool in14 in14","title":"in14"},{"location":"api/control/B2F/#in15","text":"public property bool in15 in15","title":"in15"},{"location":"api/control/B2F/#in16","text":"public property bool in16 in16","title":"in16"},{"location":"api/control/B2F/#in2","text":"public property bool in2 in2","title":"in2"},{"location":"api/control/B2F/#in3","text":"public property bool in3 in3","title":"in3"},{"location":"api/control/B2F/#in4","text":"public property bool in4 in4","title":"in4"},{"location":"api/control/B2F/#in5","text":"public property bool in5 in5","title":"in5"},{"location":"api/control/B2F/#in6","text":"public property bool in6 in6","title":"in6"},{"location":"api/control/B2F/#in7","text":"public property bool in7 in7","title":"in7"},{"location":"api/control/B2F/#in8","text":"public property bool in8 in8","title":"in8"},{"location":"api/control/B2F/#in9","text":"public property bool in9 in9","title":"in9"},{"location":"api/control/B2F/#out","text":"public property float out [readonly] out = encoded value of inputs, with in16 the MSB and in1 as the LSB.","title":"out"},{"location":"api/control/B2F/#methods","text":"","title":"Methods"},{"location":"api/control/B2F/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > B2F","title":"execute"},{"location":"api/control/B2P/","text":"B2P \u00b6 Doc Home > API Index > control > B2P Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::B2P public class B2P [niagaraIcon=\"module://icons/x16/control/control.png\"] B2P Boolean to pulse object out = in for one scan cycle, on rising edge of in Fields \u00b6 in \u00b6 public property bool in rising edge of in causes out to go true for one cycle out \u00b6 public property bool out [readonly] out = in for one scan cycle, on rising edge of in Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > B2P","title":"B2P"},{"location":"api/control/B2P/#b2p","text":"Doc Home > API Index > control > B2P","title":"B2P"},{"location":"api/control/B2P/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::B2P public class B2P [niagaraIcon=\"module://icons/x16/control/control.png\"] B2P Boolean to pulse object out = in for one scan cycle, on rising edge of in","title":"Inheritance"},{"location":"api/control/B2P/#fields","text":"","title":"Fields"},{"location":"api/control/B2P/#in","text":"public property bool in rising edge of in causes out to go true for one cycle","title":"in"},{"location":"api/control/B2P/#out","text":"public property bool out [readonly] out = in for one scan cycle, on rising edge of in","title":"out"},{"location":"api/control/B2P/#methods","text":"","title":"Methods"},{"location":"api/control/B2P/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/B2P/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > B2P","title":"start"},{"location":"api/control/BSW/","text":"BSW \u00b6 Doc Home > API Index > control > BSW Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::BSW public class BSW [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] BSW: Boolean Switch object if s1 is null output is null if (s1) out = in2 else out = in1 Fields \u00b6 in1 \u00b6 public property bool in1 boolean input 1 in2 \u00b6 public property bool in2 boolean input 2 out \u00b6 public property bool out [readonly] boolean output s1 \u00b6 public property bool s1 if s1 is null output is null if (s1) out = in2 else out = in1 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > BSW","title":"BSW"},{"location":"api/control/BSW/#bsw","text":"Doc Home > API Index > control > BSW","title":"BSW"},{"location":"api/control/BSW/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::BSW public class BSW [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] BSW: Boolean Switch object if s1 is null output is null if (s1) out = in2 else out = in1","title":"Inheritance"},{"location":"api/control/BSW/#fields","text":"","title":"Fields"},{"location":"api/control/BSW/#in1","text":"public property bool in1 boolean input 1","title":"in1"},{"location":"api/control/BSW/#in2","text":"public property bool in2 boolean input 2","title":"in2"},{"location":"api/control/BSW/#out","text":"public property bool out [readonly] boolean output","title":"out"},{"location":"api/control/BSW/#s1","text":"public property bool s1 if s1 is null output is null if (s1) out = in2 else out = in1","title":"s1"},{"location":"api/control/BSW/#methods","text":"","title":"Methods"},{"location":"api/control/BSW/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > BSW","title":"execute"},{"location":"api/control/Cmpr/","text":"Cmpr \u00b6 Doc Home > API Index > control > Cmpr Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Cmpr public class Cmpr [niagaraIcon=\"module://icons/x16/control/logic/lessThan.png\"] Cmpr comparison math object xgy = x > y; xey = x = y; xly = x < y; Fields \u00b6 x \u00b6 public property float x input x xey \u00b6 public property bool xey [readonly] xey is true if x == y xgy \u00b6 public property bool xgy [readonly] xgy is true if x > y xly \u00b6 public property bool xly [readonly] xly is true if x < y y \u00b6 public property float y input y Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Cmpr","title":"Cmpr"},{"location":"api/control/Cmpr/#cmpr","text":"Doc Home > API Index > control > Cmpr","title":"Cmpr"},{"location":"api/control/Cmpr/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Cmpr public class Cmpr [niagaraIcon=\"module://icons/x16/control/logic/lessThan.png\"] Cmpr comparison math object xgy = x > y; xey = x = y; xly = x < y;","title":"Inheritance"},{"location":"api/control/Cmpr/#fields","text":"","title":"Fields"},{"location":"api/control/Cmpr/#x","text":"public property float x input x","title":"x"},{"location":"api/control/Cmpr/#xey","text":"public property bool xey [readonly] xey is true if x == y","title":"xey"},{"location":"api/control/Cmpr/#xgy","text":"public property bool xgy [readonly] xgy is true if x > y","title":"xgy"},{"location":"api/control/Cmpr/#xly","text":"public property bool xly [readonly] xly is true if x < y","title":"xly"},{"location":"api/control/Cmpr/#y","text":"public property float y input y","title":"y"},{"location":"api/control/Cmpr/#methods","text":"","title":"Methods"},{"location":"api/control/Cmpr/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Cmpr","title":"execute"},{"location":"api/control/ConstBool/","text":"ConstBool \u00b6 Doc Home > API Index > control > ConstBool Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::ConstBool public class ConstBool [niagaraIcon=\"module://icons/x16/control/booleanPoint.png\"] ConstBool: boolean constant out should never be a link destination. Fields \u00b6 out \u00b6 public property bool out [summary, config] out value is set by actions Methods \u00b6 setFalse \u00b6 public action void setFalse() action to set out to false setNull \u00b6 public action void setNull() action to set out to null setTrue \u00b6 public action void setTrue() action to set out to true Doc Home > API Index > control > ConstBool","title":"ConstBool"},{"location":"api/control/ConstBool/#constbool","text":"Doc Home > API Index > control > ConstBool","title":"ConstBool"},{"location":"api/control/ConstBool/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::ConstBool public class ConstBool [niagaraIcon=\"module://icons/x16/control/booleanPoint.png\"] ConstBool: boolean constant out should never be a link destination.","title":"Inheritance"},{"location":"api/control/ConstBool/#fields","text":"","title":"Fields"},{"location":"api/control/ConstBool/#out","text":"public property bool out [summary, config] out value is set by actions","title":"out"},{"location":"api/control/ConstBool/#methods","text":"","title":"Methods"},{"location":"api/control/ConstBool/#setfalse","text":"public action void setFalse() action to set out to false","title":"setFalse"},{"location":"api/control/ConstBool/#setnull","text":"public action void setNull() action to set out to null","title":"setNull"},{"location":"api/control/ConstBool/#settrue","text":"public action void setTrue() action to set out to true Doc Home > API Index > control > ConstBool","title":"setTrue"},{"location":"api/control/ConstFloat/","text":"ConstFloat \u00b6 Doc Home > API Index > control > ConstFloat Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::ConstFloat public class ConstFloat [niagaraIcon=\"module://icons/x16/control/numericPoint.png\"] ConstFloat: float constant out should never be a link destination. Fields \u00b6 out \u00b6 public property float out [summary, config] out value is set by actions Methods \u00b6 set \u00b6 public action void set(float x) action to set out value setNull \u00b6 public action void setNull() action to set out to null Doc Home > API Index > control > ConstFloat","title":"ConstFloat"},{"location":"api/control/ConstFloat/#constfloat","text":"Doc Home > API Index > control > ConstFloat","title":"ConstFloat"},{"location":"api/control/ConstFloat/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::ConstFloat public class ConstFloat [niagaraIcon=\"module://icons/x16/control/numericPoint.png\"] ConstFloat: float constant out should never be a link destination.","title":"Inheritance"},{"location":"api/control/ConstFloat/#fields","text":"","title":"Fields"},{"location":"api/control/ConstFloat/#out","text":"public property float out [summary, config] out value is set by actions","title":"out"},{"location":"api/control/ConstFloat/#methods","text":"","title":"Methods"},{"location":"api/control/ConstFloat/#set","text":"public action void set(float x) action to set out value","title":"set"},{"location":"api/control/ConstFloat/#setnull","text":"public action void setNull() action to set out to null Doc Home > API Index > control > ConstFloat","title":"setNull"},{"location":"api/control/ConstInt/","text":"ConstInt \u00b6 Doc Home > API Index > control > ConstInt Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::ConstInt public class ConstInt [niagaraIcon=\"module://icons/x16/control/enumPoint.png\"] ConstInt: int constant out should never be a link destination. Fields \u00b6 out \u00b6 public property int out [summary, config] out value is set by actions Methods \u00b6 set \u00b6 public action void set(int x) action to set out value Doc Home > API Index > control > ConstInt","title":"ConstInt"},{"location":"api/control/ConstInt/#constint","text":"Doc Home > API Index > control > ConstInt","title":"ConstInt"},{"location":"api/control/ConstInt/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::ConstInt public class ConstInt [niagaraIcon=\"module://icons/x16/control/enumPoint.png\"] ConstInt: int constant out should never be a link destination.","title":"Inheritance"},{"location":"api/control/ConstInt/#fields","text":"","title":"Fields"},{"location":"api/control/ConstInt/#out","text":"public property int out [summary, config] out value is set by actions","title":"out"},{"location":"api/control/ConstInt/#methods","text":"","title":"Methods"},{"location":"api/control/ConstInt/#set","text":"public action void set(int x) action to set out value Doc Home > API Index > control > ConstInt","title":"set"},{"location":"api/control/Count/","text":"Count \u00b6 Doc Home > API Index > control > Count Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Count public class Count [niagaraIcon=\"module://icons/x16/control/util/step.png\"] pulse counter object, counts transitions form 0 to 1 of input \"in\" Counts up if dir == true, counts down if dir == false Forced to preset value if enable = false In the case where dir == false, the counter will stop counting down at 0 Fields \u00b6 dir \u00b6 public property bool dir [falseText=\"down\", defaultOnClone, config, trueText=\"up\"] Configures direction. True = \"up\", False = \"down\" enable \u00b6 public property bool enable enable input in \u00b6 public property bool in input, transitions from false to true increment out by 1 out \u00b6 public property int out [readonly] Number of times \"in\" property has transitioned from 0 to 1 preset \u00b6 public property int preset [min=0, defaultOnClone, config] Presets the counter to a specific value, defaults to 0 r \u00b6 public property bool r if r is true, out = preset and no counting takes place Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. increment/decrement the count on rising edge of \"in\" if \"enable\" is true reset \u00b6 public action void reset() Resets the counter to the \"preset\" value start \u00b6 public virtual override void start() Override of start method to initialize the counter Doc Home > API Index > control > Count","title":"Count"},{"location":"api/control/Count/#count","text":"Doc Home > API Index > control > Count","title":"Count"},{"location":"api/control/Count/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Count public class Count [niagaraIcon=\"module://icons/x16/control/util/step.png\"] pulse counter object, counts transitions form 0 to 1 of input \"in\" Counts up if dir == true, counts down if dir == false Forced to preset value if enable = false In the case where dir == false, the counter will stop counting down at 0","title":"Inheritance"},{"location":"api/control/Count/#fields","text":"","title":"Fields"},{"location":"api/control/Count/#dir","text":"public property bool dir [falseText=\"down\", defaultOnClone, config, trueText=\"up\"] Configures direction. True = \"up\", False = \"down\"","title":"dir"},{"location":"api/control/Count/#enable","text":"public property bool enable enable input","title":"enable"},{"location":"api/control/Count/#in","text":"public property bool in input, transitions from false to true increment out by 1","title":"in"},{"location":"api/control/Count/#out","text":"public property int out [readonly] Number of times \"in\" property has transitioned from 0 to 1","title":"out"},{"location":"api/control/Count/#preset","text":"public property int preset [min=0, defaultOnClone, config] Presets the counter to a specific value, defaults to 0","title":"preset"},{"location":"api/control/Count/#r","text":"public property bool r if r is true, out = preset and no counting takes place","title":"r"},{"location":"api/control/Count/#methods","text":"","title":"Methods"},{"location":"api/control/Count/#execute","text":"public virtual override void execute() Execute is called once every scan. increment/decrement the count on rising edge of \"in\" if \"enable\" is true","title":"execute"},{"location":"api/control/Count/#reset","text":"public action void reset() Resets the counter to the \"preset\" value","title":"reset"},{"location":"api/control/Count/#start","text":"public virtual override void start() Override of start method to initialize the counter Doc Home > API Index > control > Count","title":"start"},{"location":"api/control/DemuxI2B4/","text":"DemuxI2B4 \u00b6 Doc Home > API Index > control > DemuxI2B4 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::DemuxI2B4 public class DemuxI2B4 [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] Demuxes an integer count input into 4 boolean outputs. By setting \"startsAt\" appropriately, N objects can demux to N*4 outputs (ie, you can create a 4x, 8x, 16x, etc demux) if in == startsAt + 0, out1 is true, else false if in == startsAt + 1, out2 is true, else false if in == startsAt + 2, out3 is true, else false if in == startsAt + 3, out4 is true, else false Fields \u00b6 in \u00b6 public property int in input out1 \u00b6 public property bool out1 [readonly] if in == startsAt + 0, out1 is true, else false out2 \u00b6 public property bool out2 [readonly] if in == startsAt + 1, out2 is true, else false out3 \u00b6 public property bool out3 [readonly] if in == startsAt + 2, out3 is true, else false out4 \u00b6 public property bool out4 [readonly] if in == startsAt + 3, out4 is true, else false startsAt \u00b6 public property int startsAt [config] starting value for in Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > DemuxI2B4","title":"DemuxI2B4"},{"location":"api/control/DemuxI2B4/#demuxi2b4","text":"Doc Home > API Index > control > DemuxI2B4","title":"DemuxI2B4"},{"location":"api/control/DemuxI2B4/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::DemuxI2B4 public class DemuxI2B4 [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] Demuxes an integer count input into 4 boolean outputs. By setting \"startsAt\" appropriately, N objects can demux to N*4 outputs (ie, you can create a 4x, 8x, 16x, etc demux) if in == startsAt + 0, out1 is true, else false if in == startsAt + 1, out2 is true, else false if in == startsAt + 2, out3 is true, else false if in == startsAt + 3, out4 is true, else false","title":"Inheritance"},{"location":"api/control/DemuxI2B4/#fields","text":"","title":"Fields"},{"location":"api/control/DemuxI2B4/#in","text":"public property int in input","title":"in"},{"location":"api/control/DemuxI2B4/#out1","text":"public property bool out1 [readonly] if in == startsAt + 0, out1 is true, else false","title":"out1"},{"location":"api/control/DemuxI2B4/#out2","text":"public property bool out2 [readonly] if in == startsAt + 1, out2 is true, else false","title":"out2"},{"location":"api/control/DemuxI2B4/#out3","text":"public property bool out3 [readonly] if in == startsAt + 2, out3 is true, else false","title":"out3"},{"location":"api/control/DemuxI2B4/#out4","text":"public property bool out4 [readonly] if in == startsAt + 3, out4 is true, else false","title":"out4"},{"location":"api/control/DemuxI2B4/#startsat","text":"public property int startsAt [config] starting value for in","title":"startsAt"},{"location":"api/control/DemuxI2B4/#methods","text":"","title":"Methods"},{"location":"api/control/DemuxI2B4/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > DemuxI2B4","title":"execute"},{"location":"api/control/Div2/","text":"Div2 \u00b6 Doc Home > API Index > control > Div2 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Div2 public class Div2 [niagaraIcon=\"module://icons/x16/control/math/divide.png\"] Div2 Two Input Division object out = in1 / in2 Fields \u00b6 div0 \u00b6 public property bool div0 [readonly] if in2 is 0, div0 is true and out gets set to 0.0 in1 \u00b6 public property float in1 numerator value in2 \u00b6 public property float in2 denominator value out \u00b6 public property float out [readonly] output value Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Div2","title":"Div2"},{"location":"api/control/Div2/#div2","text":"Doc Home > API Index > control > Div2","title":"Div2"},{"location":"api/control/Div2/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Div2 public class Div2 [niagaraIcon=\"module://icons/x16/control/math/divide.png\"] Div2 Two Input Division object out = in1 / in2","title":"Inheritance"},{"location":"api/control/Div2/#fields","text":"","title":"Fields"},{"location":"api/control/Div2/#div0","text":"public property bool div0 [readonly] if in2 is 0, div0 is true and out gets set to 0.0","title":"div0"},{"location":"api/control/Div2/#in1","text":"public property float in1 numerator value","title":"in1"},{"location":"api/control/Div2/#in2","text":"public property float in2 denominator value","title":"in2"},{"location":"api/control/Div2/#out","text":"public property float out [readonly] output value","title":"out"},{"location":"api/control/Div2/#methods","text":"","title":"Methods"},{"location":"api/control/Div2/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Div2","title":"execute"},{"location":"api/control/DlyOff/","text":"DlyOff \u00b6 Doc Home > API Index > control > DlyOff Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::DlyOff public class DlyOff [niagaraIcon=\"module://icons/x16/control/control.png\"] DlyOff Delay Off object Delays the on to off transition by a time delay Fields \u00b6 delayTime \u00b6 public property float delayTime [summary, unit=\"second\", config] Specified hold time in sec hold \u00b6 public property int hold [unit=\"millisecond\", readonly] Remaining hold time in msec in \u00b6 public property bool in Input signal out \u00b6 public property bool out [readonly] Output signal Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > DlyOff","title":"DlyOff"},{"location":"api/control/DlyOff/#dlyoff","text":"Doc Home > API Index > control > DlyOff","title":"DlyOff"},{"location":"api/control/DlyOff/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::DlyOff public class DlyOff [niagaraIcon=\"module://icons/x16/control/control.png\"] DlyOff Delay Off object Delays the on to off transition by a time delay","title":"Inheritance"},{"location":"api/control/DlyOff/#fields","text":"","title":"Fields"},{"location":"api/control/DlyOff/#delaytime","text":"public property float delayTime [summary, unit=\"second\", config] Specified hold time in sec","title":"delayTime"},{"location":"api/control/DlyOff/#hold","text":"public property int hold [unit=\"millisecond\", readonly] Remaining hold time in msec","title":"hold"},{"location":"api/control/DlyOff/#in","text":"public property bool in Input signal","title":"in"},{"location":"api/control/DlyOff/#out","text":"public property bool out [readonly] Output signal","title":"out"},{"location":"api/control/DlyOff/#methods","text":"","title":"Methods"},{"location":"api/control/DlyOff/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/DlyOff/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > DlyOff","title":"start"},{"location":"api/control/DlyOn/","text":"DlyOn \u00b6 Doc Home > API Index > control > DlyOn Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::DlyOn public class DlyOn [niagaraIcon=\"module://icons/x16/control/control.png\"] DlyOn Delay On object Delays the off to on transition by a time delay Fields \u00b6 delayTime \u00b6 public property float delayTime [summary, unit=\"second\", config] Specified hold time in sec hold \u00b6 public property int hold [unit=\"millisecond\", readonly] Remaining hold time in msec in \u00b6 public property bool in Input signal out \u00b6 public property bool out [readonly] Output signal Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > DlyOn","title":"DlyOn"},{"location":"api/control/DlyOn/#dlyon","text":"Doc Home > API Index > control > DlyOn","title":"DlyOn"},{"location":"api/control/DlyOn/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::DlyOn public class DlyOn [niagaraIcon=\"module://icons/x16/control/control.png\"] DlyOn Delay On object Delays the off to on transition by a time delay","title":"Inheritance"},{"location":"api/control/DlyOn/#fields","text":"","title":"Fields"},{"location":"api/control/DlyOn/#delaytime","text":"public property float delayTime [summary, unit=\"second\", config] Specified hold time in sec","title":"delayTime"},{"location":"api/control/DlyOn/#hold","text":"public property int hold [unit=\"millisecond\", readonly] Remaining hold time in msec","title":"hold"},{"location":"api/control/DlyOn/#in","text":"public property bool in Input signal","title":"in"},{"location":"api/control/DlyOn/#out","text":"public property bool out [readonly] Output signal","title":"out"},{"location":"api/control/DlyOn/#methods","text":"","title":"Methods"},{"location":"api/control/DlyOn/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/DlyOn/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > DlyOn","title":"start"},{"location":"api/control/F2B/","text":"F2B \u00b6 Doc Home > API Index > control > F2B Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::F2B public class F2B [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] F2b float 16 bit decoder object The input float is cast to an int, which is then decoded to 16 bools of output out1 to out16 = decode with out1 = LSB and out16 = MSB ovrf is set if in > 65535 Fields \u00b6 in \u00b6 public property float in input value to be decoded out1 \u00b6 public property bool out1 [readonly] out1 is set if bit 0 (LSB) is set out10 \u00b6 public property bool out10 [readonly] out2 is set if bit 9 is set out11 \u00b6 public property bool out11 [readonly] out2 is set if bit 10 is set out12 \u00b6 public property bool out12 [readonly] out2 is set if bit 11 is set out13 \u00b6 public property bool out13 [readonly] out2 is set if bit 12 is set out14 \u00b6 public property bool out14 [readonly] out2 is set if bit 13 is set out15 \u00b6 public property bool out15 [readonly] out2 is set if bit 14 is set out16 \u00b6 public property bool out16 [readonly] out2 is set if bit 15 (MSB) is set out2 \u00b6 public property bool out2 [readonly] out2 is set if bit 1 is set out3 \u00b6 public property bool out3 [readonly] out2 is set if bit 2 is set out4 \u00b6 public property bool out4 [readonly] out2 is set if bit 3 is set out5 \u00b6 public property bool out5 [readonly] out2 is set if bit 4 is set out6 \u00b6 public property bool out6 [readonly] out2 is set if bit 5 is set out7 \u00b6 public property bool out7 [readonly] out2 is set if bit 6 is set out8 \u00b6 public property bool out8 [readonly] out2 is set if bit 7 is set out9 \u00b6 public property bool out9 [readonly] out2 is set if bit 8 is set ovrf \u00b6 public property bool ovrf [readonly] ovrf is set if in > 65535 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > F2B","title":"F2B"},{"location":"api/control/F2B/#f2b","text":"Doc Home > API Index > control > F2B","title":"F2B"},{"location":"api/control/F2B/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::F2B public class F2B [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] F2b float 16 bit decoder object The input float is cast to an int, which is then decoded to 16 bools of output out1 to out16 = decode with out1 = LSB and out16 = MSB ovrf is set if in > 65535","title":"Inheritance"},{"location":"api/control/F2B/#fields","text":"","title":"Fields"},{"location":"api/control/F2B/#in","text":"public property float in input value to be decoded","title":"in"},{"location":"api/control/F2B/#out1","text":"public property bool out1 [readonly] out1 is set if bit 0 (LSB) is set","title":"out1"},{"location":"api/control/F2B/#out10","text":"public property bool out10 [readonly] out2 is set if bit 9 is set","title":"out10"},{"location":"api/control/F2B/#out11","text":"public property bool out11 [readonly] out2 is set if bit 10 is set","title":"out11"},{"location":"api/control/F2B/#out12","text":"public property bool out12 [readonly] out2 is set if bit 11 is set","title":"out12"},{"location":"api/control/F2B/#out13","text":"public property bool out13 [readonly] out2 is set if bit 12 is set","title":"out13"},{"location":"api/control/F2B/#out14","text":"public property bool out14 [readonly] out2 is set if bit 13 is set","title":"out14"},{"location":"api/control/F2B/#out15","text":"public property bool out15 [readonly] out2 is set if bit 14 is set","title":"out15"},{"location":"api/control/F2B/#out16","text":"public property bool out16 [readonly] out2 is set if bit 15 (MSB) is set","title":"out16"},{"location":"api/control/F2B/#out2","text":"public property bool out2 [readonly] out2 is set if bit 1 is set","title":"out2"},{"location":"api/control/F2B/#out3","text":"public property bool out3 [readonly] out2 is set if bit 2 is set","title":"out3"},{"location":"api/control/F2B/#out4","text":"public property bool out4 [readonly] out2 is set if bit 3 is set","title":"out4"},{"location":"api/control/F2B/#out5","text":"public property bool out5 [readonly] out2 is set if bit 4 is set","title":"out5"},{"location":"api/control/F2B/#out6","text":"public property bool out6 [readonly] out2 is set if bit 5 is set","title":"out6"},{"location":"api/control/F2B/#out7","text":"public property bool out7 [readonly] out2 is set if bit 6 is set","title":"out7"},{"location":"api/control/F2B/#out8","text":"public property bool out8 [readonly] out2 is set if bit 7 is set","title":"out8"},{"location":"api/control/F2B/#out9","text":"public property bool out9 [readonly] out2 is set if bit 8 is set","title":"out9"},{"location":"api/control/F2B/#ovrf","text":"public property bool ovrf [readonly] ovrf is set if in > 65535","title":"ovrf"},{"location":"api/control/F2B/#methods","text":"","title":"Methods"},{"location":"api/control/F2B/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > F2B","title":"execute"},{"location":"api/control/F2I/","text":"F2I \u00b6 Doc Home > API Index > control > F2I Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::F2I public class F2I [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] F2I float-to-integer converter Fields \u00b6 in \u00b6 public property float in input to convert to integer out \u00b6 public property int out [readonly] input converted to an integer Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > F2I","title":"F2I"},{"location":"api/control/F2I/#f2i","text":"Doc Home > API Index > control > F2I","title":"F2I"},{"location":"api/control/F2I/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::F2I public class F2I [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] F2I float-to-integer converter","title":"Inheritance"},{"location":"api/control/F2I/#fields","text":"","title":"Fields"},{"location":"api/control/F2I/#in","text":"public property float in input to convert to integer","title":"in"},{"location":"api/control/F2I/#out","text":"public property int out [readonly] input converted to an integer","title":"out"},{"location":"api/control/F2I/#methods","text":"","title":"Methods"},{"location":"api/control/F2I/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > F2I","title":"execute"},{"location":"api/control/FloatOffset/","text":"FloatOffset \u00b6 Doc Home > API Index > control > FloatOffset Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::FloatOffset public class FloatOffset [niagaraIcon=\"module://icons/x16/control/math/add.png\"] FloatOffset: adds an offset value to the input value out = in + offset Fields \u00b6 in \u00b6 public property float in input value offset \u00b6 public property float offset [config] constant value to add to the input to get output out \u00b6 public property float out [readonly] out = in + offset Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > FloatOffset","title":"FloatOffset"},{"location":"api/control/FloatOffset/#floatoffset","text":"Doc Home > API Index > control > FloatOffset","title":"FloatOffset"},{"location":"api/control/FloatOffset/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::FloatOffset public class FloatOffset [niagaraIcon=\"module://icons/x16/control/math/add.png\"] FloatOffset: adds an offset value to the input value out = in + offset","title":"Inheritance"},{"location":"api/control/FloatOffset/#fields","text":"","title":"Fields"},{"location":"api/control/FloatOffset/#in","text":"public property float in input value","title":"in"},{"location":"api/control/FloatOffset/#offset","text":"public property float offset [config] constant value to add to the input to get output","title":"offset"},{"location":"api/control/FloatOffset/#out","text":"public property float out [readonly] out = in + offset","title":"out"},{"location":"api/control/FloatOffset/#methods","text":"","title":"Methods"},{"location":"api/control/FloatOffset/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > FloatOffset","title":"execute"},{"location":"api/control/Freq/","text":"Freq \u00b6 Doc Home > API Index > control > Freq Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Freq public class Freq [niagaraIcon=\"module://icons/x16/control/control.png\"] Freq calculates instantaneous input pulse frequency (based on rising edges). Result is output in pulses per second and pulses per minute. Note: since input is checked only once per app cycle, result cannot exceed 1/2 execute scan frequency. Fields \u00b6 in \u00b6 public property bool in input ppm \u00b6 public property float ppm [unit=\"per_minute\", readonly, precision=3] frequency in pulse per minute pps \u00b6 public property float pps [unit=\"per_second\", readonly, precision=3] frequency in pulses per second Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > Freq","title":"Freq"},{"location":"api/control/Freq/#freq","text":"Doc Home > API Index > control > Freq","title":"Freq"},{"location":"api/control/Freq/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Freq public class Freq [niagaraIcon=\"module://icons/x16/control/control.png\"] Freq calculates instantaneous input pulse frequency (based on rising edges). Result is output in pulses per second and pulses per minute. Note: since input is checked only once per app cycle, result cannot exceed 1/2 execute scan frequency.","title":"Inheritance"},{"location":"api/control/Freq/#fields","text":"","title":"Fields"},{"location":"api/control/Freq/#in","text":"public property bool in input","title":"in"},{"location":"api/control/Freq/#ppm","text":"public property float ppm [unit=\"per_minute\", readonly, precision=3] frequency in pulse per minute","title":"ppm"},{"location":"api/control/Freq/#pps","text":"public property float pps [unit=\"per_second\", readonly, precision=3] frequency in pulses per second","title":"pps"},{"location":"api/control/Freq/#methods","text":"","title":"Methods"},{"location":"api/control/Freq/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/Freq/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > Freq","title":"start"},{"location":"api/control/Hysteresis/","text":"Hysteresis \u00b6 Doc Home > API Index > control > Hysteresis Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Hysteresis public class Hysteresis [niagaraIcon=\"module://icons/x16/control/util/hysteresis.png\"] Applies hysteresis to an input value to set a boolean out. NOTE: If \"Rising Edge\" > \"Falling Edge\", then out behaves \"normally\", ie out switches to \"true\" when in rises above \"Rising Edge\", and switches back to \"false\" when in falls below \"Falling Edge\" Falling Rising Edge Edge |----------|------- | | --------|----------| NOTE: If \"Rising Edge\" < \"Falling Edge\", then out behaves \"inverted\", ie out switches to \"false\" when in rises above \"Falling Edge\", and switches back to \"true\" when in falls below \"Rising Edge\" Rising Falling Edge Edge --------|----------| | | |----------|------- NOTE: If \"Rising Edge\" == \"Falling Edge\", this object become a simple comparator, where if in > Rising Edge, then out = true Fields \u00b6 fallingEdge \u00b6 public property float fallingEdge [defaultOnClone, config] threshold for falling edge in \u00b6 public property float in input value to which hysteresis is to be applied out \u00b6 public property bool out [readonly] boolean output risingEdge \u00b6 public property float risingEdge [defaultOnClone, config] threshold for rising edge Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Hysteresis","title":"Hysteresis"},{"location":"api/control/Hysteresis/#hysteresis","text":"Doc Home > API Index > control > Hysteresis","title":"Hysteresis"},{"location":"api/control/Hysteresis/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Hysteresis public class Hysteresis [niagaraIcon=\"module://icons/x16/control/util/hysteresis.png\"] Applies hysteresis to an input value to set a boolean out. NOTE: If \"Rising Edge\" > \"Falling Edge\", then out behaves \"normally\", ie out switches to \"true\" when in rises above \"Rising Edge\", and switches back to \"false\" when in falls below \"Falling Edge\" Falling Rising Edge Edge |----------|------- | | --------|----------| NOTE: If \"Rising Edge\" < \"Falling Edge\", then out behaves \"inverted\", ie out switches to \"false\" when in rises above \"Falling Edge\", and switches back to \"true\" when in falls below \"Rising Edge\" Rising Falling Edge Edge --------|----------| | | |----------|------- NOTE: If \"Rising Edge\" == \"Falling Edge\", this object become a simple comparator, where if in > Rising Edge, then out = true","title":"Inheritance"},{"location":"api/control/Hysteresis/#fields","text":"","title":"Fields"},{"location":"api/control/Hysteresis/#fallingedge","text":"public property float fallingEdge [defaultOnClone, config] threshold for falling edge","title":"fallingEdge"},{"location":"api/control/Hysteresis/#in","text":"public property float in input value to which hysteresis is to be applied","title":"in"},{"location":"api/control/Hysteresis/#out","text":"public property bool out [readonly] boolean output","title":"out"},{"location":"api/control/Hysteresis/#risingedge","text":"public property float risingEdge [defaultOnClone, config] threshold for rising edge","title":"risingEdge"},{"location":"api/control/Hysteresis/#methods","text":"","title":"Methods"},{"location":"api/control/Hysteresis/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Hysteresis","title":"execute"},{"location":"api/control/I2F/","text":"I2F \u00b6 Doc Home > API Index > control > I2F Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::I2F public class I2F [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] I2F integer-to-float converter Fields \u00b6 in \u00b6 public property int in input to convert to float out \u00b6 public property float out [readonly] input converted to an float Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > I2F","title":"I2F"},{"location":"api/control/I2F/#i2f","text":"Doc Home > API Index > control > I2F","title":"I2F"},{"location":"api/control/I2F/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::I2F public class I2F [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] I2F integer-to-float converter","title":"Inheritance"},{"location":"api/control/I2F/#fields","text":"","title":"Fields"},{"location":"api/control/I2F/#in","text":"public property int in input to convert to float","title":"in"},{"location":"api/control/I2F/#out","text":"public property float out [readonly] input converted to an float","title":"out"},{"location":"api/control/I2F/#methods","text":"","title":"Methods"},{"location":"api/control/I2F/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > I2F","title":"execute"},{"location":"api/control/IRamp/","text":"IRamp \u00b6 Doc Home > API Index > control > IRamp Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::IRamp public class IRamp [niagaraIcon=\"module://icons/x16/control/util/sine.png\"] Ramp Triangle wave between min & max Slope is \"delta\" per \"secs\" seconds 'max' must be configured greater than 'min' Fields \u00b6 delta \u00b6 public property int delta [min=1, config] delta is added or subtracted from out every \"secs\" seconds max \u00b6 public property int max [config] max out value of the ramp object. Once max is reached, out will start ramping down min \u00b6 public property int min [config] min out value of the ramp object. Once min is reached, out will start ramping up out \u00b6 public property int out [readonly] secs \u00b6 public property long secs [unit=\"second\", min=1, config] determines how often delta is added/subtracted from out Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Start initializes the output Doc Home > API Index > control > IRamp","title":"IRamp"},{"location":"api/control/IRamp/#iramp","text":"Doc Home > API Index > control > IRamp","title":"IRamp"},{"location":"api/control/IRamp/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::IRamp public class IRamp [niagaraIcon=\"module://icons/x16/control/util/sine.png\"] Ramp Triangle wave between min & max Slope is \"delta\" per \"secs\" seconds 'max' must be configured greater than 'min'","title":"Inheritance"},{"location":"api/control/IRamp/#fields","text":"","title":"Fields"},{"location":"api/control/IRamp/#delta","text":"public property int delta [min=1, config] delta is added or subtracted from out every \"secs\" seconds","title":"delta"},{"location":"api/control/IRamp/#max","text":"public property int max [config] max out value of the ramp object. Once max is reached, out will start ramping down","title":"max"},{"location":"api/control/IRamp/#min","text":"public property int min [config] min out value of the ramp object. Once min is reached, out will start ramping up","title":"min"},{"location":"api/control/IRamp/#out","text":"public property int out [readonly]","title":"out"},{"location":"api/control/IRamp/#secs","text":"public property long secs [unit=\"second\", min=1, config] determines how often delta is added/subtracted from out","title":"secs"},{"location":"api/control/IRamp/#methods","text":"","title":"Methods"},{"location":"api/control/IRamp/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/IRamp/#start","text":"public virtual override void start() Start initializes the output Doc Home > API Index > control > IRamp","title":"start"},{"location":"api/control/ISW/","text":"ISW \u00b6 Doc Home > API Index > control > ISW Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::ISW public class ISW [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] ISW Integer Switch object out = s1 ? in2 : in1 Fields \u00b6 in1 \u00b6 public property int in1 input 1 in2 \u00b6 public property int in2 input 2 out \u00b6 public property int out [readonly] out = s1 ? in2 : in1 s1 \u00b6 public property bool s1 switch input Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > ISW","title":"ISW"},{"location":"api/control/ISW/#isw","text":"Doc Home > API Index > control > ISW","title":"ISW"},{"location":"api/control/ISW/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::ISW public class ISW [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] ISW Integer Switch object out = s1 ? in2 : in1","title":"Inheritance"},{"location":"api/control/ISW/#fields","text":"","title":"Fields"},{"location":"api/control/ISW/#in1","text":"public property int in1 input 1","title":"in1"},{"location":"api/control/ISW/#in2","text":"public property int in2 input 2","title":"in2"},{"location":"api/control/ISW/#out","text":"public property int out [readonly] out = s1 ? in2 : in1","title":"out"},{"location":"api/control/ISW/#s1","text":"public property bool s1 switch input","title":"s1"},{"location":"api/control/ISW/#methods","text":"","title":"Methods"},{"location":"api/control/ISW/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > ISW","title":"execute"},{"location":"api/control/L2F/","text":"L2F \u00b6 Doc Home > API Index > control > L2F Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::L2F public class L2F [niagaraIcon=\"module://icons/x16/doubleArrowRight.png\"] I2F integer-to-float converter Fields \u00b6 in \u00b6 public property long in input to convert to float out \u00b6 public property float out [readonly] input converted to an float Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > L2F","title":"L2F"},{"location":"api/control/L2F/#l2f","text":"Doc Home > API Index > control > L2F","title":"L2F"},{"location":"api/control/L2F/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::L2F public class L2F [niagaraIcon=\"module://icons/x16/doubleArrowRight.png\"] I2F integer-to-float converter","title":"Inheritance"},{"location":"api/control/L2F/#fields","text":"","title":"Fields"},{"location":"api/control/L2F/#in","text":"public property long in input to convert to float","title":"in"},{"location":"api/control/L2F/#out","text":"public property float out [readonly] input converted to an float","title":"out"},{"location":"api/control/L2F/#methods","text":"","title":"Methods"},{"location":"api/control/L2F/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > L2F","title":"execute"},{"location":"api/control/LP/","text":"LP \u00b6 Doc Home > API Index > control > LP Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::LP public class LP [niagaraIcon=\"module://icons/x16/control/numericPoint.png\"] Pid Loop object Fields \u00b6 bias \u00b6 public property float bias [config, precision=6] bias is applied directly to output if ki equals 0 cv \u00b6 public property float cv [precision=3] process feedback direct \u00b6 public property bool direct [config] direct acting or reverse acting process enable \u00b6 public property bool enable [config] loop enable. If false, output is held constant at previous value exTime \u00b6 public property int exTime [unit=\"millisecond\", min=0, config] loop is executed every exTime ms kd \u00b6 public property float kd [unit=\"second\", min=0.0, config, precision=6] derivative constant ki \u00b6 public property float ki [unit=\"per_minute\", min=0.0, config, precision=6] integral constant kp \u00b6 public property float kp [min=0.0, config, precision=6] proportional constant max \u00b6 public property float max [config, precision=6] max out value maxDelta \u00b6 public property float maxDelta [min=0.0, config, precision=6] the max amount out is allowed to change in exTime ms A setting of 0 disables this function min \u00b6 public property float min [config, precision=6] min out value out \u00b6 public property float out [readonly] out value, constrained to be between min and max sp \u00b6 public property float sp [summary, config] setpoint Methods \u00b6 changed \u00b6 public virtual override void changed( Slot slot) Behavior to execute when a property is changed externally execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > LP","title":"LP"},{"location":"api/control/LP/#lp","text":"Doc Home > API Index > control > LP","title":"LP"},{"location":"api/control/LP/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::LP public class LP [niagaraIcon=\"module://icons/x16/control/numericPoint.png\"] Pid Loop object","title":"Inheritance"},{"location":"api/control/LP/#fields","text":"","title":"Fields"},{"location":"api/control/LP/#bias","text":"public property float bias [config, precision=6] bias is applied directly to output if ki equals 0","title":"bias"},{"location":"api/control/LP/#cv","text":"public property float cv [precision=3] process feedback","title":"cv"},{"location":"api/control/LP/#direct","text":"public property bool direct [config] direct acting or reverse acting process","title":"direct"},{"location":"api/control/LP/#enable","text":"public property bool enable [config] loop enable. If false, output is held constant at previous value","title":"enable"},{"location":"api/control/LP/#extime","text":"public property int exTime [unit=\"millisecond\", min=0, config] loop is executed every exTime ms","title":"exTime"},{"location":"api/control/LP/#kd","text":"public property float kd [unit=\"second\", min=0.0, config, precision=6] derivative constant","title":"kd"},{"location":"api/control/LP/#ki","text":"public property float ki [unit=\"per_minute\", min=0.0, config, precision=6] integral constant","title":"ki"},{"location":"api/control/LP/#kp","text":"public property float kp [min=0.0, config, precision=6] proportional constant","title":"kp"},{"location":"api/control/LP/#max","text":"public property float max [config, precision=6] max out value","title":"max"},{"location":"api/control/LP/#maxdelta","text":"public property float maxDelta [min=0.0, config, precision=6] the max amount out is allowed to change in exTime ms A setting of 0 disables this function","title":"maxDelta"},{"location":"api/control/LP/#min","text":"public property float min [config, precision=6] min out value","title":"min"},{"location":"api/control/LP/#out","text":"public property float out [readonly] out value, constrained to be between min and max","title":"out"},{"location":"api/control/LP/#sp","text":"public property float sp [summary, config] setpoint","title":"sp"},{"location":"api/control/LP/#methods","text":"","title":"Methods"},{"location":"api/control/LP/#changed","text":"public virtual override void changed( Slot slot) Behavior to execute when a property is changed externally","title":"changed"},{"location":"api/control/LP/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/LP/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > LP","title":"start"},{"location":"api/control/LSeq/","text":"LSeq \u00b6 Doc Home > API Index > control > LSeq Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::LSeq public class LSeq [niagaraIcon=\"module://icons/x16/control/util/step.png\"] LSeq will provide a linear sequence of 1 to 16 loads. Analogous to a bar graph of the input value, where the delta represented by each output is (inMax-inMin)/(numOuts + 1). So given an input value, outputs 1 through n will be set true, and any remaining outputs will be false. If 'in' > 'inMax', then 'numOuts' outputs will be set true, and 'ovfl' will be set true The range of 'inMin' to 'inMax' is divided into 'numOuts+1' threshold values (delta), where: 'out1' is driven true if in > inMin + 1*delta, 'out1' and 'out2' are driven true if in > inMin + 2*delta, 'out1','out2', and 'out3' are driven true if in > inMin + 3*delta, etc delta = inMax-inMin/(numOuts + 1) A hysteresis of \u00bd delta is required to turn an output off. Fields \u00b6 dOn \u00b6 public property byte dOn [readonly] Number of outputs turned on delta \u00b6 public property float delta [readonly] Size of each output's range delta = (inMax-inMin)/(numOuts+1) in \u00b6 public property float in input will be divided into 'numOuts' sub ranges over the range inMin to inMax inMax \u00b6 public property float inMax [config] Expected input maximum inMin \u00b6 public property float inMin [config] Expected input minimum invalidConfig \u00b6 public bool invalidConfig max \u00b6 public float max min \u00b6 public float min numOuts \u00b6 public property int numOuts [min=1, max=16, config] The range of 'inMin' to 'inMax' is divided into 'numOuts' threshold values, where: delta = (inMax-inMin)/(numOuts + 1) 'out1' is driven true if in > inMin + 1*delta, 'out1' and 'out2' are driven true if in > inMin + 2*delta, 'out1','out2', and 'out3' are driven true if in > inMin + 3*delta, etc out1 \u00b6 public property bool out1 [readonly] output 1 out10 \u00b6 public property bool out10 [readonly] output 10 out11 \u00b6 public property bool out11 [readonly] output 11 out12 \u00b6 public property bool out12 [readonly] output 12 out13 \u00b6 public property bool out13 [readonly] output 13 out14 \u00b6 public property bool out14 [readonly] output 14 out15 \u00b6 public property bool out15 [readonly] output 15 out16 \u00b6 public property bool out16 [readonly] output 16 out2 \u00b6 public property bool out2 [readonly] output 2 out3 \u00b6 public property bool out3 [readonly] output 3 out4 \u00b6 public property bool out4 [readonly] output 4 out5 \u00b6 public property bool out5 [readonly] output 5 out6 \u00b6 public property bool out6 [readonly] output 6 out7 \u00b6 public property bool out7 [readonly] output 7 out8 \u00b6 public property bool out8 [readonly] output 8 out9 \u00b6 public property bool out9 [readonly] output 9 ovfl \u00b6 public property bool ovfl [readonly] Overflow is set when in > inMax Methods \u00b6 changed \u00b6 public override void changed( Slot slot) Behavior to execute when a property is changed externally Update the delta value execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > LSeq","title":"LSeq"},{"location":"api/control/LSeq/#lseq","text":"Doc Home > API Index > control > LSeq","title":"LSeq"},{"location":"api/control/LSeq/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::LSeq public class LSeq [niagaraIcon=\"module://icons/x16/control/util/step.png\"] LSeq will provide a linear sequence of 1 to 16 loads. Analogous to a bar graph of the input value, where the delta represented by each output is (inMax-inMin)/(numOuts + 1). So given an input value, outputs 1 through n will be set true, and any remaining outputs will be false. If 'in' > 'inMax', then 'numOuts' outputs will be set true, and 'ovfl' will be set true The range of 'inMin' to 'inMax' is divided into 'numOuts+1' threshold values (delta), where: 'out1' is driven true if in > inMin + 1*delta, 'out1' and 'out2' are driven true if in > inMin + 2*delta, 'out1','out2', and 'out3' are driven true if in > inMin + 3*delta, etc delta = inMax-inMin/(numOuts + 1) A hysteresis of \u00bd delta is required to turn an output off.","title":"Inheritance"},{"location":"api/control/LSeq/#fields","text":"","title":"Fields"},{"location":"api/control/LSeq/#don","text":"public property byte dOn [readonly] Number of outputs turned on","title":"dOn"},{"location":"api/control/LSeq/#delta","text":"public property float delta [readonly] Size of each output's range delta = (inMax-inMin)/(numOuts+1)","title":"delta"},{"location":"api/control/LSeq/#in","text":"public property float in input will be divided into 'numOuts' sub ranges over the range inMin to inMax","title":"in"},{"location":"api/control/LSeq/#inmax","text":"public property float inMax [config] Expected input maximum","title":"inMax"},{"location":"api/control/LSeq/#inmin","text":"public property float inMin [config] Expected input minimum","title":"inMin"},{"location":"api/control/LSeq/#invalidconfig","text":"public bool invalidConfig","title":"invalidConfig"},{"location":"api/control/LSeq/#max","text":"public float max","title":"max"},{"location":"api/control/LSeq/#min","text":"public float min","title":"min"},{"location":"api/control/LSeq/#numouts","text":"public property int numOuts [min=1, max=16, config] The range of 'inMin' to 'inMax' is divided into 'numOuts' threshold values, where: delta = (inMax-inMin)/(numOuts + 1) 'out1' is driven true if in > inMin + 1*delta, 'out1' and 'out2' are driven true if in > inMin + 2*delta, 'out1','out2', and 'out3' are driven true if in > inMin + 3*delta, etc","title":"numOuts"},{"location":"api/control/LSeq/#out1","text":"public property bool out1 [readonly] output 1","title":"out1"},{"location":"api/control/LSeq/#out10","text":"public property bool out10 [readonly] output 10","title":"out10"},{"location":"api/control/LSeq/#out11","text":"public property bool out11 [readonly] output 11","title":"out11"},{"location":"api/control/LSeq/#out12","text":"public property bool out12 [readonly] output 12","title":"out12"},{"location":"api/control/LSeq/#out13","text":"public property bool out13 [readonly] output 13","title":"out13"},{"location":"api/control/LSeq/#out14","text":"public property bool out14 [readonly] output 14","title":"out14"},{"location":"api/control/LSeq/#out15","text":"public property bool out15 [readonly] output 15","title":"out15"},{"location":"api/control/LSeq/#out16","text":"public property bool out16 [readonly] output 16","title":"out16"},{"location":"api/control/LSeq/#out2","text":"public property bool out2 [readonly] output 2","title":"out2"},{"location":"api/control/LSeq/#out3","text":"public property bool out3 [readonly] output 3","title":"out3"},{"location":"api/control/LSeq/#out4","text":"public property bool out4 [readonly] output 4","title":"out4"},{"location":"api/control/LSeq/#out5","text":"public property bool out5 [readonly] output 5","title":"out5"},{"location":"api/control/LSeq/#out6","text":"public property bool out6 [readonly] output 6","title":"out6"},{"location":"api/control/LSeq/#out7","text":"public property bool out7 [readonly] output 7","title":"out7"},{"location":"api/control/LSeq/#out8","text":"public property bool out8 [readonly] output 8","title":"out8"},{"location":"api/control/LSeq/#out9","text":"public property bool out9 [readonly] output 9","title":"out9"},{"location":"api/control/LSeq/#ovfl","text":"public property bool ovfl [readonly] Overflow is set when in > inMax","title":"ovfl"},{"location":"api/control/LSeq/#methods","text":"","title":"Methods"},{"location":"api/control/LSeq/#changed","text":"public override void changed( Slot slot) Behavior to execute when a property is changed externally Update the delta value","title":"changed"},{"location":"api/control/LSeq/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/LSeq/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > LSeq","title":"start"},{"location":"api/control/Limiter/","text":"Limiter \u00b6 Doc Home > API Index > control > Limiter Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Limiter public class Limiter [niagaraIcon=\"module://icons/x16/control/util/limit.png\"] Limits input between two configured values If (in < lowLmt), out = lowLmt else if (in > highLmt), out = highLmt else out = in Fields \u00b6 highLmt \u00b6 public property float highLmt [config] high limit value. If (in > highLmt), out = highLmt in \u00b6 public property float in input value lowLmt \u00b6 public property float lowLmt [config] low limit value. If (in < lowLmt), out = lowLmt out \u00b6 public property float out [readonly] the range limited output Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Limiter","title":"Limiter"},{"location":"api/control/Limiter/#limiter","text":"Doc Home > API Index > control > Limiter","title":"Limiter"},{"location":"api/control/Limiter/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Limiter public class Limiter [niagaraIcon=\"module://icons/x16/control/util/limit.png\"] Limits input between two configured values If (in < lowLmt), out = lowLmt else if (in > highLmt), out = highLmt else out = in","title":"Inheritance"},{"location":"api/control/Limiter/#fields","text":"","title":"Fields"},{"location":"api/control/Limiter/#highlmt","text":"public property float highLmt [config] high limit value. If (in > highLmt), out = highLmt","title":"highLmt"},{"location":"api/control/Limiter/#in","text":"public property float in input value","title":"in"},{"location":"api/control/Limiter/#lowlmt","text":"public property float lowLmt [config] low limit value. If (in < lowLmt), out = lowLmt","title":"lowLmt"},{"location":"api/control/Limiter/#out","text":"public property float out [readonly] the range limited output","title":"out"},{"location":"api/control/Limiter/#methods","text":"","title":"Methods"},{"location":"api/control/Limiter/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Limiter","title":"execute"},{"location":"api/control/Linearize/","text":"Linearize \u00b6 Doc Home > API Index > control > Linearize Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Linearize public class Linearize [niagaraIcon=\"module://icons/x16/control/util/xy.png\"] Converts a table of values into a curve using linear interpolation between the values. Individual slope/intercept constants are computed between the x's and y's using the formula y = mx + b, where m = ym - yn/xm - xn If in is not in the range of x0 to x9, then output is set to \"nan\" Note that slope may be positive or negative, and is indicated by comparison of x1 and x0 (positive if x1 > x0, negitive if x1 < x0) Fields \u00b6 in \u00b6 public property float in input out \u00b6 public property float out [readonly] linearized output tmp \u00b6 public float tmp x0 \u00b6 public property float x0 [config] linear interpolation x0 point x1 \u00b6 public property float x1 [config] linear interpolation x1 point x2 \u00b6 public property float x2 [config] linear interpolation x2 point x3 \u00b6 public property float x3 [config] linear interpolation x3 point x4 \u00b6 public property float x4 [config] linear interpolation x4 point x5 \u00b6 public property float x5 [config] linear interpolation x5 point x6 \u00b6 public property float x6 [config] linear interpolation x6 point x7 \u00b6 public property float x7 [config] linear interpolation x7 point x8 \u00b6 public property float x8 [config] linear interpolation x8 point x9 \u00b6 public property float x9 [config] linear interpolation x9 point y0 \u00b6 public property float y0 [config] linear interpolation y0 point y1 \u00b6 public property float y1 [config] linear interpolation y1 point y2 \u00b6 public property float y2 [config] linear interpolation y2 point y3 \u00b6 public property float y3 [config] linear interpolation y3 point y4 \u00b6 public property float y4 [config] linear interpolation y4 point y5 \u00b6 public property float y5 [config] linear interpolation Y5 point y6 \u00b6 public property float y6 [config] linear interpolation Y6 point y7 \u00b6 public property float y7 [config] linear interpolation Y7 point y8 \u00b6 public property float y8 [config] linear interpolation Y8 point y9 \u00b6 public property float y9 [config] linear interpolation Y9 point Methods \u00b6 convert \u00b6 public virtual void convert(float Y2, float Y1, float X2, float X1) Convert value in to value out by using linear interpolation between point1 and point2 using formula y=mx + b execute \u00b6 public virtual override void execute() Execute is called once every scan to convert 'in' to 'out' using linear interpolation between inflection points (x,y) Doc Home > API Index > control > Linearize","title":"Linearize"},{"location":"api/control/Linearize/#linearize","text":"Doc Home > API Index > control > Linearize","title":"Linearize"},{"location":"api/control/Linearize/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Linearize public class Linearize [niagaraIcon=\"module://icons/x16/control/util/xy.png\"] Converts a table of values into a curve using linear interpolation between the values. Individual slope/intercept constants are computed between the x's and y's using the formula y = mx + b, where m = ym - yn/xm - xn If in is not in the range of x0 to x9, then output is set to \"nan\" Note that slope may be positive or negative, and is indicated by comparison of x1 and x0 (positive if x1 > x0, negitive if x1 < x0)","title":"Inheritance"},{"location":"api/control/Linearize/#fields","text":"","title":"Fields"},{"location":"api/control/Linearize/#in","text":"public property float in input","title":"in"},{"location":"api/control/Linearize/#out","text":"public property float out [readonly] linearized output","title":"out"},{"location":"api/control/Linearize/#tmp","text":"public float tmp","title":"tmp"},{"location":"api/control/Linearize/#x0","text":"public property float x0 [config] linear interpolation x0 point","title":"x0"},{"location":"api/control/Linearize/#x1","text":"public property float x1 [config] linear interpolation x1 point","title":"x1"},{"location":"api/control/Linearize/#x2","text":"public property float x2 [config] linear interpolation x2 point","title":"x2"},{"location":"api/control/Linearize/#x3","text":"public property float x3 [config] linear interpolation x3 point","title":"x3"},{"location":"api/control/Linearize/#x4","text":"public property float x4 [config] linear interpolation x4 point","title":"x4"},{"location":"api/control/Linearize/#x5","text":"public property float x5 [config] linear interpolation x5 point","title":"x5"},{"location":"api/control/Linearize/#x6","text":"public property float x6 [config] linear interpolation x6 point","title":"x6"},{"location":"api/control/Linearize/#x7","text":"public property float x7 [config] linear interpolation x7 point","title":"x7"},{"location":"api/control/Linearize/#x8","text":"public property float x8 [config] linear interpolation x8 point","title":"x8"},{"location":"api/control/Linearize/#x9","text":"public property float x9 [config] linear interpolation x9 point","title":"x9"},{"location":"api/control/Linearize/#y0","text":"public property float y0 [config] linear interpolation y0 point","title":"y0"},{"location":"api/control/Linearize/#y1","text":"public property float y1 [config] linear interpolation y1 point","title":"y1"},{"location":"api/control/Linearize/#y2","text":"public property float y2 [config] linear interpolation y2 point","title":"y2"},{"location":"api/control/Linearize/#y3","text":"public property float y3 [config] linear interpolation y3 point","title":"y3"},{"location":"api/control/Linearize/#y4","text":"public property float y4 [config] linear interpolation y4 point","title":"y4"},{"location":"api/control/Linearize/#y5","text":"public property float y5 [config] linear interpolation Y5 point","title":"y5"},{"location":"api/control/Linearize/#y6","text":"public property float y6 [config] linear interpolation Y6 point","title":"y6"},{"location":"api/control/Linearize/#y7","text":"public property float y7 [config] linear interpolation Y7 point","title":"y7"},{"location":"api/control/Linearize/#y8","text":"public property float y8 [config] linear interpolation Y8 point","title":"y8"},{"location":"api/control/Linearize/#y9","text":"public property float y9 [config] linear interpolation Y9 point","title":"y9"},{"location":"api/control/Linearize/#methods","text":"","title":"Methods"},{"location":"api/control/Linearize/#convert","text":"public virtual void convert(float Y2, float Y1, float X2, float X1) Convert value in to value out by using linear interpolation between point1 and point2 using formula y=mx + b","title":"convert"},{"location":"api/control/Linearize/#execute","text":"public virtual override void execute() Execute is called once every scan to convert 'in' to 'out' using linear interpolation between inflection points (x,y) Doc Home > API Index > control > Linearize","title":"execute"},{"location":"api/control/Max/","text":"Max \u00b6 Doc Home > API Index > control > Max Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Max public class Max [niagaraIcon=\"module://icons/x16/control/control.png\"] Max selects the highest of 2 inputs to send to the output Fields \u00b6 in1 \u00b6 public property float in1 first value for comparison in2 \u00b6 public property float in2 second value for comparison out \u00b6 public property float out [readonly] the minimum of in1 and in2 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute the comparison Doc Home > API Index > control > Max","title":"Max"},{"location":"api/control/Max/#max","text":"Doc Home > API Index > control > Max","title":"Max"},{"location":"api/control/Max/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Max public class Max [niagaraIcon=\"module://icons/x16/control/control.png\"] Max selects the highest of 2 inputs to send to the output","title":"Inheritance"},{"location":"api/control/Max/#fields","text":"","title":"Fields"},{"location":"api/control/Max/#in1","text":"public property float in1 first value for comparison","title":"in1"},{"location":"api/control/Max/#in2","text":"public property float in2 second value for comparison","title":"in2"},{"location":"api/control/Max/#out","text":"public property float out [readonly] the minimum of in1 and in2","title":"out"},{"location":"api/control/Max/#methods","text":"","title":"Methods"},{"location":"api/control/Max/#execute","text":"public virtual override void execute() Execute the comparison Doc Home > API Index > control > Max","title":"execute"},{"location":"api/control/Min/","text":"Min \u00b6 Doc Home > API Index > control > Min Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Min public class Min [niagaraIcon=\"module://icons/x16/control/control.png\"] Min selects the lowest of 2 inputs to send to the output Fields \u00b6 in1 \u00b6 public property float in1 first value for comparison in2 \u00b6 public property float in2 second value for comparison out \u00b6 public property float out [readonly] the minimum of in1 and in2 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute the comparison Doc Home > API Index > control > Min","title":"Min"},{"location":"api/control/Min/#min","text":"Doc Home > API Index > control > Min","title":"Min"},{"location":"api/control/Min/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Min public class Min [niagaraIcon=\"module://icons/x16/control/control.png\"] Min selects the lowest of 2 inputs to send to the output","title":"Inheritance"},{"location":"api/control/Min/#fields","text":"","title":"Fields"},{"location":"api/control/Min/#in1","text":"public property float in1 first value for comparison","title":"in1"},{"location":"api/control/Min/#in2","text":"public property float in2 second value for comparison","title":"in2"},{"location":"api/control/Min/#out","text":"public property float out [readonly] the minimum of in1 and in2","title":"out"},{"location":"api/control/Min/#methods","text":"","title":"Methods"},{"location":"api/control/Min/#execute","text":"public virtual override void execute() Execute the comparison Doc Home > API Index > control > Min","title":"execute"},{"location":"api/control/MinMax/","text":"MinMax \u00b6 Doc Home > API Index > control > MinMax Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::MinMax public class MinMax [niagaraIcon=\"module://icons/x16/control/control.png\"] Min/Max object computes min and max of an input value every execute cycle Resets min/max to input value if r == true Fields \u00b6 in \u00b6 public property float in the value on which to track the min and max value maxOut \u00b6 public property float maxOut [readonly] the computed max of all in's minOut \u00b6 public property float minOut [readonly] the computed min of all in's r \u00b6 public property bool r reset input. If r = true, then minOut and maxOut are forced to \"in\" value Methods \u00b6 execute \u00b6 public virtual override void execute() Execute computes the min/max reset \u00b6 public action void reset() reset action sets the initial values start \u00b6 public virtual override void start() Start sets the initial values Doc Home > API Index > control > MinMax","title":"MinMax"},{"location":"api/control/MinMax/#minmax","text":"Doc Home > API Index > control > MinMax","title":"MinMax"},{"location":"api/control/MinMax/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::MinMax public class MinMax [niagaraIcon=\"module://icons/x16/control/control.png\"] Min/Max object computes min and max of an input value every execute cycle Resets min/max to input value if r == true","title":"Inheritance"},{"location":"api/control/MinMax/#fields","text":"","title":"Fields"},{"location":"api/control/MinMax/#in","text":"public property float in the value on which to track the min and max value","title":"in"},{"location":"api/control/MinMax/#maxout","text":"public property float maxOut [readonly] the computed max of all in's","title":"maxOut"},{"location":"api/control/MinMax/#minout","text":"public property float minOut [readonly] the computed min of all in's","title":"minOut"},{"location":"api/control/MinMax/#r","text":"public property bool r reset input. If r = true, then minOut and maxOut are forced to \"in\" value","title":"r"},{"location":"api/control/MinMax/#methods","text":"","title":"Methods"},{"location":"api/control/MinMax/#execute","text":"public virtual override void execute() Execute computes the min/max","title":"execute"},{"location":"api/control/MinMax/#reset","text":"public action void reset() reset action sets the initial values","title":"reset"},{"location":"api/control/MinMax/#start","text":"public virtual override void start() Start sets the initial values Doc Home > API Index > control > MinMax","title":"start"},{"location":"api/control/Mul2/","text":"Mul2 \u00b6 Doc Home > API Index > control > Mul2 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Mul2 public class Mul2 [niagaraIcon=\"module://icons/x16/control/math/multiply.png\"] Mul2 Two Input Multiplication object out = in1 * in2 Fields \u00b6 in1 \u00b6 public property float in1 input 1 in2 \u00b6 public property float in2 input 2 out \u00b6 public property float out [readonly] out = in1 * in2 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Mul2","title":"Mul2"},{"location":"api/control/Mul2/#mul2","text":"Doc Home > API Index > control > Mul2","title":"Mul2"},{"location":"api/control/Mul2/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Mul2 public class Mul2 [niagaraIcon=\"module://icons/x16/control/math/multiply.png\"] Mul2 Two Input Multiplication object out = in1 * in2","title":"Inheritance"},{"location":"api/control/Mul2/#fields","text":"","title":"Fields"},{"location":"api/control/Mul2/#in1","text":"public property float in1 input 1","title":"in1"},{"location":"api/control/Mul2/#in2","text":"public property float in2 input 2","title":"in2"},{"location":"api/control/Mul2/#out","text":"public property float out [readonly] out = in1 * in2","title":"out"},{"location":"api/control/Mul2/#methods","text":"","title":"Methods"},{"location":"api/control/Mul2/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Mul2","title":"execute"},{"location":"api/control/Mul4/","text":"Mul4 \u00b6 Doc Home > API Index > control > Mul4 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Mul2 control::Mul4 public class Mul4 Mul4 Four Input Multiplication object out = in1 * in2 * in3 * in4 Fields \u00b6 in3 \u00b6 public property float in3 input 3 in4 \u00b6 public property float in4 input 4 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Mul4","title":"Mul4"},{"location":"api/control/Mul4/#mul4","text":"Doc Home > API Index > control > Mul4","title":"Mul4"},{"location":"api/control/Mul4/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Mul2 control::Mul4 public class Mul4 Mul4 Four Input Multiplication object out = in1 * in2 * in3 * in4","title":"Inheritance"},{"location":"api/control/Mul4/#fields","text":"","title":"Fields"},{"location":"api/control/Mul4/#in3","text":"public property float in3 input 3","title":"in3"},{"location":"api/control/Mul4/#in4","text":"public property float in4 input 4","title":"in4"},{"location":"api/control/Mul4/#methods","text":"","title":"Methods"},{"location":"api/control/Mul4/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Mul4","title":"execute"},{"location":"api/control/Neg/","text":"Neg \u00b6 Doc Home > API Index > control > Neg Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Neg public class Neg [niagaraIcon=\"module://icons/x16/control/math/subtract.png\"] Neg Negate math object out = -in Fields \u00b6 in \u00b6 public property float in input out \u00b6 public property float out [readonly] output is negative of the input Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Neg","title":"Neg"},{"location":"api/control/Neg/#neg","text":"Doc Home > API Index > control > Neg","title":"Neg"},{"location":"api/control/Neg/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Neg public class Neg [niagaraIcon=\"module://icons/x16/control/math/subtract.png\"] Neg Negate math object out = -in","title":"Inheritance"},{"location":"api/control/Neg/#fields","text":"","title":"Fields"},{"location":"api/control/Neg/#in","text":"public property float in input","title":"in"},{"location":"api/control/Neg/#out","text":"public property float out [readonly] output is negative of the input","title":"out"},{"location":"api/control/Neg/#methods","text":"","title":"Methods"},{"location":"api/control/Neg/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Neg","title":"execute"},{"location":"api/control/Not/","text":"Not \u00b6 Doc Home > API Index > control > Not Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Not public class Not [niagaraIcon=\"module://icons/x16/control/logic/not.png\"] Not logic object if in == null, out = null else out = !in Fields \u00b6 in \u00b6 public property bool in input out \u00b6 public property bool out [readonly] output is !input Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Not","title":"Not"},{"location":"api/control/Not/#not","text":"Doc Home > API Index > control > Not","title":"Not"},{"location":"api/control/Not/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Not public class Not [niagaraIcon=\"module://icons/x16/control/logic/not.png\"] Not logic object if in == null, out = null else out = !in","title":"Inheritance"},{"location":"api/control/Not/#fields","text":"","title":"Fields"},{"location":"api/control/Not/#in","text":"public property bool in input","title":"in"},{"location":"api/control/Not/#out","text":"public property bool out [readonly] output is !input","title":"out"},{"location":"api/control/Not/#methods","text":"","title":"Methods"},{"location":"api/control/Not/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Not","title":"execute"},{"location":"api/control/OneShot/","text":"OneShot \u00b6 Doc Home > API Index > control > OneShot Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::OneShot public class OneShot [niagaraIcon=\"module://icons/x16/control/control.png\"] OneShot: Boolean one-shot pulse generator out = true for pulseWidth sec, beginning at rising edge of in pulse retriggers on each rising edge of in, if canRetrig = true Fields \u00b6 canRetrig \u00b6 public property bool canRetrig [config] If true, subsequent edges on input will restart pulse width measurement (resulting in wider overall output pulse) in \u00b6 public property bool in Input signal out \u00b6 public property bool out [readonly] Output signal pulseWidth \u00b6 public property float pulseWidth [unit=\"second\", min=0, config] Width of desired output pulse, in seconds Methods \u00b6 clear \u00b6 public action void clear() Clears the output immediately, cancelling any pulse in progress execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > OneShot","title":"OneShot"},{"location":"api/control/OneShot/#oneshot","text":"Doc Home > API Index > control > OneShot","title":"OneShot"},{"location":"api/control/OneShot/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::OneShot public class OneShot [niagaraIcon=\"module://icons/x16/control/control.png\"] OneShot: Boolean one-shot pulse generator out = true for pulseWidth sec, beginning at rising edge of in pulse retriggers on each rising edge of in, if canRetrig = true","title":"Inheritance"},{"location":"api/control/OneShot/#fields","text":"","title":"Fields"},{"location":"api/control/OneShot/#canretrig","text":"public property bool canRetrig [config] If true, subsequent edges on input will restart pulse width measurement (resulting in wider overall output pulse)","title":"canRetrig"},{"location":"api/control/OneShot/#in","text":"public property bool in Input signal","title":"in"},{"location":"api/control/OneShot/#out","text":"public property bool out [readonly] Output signal","title":"out"},{"location":"api/control/OneShot/#pulsewidth","text":"public property float pulseWidth [unit=\"second\", min=0, config] Width of desired output pulse, in seconds","title":"pulseWidth"},{"location":"api/control/OneShot/#methods","text":"","title":"Methods"},{"location":"api/control/OneShot/#clear","text":"public action void clear() Clears the output immediately, cancelling any pulse in progress","title":"clear"},{"location":"api/control/OneShot/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/OneShot/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > OneShot","title":"start"},{"location":"api/control/Or2/","text":"Or2 \u00b6 Doc Home > API Index > control > Or2 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Or2 public class Or2 [niagaraIcon=\"module://icons/x16/control/logic/or.png\"] Or2 Two input Or logic object null inputs ignored. If all inputs null, output is null out = in1 || in2 Fields \u00b6 in1 \u00b6 public property bool in1 input 1 in2 \u00b6 public property bool in2 input 2 out \u00b6 public property bool out [readonly] output = in1 || in2 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Or2","title":"Or2"},{"location":"api/control/Or2/#or2","text":"Doc Home > API Index > control > Or2","title":"Or2"},{"location":"api/control/Or2/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Or2 public class Or2 [niagaraIcon=\"module://icons/x16/control/logic/or.png\"] Or2 Two input Or logic object null inputs ignored. If all inputs null, output is null out = in1 || in2","title":"Inheritance"},{"location":"api/control/Or2/#fields","text":"","title":"Fields"},{"location":"api/control/Or2/#in1","text":"public property bool in1 input 1","title":"in1"},{"location":"api/control/Or2/#in2","text":"public property bool in2 input 2","title":"in2"},{"location":"api/control/Or2/#out","text":"public property bool out [readonly] output = in1 || in2","title":"out"},{"location":"api/control/Or2/#methods","text":"","title":"Methods"},{"location":"api/control/Or2/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Or2","title":"execute"},{"location":"api/control/Or4/","text":"Or4 \u00b6 Doc Home > API Index > control > Or4 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Or2 control::Or4 public class Or4 Or4 4 input OR logic object null inputs ignored. If all inputs null, output is null out = in1 || in2 || in3 || in4 in1 and in2 are inherited from Or2 class Fields \u00b6 in3 \u00b6 public property bool in3 input 3 in4 \u00b6 public property bool in4 input 4 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Or4","title":"Or4"},{"location":"api/control/Or4/#or4","text":"Doc Home > API Index > control > Or4","title":"Or4"},{"location":"api/control/Or4/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Or2 control::Or4 public class Or4 Or4 4 input OR logic object null inputs ignored. If all inputs null, output is null out = in1 || in2 || in3 || in4 in1 and in2 are inherited from Or2 class","title":"Inheritance"},{"location":"api/control/Or4/#fields","text":"","title":"Fields"},{"location":"api/control/Or4/#in3","text":"public property bool in3 input 3","title":"in3"},{"location":"api/control/Or4/#in4","text":"public property bool in4 input 4","title":"in4"},{"location":"api/control/Or4/#methods","text":"","title":"Methods"},{"location":"api/control/Or4/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Or4","title":"execute"},{"location":"api/control/Ramp/","text":"Ramp \u00b6 Doc Home > API Index > control > Ramp Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Ramp public class Ramp [niagaraIcon=\"module://icons/x16/control/util/sine.png\"] Ramp Triangle or sawtooth wave between min & max. New value calculated every execute cycle (does not rely on execution rate). Fields \u00b6 SAWTOOTH \u00b6 public static const define bool SAWTOOTH TRIANGLE \u00b6 public static const define bool TRIANGLE max \u00b6 public property float max [config] Maximum value min \u00b6 public property float min [config] Minimum value out \u00b6 public property float out [readonly] Ramp output period \u00b6 public property float period [unit=\"second\", min=0, config, precision=0] Ramp period If rampType is true (triangle) then this is the time it takes to complete up/down cycle. If rampType is false (sawtooth) then this is the time it takes to complete up cycle. A value of 0 forces output to min value. periodInNanos \u00b6 public long periodInNanos rampType \u00b6 public property bool rampType [falseText=\"sawtooth\", config, trueText=\"triangle\"] Specifies whether ramp is sawtooth (min to max and repeat), or triangle (min to max/max to min and repeat) Defaults to triangle. range \u00b6 public float range Methods \u00b6 changed \u00b6 public virtual override void changed( Slot slot) recompute internal constants if ramp parameters change execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() compute internal constants at startup Doc Home > API Index > control > Ramp","title":"Ramp"},{"location":"api/control/Ramp/#ramp","text":"Doc Home > API Index > control > Ramp","title":"Ramp"},{"location":"api/control/Ramp/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Ramp public class Ramp [niagaraIcon=\"module://icons/x16/control/util/sine.png\"] Ramp Triangle or sawtooth wave between min & max. New value calculated every execute cycle (does not rely on execution rate).","title":"Inheritance"},{"location":"api/control/Ramp/#fields","text":"","title":"Fields"},{"location":"api/control/Ramp/#sawtooth","text":"public static const define bool SAWTOOTH","title":"SAWTOOTH"},{"location":"api/control/Ramp/#triangle","text":"public static const define bool TRIANGLE","title":"TRIANGLE"},{"location":"api/control/Ramp/#max","text":"public property float max [config] Maximum value","title":"max"},{"location":"api/control/Ramp/#min","text":"public property float min [config] Minimum value","title":"min"},{"location":"api/control/Ramp/#out","text":"public property float out [readonly] Ramp output","title":"out"},{"location":"api/control/Ramp/#period","text":"public property float period [unit=\"second\", min=0, config, precision=0] Ramp period If rampType is true (triangle) then this is the time it takes to complete up/down cycle. If rampType is false (sawtooth) then this is the time it takes to complete up cycle. A value of 0 forces output to min value.","title":"period"},{"location":"api/control/Ramp/#periodinnanos","text":"public long periodInNanos","title":"periodInNanos"},{"location":"api/control/Ramp/#ramptype","text":"public property bool rampType [falseText=\"sawtooth\", config, trueText=\"triangle\"] Specifies whether ramp is sawtooth (min to max and repeat), or triangle (min to max/max to min and repeat) Defaults to triangle.","title":"rampType"},{"location":"api/control/Ramp/#range","text":"public float range","title":"range"},{"location":"api/control/Ramp/#methods","text":"","title":"Methods"},{"location":"api/control/Ramp/#changed","text":"public virtual override void changed( Slot slot) recompute internal constants if ramp parameters change","title":"changed"},{"location":"api/control/Ramp/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/Ramp/#start","text":"public virtual override void start() compute internal constants at startup Doc Home > API Index > control > Ramp","title":"start"},{"location":"api/control/ReheatSeq/","text":"ReheatSeq \u00b6 Doc Home > API Index > control > ReheatSeq Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::ReheatSeq public class ReheatSeq [niagaraIcon=\"module://icons/x16/control/util/step.png\"] ReheatSeq will provide a linear sequence of up to 4 loads based on configurable thresholds Sets an output true if the \"in\" value is greater than corresponding threshold, and returns the ouput to false if the \"in\" value is less than threshold minus the hysteresis value. \"dOn\" is the count of outputs that are true (0 to 4) If \"enable\" is false, all outputs are set to false regardless of in value. Fields \u00b6 dOn \u00b6 public property byte dOn [readonly] number of outputs currently turned on enable \u00b6 public property bool enable [config] all outputs are false if enable == false hysteresis \u00b6 public property float hysteresis [config] hysteresis value - in < threshold - hysteresis is required to turn an output off in \u00b6 public property float in cv input out1 \u00b6 public property bool out1 [readonly] output 1 out2 \u00b6 public property bool out2 [readonly] output 2 out3 \u00b6 public property bool out3 [readonly] output 3 out4 \u00b6 public property bool out4 [readonly] output 4 threshold1 \u00b6 public property float threshold1 [config] threshold to turn out1 on threshold2 \u00b6 public property float threshold2 [config] threshold to turn out2 on threshold3 \u00b6 public property float threshold3 [config] threshold to turn out3 on threshold4 \u00b6 public property float threshold4 [config] threshold to turn out4 on Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > ReheatSeq","title":"ReheatSeq"},{"location":"api/control/ReheatSeq/#reheatseq","text":"Doc Home > API Index > control > ReheatSeq","title":"ReheatSeq"},{"location":"api/control/ReheatSeq/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::ReheatSeq public class ReheatSeq [niagaraIcon=\"module://icons/x16/control/util/step.png\"] ReheatSeq will provide a linear sequence of up to 4 loads based on configurable thresholds Sets an output true if the \"in\" value is greater than corresponding threshold, and returns the ouput to false if the \"in\" value is less than threshold minus the hysteresis value. \"dOn\" is the count of outputs that are true (0 to 4) If \"enable\" is false, all outputs are set to false regardless of in value.","title":"Inheritance"},{"location":"api/control/ReheatSeq/#fields","text":"","title":"Fields"},{"location":"api/control/ReheatSeq/#don","text":"public property byte dOn [readonly] number of outputs currently turned on","title":"dOn"},{"location":"api/control/ReheatSeq/#enable","text":"public property bool enable [config] all outputs are false if enable == false","title":"enable"},{"location":"api/control/ReheatSeq/#hysteresis","text":"public property float hysteresis [config] hysteresis value - in < threshold - hysteresis is required to turn an output off","title":"hysteresis"},{"location":"api/control/ReheatSeq/#in","text":"public property float in cv input","title":"in"},{"location":"api/control/ReheatSeq/#out1","text":"public property bool out1 [readonly] output 1","title":"out1"},{"location":"api/control/ReheatSeq/#out2","text":"public property bool out2 [readonly] output 2","title":"out2"},{"location":"api/control/ReheatSeq/#out3","text":"public property bool out3 [readonly] output 3","title":"out3"},{"location":"api/control/ReheatSeq/#out4","text":"public property bool out4 [readonly] output 4","title":"out4"},{"location":"api/control/ReheatSeq/#threshold1","text":"public property float threshold1 [config] threshold to turn out1 on","title":"threshold1"},{"location":"api/control/ReheatSeq/#threshold2","text":"public property float threshold2 [config] threshold to turn out2 on","title":"threshold2"},{"location":"api/control/ReheatSeq/#threshold3","text":"public property float threshold3 [config] threshold to turn out3 on","title":"threshold3"},{"location":"api/control/ReheatSeq/#threshold4","text":"public property float threshold4 [config] threshold to turn out4 on","title":"threshold4"},{"location":"api/control/ReheatSeq/#methods","text":"","title":"Methods"},{"location":"api/control/ReheatSeq/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > ReheatSeq","title":"execute"},{"location":"api/control/Reset/","text":"Reset \u00b6 Doc Home > API Index > control > Reset Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Reset public class Reset [niagaraIcon=\"module://icons/x16/control/math/reset.png\"] Reset re-scales in value to out value object This function performs a \"reset\" on the input value. \"Reset\" is a HVAC term for scaling a number between two limits. When inMin < inA < inMax, the output value scales linearly between outMin and outMax. If inA < inMin, the value is capped at outMin. If inA > inMax, the value is capped at outMax. To calculate out, the following equation is used: (outMax-outMin) out = --------------- * (in - inMin) + outMin (inMax-inMin) Fields \u00b6 in \u00b6 public property float in input inMax \u00b6 public property float inMax [config] scaling constant inMax inMin \u00b6 public property float inMin [config] scaling constant inMin out \u00b6 public property float out [readonly] re-scaled output outMax \u00b6 public property float outMax [config] scaling constant outMax outMin \u00b6 public property float outMin [config] scaling constant outMin Methods \u00b6 changed \u00b6 public override void changed( Slot slot) Behavior to execute when a property is changed externally execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > Reset","title":"Reset"},{"location":"api/control/Reset/#reset","text":"Doc Home > API Index > control > Reset","title":"Reset"},{"location":"api/control/Reset/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Reset public class Reset [niagaraIcon=\"module://icons/x16/control/math/reset.png\"] Reset re-scales in value to out value object This function performs a \"reset\" on the input value. \"Reset\" is a HVAC term for scaling a number between two limits. When inMin < inA < inMax, the output value scales linearly between outMin and outMax. If inA < inMin, the value is capped at outMin. If inA > inMax, the value is capped at outMax. To calculate out, the following equation is used: (outMax-outMin) out = --------------- * (in - inMin) + outMin (inMax-inMin)","title":"Inheritance"},{"location":"api/control/Reset/#fields","text":"","title":"Fields"},{"location":"api/control/Reset/#in","text":"public property float in input","title":"in"},{"location":"api/control/Reset/#inmax","text":"public property float inMax [config] scaling constant inMax","title":"inMax"},{"location":"api/control/Reset/#inmin","text":"public property float inMin [config] scaling constant inMin","title":"inMin"},{"location":"api/control/Reset/#out","text":"public property float out [readonly] re-scaled output","title":"out"},{"location":"api/control/Reset/#outmax","text":"public property float outMax [config] scaling constant outMax","title":"outMax"},{"location":"api/control/Reset/#outmin","text":"public property float outMin [config] scaling constant outMin","title":"outMin"},{"location":"api/control/Reset/#methods","text":"","title":"Methods"},{"location":"api/control/Reset/#changed","text":"public override void changed( Slot slot) Behavior to execute when a property is changed externally","title":"changed"},{"location":"api/control/Reset/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/Reset/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > Reset","title":"start"},{"location":"api/control/Round/","text":"Round \u00b6 Doc Home > API Index > control > Round Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Round public class Round [niagaraIcon=\"module://icons/x16/control/numericPoint.png\"] Rounds a float to nearest n places. Uses the tie-breaker rule that positive number are rounded up if a tie-break situation exists, and negative numbers are rounded down (\"more negative\") if a tie-break situation exists. Example: 123.456 with n = 0 : rounds to 123.000 with n = 1 : rounds to 123.500 with n = -1: rounds to 120.000 Example: -123.456 with n = 0 : rounds to -123.000 with n = 1 : rounds to -123.500 with n = -1: rounds to -120.000 Positive numbers: 1) multiply by 10^n 2) add 0.5 and truncate (convert to integer) 3) divide by 10^n Negative numbers: 1) multiply by 10^n 2) subtract 0.5 and truncate (convert to integer) 3) divide by 10^n where n = number of decimal places to round out = round(in) Fields \u00b6 decimalPlaces \u00b6 public property int decimalPlaces [min=-1, max=3, config] number of decimal places to round in \u00b6 public property float in [precision=3] input value out \u00b6 public property float out [readonly, precision=1] out = in rounded to a precision Methods \u00b6 changed \u00b6 public virtual override void changed( Slot slot) Component override of changed execute \u00b6 public virtual override void execute() Execute start \u00b6 public virtual override void start() Component override of start sets up a multiplier factor Doc Home > API Index > control > Round","title":"Round"},{"location":"api/control/Round/#round","text":"Doc Home > API Index > control > Round","title":"Round"},{"location":"api/control/Round/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Round public class Round [niagaraIcon=\"module://icons/x16/control/numericPoint.png\"] Rounds a float to nearest n places. Uses the tie-breaker rule that positive number are rounded up if a tie-break situation exists, and negative numbers are rounded down (\"more negative\") if a tie-break situation exists. Example: 123.456 with n = 0 : rounds to 123.000 with n = 1 : rounds to 123.500 with n = -1: rounds to 120.000 Example: -123.456 with n = 0 : rounds to -123.000 with n = 1 : rounds to -123.500 with n = -1: rounds to -120.000 Positive numbers: 1) multiply by 10^n 2) add 0.5 and truncate (convert to integer) 3) divide by 10^n Negative numbers: 1) multiply by 10^n 2) subtract 0.5 and truncate (convert to integer) 3) divide by 10^n where n = number of decimal places to round out = round(in)","title":"Inheritance"},{"location":"api/control/Round/#fields","text":"","title":"Fields"},{"location":"api/control/Round/#decimalplaces","text":"public property int decimalPlaces [min=-1, max=3, config] number of decimal places to round","title":"decimalPlaces"},{"location":"api/control/Round/#in","text":"public property float in [precision=3] input value","title":"in"},{"location":"api/control/Round/#out","text":"public property float out [readonly, precision=1] out = in rounded to a precision","title":"out"},{"location":"api/control/Round/#methods","text":"","title":"Methods"},{"location":"api/control/Round/#changed","text":"public virtual override void changed( Slot slot) Component override of changed","title":"changed"},{"location":"api/control/Round/#execute","text":"public virtual override void execute() Execute","title":"execute"},{"location":"api/control/Round/#start","text":"public virtual override void start() Component override of start sets up a multiplier factor Doc Home > API Index > control > Round","title":"start"},{"location":"api/control/SRLatch/","text":"SRLatch \u00b6 Doc Home > API Index > control > SRLatch Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::SRLatch public class SRLatch [niagaraIcon=\"module://icons/x16/control/control.png\"] SRLatch Set Reset Latch object if ^s out = true; if ^r out = false; If both inputs have rising edges, out becomes false Fields \u00b6 lastReset \u00b6 public bool lastReset lastSet \u00b6 public bool lastSet out \u00b6 public property bool out [readonly] output r \u00b6 public property bool r On rising edge of r, out becomes false s \u00b6 public property bool s On rising edge of s, out becomes true Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. On rising edge of s, out becomes true On rising edge of r, out becomes false If both inputs have rising edges, out becomes false start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > SRLatch","title":"SRLatch"},{"location":"api/control/SRLatch/#srlatch","text":"Doc Home > API Index > control > SRLatch","title":"SRLatch"},{"location":"api/control/SRLatch/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::SRLatch public class SRLatch [niagaraIcon=\"module://icons/x16/control/control.png\"] SRLatch Set Reset Latch object if ^s out = true; if ^r out = false; If both inputs have rising edges, out becomes false","title":"Inheritance"},{"location":"api/control/SRLatch/#fields","text":"","title":"Fields"},{"location":"api/control/SRLatch/#lastreset","text":"public bool lastReset","title":"lastReset"},{"location":"api/control/SRLatch/#lastset","text":"public bool lastSet","title":"lastSet"},{"location":"api/control/SRLatch/#out","text":"public property bool out [readonly] output","title":"out"},{"location":"api/control/SRLatch/#r","text":"public property bool r On rising edge of r, out becomes false","title":"r"},{"location":"api/control/SRLatch/#s","text":"public property bool s On rising edge of s, out becomes true","title":"s"},{"location":"api/control/SRLatch/#methods","text":"","title":"Methods"},{"location":"api/control/SRLatch/#execute","text":"public virtual override void execute() Execute is called once every scan. On rising edge of s, out becomes true On rising edge of r, out becomes false If both inputs have rising edges, out becomes false","title":"execute"},{"location":"api/control/SRLatch/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > SRLatch","title":"start"},{"location":"api/control/Sub2/","text":"Sub2 \u00b6 Doc Home > API Index > control > Sub2 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Sub2 public class Sub2 [niagaraIcon=\"module://icons/x16/control/math/subtract.png\"] Sub2 Two Input Subtract object out = in1 - in2 Fields \u00b6 in1 \u00b6 public property float in1 in1 in2 \u00b6 public property float in2 in2 out \u00b6 public property float out [readonly] result o subracting in1 - in2 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Sub2","title":"Sub2"},{"location":"api/control/Sub2/#sub2","text":"Doc Home > API Index > control > Sub2","title":"Sub2"},{"location":"api/control/Sub2/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Sub2 public class Sub2 [niagaraIcon=\"module://icons/x16/control/math/subtract.png\"] Sub2 Two Input Subtract object out = in1 - in2","title":"Inheritance"},{"location":"api/control/Sub2/#fields","text":"","title":"Fields"},{"location":"api/control/Sub2/#in1","text":"public property float in1 in1","title":"in1"},{"location":"api/control/Sub2/#in2","text":"public property float in2 in2","title":"in2"},{"location":"api/control/Sub2/#out","text":"public property float out [readonly] result o subracting in1 - in2","title":"out"},{"location":"api/control/Sub2/#methods","text":"","title":"Methods"},{"location":"api/control/Sub2/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Sub2","title":"execute"},{"location":"api/control/Sub4/","text":"Sub4 \u00b6 Doc Home > API Index > control > Sub4 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Sub2 control::Sub4 public class Sub4 Sub4 Four Input Subtract object out = in1 - in2 - in3 - in4 out, in1, and in2 are inherited from Sub2 class Fields \u00b6 in3 \u00b6 public property float in3 in3 in4 \u00b6 public property float in4 in4 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Sub4","title":"Sub4"},{"location":"api/control/Sub4/#sub4","text":"Doc Home > API Index > control > Sub4","title":"Sub4"},{"location":"api/control/Sub4/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Sub2 control::Sub4 public class Sub4 Sub4 Four Input Subtract object out = in1 - in2 - in3 - in4 out, in1, and in2 are inherited from Sub2 class","title":"Inheritance"},{"location":"api/control/Sub4/#fields","text":"","title":"Fields"},{"location":"api/control/Sub4/#in3","text":"public property float in3 in3","title":"in3"},{"location":"api/control/Sub4/#in4","text":"public property float in4 in4","title":"in4"},{"location":"api/control/Sub4/#methods","text":"","title":"Methods"},{"location":"api/control/Sub4/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Sub4","title":"execute"},{"location":"api/control/TickTock/","text":"TickTock \u00b6 Doc Home > API Index > control > TickTock Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::TickTock public class TickTock [niagaraIcon=\"module://icons/x16/control/util/sine.png\"] TickTock component Generates boolean square wave with ticksPerSec pulses per second Fields \u00b6 out \u00b6 public property bool out [readonly] output pulses ticksPerSec \u00b6 public property int ticksPerSec [unit=\"per_second\", min=1, max=10, config] can configure 1 to 10 pulses per second Methods \u00b6 changed \u00b6 public override void changed( Slot slot) Behavior to execute when a property is changed externally execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > TickTock","title":"TickTock"},{"location":"api/control/TickTock/#ticktock","text":"Doc Home > API Index > control > TickTock","title":"TickTock"},{"location":"api/control/TickTock/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::TickTock public class TickTock [niagaraIcon=\"module://icons/x16/control/util/sine.png\"] TickTock component Generates boolean square wave with ticksPerSec pulses per second","title":"Inheritance"},{"location":"api/control/TickTock/#fields","text":"","title":"Fields"},{"location":"api/control/TickTock/#out","text":"public property bool out [readonly] output pulses","title":"out"},{"location":"api/control/TickTock/#tickspersec","text":"public property int ticksPerSec [unit=\"per_second\", min=1, max=10, config] can configure 1 to 10 pulses per second","title":"ticksPerSec"},{"location":"api/control/TickTock/#methods","text":"","title":"Methods"},{"location":"api/control/TickTock/#changed","text":"public override void changed( Slot slot) Behavior to execute when a property is changed externally","title":"changed"},{"location":"api/control/TickTock/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/TickTock/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > TickTock","title":"start"},{"location":"api/control/TimeAvg/","text":"TimeAvg \u00b6 Doc Home > API Index > control > TimeAvg Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::TimeAvg public class TimeAvg [niagaraIcon=\"module://icons/x16/control/math/average.png\"] TimeAvg object averages \"in\" over the configured time. Note that this is NOT a running or moving average - this object caches the average over the previous time as the out value, and updates out every \"time\" ms. Until the first full cycle has elapsed, out is set to average of all samples so far. The average may be reset/restarted at any time using the \"reset\" action. Fields \u00b6 in \u00b6 public property float in The value to average out \u00b6 public property float out [readonly] Value averaged over last \"time\" period time \u00b6 public property int time [summary, unit=\"millisecond\", config] The time period over which to average the in value to get the out value Methods \u00b6 execute \u00b6 public virtual override void execute() calculate the average. If not enough samples collected, then average the ones we have. reset \u00b6 public action void reset() Reset the average computation start \u00b6 public virtual override void start() Override start to initialize averaging variables Doc Home > API Index > control > TimeAvg","title":"TimeAvg"},{"location":"api/control/TimeAvg/#timeavg","text":"Doc Home > API Index > control > TimeAvg","title":"TimeAvg"},{"location":"api/control/TimeAvg/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::TimeAvg public class TimeAvg [niagaraIcon=\"module://icons/x16/control/math/average.png\"] TimeAvg object averages \"in\" over the configured time. Note that this is NOT a running or moving average - this object caches the average over the previous time as the out value, and updates out every \"time\" ms. Until the first full cycle has elapsed, out is set to average of all samples so far. The average may be reset/restarted at any time using the \"reset\" action.","title":"Inheritance"},{"location":"api/control/TimeAvg/#fields","text":"","title":"Fields"},{"location":"api/control/TimeAvg/#in","text":"public property float in The value to average","title":"in"},{"location":"api/control/TimeAvg/#out","text":"public property float out [readonly] Value averaged over last \"time\" period","title":"out"},{"location":"api/control/TimeAvg/#time","text":"public property int time [summary, unit=\"millisecond\", config] The time period over which to average the in value to get the out value","title":"time"},{"location":"api/control/TimeAvg/#methods","text":"","title":"Methods"},{"location":"api/control/TimeAvg/#execute","text":"public virtual override void execute() calculate the average. If not enough samples collected, then average the ones we have.","title":"execute"},{"location":"api/control/TimeAvg/#reset","text":"public action void reset() Reset the average computation","title":"reset"},{"location":"api/control/TimeAvg/#start","text":"public virtual override void start() Override start to initialize averaging variables Doc Home > API Index > control > TimeAvg","title":"start"},{"location":"api/control/Timer/","text":"Timer \u00b6 Doc Home > API Index > control > Timer Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Timer public class Timer [niagaraIcon=\"module://icons/x16/clock.png\"] Timer outputs a pulse for the configured amount of time \"in\" is used to fire the timer: - if low, out is forced to false - if high, out = 1 until timer reaches \"time\" seconds Alternatively, the pulse can be fired from the \"Start Timer\" action if run is not linked. Fields \u00b6 left \u00b6 public property int left [summary, unit=\"second\", readonly] Time left on the timer if running, in seconds If not running, this value is 0 out \u00b6 public property bool out [readonly] The timed output pulse run \u00b6 public property bool run [falseText=\"stop\", trueText=\"run\"] Used to fire the timer on transition from false -> true time \u00b6 public property int time [summary, unit=\"second\", config] Desired duration of the output pulse, in seconds Methods \u00b6 changed \u00b6 public virtual override void changed( Slot slot) override changed to recompute ms length of the timer if the time changes execute \u00b6 public virtual override void execute() Execute is called once every scan. resetTimer \u00b6 public action void resetTimer() Action to reset the timer. Any time already in progress is immediately canceled, and the \"left\" is set to 0 sec start \u00b6 public virtual override void start() start computes the ms length of the timer startTimer \u00b6 public action void startTimer() Used to manually start the timer in cases where there is no link to \"in\" property Issuing this command while the timer is already active will reset/restart the timer Doc Home > API Index > control > Timer","title":"Timer"},{"location":"api/control/Timer/#timer","text":"Doc Home > API Index > control > Timer","title":"Timer"},{"location":"api/control/Timer/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Timer public class Timer [niagaraIcon=\"module://icons/x16/clock.png\"] Timer outputs a pulse for the configured amount of time \"in\" is used to fire the timer: - if low, out is forced to false - if high, out = 1 until timer reaches \"time\" seconds Alternatively, the pulse can be fired from the \"Start Timer\" action if run is not linked.","title":"Inheritance"},{"location":"api/control/Timer/#fields","text":"","title":"Fields"},{"location":"api/control/Timer/#left","text":"public property int left [summary, unit=\"second\", readonly] Time left on the timer if running, in seconds If not running, this value is 0","title":"left"},{"location":"api/control/Timer/#out","text":"public property bool out [readonly] The timed output pulse","title":"out"},{"location":"api/control/Timer/#run","text":"public property bool run [falseText=\"stop\", trueText=\"run\"] Used to fire the timer on transition from false -> true","title":"run"},{"location":"api/control/Timer/#time","text":"public property int time [summary, unit=\"second\", config] Desired duration of the output pulse, in seconds","title":"time"},{"location":"api/control/Timer/#methods","text":"","title":"Methods"},{"location":"api/control/Timer/#changed","text":"public virtual override void changed( Slot slot) override changed to recompute ms length of the timer if the time changes","title":"changed"},{"location":"api/control/Timer/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/Timer/#resettimer","text":"public action void resetTimer() Action to reset the timer. Any time already in progress is immediately canceled, and the \"left\" is set to 0 sec","title":"resetTimer"},{"location":"api/control/Timer/#start","text":"public virtual override void start() start computes the ms length of the timer","title":"start"},{"location":"api/control/Timer/#starttimer","text":"public action void startTimer() Used to manually start the timer in cases where there is no link to \"in\" property Issuing this command while the timer is already active will reset/restart the timer Doc Home > API Index > control > Timer","title":"startTimer"},{"location":"api/control/Tstat/","text":"Tstat \u00b6 Doc Home > API Index > control > Tstat Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Tstat public class Tstat [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] Tstat Provides On/Off or Floating Thermostat control raise & lower outputs operate independently of isHeating mode. lower will be set to true if cv > (sp + diff/2) and will remain set until cv < (sp - diff/2). raise will be set to true if cv < (sp - diff/2) and will remain set until CV > (sp + diff/2). out will be set based on isHeating mode. if isHeating out = raise else out = lower Fields \u00b6 cv \u00b6 public property float cv actual diff \u00b6 public property float diff [summary, config] deadband centered around sp isHeating \u00b6 public property bool isHeating [summary, config] set true to put into heating mode, false for cooling mode lower \u00b6 public property bool lower [readonly] need to lower out \u00b6 public property bool out [readonly] calls for cooling or heating as required by sp/cv/isheating raise \u00b6 public property bool raise [readonly] need to raise sp \u00b6 public property float sp [summary, config] the setpoint Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Tstat","title":"Tstat"},{"location":"api/control/Tstat/#tstat","text":"Doc Home > API Index > control > Tstat","title":"Tstat"},{"location":"api/control/Tstat/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Tstat public class Tstat [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] Tstat Provides On/Off or Floating Thermostat control raise & lower outputs operate independently of isHeating mode. lower will be set to true if cv > (sp + diff/2) and will remain set until cv < (sp - diff/2). raise will be set to true if cv < (sp - diff/2) and will remain set until CV > (sp + diff/2). out will be set based on isHeating mode. if isHeating out = raise else out = lower","title":"Inheritance"},{"location":"api/control/Tstat/#fields","text":"","title":"Fields"},{"location":"api/control/Tstat/#cv","text":"public property float cv actual","title":"cv"},{"location":"api/control/Tstat/#diff","text":"public property float diff [summary, config] deadband centered around sp","title":"diff"},{"location":"api/control/Tstat/#isheating","text":"public property bool isHeating [summary, config] set true to put into heating mode, false for cooling mode","title":"isHeating"},{"location":"api/control/Tstat/#lower","text":"public property bool lower [readonly] need to lower","title":"lower"},{"location":"api/control/Tstat/#out","text":"public property bool out [readonly] calls for cooling or heating as required by sp/cv/isheating","title":"out"},{"location":"api/control/Tstat/#raise","text":"public property bool raise [readonly] need to raise","title":"raise"},{"location":"api/control/Tstat/#sp","text":"public property float sp [summary, config] the setpoint","title":"sp"},{"location":"api/control/Tstat/#methods","text":"","title":"Methods"},{"location":"api/control/Tstat/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Tstat","title":"execute"},{"location":"api/control/UpDn/","text":"UpDn \u00b6 Doc Home > API Index > control > UpDn Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::UpDn public class UpDn [niagaraIcon=\"module://icons/x16/control/control.png\"] UpDn Up/down counter object Fields \u00b6 cDwn \u00b6 public property bool cDwn [summary, config] Count down if true; o/w count up holdAtLimit \u00b6 public property bool holdAtLimit [config] Stop counting when limit reached if true in \u00b6 public property bool in Increment/decrement counter on positive edge limit \u00b6 public property float limit [config] Overflow limit out \u00b6 public property float out [readonly] Current count ovr \u00b6 public property bool ovr [readonly] Overflow indicator rst \u00b6 public property bool rst Reset count Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > UpDn","title":"UpDn"},{"location":"api/control/UpDn/#updn","text":"Doc Home > API Index > control > UpDn","title":"UpDn"},{"location":"api/control/UpDn/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::UpDn public class UpDn [niagaraIcon=\"module://icons/x16/control/control.png\"] UpDn Up/down counter object","title":"Inheritance"},{"location":"api/control/UpDn/#fields","text":"","title":"Fields"},{"location":"api/control/UpDn/#cdwn","text":"public property bool cDwn [summary, config] Count down if true; o/w count up","title":"cDwn"},{"location":"api/control/UpDn/#holdatlimit","text":"public property bool holdAtLimit [config] Stop counting when limit reached if true","title":"holdAtLimit"},{"location":"api/control/UpDn/#in","text":"public property bool in Increment/decrement counter on positive edge","title":"in"},{"location":"api/control/UpDn/#limit","text":"public property float limit [config] Overflow limit","title":"limit"},{"location":"api/control/UpDn/#out","text":"public property float out [readonly] Current count","title":"out"},{"location":"api/control/UpDn/#ovr","text":"public property bool ovr [readonly] Overflow indicator","title":"ovr"},{"location":"api/control/UpDn/#rst","text":"public property bool rst Reset count","title":"rst"},{"location":"api/control/UpDn/#methods","text":"","title":"Methods"},{"location":"api/control/UpDn/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/UpDn/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > control > UpDn","title":"start"},{"location":"api/control/WriteBool/","text":"WriteBool \u00b6 Doc Home > API Index > control > WriteBool Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::WriteBool public class WriteBool [niagaraIcon=\"module://icons/x16/control/booleanPointWr.png\"] WriteBool can be used to link or set a boolean. If in is unlinked, in values can be set by actions. Fields \u00b6 in \u00b6 public property bool in [summary, config] input property, persisted as config property out \u00b6 public property bool out [summary, readonly] output property = in, runtime property Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. setFalse \u00b6 public action void setFalse() action to set in to false setNull \u00b6 public action void setNull() action to set out to null setTrue \u00b6 public action void setTrue() action to set in to true Doc Home > API Index > control > WriteBool","title":"WriteBool"},{"location":"api/control/WriteBool/#writebool","text":"Doc Home > API Index > control > WriteBool","title":"WriteBool"},{"location":"api/control/WriteBool/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::WriteBool public class WriteBool [niagaraIcon=\"module://icons/x16/control/booleanPointWr.png\"] WriteBool can be used to link or set a boolean. If in is unlinked, in values can be set by actions.","title":"Inheritance"},{"location":"api/control/WriteBool/#fields","text":"","title":"Fields"},{"location":"api/control/WriteBool/#in","text":"public property bool in [summary, config] input property, persisted as config property","title":"in"},{"location":"api/control/WriteBool/#out","text":"public property bool out [summary, readonly] output property = in, runtime property","title":"out"},{"location":"api/control/WriteBool/#methods","text":"","title":"Methods"},{"location":"api/control/WriteBool/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/WriteBool/#setfalse","text":"public action void setFalse() action to set in to false","title":"setFalse"},{"location":"api/control/WriteBool/#setnull","text":"public action void setNull() action to set out to null","title":"setNull"},{"location":"api/control/WriteBool/#settrue","text":"public action void setTrue() action to set in to true Doc Home > API Index > control > WriteBool","title":"setTrue"},{"location":"api/control/WriteFloat/","text":"WriteFloat \u00b6 Doc Home > API Index > control > WriteFloat Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::WriteFloat public class WriteFloat [niagaraIcon=\"module://icons/x16/control/numericPointWr.png\"] WriteFloat can be used to link or set a float. If in is unlinked, in values can be set by actions. Fields \u00b6 in \u00b6 public property float in [summary, config] input property, persisted as config property out \u00b6 public property float out [summary, readonly] output property = in, runtime property Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. set \u00b6 public action void set(float x) action sets in to a value setNull \u00b6 public action void setNull() action sets in to null Doc Home > API Index > control > WriteFloat","title":"WriteFloat"},{"location":"api/control/WriteFloat/#writefloat","text":"Doc Home > API Index > control > WriteFloat","title":"WriteFloat"},{"location":"api/control/WriteFloat/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::WriteFloat public class WriteFloat [niagaraIcon=\"module://icons/x16/control/numericPointWr.png\"] WriteFloat can be used to link or set a float. If in is unlinked, in values can be set by actions.","title":"Inheritance"},{"location":"api/control/WriteFloat/#fields","text":"","title":"Fields"},{"location":"api/control/WriteFloat/#in","text":"public property float in [summary, config] input property, persisted as config property","title":"in"},{"location":"api/control/WriteFloat/#out","text":"public property float out [summary, readonly] output property = in, runtime property","title":"out"},{"location":"api/control/WriteFloat/#methods","text":"","title":"Methods"},{"location":"api/control/WriteFloat/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/WriteFloat/#set","text":"public action void set(float x) action sets in to a value","title":"set"},{"location":"api/control/WriteFloat/#setnull","text":"public action void setNull() action sets in to null Doc Home > API Index > control > WriteFloat","title":"setNull"},{"location":"api/control/WriteInt/","text":"WriteInt \u00b6 Doc Home > API Index > control > WriteInt Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::WriteInt public class WriteInt [niagaraIcon=\"module://icons/x16/control/enumPointWr.png\"] WriteInt can be used to link or set a integer value. If in is unlinked, in values can be set by actions. Fields \u00b6 in \u00b6 public property int in [summary, config] input property, persisted as config property out \u00b6 public property int out [summary, readonly] output property = in, runtime property Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. set \u00b6 public action void set(int x) action to in to a value Doc Home > API Index > control > WriteInt","title":"WriteInt"},{"location":"api/control/WriteInt/#writeint","text":"Doc Home > API Index > control > WriteInt","title":"WriteInt"},{"location":"api/control/WriteInt/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::WriteInt public class WriteInt [niagaraIcon=\"module://icons/x16/control/enumPointWr.png\"] WriteInt can be used to link or set a integer value. If in is unlinked, in values can be set by actions.","title":"Inheritance"},{"location":"api/control/WriteInt/#fields","text":"","title":"Fields"},{"location":"api/control/WriteInt/#in","text":"public property int in [summary, config] input property, persisted as config property","title":"in"},{"location":"api/control/WriteInt/#out","text":"public property int out [summary, readonly] output property = in, runtime property","title":"out"},{"location":"api/control/WriteInt/#methods","text":"","title":"Methods"},{"location":"api/control/WriteInt/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/control/WriteInt/#set","text":"public action void set(int x) action to in to a value Doc Home > API Index > control > WriteInt","title":"set"},{"location":"api/control/Xor/","text":"Xor \u00b6 Doc Home > API Index > control > Xor Inheritance \u00b6 sys::Obj sys::Virtual sys::Component control::Xor public class Xor [niagaraIcon=\"module://icons/x16/control/logic/xor.png\"] Xor Exclusive Or logic object if either input null output is null out = in1 xor in2 Fields \u00b6 in1 \u00b6 public property bool in1 input 1 in2 \u00b6 public property bool in2 input 2 out \u00b6 public property bool out [readonly] output value Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Xor","title":"Xor"},{"location":"api/control/Xor/#xor","text":"Doc Home > API Index > control > Xor","title":"Xor"},{"location":"api/control/Xor/#inheritance","text":"sys::Obj sys::Virtual sys::Component control::Xor public class Xor [niagaraIcon=\"module://icons/x16/control/logic/xor.png\"] Xor Exclusive Or logic object if either input null output is null out = in1 xor in2","title":"Inheritance"},{"location":"api/control/Xor/#fields","text":"","title":"Fields"},{"location":"api/control/Xor/#in1","text":"public property bool in1 input 1","title":"in1"},{"location":"api/control/Xor/#in2","text":"public property bool in2 input 2","title":"in2"},{"location":"api/control/Xor/#out","text":"public property bool out [readonly] output value","title":"out"},{"location":"api/control/Xor/#methods","text":"","title":"Methods"},{"location":"api/control/Xor/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > control > Xor","title":"execute"},{"location":"api/datetime/","text":"datetime \u00b6 Doc Home > API Index > datetime date time functions DateTime \u00b6 DateTimeService \u00b6 DayOfWeek \u00b6 Month \u00b6 Doc Home > API Index > datetime","title":"Index"},{"location":"api/datetime/#datetime","text":"Doc Home > API Index > datetime date time functions","title":"datetime"},{"location":"api/datetime/#datetime_1","text":"","title":"DateTime"},{"location":"api/datetime/#datetimeservice","text":"","title":"DateTimeService"},{"location":"api/datetime/#dayofweek","text":"","title":"DayOfWeek"},{"location":"api/datetime/#month","text":"Doc Home > API Index > datetime","title":"Month"},{"location":"api/datetime/DateTime/","text":"DateTime \u00b6 Doc Home > API Index > datetime Inheritance \u00b6 sys::Obj sys::Virtual datetime::DateTime public class DateTime Fields \u00b6 day \u00b6 public byte day Day of month (1-based). Only valid after successful fromNanos() call. dayOfWeek \u00b6 public byte dayOfWeek Day of week (Sun = 0). Only valid after successful fromNanos() call. daysPerMonth \u00b6 public static const define byte[] daysPerMonth epochDayOfWeek \u00b6 public static const define int epochDayOfWeek hour \u00b6 public byte hour Hour of day (0-23). Only valid after successful fromNanos() call. invalid \u00b6 public static const define long invalid minute \u00b6 public byte minute Minute of hour (0-59). Only valid after successful fromNanos() call. month \u00b6 public byte month Month of year (1-based). Only valid after successful fromNanos() call. nanosMax \u00b6 public static const define long nanosMax nanosecond \u00b6 public int nanosecond Fractional seconds in nanoseconds (0 - 999,999) Only valid after successful fromNanos() call. second \u00b6 public byte second Seconds of minute (0-59). Only valid after successful fromNanos() call. utcOffset \u00b6 public int utcOffset [unit=\"second\"] UTC offset in seconds. Used in to/from Nanos calculations. year \u00b6 public short year Year (2000-2099). Only valid after successful fromNanos() call. Methods \u00b6 fromNanos \u00b6 public int fromNanos(long nanos) Initialize a DateTime given nanoseconds since epoch. Return -1 if parameters are out of range isLeapYear \u00b6 public static bool isLeapYear(int year) Return true if given absolute year is a leap year reset \u00b6 public void reset() Reset DateTime instance to default value of 1 Jan 2000 00:00:00 with UTC offset of 0L toNanos \u00b6 public long toNanos() Convert a local time to nanos since the Sedona epoch of 1 Jan 2000 Returns DateTime.invalid if any parameters are out of range Year must be between 2000 and 2099 Month is 1 based, 1-12 day is 1-based hour must be 0-23 min, sec are 0-59 ns represents fraction seconds, must be <= 999,999,999 utcOffset represents the local time offset (in seconds) from UTC, including daylight savings time adjustment (if any) Doc Home > API Index > datetime","title":"DateTime"},{"location":"api/datetime/DateTime/#datetime","text":"Doc Home > API Index > datetime","title":"DateTime"},{"location":"api/datetime/DateTime/#inheritance","text":"sys::Obj sys::Virtual datetime::DateTime public class DateTime","title":"Inheritance"},{"location":"api/datetime/DateTime/#fields","text":"","title":"Fields"},{"location":"api/datetime/DateTime/#day","text":"public byte day Day of month (1-based). Only valid after successful fromNanos() call.","title":"day"},{"location":"api/datetime/DateTime/#dayofweek","text":"public byte dayOfWeek Day of week (Sun = 0). Only valid after successful fromNanos() call.","title":"dayOfWeek"},{"location":"api/datetime/DateTime/#dayspermonth","text":"public static const define byte[] daysPerMonth","title":"daysPerMonth"},{"location":"api/datetime/DateTime/#epochdayofweek","text":"public static const define int epochDayOfWeek","title":"epochDayOfWeek"},{"location":"api/datetime/DateTime/#hour","text":"public byte hour Hour of day (0-23). Only valid after successful fromNanos() call.","title":"hour"},{"location":"api/datetime/DateTime/#invalid","text":"public static const define long invalid","title":"invalid"},{"location":"api/datetime/DateTime/#minute","text":"public byte minute Minute of hour (0-59). Only valid after successful fromNanos() call.","title":"minute"},{"location":"api/datetime/DateTime/#month","text":"public byte month Month of year (1-based). Only valid after successful fromNanos() call.","title":"month"},{"location":"api/datetime/DateTime/#nanosmax","text":"public static const define long nanosMax","title":"nanosMax"},{"location":"api/datetime/DateTime/#nanosecond","text":"public int nanosecond Fractional seconds in nanoseconds (0 - 999,999) Only valid after successful fromNanos() call.","title":"nanosecond"},{"location":"api/datetime/DateTime/#second","text":"public byte second Seconds of minute (0-59). Only valid after successful fromNanos() call.","title":"second"},{"location":"api/datetime/DateTime/#utcoffset","text":"public int utcOffset [unit=\"second\"] UTC offset in seconds. Used in to/from Nanos calculations.","title":"utcOffset"},{"location":"api/datetime/DateTime/#year","text":"public short year Year (2000-2099). Only valid after successful fromNanos() call.","title":"year"},{"location":"api/datetime/DateTime/#methods","text":"","title":"Methods"},{"location":"api/datetime/DateTime/#fromnanos","text":"public int fromNanos(long nanos) Initialize a DateTime given nanoseconds since epoch. Return -1 if parameters are out of range","title":"fromNanos"},{"location":"api/datetime/DateTime/#isleapyear","text":"public static bool isLeapYear(int year) Return true if given absolute year is a leap year","title":"isLeapYear"},{"location":"api/datetime/DateTime/#reset","text":"public void reset() Reset DateTime instance to default value of 1 Jan 2000 00:00:00 with UTC offset of 0L","title":"reset"},{"location":"api/datetime/DateTime/#tonanos","text":"public long toNanos() Convert a local time to nanos since the Sedona epoch of 1 Jan 2000 Returns DateTime.invalid if any parameters are out of range Year must be between 2000 and 2099 Month is 1 based, 1-12 day is 1-based hour must be 0-23 min, sec are 0-59 ns represents fraction seconds, must be <= 999,999,999 utcOffset represents the local time offset (in seconds) from UTC, including daylight savings time adjustment (if any) Doc Home > API Index > datetime","title":"toNanos"},{"location":"api/datetime/DateTimeService/","text":"DateTimeService \u00b6 Doc Home > API Index > datetime > DateTimeService Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::Service datetime::DateTimeService public class DateTimeService DateTimeService is used to manage the system clock. It also stores the current time which is automatically updated each second. Fields \u00b6 day \u00b6 public property byte day Day of month dayOfWeek \u00b6 public property byte dayOfWeek Day of week (see also datetime::DayOfWeek) dt \u00b6 protected inline DateTime dt hour \u00b6 public property byte hour Hour, adjusted for UTC offset lastRefreshTicks \u00b6 public long lastRefreshTicks log \u00b6 public static const define Log log minute \u00b6 public property byte minute Minute month \u00b6 public property byte month Month of year (see also datetime::Month) nanos \u00b6 public property long nanos [unit=\"nanosecond\"] Nanos since epoch osUtcOffset \u00b6 public property bool osUtcOffset [config] If true, then the utcOffset is controlled by the operating system. If false then the utcOffset is configured strictly by Sedona. second \u00b6 public property byte second Second tz \u00b6 public inline property Buf tz [asStr, config, max=32] Olsen timezone identifier such as \"America/New_York\". This property is purely extra informational meta-data to help tools interpret the utcOffset property. utcOffset \u00b6 public property int utcOffset [unit=\"second\", config] Current UTC offset in seconds used to calculate the time fields from nanos. If osUtcOffset is true this is a read-only property read from the operating system. If osUtcOffset is false then this is a configuration property. year \u00b6 public property int year Year Methods \u00b6 getUtcOffset \u00b6 public virtual int getUtcOffset() Return the current UTC offset in seconds, including adjustment for daylight savings time if necessary now \u00b6 public virtual long now() Return the current UTC date/time on the system in nanoseconds, or DateTime.invalid if not supported, i.e. platform does not have clock capability refresh \u00b6 public action void refresh() Refreshes all property fields with current value setClock \u00b6 protected virtual void setClock(long nanos) Set the system clock to the given UTC value. May not be supported on all platform. setSysClock \u00b6 public action void setSysClock(long nanos) Sets the system clock and refreshes properties. May not be supported on all properties start \u00b6 public virtual override void start() Callback when component first started updateProperties \u00b6 protected void updateProperties(long n) Update the property fields with values stored in dt work \u00b6 public virtual override bool work() Perform a chunk of background work. Return true is there is pending work or false if the Service is done working this cycle. Doc Home > API Index > datetime > DateTimeService","title":"DateTimeService"},{"location":"api/datetime/DateTimeService/#datetimeservice","text":"Doc Home > API Index > datetime > DateTimeService","title":"DateTimeService"},{"location":"api/datetime/DateTimeService/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::Service datetime::DateTimeService public class DateTimeService DateTimeService is used to manage the system clock. It also stores the current time which is automatically updated each second.","title":"Inheritance"},{"location":"api/datetime/DateTimeService/#fields","text":"","title":"Fields"},{"location":"api/datetime/DateTimeService/#day","text":"public property byte day Day of month","title":"day"},{"location":"api/datetime/DateTimeService/#dayofweek","text":"public property byte dayOfWeek Day of week (see also datetime::DayOfWeek)","title":"dayOfWeek"},{"location":"api/datetime/DateTimeService/#dt","text":"protected inline DateTime dt","title":"dt"},{"location":"api/datetime/DateTimeService/#hour","text":"public property byte hour Hour, adjusted for UTC offset","title":"hour"},{"location":"api/datetime/DateTimeService/#lastrefreshticks","text":"public long lastRefreshTicks","title":"lastRefreshTicks"},{"location":"api/datetime/DateTimeService/#log","text":"public static const define Log log","title":"log"},{"location":"api/datetime/DateTimeService/#minute","text":"public property byte minute Minute","title":"minute"},{"location":"api/datetime/DateTimeService/#month","text":"public property byte month Month of year (see also datetime::Month)","title":"month"},{"location":"api/datetime/DateTimeService/#nanos","text":"public property long nanos [unit=\"nanosecond\"] Nanos since epoch","title":"nanos"},{"location":"api/datetime/DateTimeService/#osutcoffset","text":"public property bool osUtcOffset [config] If true, then the utcOffset is controlled by the operating system. If false then the utcOffset is configured strictly by Sedona.","title":"osUtcOffset"},{"location":"api/datetime/DateTimeService/#second","text":"public property byte second Second","title":"second"},{"location":"api/datetime/DateTimeService/#tz","text":"public inline property Buf tz [asStr, config, max=32] Olsen timezone identifier such as \"America/New_York\". This property is purely extra informational meta-data to help tools interpret the utcOffset property.","title":"tz"},{"location":"api/datetime/DateTimeService/#utcoffset","text":"public property int utcOffset [unit=\"second\", config] Current UTC offset in seconds used to calculate the time fields from nanos. If osUtcOffset is true this is a read-only property read from the operating system. If osUtcOffset is false then this is a configuration property.","title":"utcOffset"},{"location":"api/datetime/DateTimeService/#year","text":"public property int year Year","title":"year"},{"location":"api/datetime/DateTimeService/#methods","text":"","title":"Methods"},{"location":"api/datetime/DateTimeService/#getutcoffset","text":"public virtual int getUtcOffset() Return the current UTC offset in seconds, including adjustment for daylight savings time if necessary","title":"getUtcOffset"},{"location":"api/datetime/DateTimeService/#now","text":"public virtual long now() Return the current UTC date/time on the system in nanoseconds, or DateTime.invalid if not supported, i.e. platform does not have clock capability","title":"now"},{"location":"api/datetime/DateTimeService/#refresh","text":"public action void refresh() Refreshes all property fields with current value","title":"refresh"},{"location":"api/datetime/DateTimeService/#setclock","text":"protected virtual void setClock(long nanos) Set the system clock to the given UTC value. May not be supported on all platform.","title":"setClock"},{"location":"api/datetime/DateTimeService/#setsysclock","text":"public action void setSysClock(long nanos) Sets the system clock and refreshes properties. May not be supported on all properties","title":"setSysClock"},{"location":"api/datetime/DateTimeService/#start","text":"public virtual override void start() Callback when component first started","title":"start"},{"location":"api/datetime/DateTimeService/#updateproperties","text":"protected void updateProperties(long n) Update the property fields with values stored in dt","title":"updateProperties"},{"location":"api/datetime/DateTimeService/#work","text":"public virtual override bool work() Perform a chunk of background work. Return true is there is pending work or false if the Service is done working this cycle. Doc Home > API Index > datetime > DateTimeService","title":"work"},{"location":"api/datetime/DayOfWeek/","text":"DayOfWeek \u00b6 Doc Home > API Index > datetime > DayOfWeek Inheritance \u00b6 sys::Obj datetime::DayOfWeek public final class DayOfWeek Standard defines for days of the week Fields \u00b6 fri \u00b6 public static const define int fri mon \u00b6 public static const define int mon sat \u00b6 public static const define int sat sun \u00b6 public static const define int sun thu \u00b6 public static const define int thu tue \u00b6 public static const define int tue wed \u00b6 public static const define int wed Doc Home > API Index > datetime > DayOfWeek","title":"DayOfWeek"},{"location":"api/datetime/DayOfWeek/#dayofweek","text":"Doc Home > API Index > datetime > DayOfWeek","title":"DayOfWeek"},{"location":"api/datetime/DayOfWeek/#inheritance","text":"sys::Obj datetime::DayOfWeek public final class DayOfWeek Standard defines for days of the week","title":"Inheritance"},{"location":"api/datetime/DayOfWeek/#fields","text":"","title":"Fields"},{"location":"api/datetime/DayOfWeek/#fri","text":"public static const define int fri","title":"fri"},{"location":"api/datetime/DayOfWeek/#mon","text":"public static const define int mon","title":"mon"},{"location":"api/datetime/DayOfWeek/#sat","text":"public static const define int sat","title":"sat"},{"location":"api/datetime/DayOfWeek/#sun","text":"public static const define int sun","title":"sun"},{"location":"api/datetime/DayOfWeek/#thu","text":"public static const define int thu","title":"thu"},{"location":"api/datetime/DayOfWeek/#tue","text":"public static const define int tue","title":"tue"},{"location":"api/datetime/DayOfWeek/#wed","text":"public static const define int wed Doc Home > API Index > datetime > DayOfWeek","title":"wed"},{"location":"api/datetime/Month/","text":"Month \u00b6 Doc Home > API Index > datetime > Month Inheritance \u00b6 sys::Obj datetime::Month public final class Month Standard defines for months of the year Fields \u00b6 apr \u00b6 public static const define int apr aug \u00b6 public static const define int aug dec \u00b6 public static const define int dec feb \u00b6 public static const define int feb jan \u00b6 public static const define int jan jul \u00b6 public static const define int jul jun \u00b6 public static const define int jun mar \u00b6 public static const define int mar may \u00b6 public static const define int may nov \u00b6 public static const define int nov oct \u00b6 public static const define int oct sep \u00b6 public static const define int sep Doc Home > API Index > datetime > Month","title":"Month"},{"location":"api/datetime/Month/#month","text":"Doc Home > API Index > datetime > Month","title":"Month"},{"location":"api/datetime/Month/#inheritance","text":"sys::Obj datetime::Month public final class Month Standard defines for months of the year","title":"Inheritance"},{"location":"api/datetime/Month/#fields","text":"","title":"Fields"},{"location":"api/datetime/Month/#apr","text":"public static const define int apr","title":"apr"},{"location":"api/datetime/Month/#aug","text":"public static const define int aug","title":"aug"},{"location":"api/datetime/Month/#dec","text":"public static const define int dec","title":"dec"},{"location":"api/datetime/Month/#feb","text":"public static const define int feb","title":"feb"},{"location":"api/datetime/Month/#jan","text":"public static const define int jan","title":"jan"},{"location":"api/datetime/Month/#jul","text":"public static const define int jul","title":"jul"},{"location":"api/datetime/Month/#jun","text":"public static const define int jun","title":"jun"},{"location":"api/datetime/Month/#mar","text":"public static const define int mar","title":"mar"},{"location":"api/datetime/Month/#may","text":"public static const define int may","title":"may"},{"location":"api/datetime/Month/#nov","text":"public static const define int nov","title":"nov"},{"location":"api/datetime/Month/#oct","text":"public static const define int oct","title":"oct"},{"location":"api/datetime/Month/#sep","text":"public static const define int sep Doc Home > API Index > datetime > Month","title":"sep"},{"location":"api/datetimeStd/","text":"datetimeStd \u00b6 Doc Home > API Index > datetimeStd date time OS service using stdlib DateTimeServiceStd \u00b6 Doc Home > API Index > datetimeStd","title":"Index"},{"location":"api/datetimeStd/#datetimestd","text":"Doc Home > API Index > datetimeStd date time OS service using stdlib","title":"datetimeStd"},{"location":"api/datetimeStd/#datetimeservicestd","text":"Doc Home > API Index > datetimeStd","title":"DateTimeServiceStd"},{"location":"api/datetimeStd/DateTimeServiceStd/","text":"DateTimeServiceStd \u00b6 Doc Home > API Index > datetimeStd > DateTimeServiceStd Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::Service datetime::DateTimeService datetimeStd::DateTimeServiceStd public class DateTimeServiceStd Fields \u00b6 Methods \u00b6 doGetUtcOffset \u00b6 public static native int doGetUtcOffset() doNow \u00b6 public static native long doNow() doSetClock \u00b6 public static native void doSetClock(long nanos) getUtcOffset \u00b6 public virtual override int getUtcOffset() Return current UTC offset as reported by platform now \u00b6 public virtual override long now() Return the current UTC date/time on the system in nanoseconds, or DateTime.invalid if not supported, i.e. platform does not have clock capability setClock \u00b6 public virtual override void setClock(long nanos) Set the current UTC date/time in nanoseconds. May not be supported on all platforms Doc Home > API Index > datetimeStd > DateTimeServiceStd","title":"DateTimeServiceStd"},{"location":"api/datetimeStd/DateTimeServiceStd/#datetimeservicestd","text":"Doc Home > API Index > datetimeStd > DateTimeServiceStd","title":"DateTimeServiceStd"},{"location":"api/datetimeStd/DateTimeServiceStd/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::Service datetime::DateTimeService datetimeStd::DateTimeServiceStd public class DateTimeServiceStd","title":"Inheritance"},{"location":"api/datetimeStd/DateTimeServiceStd/#fields","text":"","title":"Fields"},{"location":"api/datetimeStd/DateTimeServiceStd/#methods","text":"","title":"Methods"},{"location":"api/datetimeStd/DateTimeServiceStd/#dogetutcoffset","text":"public static native int doGetUtcOffset()","title":"doGetUtcOffset"},{"location":"api/datetimeStd/DateTimeServiceStd/#donow","text":"public static native long doNow()","title":"doNow"},{"location":"api/datetimeStd/DateTimeServiceStd/#dosetclock","text":"public static native void doSetClock(long nanos)","title":"doSetClock"},{"location":"api/datetimeStd/DateTimeServiceStd/#getutcoffset","text":"public virtual override int getUtcOffset() Return current UTC offset as reported by platform","title":"getUtcOffset"},{"location":"api/datetimeStd/DateTimeServiceStd/#now","text":"public virtual override long now() Return the current UTC date/time on the system in nanoseconds, or DateTime.invalid if not supported, i.e. platform does not have clock capability","title":"now"},{"location":"api/datetimeStd/DateTimeServiceStd/#setclock","text":"public virtual override void setClock(long nanos) Set the current UTC date/time in nanoseconds. May not be supported on all platforms Doc Home > API Index > datetimeStd > DateTimeServiceStd","title":"setClock"},{"location":"api/driver/","text":"driver \u00b6 Doc Home > API Index > driver general driver AiPoint \u00b6 AoPoint \u00b6 Device \u00b6 DeviceNetwork \u00b6 DiPoint \u00b6 DoPoint \u00b6 Point \u00b6 Status \u00b6 Doc Home > API Index > driver","title":"Index"},{"location":"api/driver/#driver","text":"Doc Home > API Index > driver general driver","title":"driver"},{"location":"api/driver/#aipoint","text":"","title":"AiPoint"},{"location":"api/driver/#aopoint","text":"","title":"AoPoint"},{"location":"api/driver/#device","text":"","title":"Device"},{"location":"api/driver/#devicenetwork","text":"","title":"DeviceNetwork"},{"location":"api/driver/#dipoint","text":"","title":"DiPoint"},{"location":"api/driver/#dopoint","text":"","title":"DoPoint"},{"location":"api/driver/#point","text":"","title":"Point"},{"location":"api/driver/#status","text":"Doc Home > API Index > driver","title":"Status"},{"location":"api/driver/AiPoint/","text":"AiPoint \u00b6 Doc Home > API Index > driver > AiPoint Inheritance \u00b6 sys::Obj sys::Virtual sys::Component driver::Point driver::AiPoint public class AiPoint Models an analog input point in a Device. Fields \u00b6 out \u00b6 public property float out Value read from analog input Doc Home > API Index > driver > AiPoint","title":"AiPoint"},{"location":"api/driver/AiPoint/#aipoint","text":"Doc Home > API Index > driver > AiPoint","title":"AiPoint"},{"location":"api/driver/AiPoint/#inheritance","text":"sys::Obj sys::Virtual sys::Component driver::Point driver::AiPoint public class AiPoint Models an analog input point in a Device.","title":"Inheritance"},{"location":"api/driver/AiPoint/#fields","text":"","title":"Fields"},{"location":"api/driver/AiPoint/#out","text":"public property float out Value read from analog input Doc Home > API Index > driver > AiPoint","title":"out"},{"location":"api/driver/AoPoint/","text":"AoPoint \u00b6 Doc Home > API Index > driver > AoPoint Inheritance \u00b6 sys::Obj sys::Virtual sys::Component driver::Point driver::AiPoint driver::AoPoint public class AoPoint Models an analog output point in a Device. Fields \u00b6 in \u00b6 public property float in [config] Value to write to analog output inMax \u00b6 public property float inMax [config] Maximum input value allowed inMin \u00b6 public property float inMin [config] Minimum input value allowed isFirstTime \u00b6 public bool isFirstTime lastValue \u00b6 public float lastValue Methods \u00b6 execute \u00b6 public virtual override void execute() Calls super to propagate fault state from device; writes 'in' to analog output on (a) value change or (b) first cycle after point status becomes 'up'. While status is 'down', does nothing. If 'in' exceeds inMax/inMin limits, it is clipped. wrValue \u00b6 public virtual void wrValue(float value) wrValue call back when input changes Doc Home > API Index > driver > AoPoint","title":"AoPoint"},{"location":"api/driver/AoPoint/#aopoint","text":"Doc Home > API Index > driver > AoPoint","title":"AoPoint"},{"location":"api/driver/AoPoint/#inheritance","text":"sys::Obj sys::Virtual sys::Component driver::Point driver::AiPoint driver::AoPoint public class AoPoint Models an analog output point in a Device.","title":"Inheritance"},{"location":"api/driver/AoPoint/#fields","text":"","title":"Fields"},{"location":"api/driver/AoPoint/#in","text":"public property float in [config] Value to write to analog output","title":"in"},{"location":"api/driver/AoPoint/#inmax","text":"public property float inMax [config] Maximum input value allowed","title":"inMax"},{"location":"api/driver/AoPoint/#inmin","text":"public property float inMin [config] Minimum input value allowed","title":"inMin"},{"location":"api/driver/AoPoint/#isfirsttime","text":"public bool isFirstTime","title":"isFirstTime"},{"location":"api/driver/AoPoint/#lastvalue","text":"public float lastValue","title":"lastValue"},{"location":"api/driver/AoPoint/#methods","text":"","title":"Methods"},{"location":"api/driver/AoPoint/#execute","text":"public virtual override void execute() Calls super to propagate fault state from device; writes 'in' to analog output on (a) value change or (b) first cycle after point status becomes 'up'. While status is 'down', does nothing. If 'in' exceeds inMax/inMin limits, it is clipped.","title":"execute"},{"location":"api/driver/AoPoint/#wrvalue","text":"public virtual void wrValue(float value) wrValue call back when input changes Doc Home > API Index > driver > AoPoint","title":"wrValue"},{"location":"api/driver/Device/","text":"Device \u00b6 Doc Home > API Index > driver > Device Inheritance \u00b6 sys::Obj sys::Virtual sys::Component driver::Device public class Device Models a device as a collection of I/O points. Provides access to child components of type Point or a subclass of it. Fields \u00b6 app \u00b6 public App app enable \u00b6 public property bool enable [config] Whether the device is enabled. fault \u00b6 public property bool fault Whether the device is in fault. lastUpTime \u00b6 public long lastUpTime net \u00b6 public DeviceNetwork net nextPingTime \u00b6 public long nextPingTime pingTime \u00b6 public long pingTime status \u00b6 public property int status Status bitmask for device. Methods \u00b6 addPoint \u00b6 public void addPoint( Str name, int address, Type type) Adds a point to this device. execute \u00b6 public virtual override void execute() Updates fault state, posts ping at appropriate time. getFirstPoint \u00b6 public Point getFirstPoint() Gets first child component of type Point (or subclass). Returns null if no Point objects found. getNetwork \u00b6 public DeviceNetwork getNetwork() Returns a reference to the parent network. getNextPoint \u00b6 public Point getNextPoint( Point point) Gets next child component after 'point' that is of type Point (or subclass). Returns null if end of child list is reached without finding one. getPoint \u00b6 public Point getPoint( Type type, int address) Gets point by type and address. isDown \u00b6 public virtual bool isDown() Test down status flag. postPing \u00b6 public virtual void postPing() Method invoked when time to ping device. setAoValue \u00b6 public virtual void setAoValue(int address, float value) Callback to write a AO point value. setDoValue \u00b6 public virtual void setDoValue(int address, bool value) Callback to write a DO point value. setDown \u00b6 public virtual void setDown(bool isDown) Sets/clears the down status flag. start \u00b6 public virtual override void start() Sets up pointers and timestamps. Doc Home > API Index > driver > Device","title":"Device"},{"location":"api/driver/Device/#device","text":"Doc Home > API Index > driver > Device","title":"Device"},{"location":"api/driver/Device/#inheritance","text":"sys::Obj sys::Virtual sys::Component driver::Device public class Device Models a device as a collection of I/O points. Provides access to child components of type Point or a subclass of it.","title":"Inheritance"},{"location":"api/driver/Device/#fields","text":"","title":"Fields"},{"location":"api/driver/Device/#app","text":"public App app","title":"app"},{"location":"api/driver/Device/#enable","text":"public property bool enable [config] Whether the device is enabled.","title":"enable"},{"location":"api/driver/Device/#fault","text":"public property bool fault Whether the device is in fault.","title":"fault"},{"location":"api/driver/Device/#lastuptime","text":"public long lastUpTime","title":"lastUpTime"},{"location":"api/driver/Device/#net","text":"public DeviceNetwork net","title":"net"},{"location":"api/driver/Device/#nextpingtime","text":"public long nextPingTime","title":"nextPingTime"},{"location":"api/driver/Device/#pingtime","text":"public long pingTime","title":"pingTime"},{"location":"api/driver/Device/#status","text":"public property int status Status bitmask for device.","title":"status"},{"location":"api/driver/Device/#methods","text":"","title":"Methods"},{"location":"api/driver/Device/#addpoint","text":"public void addPoint( Str name, int address, Type type) Adds a point to this device.","title":"addPoint"},{"location":"api/driver/Device/#execute","text":"public virtual override void execute() Updates fault state, posts ping at appropriate time.","title":"execute"},{"location":"api/driver/Device/#getfirstpoint","text":"public Point getFirstPoint() Gets first child component of type Point (or subclass). Returns null if no Point objects found.","title":"getFirstPoint"},{"location":"api/driver/Device/#getnetwork","text":"public DeviceNetwork getNetwork() Returns a reference to the parent network.","title":"getNetwork"},{"location":"api/driver/Device/#getnextpoint","text":"public Point getNextPoint( Point point) Gets next child component after 'point' that is of type Point (or subclass). Returns null if end of child list is reached without finding one.","title":"getNextPoint"},{"location":"api/driver/Device/#getpoint","text":"public Point getPoint( Type type, int address) Gets point by type and address.","title":"getPoint"},{"location":"api/driver/Device/#isdown","text":"public virtual bool isDown() Test down status flag.","title":"isDown"},{"location":"api/driver/Device/#postping","text":"public virtual void postPing() Method invoked when time to ping device.","title":"postPing"},{"location":"api/driver/Device/#setaovalue","text":"public virtual void setAoValue(int address, float value) Callback to write a AO point value.","title":"setAoValue"},{"location":"api/driver/Device/#setdovalue","text":"public virtual void setDoValue(int address, bool value) Callback to write a DO point value.","title":"setDoValue"},{"location":"api/driver/Device/#setdown","text":"public virtual void setDown(bool isDown) Sets/clears the down status flag.","title":"setDown"},{"location":"api/driver/Device/#start","text":"public virtual override void start() Sets up pointers and timestamps. Doc Home > API Index > driver > Device","title":"start"},{"location":"api/driver/DeviceNetwork/","text":"DeviceNetwork \u00b6 Doc Home > API Index > driver > DeviceNetwork Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::Service driver::DeviceNetwork public class DeviceNetwork Models a network of devices. Provides access to child components of type Device or a subclass of it. Fields \u00b6 app \u00b6 public App app pingTimeSec \u00b6 public property int pingTimeSec [unit=\"second\", config] Methods \u00b6 getFirstDevice \u00b6 public Device getFirstDevice() Get first child component of type Device (or subclass). Returns null if no Device objects found. getNextDevice \u00b6 public Device getNextDevice( Device device) Get next child component after 'device' that is of type Device (or subclass). Returns null if it reaches the end of the list without finding one. start \u00b6 public virtual override void start() Doc Home > API Index > driver > DeviceNetwork","title":"DeviceNetwork"},{"location":"api/driver/DeviceNetwork/#devicenetwork","text":"Doc Home > API Index > driver > DeviceNetwork","title":"DeviceNetwork"},{"location":"api/driver/DeviceNetwork/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::Service driver::DeviceNetwork public class DeviceNetwork Models a network of devices. Provides access to child components of type Device or a subclass of it.","title":"Inheritance"},{"location":"api/driver/DeviceNetwork/#fields","text":"","title":"Fields"},{"location":"api/driver/DeviceNetwork/#app","text":"public App app","title":"app"},{"location":"api/driver/DeviceNetwork/#pingtimesec","text":"public property int pingTimeSec [unit=\"second\", config]","title":"pingTimeSec"},{"location":"api/driver/DeviceNetwork/#methods","text":"","title":"Methods"},{"location":"api/driver/DeviceNetwork/#getfirstdevice","text":"public Device getFirstDevice() Get first child component of type Device (or subclass). Returns null if no Device objects found.","title":"getFirstDevice"},{"location":"api/driver/DeviceNetwork/#getnextdevice","text":"public Device getNextDevice( Device device) Get next child component after 'device' that is of type Device (or subclass). Returns null if it reaches the end of the list without finding one.","title":"getNextDevice"},{"location":"api/driver/DeviceNetwork/#start","text":"public virtual override void start() Doc Home > API Index > driver > DeviceNetwork","title":"start"},{"location":"api/driver/DiPoint/","text":"DiPoint \u00b6 Doc Home > API Index > driver > DiPoint Inheritance \u00b6 sys::Obj sys::Virtual sys::Component driver::Point driver::DiPoint public class DiPoint DiPoint models a digital input point in a Device. Fields \u00b6 out \u00b6 public property bool out Value read from digital input Doc Home > API Index > driver > DiPoint","title":"DiPoint"},{"location":"api/driver/DiPoint/#dipoint","text":"Doc Home > API Index > driver > DiPoint","title":"DiPoint"},{"location":"api/driver/DiPoint/#inheritance","text":"sys::Obj sys::Virtual sys::Component driver::Point driver::DiPoint public class DiPoint DiPoint models a digital input point in a Device.","title":"Inheritance"},{"location":"api/driver/DiPoint/#fields","text":"","title":"Fields"},{"location":"api/driver/DiPoint/#out","text":"public property bool out Value read from digital input Doc Home > API Index > driver > DiPoint","title":"out"},{"location":"api/driver/DoPoint/","text":"DoPoint \u00b6 Doc Home > API Index > driver > DoPoint Inheritance \u00b6 sys::Obj sys::Virtual sys::Component driver::Point driver::DoPoint public class DoPoint Models a digital output point in a Device. Fields \u00b6 in \u00b6 public property bool in Value to write to digital output isFirstTime \u00b6 public bool isFirstTime isInChanged \u00b6 public bool isInChanged lastValue \u00b6 public bool lastValue Methods \u00b6 execute \u00b6 public virtual override void execute() Calls super to propagate fault state from device; writes 'in' to digital output on (a) value change or (b) first cycle after point status becomes 'up'. While status is 'down', does nothing. wrValue \u00b6 public virtual void wrValue(bool value) wrValue call back when input changes Doc Home > API Index > driver > DoPoint","title":"DoPoint"},{"location":"api/driver/DoPoint/#dopoint","text":"Doc Home > API Index > driver > DoPoint","title":"DoPoint"},{"location":"api/driver/DoPoint/#inheritance","text":"sys::Obj sys::Virtual sys::Component driver::Point driver::DoPoint public class DoPoint Models a digital output point in a Device.","title":"Inheritance"},{"location":"api/driver/DoPoint/#fields","text":"","title":"Fields"},{"location":"api/driver/DoPoint/#in","text":"public property bool in Value to write to digital output","title":"in"},{"location":"api/driver/DoPoint/#isfirsttime","text":"public bool isFirstTime","title":"isFirstTime"},{"location":"api/driver/DoPoint/#isinchanged","text":"public bool isInChanged","title":"isInChanged"},{"location":"api/driver/DoPoint/#lastvalue","text":"public bool lastValue","title":"lastValue"},{"location":"api/driver/DoPoint/#methods","text":"","title":"Methods"},{"location":"api/driver/DoPoint/#execute","text":"public virtual override void execute() Calls super to propagate fault state from device; writes 'in' to digital output on (a) value change or (b) first cycle after point status becomes 'up'. While status is 'down', does nothing.","title":"execute"},{"location":"api/driver/DoPoint/#wrvalue","text":"public virtual void wrValue(bool value) wrValue call back when input changes Doc Home > API Index > driver > DoPoint","title":"wrValue"},{"location":"api/driver/Point/","text":"Point \u00b6 Doc Home > API Index > driver > Point Inheritance \u00b6 sys::Obj sys::Virtual sys::Component driver::Point public class Point Base class to model a data point in a Device. Fields \u00b6 address \u00b6 public property int address [defaultOnClone, config] Address of point fault \u00b6 public property bool fault Whether the device is in fault. status \u00b6 public property int status Status bitmask for device. Methods \u00b6 execute \u00b6 public virtual override void execute() Propagates down & fault status from device getDevice \u00b6 public Device getDevice() Returns reference to parent device isDown \u00b6 public bool isDown() Returns true if down bit is set setDown \u00b6 public virtual void setDown(bool isDown) Sets/clears down bit in status bitmask setFault \u00b6 public virtual void setFault(bool isFault) Sets/clears fault bit in status bitmask Doc Home > API Index > driver > Point","title":"Point"},{"location":"api/driver/Point/#point","text":"Doc Home > API Index > driver > Point","title":"Point"},{"location":"api/driver/Point/#inheritance","text":"sys::Obj sys::Virtual sys::Component driver::Point public class Point Base class to model a data point in a Device.","title":"Inheritance"},{"location":"api/driver/Point/#fields","text":"","title":"Fields"},{"location":"api/driver/Point/#address","text":"public property int address [defaultOnClone, config] Address of point","title":"address"},{"location":"api/driver/Point/#fault","text":"public property bool fault Whether the device is in fault.","title":"fault"},{"location":"api/driver/Point/#status","text":"public property int status Status bitmask for device.","title":"status"},{"location":"api/driver/Point/#methods","text":"","title":"Methods"},{"location":"api/driver/Point/#execute","text":"public virtual override void execute() Propagates down & fault status from device","title":"execute"},{"location":"api/driver/Point/#getdevice","text":"public Device getDevice() Returns reference to parent device","title":"getDevice"},{"location":"api/driver/Point/#isdown","text":"public bool isDown() Returns true if down bit is set","title":"isDown"},{"location":"api/driver/Point/#setdown","text":"public virtual void setDown(bool isDown) Sets/clears down bit in status bitmask","title":"setDown"},{"location":"api/driver/Point/#setfault","text":"public virtual void setFault(bool isFault) Sets/clears fault bit in status bitmask Doc Home > API Index > driver > Point","title":"setFault"},{"location":"api/driver/Status/","text":"Status \u00b6 Doc Home > API Index > driver > Status Inheritance \u00b6 sys::Obj driver::Status public class Status Status -- Constants representing status info. Fields \u00b6 DOWN \u00b6 public static const define int DOWN FAULT \u00b6 public static const define int FAULT Doc Home > API Index > driver > Status","title":"Status"},{"location":"api/driver/Status/#status","text":"Doc Home > API Index > driver > Status","title":"Status"},{"location":"api/driver/Status/#inheritance","text":"sys::Obj driver::Status public class Status Status -- Constants representing status info.","title":"Inheritance"},{"location":"api/driver/Status/#fields","text":"","title":"Fields"},{"location":"api/driver/Status/#down","text":"public static const define int DOWN","title":"DOWN"},{"location":"api/driver/Status/#fault","text":"public static const define int FAULT Doc Home > API Index > driver > Status","title":"FAULT"},{"location":"api/func/","text":"func \u00b6 Doc Home > API Index > func Basic function block library Cmpr \u00b6 Count \u00b6 Freq \u00b6 Hysteresis \u00b6 IRamp \u00b6 LP \u00b6 Limiter \u00b6 Linearize \u00b6 Ramp \u00b6 SRLatch \u00b6 TickTock \u00b6 UpDn \u00b6 Doc Home > API Index > func","title":"Index"},{"location":"api/func/#func","text":"Doc Home > API Index > func Basic function block library","title":"func"},{"location":"api/func/#cmpr","text":"","title":"Cmpr"},{"location":"api/func/#count","text":"","title":"Count"},{"location":"api/func/#freq","text":"","title":"Freq"},{"location":"api/func/#hysteresis","text":"","title":"Hysteresis"},{"location":"api/func/#iramp","text":"","title":"IRamp"},{"location":"api/func/#lp","text":"","title":"LP"},{"location":"api/func/#limiter","text":"","title":"Limiter"},{"location":"api/func/#linearize","text":"","title":"Linearize"},{"location":"api/func/#ramp","text":"","title":"Ramp"},{"location":"api/func/#srlatch","text":"","title":"SRLatch"},{"location":"api/func/#ticktock","text":"","title":"TickTock"},{"location":"api/func/#updn","text":"Doc Home > API Index > func","title":"UpDn"},{"location":"api/func/Cmpr/","text":"Cmpr \u00b6 Doc Home > API Index > func > Cmpr Inheritance \u00b6 sys::Obj sys::Virtual sys::Component func::Cmpr public class Cmpr [niagaraIcon=\"module://icons/x16/control/logic/lessThan.png\"] Cmpr comparison math object xgy = x > y; xey = x = y; xly = x < y; Fields \u00b6 x \u00b6 public property float x input x xey \u00b6 public property bool xey [readonly] xey is true if x == y xgy \u00b6 public property bool xgy [readonly] xgy is true if x > y xly \u00b6 public property bool xly [readonly] xly is true if x < y y \u00b6 public property float y input y Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > func > Cmpr","title":"Cmpr"},{"location":"api/func/Cmpr/#cmpr","text":"Doc Home > API Index > func > Cmpr","title":"Cmpr"},{"location":"api/func/Cmpr/#inheritance","text":"sys::Obj sys::Virtual sys::Component func::Cmpr public class Cmpr [niagaraIcon=\"module://icons/x16/control/logic/lessThan.png\"] Cmpr comparison math object xgy = x > y; xey = x = y; xly = x < y;","title":"Inheritance"},{"location":"api/func/Cmpr/#fields","text":"","title":"Fields"},{"location":"api/func/Cmpr/#x","text":"public property float x input x","title":"x"},{"location":"api/func/Cmpr/#xey","text":"public property bool xey [readonly] xey is true if x == y","title":"xey"},{"location":"api/func/Cmpr/#xgy","text":"public property bool xgy [readonly] xgy is true if x > y","title":"xgy"},{"location":"api/func/Cmpr/#xly","text":"public property bool xly [readonly] xly is true if x < y","title":"xly"},{"location":"api/func/Cmpr/#y","text":"public property float y input y","title":"y"},{"location":"api/func/Cmpr/#methods","text":"","title":"Methods"},{"location":"api/func/Cmpr/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > func > Cmpr","title":"execute"},{"location":"api/func/Count/","text":"Count \u00b6 Doc Home > API Index > func > Count Inheritance \u00b6 sys::Obj sys::Virtual sys::Component func::Count public class Count [niagaraIcon=\"module://icons/x16/control/util/step.png\"] pulse counter object, counts transitions form 0 to 1 of input \"in\" Counts up if dir == true, counts down if dir == false Forced to preset value if enable = false In the case where dir == false, the counter will stop counting down at 0 Fields \u00b6 dir \u00b6 public property bool dir [falseText=\"down\", defaultOnClone, config, trueText=\"up\"] Configures direction. True = \"up\", False = \"down\" enable \u00b6 public property bool enable enable input in \u00b6 public property bool in input, transitions from false to true increment out by 1 out \u00b6 public property int out [readonly] Number of times \"in\" property has transitioned from 0 to 1 preset \u00b6 public property int preset [min=0, defaultOnClone, config] Presets the counter to a specific value, defaults to 0 r \u00b6 public property bool r if r is true, out = preset and no counting takes place Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. increment/decrement the count on rising edge of \"in\" if \"enable\" is true reset \u00b6 public action void reset() Resets the counter to the \"preset\" value start \u00b6 public virtual override void start() Override of start method to initialize the counter Doc Home > API Index > func > Count","title":"Count"},{"location":"api/func/Count/#count","text":"Doc Home > API Index > func > Count","title":"Count"},{"location":"api/func/Count/#inheritance","text":"sys::Obj sys::Virtual sys::Component func::Count public class Count [niagaraIcon=\"module://icons/x16/control/util/step.png\"] pulse counter object, counts transitions form 0 to 1 of input \"in\" Counts up if dir == true, counts down if dir == false Forced to preset value if enable = false In the case where dir == false, the counter will stop counting down at 0","title":"Inheritance"},{"location":"api/func/Count/#fields","text":"","title":"Fields"},{"location":"api/func/Count/#dir","text":"public property bool dir [falseText=\"down\", defaultOnClone, config, trueText=\"up\"] Configures direction. True = \"up\", False = \"down\"","title":"dir"},{"location":"api/func/Count/#enable","text":"public property bool enable enable input","title":"enable"},{"location":"api/func/Count/#in","text":"public property bool in input, transitions from false to true increment out by 1","title":"in"},{"location":"api/func/Count/#out","text":"public property int out [readonly] Number of times \"in\" property has transitioned from 0 to 1","title":"out"},{"location":"api/func/Count/#preset","text":"public property int preset [min=0, defaultOnClone, config] Presets the counter to a specific value, defaults to 0","title":"preset"},{"location":"api/func/Count/#r","text":"public property bool r if r is true, out = preset and no counting takes place","title":"r"},{"location":"api/func/Count/#methods","text":"","title":"Methods"},{"location":"api/func/Count/#execute","text":"public virtual override void execute() Execute is called once every scan. increment/decrement the count on rising edge of \"in\" if \"enable\" is true","title":"execute"},{"location":"api/func/Count/#reset","text":"public action void reset() Resets the counter to the \"preset\" value","title":"reset"},{"location":"api/func/Count/#start","text":"public virtual override void start() Override of start method to initialize the counter Doc Home > API Index > func > Count","title":"start"},{"location":"api/func/Freq/","text":"Freq \u00b6 Doc Home > API Index > func > Freq Inheritance \u00b6 sys::Obj sys::Virtual sys::Component func::Freq public class Freq [niagaraIcon=\"module://icons/x16/control/control.png\"] Freq calculates instantaneous input pulse frequency (based on rising edges). Result is output in pulses per second and pulses per minute. Note: since input is checked only once per app cycle, result cannot exceed 1/2 execute scan frequency. Fields \u00b6 in \u00b6 public property bool in input ppm \u00b6 public property float ppm [unit=\"per_minute\", readonly, precision=3] frequency in pulse per minute pps \u00b6 public property float pps [unit=\"per_second\", readonly, precision=3] frequency in pulses per second Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > func > Freq","title":"Freq"},{"location":"api/func/Freq/#freq","text":"Doc Home > API Index > func > Freq","title":"Freq"},{"location":"api/func/Freq/#inheritance","text":"sys::Obj sys::Virtual sys::Component func::Freq public class Freq [niagaraIcon=\"module://icons/x16/control/control.png\"] Freq calculates instantaneous input pulse frequency (based on rising edges). Result is output in pulses per second and pulses per minute. Note: since input is checked only once per app cycle, result cannot exceed 1/2 execute scan frequency.","title":"Inheritance"},{"location":"api/func/Freq/#fields","text":"","title":"Fields"},{"location":"api/func/Freq/#in","text":"public property bool in input","title":"in"},{"location":"api/func/Freq/#ppm","text":"public property float ppm [unit=\"per_minute\", readonly, precision=3] frequency in pulse per minute","title":"ppm"},{"location":"api/func/Freq/#pps","text":"public property float pps [unit=\"per_second\", readonly, precision=3] frequency in pulses per second","title":"pps"},{"location":"api/func/Freq/#methods","text":"","title":"Methods"},{"location":"api/func/Freq/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/func/Freq/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > func > Freq","title":"start"},{"location":"api/func/Hysteresis/","text":"Hysteresis \u00b6 Doc Home > API Index > func > Hysteresis Inheritance \u00b6 sys::Obj sys::Virtual sys::Component func::Hysteresis public class Hysteresis [niagaraIcon=\"module://icons/x16/control/util/hysteresis.png\"] Applies hysteresis to an input value to set a boolean out. NOTE: If \"Rising Edge\" > \"Falling Edge\", then out behaves \"normally\", ie out switches to \"true\" when in rises above \"Rising Edge\", and switches back to \"false\" when in falls below \"Falling Edge\" Falling Rising Edge Edge |----------|------- | | --------|----------| NOTE: If \"Rising Edge\" < \"Falling Edge\", then out behaves \"inverted\", ie out switches to \"false\" when in rises above \"Falling Edge\", and switches back to \"true\" when in falls below \"Rising Edge\" Rising Falling Edge Edge --------|----------| | | |----------|------- NOTE: If \"Rising Edge\" == \"Falling Edge\", this object become a simple comparator, where if in > Rising Edge, then out = true Fields \u00b6 fallingEdge \u00b6 public property float fallingEdge [defaultOnClone, config] threshold for falling edge in \u00b6 public property float in input value to which hysteresis is to be applied out \u00b6 public property bool out [readonly] boolean output risingEdge \u00b6 public property float risingEdge [defaultOnClone, config] threshold for rising edge Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > func > Hysteresis","title":"Hysteresis"},{"location":"api/func/Hysteresis/#hysteresis","text":"Doc Home > API Index > func > Hysteresis","title":"Hysteresis"},{"location":"api/func/Hysteresis/#inheritance","text":"sys::Obj sys::Virtual sys::Component func::Hysteresis public class Hysteresis [niagaraIcon=\"module://icons/x16/control/util/hysteresis.png\"] Applies hysteresis to an input value to set a boolean out. NOTE: If \"Rising Edge\" > \"Falling Edge\", then out behaves \"normally\", ie out switches to \"true\" when in rises above \"Rising Edge\", and switches back to \"false\" when in falls below \"Falling Edge\" Falling Rising Edge Edge |----------|------- | | --------|----------| NOTE: If \"Rising Edge\" < \"Falling Edge\", then out behaves \"inverted\", ie out switches to \"false\" when in rises above \"Falling Edge\", and switches back to \"true\" when in falls below \"Rising Edge\" Rising Falling Edge Edge --------|----------| | | |----------|------- NOTE: If \"Rising Edge\" == \"Falling Edge\", this object become a simple comparator, where if in > Rising Edge, then out = true","title":"Inheritance"},{"location":"api/func/Hysteresis/#fields","text":"","title":"Fields"},{"location":"api/func/Hysteresis/#fallingedge","text":"public property float fallingEdge [defaultOnClone, config] threshold for falling edge","title":"fallingEdge"},{"location":"api/func/Hysteresis/#in","text":"public property float in input value to which hysteresis is to be applied","title":"in"},{"location":"api/func/Hysteresis/#out","text":"public property bool out [readonly] boolean output","title":"out"},{"location":"api/func/Hysteresis/#risingedge","text":"public property float risingEdge [defaultOnClone, config] threshold for rising edge","title":"risingEdge"},{"location":"api/func/Hysteresis/#methods","text":"","title":"Methods"},{"location":"api/func/Hysteresis/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > func > Hysteresis","title":"execute"},{"location":"api/func/IRamp/","text":"IRamp \u00b6 Doc Home > API Index > func > IRamp Inheritance \u00b6 sys::Obj sys::Virtual sys::Component func::IRamp public class IRamp [niagaraIcon=\"module://icons/x16/control/util/sine.png\"] Ramp Triangle wave between min & max Slope is \"delta\" per \"secs\" seconds 'max' must be configured greater than 'min' Fields \u00b6 delta \u00b6 public property int delta [min=1, config] delta is added or subtracted from out every \"secs\" seconds max \u00b6 public property int max [config] max out value of the ramp object. Once max is reached, out will start ramping down min \u00b6 public property int min [config] min out value of the ramp object. Once min is reached, out will start ramping up out \u00b6 public property int out [readonly] secs \u00b6 public property long secs [unit=\"second\", min=1, config] determines how often delta is added/subtracted from out Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Start initializes the output Doc Home > API Index > func > IRamp","title":"IRamp"},{"location":"api/func/IRamp/#iramp","text":"Doc Home > API Index > func > IRamp","title":"IRamp"},{"location":"api/func/IRamp/#inheritance","text":"sys::Obj sys::Virtual sys::Component func::IRamp public class IRamp [niagaraIcon=\"module://icons/x16/control/util/sine.png\"] Ramp Triangle wave between min & max Slope is \"delta\" per \"secs\" seconds 'max' must be configured greater than 'min'","title":"Inheritance"},{"location":"api/func/IRamp/#fields","text":"","title":"Fields"},{"location":"api/func/IRamp/#delta","text":"public property int delta [min=1, config] delta is added or subtracted from out every \"secs\" seconds","title":"delta"},{"location":"api/func/IRamp/#max","text":"public property int max [config] max out value of the ramp object. Once max is reached, out will start ramping down","title":"max"},{"location":"api/func/IRamp/#min","text":"public property int min [config] min out value of the ramp object. Once min is reached, out will start ramping up","title":"min"},{"location":"api/func/IRamp/#out","text":"public property int out [readonly]","title":"out"},{"location":"api/func/IRamp/#secs","text":"public property long secs [unit=\"second\", min=1, config] determines how often delta is added/subtracted from out","title":"secs"},{"location":"api/func/IRamp/#methods","text":"","title":"Methods"},{"location":"api/func/IRamp/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/func/IRamp/#start","text":"public virtual override void start() Start initializes the output Doc Home > API Index > func > IRamp","title":"start"},{"location":"api/func/LP/","text":"LP \u00b6 Doc Home > API Index > func > LP Inheritance \u00b6 sys::Obj sys::Virtual sys::Component func::LP public class LP [niagaraIcon=\"module://icons/x16/control/numericPoint.png\"] Pid Loop object Fields \u00b6 bias \u00b6 public property float bias [config, precision=6] bias is applied directly to output if ki equals 0 cv \u00b6 public property float cv [precision=3] process feedback direct \u00b6 public property bool direct [config] direct acting or reverse acting process enable \u00b6 public property bool enable [config] loop enable. If false, output is held constant at previous value exTime \u00b6 public property int exTime [unit=\"millisecond\", min=0, config] loop is executed every exTime ms kd \u00b6 public property float kd [unit=\"second\", min=0.0, config, precision=6] derivative constant ki \u00b6 public property float ki [unit=\"per_minute\", min=0.0, config, precision=6] integral constant kp \u00b6 public property float kp [min=0.0, config, precision=6] proportional constant max \u00b6 public property float max [config, precision=6] max out value maxDelta \u00b6 public property float maxDelta [min=0.0, config, precision=6] the max amount out is allowed to change in exTime ms A setting of 0 disables this function min \u00b6 public property float min [config, precision=6] min out value out \u00b6 public property float out [readonly] out value, constrained to be between min and max sp \u00b6 public property float sp [summary, config] setpoint Methods \u00b6 changed \u00b6 public virtual override void changed( Slot slot) Behavior to execute when a property is changed externally execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > func > LP","title":"LP"},{"location":"api/func/LP/#lp","text":"Doc Home > API Index > func > LP","title":"LP"},{"location":"api/func/LP/#inheritance","text":"sys::Obj sys::Virtual sys::Component func::LP public class LP [niagaraIcon=\"module://icons/x16/control/numericPoint.png\"] Pid Loop object","title":"Inheritance"},{"location":"api/func/LP/#fields","text":"","title":"Fields"},{"location":"api/func/LP/#bias","text":"public property float bias [config, precision=6] bias is applied directly to output if ki equals 0","title":"bias"},{"location":"api/func/LP/#cv","text":"public property float cv [precision=3] process feedback","title":"cv"},{"location":"api/func/LP/#direct","text":"public property bool direct [config] direct acting or reverse acting process","title":"direct"},{"location":"api/func/LP/#enable","text":"public property bool enable [config] loop enable. If false, output is held constant at previous value","title":"enable"},{"location":"api/func/LP/#extime","text":"public property int exTime [unit=\"millisecond\", min=0, config] loop is executed every exTime ms","title":"exTime"},{"location":"api/func/LP/#kd","text":"public property float kd [unit=\"second\", min=0.0, config, precision=6] derivative constant","title":"kd"},{"location":"api/func/LP/#ki","text":"public property float ki [unit=\"per_minute\", min=0.0, config, precision=6] integral constant","title":"ki"},{"location":"api/func/LP/#kp","text":"public property float kp [min=0.0, config, precision=6] proportional constant","title":"kp"},{"location":"api/func/LP/#max","text":"public property float max [config, precision=6] max out value","title":"max"},{"location":"api/func/LP/#maxdelta","text":"public property float maxDelta [min=0.0, config, precision=6] the max amount out is allowed to change in exTime ms A setting of 0 disables this function","title":"maxDelta"},{"location":"api/func/LP/#min","text":"public property float min [config, precision=6] min out value","title":"min"},{"location":"api/func/LP/#out","text":"public property float out [readonly] out value, constrained to be between min and max","title":"out"},{"location":"api/func/LP/#sp","text":"public property float sp [summary, config] setpoint","title":"sp"},{"location":"api/func/LP/#methods","text":"","title":"Methods"},{"location":"api/func/LP/#changed","text":"public virtual override void changed( Slot slot) Behavior to execute when a property is changed externally","title":"changed"},{"location":"api/func/LP/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/func/LP/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > func > LP","title":"start"},{"location":"api/func/Limiter/","text":"Limiter \u00b6 Doc Home > API Index > func > Limiter Inheritance \u00b6 sys::Obj sys::Virtual sys::Component func::Limiter public class Limiter [niagaraIcon=\"module://icons/x16/control/util/limit.png\"] Limits input between two configured values If (in < lowLmt), out = lowLmt else if (in > highLmt), out = highLmt else out = in Fields \u00b6 highLmt \u00b6 public property float highLmt [config] high limit value. If (in > highLmt), out = highLmt in \u00b6 public property float in input value lowLmt \u00b6 public property float lowLmt [config] low limit value. If (in < lowLmt), out = lowLmt out \u00b6 public property float out [readonly] the range limited output Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > func > Limiter","title":"Limiter"},{"location":"api/func/Limiter/#limiter","text":"Doc Home > API Index > func > Limiter","title":"Limiter"},{"location":"api/func/Limiter/#inheritance","text":"sys::Obj sys::Virtual sys::Component func::Limiter public class Limiter [niagaraIcon=\"module://icons/x16/control/util/limit.png\"] Limits input between two configured values If (in < lowLmt), out = lowLmt else if (in > highLmt), out = highLmt else out = in","title":"Inheritance"},{"location":"api/func/Limiter/#fields","text":"","title":"Fields"},{"location":"api/func/Limiter/#highlmt","text":"public property float highLmt [config] high limit value. If (in > highLmt), out = highLmt","title":"highLmt"},{"location":"api/func/Limiter/#in","text":"public property float in input value","title":"in"},{"location":"api/func/Limiter/#lowlmt","text":"public property float lowLmt [config] low limit value. If (in < lowLmt), out = lowLmt","title":"lowLmt"},{"location":"api/func/Limiter/#out","text":"public property float out [readonly] the range limited output","title":"out"},{"location":"api/func/Limiter/#methods","text":"","title":"Methods"},{"location":"api/func/Limiter/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > func > Limiter","title":"execute"},{"location":"api/func/Linearize/","text":"Linearize \u00b6 Doc Home > API Index > func > Linearize Inheritance \u00b6 sys::Obj sys::Virtual sys::Component func::Linearize public class Linearize [niagaraIcon=\"module://icons/x16/control/util/xy.png\"] Converts a table of values into a curve using linear interpolation between the values. Individual slope/intercept constants are computed between the x's and y's using the formula y = mx + b, where m = ym - yn/xm - xn If in is not in the range of x0 to x9, then output is set to \"nan\" Note that slope may be positive or negative, and is indicated by comparison of x1 and x0 (positive if x1 > x0, negitive if x1 < x0) Fields \u00b6 in \u00b6 public property float in input out \u00b6 public property float out [readonly] linearized output tmp \u00b6 public float tmp x0 \u00b6 public property float x0 [config] linear interpolation x0 point x1 \u00b6 public property float x1 [config] linear interpolation x1 point x2 \u00b6 public property float x2 [config] linear interpolation x2 point x3 \u00b6 public property float x3 [config] linear interpolation x3 point x4 \u00b6 public property float x4 [config] linear interpolation x4 point x5 \u00b6 public property float x5 [config] linear interpolation x5 point x6 \u00b6 public property float x6 [config] linear interpolation x6 point x7 \u00b6 public property float x7 [config] linear interpolation x7 point x8 \u00b6 public property float x8 [config] linear interpolation x8 point x9 \u00b6 public property float x9 [config] linear interpolation x9 point y0 \u00b6 public property float y0 [config] linear interpolation y0 point y1 \u00b6 public property float y1 [config] linear interpolation y1 point y2 \u00b6 public property float y2 [config] linear interpolation y2 point y3 \u00b6 public property float y3 [config] linear interpolation y3 point y4 \u00b6 public property float y4 [config] linear interpolation y4 point y5 \u00b6 public property float y5 [config] linear interpolation Y5 point y6 \u00b6 public property float y6 [config] linear interpolation Y6 point y7 \u00b6 public property float y7 [config] linear interpolation Y7 point y8 \u00b6 public property float y8 [config] linear interpolation Y8 point y9 \u00b6 public property float y9 [config] linear interpolation Y9 point Methods \u00b6 convert \u00b6 public virtual void convert(float Y2, float Y1, float X2, float X1) Convert value in to value out by using linear interpolation between point1 and point2 using formula y=mx + b execute \u00b6 public virtual override void execute() Execute is called once every scan to convert 'in' to 'out' using linear interpolation between inflection points (x,y) Doc Home > API Index > func > Linearize","title":"Linearize"},{"location":"api/func/Linearize/#linearize","text":"Doc Home > API Index > func > Linearize","title":"Linearize"},{"location":"api/func/Linearize/#inheritance","text":"sys::Obj sys::Virtual sys::Component func::Linearize public class Linearize [niagaraIcon=\"module://icons/x16/control/util/xy.png\"] Converts a table of values into a curve using linear interpolation between the values. Individual slope/intercept constants are computed between the x's and y's using the formula y = mx + b, where m = ym - yn/xm - xn If in is not in the range of x0 to x9, then output is set to \"nan\" Note that slope may be positive or negative, and is indicated by comparison of x1 and x0 (positive if x1 > x0, negitive if x1 < x0)","title":"Inheritance"},{"location":"api/func/Linearize/#fields","text":"","title":"Fields"},{"location":"api/func/Linearize/#in","text":"public property float in input","title":"in"},{"location":"api/func/Linearize/#out","text":"public property float out [readonly] linearized output","title":"out"},{"location":"api/func/Linearize/#tmp","text":"public float tmp","title":"tmp"},{"location":"api/func/Linearize/#x0","text":"public property float x0 [config] linear interpolation x0 point","title":"x0"},{"location":"api/func/Linearize/#x1","text":"public property float x1 [config] linear interpolation x1 point","title":"x1"},{"location":"api/func/Linearize/#x2","text":"public property float x2 [config] linear interpolation x2 point","title":"x2"},{"location":"api/func/Linearize/#x3","text":"public property float x3 [config] linear interpolation x3 point","title":"x3"},{"location":"api/func/Linearize/#x4","text":"public property float x4 [config] linear interpolation x4 point","title":"x4"},{"location":"api/func/Linearize/#x5","text":"public property float x5 [config] linear interpolation x5 point","title":"x5"},{"location":"api/func/Linearize/#x6","text":"public property float x6 [config] linear interpolation x6 point","title":"x6"},{"location":"api/func/Linearize/#x7","text":"public property float x7 [config] linear interpolation x7 point","title":"x7"},{"location":"api/func/Linearize/#x8","text":"public property float x8 [config] linear interpolation x8 point","title":"x8"},{"location":"api/func/Linearize/#x9","text":"public property float x9 [config] linear interpolation x9 point","title":"x9"},{"location":"api/func/Linearize/#y0","text":"public property float y0 [config] linear interpolation y0 point","title":"y0"},{"location":"api/func/Linearize/#y1","text":"public property float y1 [config] linear interpolation y1 point","title":"y1"},{"location":"api/func/Linearize/#y2","text":"public property float y2 [config] linear interpolation y2 point","title":"y2"},{"location":"api/func/Linearize/#y3","text":"public property float y3 [config] linear interpolation y3 point","title":"y3"},{"location":"api/func/Linearize/#y4","text":"public property float y4 [config] linear interpolation y4 point","title":"y4"},{"location":"api/func/Linearize/#y5","text":"public property float y5 [config] linear interpolation Y5 point","title":"y5"},{"location":"api/func/Linearize/#y6","text":"public property float y6 [config] linear interpolation Y6 point","title":"y6"},{"location":"api/func/Linearize/#y7","text":"public property float y7 [config] linear interpolation Y7 point","title":"y7"},{"location":"api/func/Linearize/#y8","text":"public property float y8 [config] linear interpolation Y8 point","title":"y8"},{"location":"api/func/Linearize/#y9","text":"public property float y9 [config] linear interpolation Y9 point","title":"y9"},{"location":"api/func/Linearize/#methods","text":"","title":"Methods"},{"location":"api/func/Linearize/#convert","text":"public virtual void convert(float Y2, float Y1, float X2, float X1) Convert value in to value out by using linear interpolation between point1 and point2 using formula y=mx + b","title":"convert"},{"location":"api/func/Linearize/#execute","text":"public virtual override void execute() Execute is called once every scan to convert 'in' to 'out' using linear interpolation between inflection points (x,y) Doc Home > API Index > func > Linearize","title":"execute"},{"location":"api/func/Ramp/","text":"Ramp \u00b6 Doc Home > API Index > func > Ramp Inheritance \u00b6 sys::Obj sys::Virtual sys::Component func::Ramp public class Ramp [niagaraIcon=\"module://icons/x16/control/util/sine.png\"] Ramp Triangle or sawtooth wave between min & max. New value calculated every execute cycle (does not rely on execution rate). Fields \u00b6 SAWTOOTH \u00b6 public static const define bool SAWTOOTH TRIANGLE \u00b6 public static const define bool TRIANGLE max \u00b6 public property float max [config] Maximum value min \u00b6 public property float min [config] Minimum value out \u00b6 public property float out [readonly] Ramp output period \u00b6 public property float period [unit=\"second\", min=0, config, precision=0] Ramp period If rampType is true (triangle) then this is the time it takes to complete up/down cycle. If rampType is false (sawtooth) then this is the time it takes to complete up cycle. A value of 0 forces output to min value. periodInNanos \u00b6 public long periodInNanos rampType \u00b6 public property bool rampType [falseText=\"sawtooth\", config, trueText=\"triangle\"] Specifies whether ramp is sawtooth (min to max and repeat), or triangle (min to max/max to min and repeat) Defaults to triangle. range \u00b6 public float range Methods \u00b6 changed \u00b6 public virtual override void changed( Slot slot) recompute internal constants if ramp parameters change execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() compute internal constants at startup Doc Home > API Index > func > Ramp","title":"Ramp"},{"location":"api/func/Ramp/#ramp","text":"Doc Home > API Index > func > Ramp","title":"Ramp"},{"location":"api/func/Ramp/#inheritance","text":"sys::Obj sys::Virtual sys::Component func::Ramp public class Ramp [niagaraIcon=\"module://icons/x16/control/util/sine.png\"] Ramp Triangle or sawtooth wave between min & max. New value calculated every execute cycle (does not rely on execution rate).","title":"Inheritance"},{"location":"api/func/Ramp/#fields","text":"","title":"Fields"},{"location":"api/func/Ramp/#sawtooth","text":"public static const define bool SAWTOOTH","title":"SAWTOOTH"},{"location":"api/func/Ramp/#triangle","text":"public static const define bool TRIANGLE","title":"TRIANGLE"},{"location":"api/func/Ramp/#max","text":"public property float max [config] Maximum value","title":"max"},{"location":"api/func/Ramp/#min","text":"public property float min [config] Minimum value","title":"min"},{"location":"api/func/Ramp/#out","text":"public property float out [readonly] Ramp output","title":"out"},{"location":"api/func/Ramp/#period","text":"public property float period [unit=\"second\", min=0, config, precision=0] Ramp period If rampType is true (triangle) then this is the time it takes to complete up/down cycle. If rampType is false (sawtooth) then this is the time it takes to complete up cycle. A value of 0 forces output to min value.","title":"period"},{"location":"api/func/Ramp/#periodinnanos","text":"public long periodInNanos","title":"periodInNanos"},{"location":"api/func/Ramp/#ramptype","text":"public property bool rampType [falseText=\"sawtooth\", config, trueText=\"triangle\"] Specifies whether ramp is sawtooth (min to max and repeat), or triangle (min to max/max to min and repeat) Defaults to triangle.","title":"rampType"},{"location":"api/func/Ramp/#range","text":"public float range","title":"range"},{"location":"api/func/Ramp/#methods","text":"","title":"Methods"},{"location":"api/func/Ramp/#changed","text":"public virtual override void changed( Slot slot) recompute internal constants if ramp parameters change","title":"changed"},{"location":"api/func/Ramp/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/func/Ramp/#start","text":"public virtual override void start() compute internal constants at startup Doc Home > API Index > func > Ramp","title":"start"},{"location":"api/func/SRLatch/","text":"SRLatch \u00b6 Doc Home > API Index > func > SRLatch Inheritance \u00b6 sys::Obj sys::Virtual sys::Component func::SRLatch public class SRLatch [niagaraIcon=\"module://icons/x16/control/control.png\"] SRLatch Set Reset Latch object if ^s out = true; if ^r out = false; If both inputs have rising edges, out becomes false Fields \u00b6 lastReset \u00b6 public bool lastReset lastSet \u00b6 public bool lastSet out \u00b6 public property bool out [readonly] output r \u00b6 public property bool r On rising edge of r, out becomes false s \u00b6 public property bool s On rising edge of s, out becomes true Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. On rising edge of s, out becomes true On rising edge of r, out becomes false If both inputs have rising edges, out becomes false start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > func > SRLatch","title":"SRLatch"},{"location":"api/func/SRLatch/#srlatch","text":"Doc Home > API Index > func > SRLatch","title":"SRLatch"},{"location":"api/func/SRLatch/#inheritance","text":"sys::Obj sys::Virtual sys::Component func::SRLatch public class SRLatch [niagaraIcon=\"module://icons/x16/control/control.png\"] SRLatch Set Reset Latch object if ^s out = true; if ^r out = false; If both inputs have rising edges, out becomes false","title":"Inheritance"},{"location":"api/func/SRLatch/#fields","text":"","title":"Fields"},{"location":"api/func/SRLatch/#lastreset","text":"public bool lastReset","title":"lastReset"},{"location":"api/func/SRLatch/#lastset","text":"public bool lastSet","title":"lastSet"},{"location":"api/func/SRLatch/#out","text":"public property bool out [readonly] output","title":"out"},{"location":"api/func/SRLatch/#r","text":"public property bool r On rising edge of r, out becomes false","title":"r"},{"location":"api/func/SRLatch/#s","text":"public property bool s On rising edge of s, out becomes true","title":"s"},{"location":"api/func/SRLatch/#methods","text":"","title":"Methods"},{"location":"api/func/SRLatch/#execute","text":"public virtual override void execute() Execute is called once every scan. On rising edge of s, out becomes true On rising edge of r, out becomes false If both inputs have rising edges, out becomes false","title":"execute"},{"location":"api/func/SRLatch/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > func > SRLatch","title":"start"},{"location":"api/func/TickTock/","text":"TickTock \u00b6 Doc Home > API Index > func > TickTock Inheritance \u00b6 sys::Obj sys::Virtual sys::Component func::TickTock public class TickTock [niagaraIcon=\"module://icons/x16/control/util/sine.png\"] TickTock component Generates boolean square wave with ticksPerSec pulses per second Fields \u00b6 out \u00b6 public property bool out [readonly] output pulses ticksPerSec \u00b6 public property int ticksPerSec [unit=\"per_second\", min=1, max=10, config] can configure 1 to 10 pulses per second Methods \u00b6 changed \u00b6 public override void changed( Slot slot) Behavior to execute when a property is changed externally execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > func > TickTock","title":"TickTock"},{"location":"api/func/TickTock/#ticktock","text":"Doc Home > API Index > func > TickTock","title":"TickTock"},{"location":"api/func/TickTock/#inheritance","text":"sys::Obj sys::Virtual sys::Component func::TickTock public class TickTock [niagaraIcon=\"module://icons/x16/control/util/sine.png\"] TickTock component Generates boolean square wave with ticksPerSec pulses per second","title":"Inheritance"},{"location":"api/func/TickTock/#fields","text":"","title":"Fields"},{"location":"api/func/TickTock/#out","text":"public property bool out [readonly] output pulses","title":"out"},{"location":"api/func/TickTock/#tickspersec","text":"public property int ticksPerSec [unit=\"per_second\", min=1, max=10, config] can configure 1 to 10 pulses per second","title":"ticksPerSec"},{"location":"api/func/TickTock/#methods","text":"","title":"Methods"},{"location":"api/func/TickTock/#changed","text":"public override void changed( Slot slot) Behavior to execute when a property is changed externally","title":"changed"},{"location":"api/func/TickTock/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/func/TickTock/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > func > TickTock","title":"start"},{"location":"api/func/UpDn/","text":"UpDn \u00b6 Doc Home > API Index > func > UpDn Inheritance \u00b6 sys::Obj sys::Virtual sys::Component func::UpDn public class UpDn [niagaraIcon=\"module://icons/x16/control/control.png\"] UpDn Up/down counter object Fields \u00b6 cDwn \u00b6 public property bool cDwn [summary, config] Count down if true; o/w count up holdAtLimit \u00b6 public property bool holdAtLimit [config] Stop counting when limit reached if true in \u00b6 public property bool in Increment/decrement counter on positive edge limit \u00b6 public property float limit [config] Overflow limit out \u00b6 public property float out [readonly] Current count ovr \u00b6 public property bool ovr [readonly] Overflow indicator rst \u00b6 public property bool rst Reset count Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > func > UpDn","title":"UpDn"},{"location":"api/func/UpDn/#updn","text":"Doc Home > API Index > func > UpDn","title":"UpDn"},{"location":"api/func/UpDn/#inheritance","text":"sys::Obj sys::Virtual sys::Component func::UpDn public class UpDn [niagaraIcon=\"module://icons/x16/control/control.png\"] UpDn Up/down counter object","title":"Inheritance"},{"location":"api/func/UpDn/#fields","text":"","title":"Fields"},{"location":"api/func/UpDn/#cdwn","text":"public property bool cDwn [summary, config] Count down if true; o/w count up","title":"cDwn"},{"location":"api/func/UpDn/#holdatlimit","text":"public property bool holdAtLimit [config] Stop counting when limit reached if true","title":"holdAtLimit"},{"location":"api/func/UpDn/#in","text":"public property bool in Increment/decrement counter on positive edge","title":"in"},{"location":"api/func/UpDn/#limit","text":"public property float limit [config] Overflow limit","title":"limit"},{"location":"api/func/UpDn/#out","text":"public property float out [readonly] Current count","title":"out"},{"location":"api/func/UpDn/#ovr","text":"public property bool ovr [readonly] Overflow indicator","title":"ovr"},{"location":"api/func/UpDn/#rst","text":"public property bool rst Reset count","title":"rst"},{"location":"api/func/UpDn/#methods","text":"","title":"Methods"},{"location":"api/func/UpDn/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/func/UpDn/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > func > UpDn","title":"start"},{"location":"api/hvac/","text":"hvac \u00b6 Doc Home > API Index > hvac HVAC function block library LSeq \u00b6 ReheatSeq \u00b6 Reset \u00b6 Tstat \u00b6 Doc Home > API Index > hvac","title":"Index"},{"location":"api/hvac/#hvac","text":"Doc Home > API Index > hvac HVAC function block library","title":"hvac"},{"location":"api/hvac/#lseq","text":"","title":"LSeq"},{"location":"api/hvac/#reheatseq","text":"","title":"ReheatSeq"},{"location":"api/hvac/#reset","text":"","title":"Reset"},{"location":"api/hvac/#tstat","text":"Doc Home > API Index > hvac","title":"Tstat"},{"location":"api/hvac/LSeq/","text":"LSeq \u00b6 Doc Home > API Index > hvac > LSeq Inheritance \u00b6 sys::Obj sys::Virtual sys::Component hvac::LSeq public class LSeq [niagaraIcon=\"module://icons/x16/control/util/step.png\"] LSeq will provide a linear sequence of 1 to 16 loads. Analogous to a bar graph of the input value, where the delta represented by each output is (inMax-inMin)/(numOuts + 1). So given an input value, outputs 1 through n will be set true, and any remaining outputs will be false. If 'in' > 'inMax', then 'numOuts' outputs will be set true, and 'ovfl' will be set true The range of 'inMin' to 'inMax' is divided into 'numOuts+1' threshold values (delta), where: 'out1' is driven true if in > inMin + 1*delta, 'out1' and 'out2' are driven true if in > inMin + 2*delta, 'out1','out2', and 'out3' are driven true if in > inMin + 3*delta, etc delta = inMax-inMin/(numOuts + 1) A hysteresis of \u00bd delta is required to turn an output off. Fields \u00b6 dOn \u00b6 public property byte dOn [readonly] Number of outputs turned on delta \u00b6 public property float delta [readonly] Size of each output's range delta = (inMax-inMin)/(numOuts+1) in \u00b6 public property float in input will be divided into 'numOuts' sub ranges over the range inMin to inMax inMax \u00b6 public property float inMax [config] Expected input maximum inMin \u00b6 public property float inMin [config] Expected input minimum invalidConfig \u00b6 public bool invalidConfig max \u00b6 public float max min \u00b6 public float min numOuts \u00b6 public property int numOuts [min=1, max=16, config] The range of 'inMin' to 'inMax' is divided into 'numOuts' threshold values, where: delta = (inMax-inMin)/(numOuts + 1) 'out1' is driven true if in > inMin + 1*delta, 'out1' and 'out2' are driven true if in > inMin + 2*delta, 'out1','out2', and 'out3' are driven true if in > inMin + 3*delta, etc out1 \u00b6 public property bool out1 [readonly] output 1 out10 \u00b6 public property bool out10 [readonly] output 10 out11 \u00b6 public property bool out11 [readonly] output 11 out12 \u00b6 public property bool out12 [readonly] output 12 out13 \u00b6 public property bool out13 [readonly] output 13 out14 \u00b6 public property bool out14 [readonly] output 14 out15 \u00b6 public property bool out15 [readonly] output 15 out16 \u00b6 public property bool out16 [readonly] output 16 out2 \u00b6 public property bool out2 [readonly] output 2 out3 \u00b6 public property bool out3 [readonly] output 3 out4 \u00b6 public property bool out4 [readonly] output 4 out5 \u00b6 public property bool out5 [readonly] output 5 out6 \u00b6 public property bool out6 [readonly] output 6 out7 \u00b6 public property bool out7 [readonly] output 7 out8 \u00b6 public property bool out8 [readonly] output 8 out9 \u00b6 public property bool out9 [readonly] output 9 ovfl \u00b6 public property bool ovfl [readonly] Overflow is set when in > inMax Methods \u00b6 changed \u00b6 public override void changed( Slot slot) Behavior to execute when a property is changed externally Update the delta value execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > hvac > LSeq","title":"LSeq"},{"location":"api/hvac/LSeq/#lseq","text":"Doc Home > API Index > hvac > LSeq","title":"LSeq"},{"location":"api/hvac/LSeq/#inheritance","text":"sys::Obj sys::Virtual sys::Component hvac::LSeq public class LSeq [niagaraIcon=\"module://icons/x16/control/util/step.png\"] LSeq will provide a linear sequence of 1 to 16 loads. Analogous to a bar graph of the input value, where the delta represented by each output is (inMax-inMin)/(numOuts + 1). So given an input value, outputs 1 through n will be set true, and any remaining outputs will be false. If 'in' > 'inMax', then 'numOuts' outputs will be set true, and 'ovfl' will be set true The range of 'inMin' to 'inMax' is divided into 'numOuts+1' threshold values (delta), where: 'out1' is driven true if in > inMin + 1*delta, 'out1' and 'out2' are driven true if in > inMin + 2*delta, 'out1','out2', and 'out3' are driven true if in > inMin + 3*delta, etc delta = inMax-inMin/(numOuts + 1) A hysteresis of \u00bd delta is required to turn an output off.","title":"Inheritance"},{"location":"api/hvac/LSeq/#fields","text":"","title":"Fields"},{"location":"api/hvac/LSeq/#don","text":"public property byte dOn [readonly] Number of outputs turned on","title":"dOn"},{"location":"api/hvac/LSeq/#delta","text":"public property float delta [readonly] Size of each output's range delta = (inMax-inMin)/(numOuts+1)","title":"delta"},{"location":"api/hvac/LSeq/#in","text":"public property float in input will be divided into 'numOuts' sub ranges over the range inMin to inMax","title":"in"},{"location":"api/hvac/LSeq/#inmax","text":"public property float inMax [config] Expected input maximum","title":"inMax"},{"location":"api/hvac/LSeq/#inmin","text":"public property float inMin [config] Expected input minimum","title":"inMin"},{"location":"api/hvac/LSeq/#invalidconfig","text":"public bool invalidConfig","title":"invalidConfig"},{"location":"api/hvac/LSeq/#max","text":"public float max","title":"max"},{"location":"api/hvac/LSeq/#min","text":"public float min","title":"min"},{"location":"api/hvac/LSeq/#numouts","text":"public property int numOuts [min=1, max=16, config] The range of 'inMin' to 'inMax' is divided into 'numOuts' threshold values, where: delta = (inMax-inMin)/(numOuts + 1) 'out1' is driven true if in > inMin + 1*delta, 'out1' and 'out2' are driven true if in > inMin + 2*delta, 'out1','out2', and 'out3' are driven true if in > inMin + 3*delta, etc","title":"numOuts"},{"location":"api/hvac/LSeq/#out1","text":"public property bool out1 [readonly] output 1","title":"out1"},{"location":"api/hvac/LSeq/#out10","text":"public property bool out10 [readonly] output 10","title":"out10"},{"location":"api/hvac/LSeq/#out11","text":"public property bool out11 [readonly] output 11","title":"out11"},{"location":"api/hvac/LSeq/#out12","text":"public property bool out12 [readonly] output 12","title":"out12"},{"location":"api/hvac/LSeq/#out13","text":"public property bool out13 [readonly] output 13","title":"out13"},{"location":"api/hvac/LSeq/#out14","text":"public property bool out14 [readonly] output 14","title":"out14"},{"location":"api/hvac/LSeq/#out15","text":"public property bool out15 [readonly] output 15","title":"out15"},{"location":"api/hvac/LSeq/#out16","text":"public property bool out16 [readonly] output 16","title":"out16"},{"location":"api/hvac/LSeq/#out2","text":"public property bool out2 [readonly] output 2","title":"out2"},{"location":"api/hvac/LSeq/#out3","text":"public property bool out3 [readonly] output 3","title":"out3"},{"location":"api/hvac/LSeq/#out4","text":"public property bool out4 [readonly] output 4","title":"out4"},{"location":"api/hvac/LSeq/#out5","text":"public property bool out5 [readonly] output 5","title":"out5"},{"location":"api/hvac/LSeq/#out6","text":"public property bool out6 [readonly] output 6","title":"out6"},{"location":"api/hvac/LSeq/#out7","text":"public property bool out7 [readonly] output 7","title":"out7"},{"location":"api/hvac/LSeq/#out8","text":"public property bool out8 [readonly] output 8","title":"out8"},{"location":"api/hvac/LSeq/#out9","text":"public property bool out9 [readonly] output 9","title":"out9"},{"location":"api/hvac/LSeq/#ovfl","text":"public property bool ovfl [readonly] Overflow is set when in > inMax","title":"ovfl"},{"location":"api/hvac/LSeq/#methods","text":"","title":"Methods"},{"location":"api/hvac/LSeq/#changed","text":"public override void changed( Slot slot) Behavior to execute when a property is changed externally Update the delta value","title":"changed"},{"location":"api/hvac/LSeq/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/hvac/LSeq/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > hvac > LSeq","title":"start"},{"location":"api/hvac/ReheatSeq/","text":"ReheatSeq \u00b6 Doc Home > API Index > hvac > ReheatSeq Inheritance \u00b6 sys::Obj sys::Virtual sys::Component hvac::ReheatSeq public class ReheatSeq [niagaraIcon=\"module://icons/x16/control/util/step.png\"] ReheatSeq will provide a linear sequence of up to 4 loads based on configurable thresholds Sets an output true if the \"in\" value is greater than corresponding threshold, and returns the ouput to false if the \"in\" value is less than threshold minus the hysteresis value. \"dOn\" is the count of outputs that are true (0 to 4) If \"enable\" is false, all outputs are set to false regardless of in value. Fields \u00b6 dOn \u00b6 public property byte dOn [readonly] number of outputs currently turned on enable \u00b6 public property bool enable [config] all outputs are false if enable == false hysteresis \u00b6 public property float hysteresis [config] hysteresis value - in < threshold - hysteresis is required to turn an output off in \u00b6 public property float in cv input out1 \u00b6 public property bool out1 [readonly] output 1 out2 \u00b6 public property bool out2 [readonly] output 2 out3 \u00b6 public property bool out3 [readonly] output 3 out4 \u00b6 public property bool out4 [readonly] output 4 threshold1 \u00b6 public property float threshold1 [config] threshold to turn out1 on threshold2 \u00b6 public property float threshold2 [config] threshold to turn out2 on threshold3 \u00b6 public property float threshold3 [config] threshold to turn out3 on threshold4 \u00b6 public property float threshold4 [config] threshold to turn out4 on Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > hvac > ReheatSeq","title":"ReheatSeq"},{"location":"api/hvac/ReheatSeq/#reheatseq","text":"Doc Home > API Index > hvac > ReheatSeq","title":"ReheatSeq"},{"location":"api/hvac/ReheatSeq/#inheritance","text":"sys::Obj sys::Virtual sys::Component hvac::ReheatSeq public class ReheatSeq [niagaraIcon=\"module://icons/x16/control/util/step.png\"] ReheatSeq will provide a linear sequence of up to 4 loads based on configurable thresholds Sets an output true if the \"in\" value is greater than corresponding threshold, and returns the ouput to false if the \"in\" value is less than threshold minus the hysteresis value. \"dOn\" is the count of outputs that are true (0 to 4) If \"enable\" is false, all outputs are set to false regardless of in value.","title":"Inheritance"},{"location":"api/hvac/ReheatSeq/#fields","text":"","title":"Fields"},{"location":"api/hvac/ReheatSeq/#don","text":"public property byte dOn [readonly] number of outputs currently turned on","title":"dOn"},{"location":"api/hvac/ReheatSeq/#enable","text":"public property bool enable [config] all outputs are false if enable == false","title":"enable"},{"location":"api/hvac/ReheatSeq/#hysteresis","text":"public property float hysteresis [config] hysteresis value - in < threshold - hysteresis is required to turn an output off","title":"hysteresis"},{"location":"api/hvac/ReheatSeq/#in","text":"public property float in cv input","title":"in"},{"location":"api/hvac/ReheatSeq/#out1","text":"public property bool out1 [readonly] output 1","title":"out1"},{"location":"api/hvac/ReheatSeq/#out2","text":"public property bool out2 [readonly] output 2","title":"out2"},{"location":"api/hvac/ReheatSeq/#out3","text":"public property bool out3 [readonly] output 3","title":"out3"},{"location":"api/hvac/ReheatSeq/#out4","text":"public property bool out4 [readonly] output 4","title":"out4"},{"location":"api/hvac/ReheatSeq/#threshold1","text":"public property float threshold1 [config] threshold to turn out1 on","title":"threshold1"},{"location":"api/hvac/ReheatSeq/#threshold2","text":"public property float threshold2 [config] threshold to turn out2 on","title":"threshold2"},{"location":"api/hvac/ReheatSeq/#threshold3","text":"public property float threshold3 [config] threshold to turn out3 on","title":"threshold3"},{"location":"api/hvac/ReheatSeq/#threshold4","text":"public property float threshold4 [config] threshold to turn out4 on","title":"threshold4"},{"location":"api/hvac/ReheatSeq/#methods","text":"","title":"Methods"},{"location":"api/hvac/ReheatSeq/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > hvac > ReheatSeq","title":"execute"},{"location":"api/hvac/Reset/","text":"Reset \u00b6 Doc Home > API Index > hvac > Reset Inheritance \u00b6 sys::Obj sys::Virtual sys::Component hvac::Reset public class Reset [niagaraIcon=\"module://icons/x16/control/math/reset.png\"] Reset re-scales in value to out value object This function performs a \"reset\" on the input value. \"Reset\" is a HVAC term for scaling a number between two limits. When inMin < inA < inMax, the output value scales linearly between outMin and outMax. If inA < inMin, the value is capped at outMin. If inA > inMax, the value is capped at outMax. To calculate out, the following equation is used: (outMax-outMin) out = --------------- * (in - inMin) + outMin (inMax-inMin) Fields \u00b6 in \u00b6 public property float in input inMax \u00b6 public property float inMax [config] scaling constant inMax inMin \u00b6 public property float inMin [config] scaling constant inMin out \u00b6 public property float out [readonly] re-scaled output outMax \u00b6 public property float outMax [config] scaling constant outMax outMin \u00b6 public property float outMin [config] scaling constant outMin Methods \u00b6 changed \u00b6 public override void changed( Slot slot) Behavior to execute when a property is changed externally execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > hvac > Reset","title":"Reset"},{"location":"api/hvac/Reset/#reset","text":"Doc Home > API Index > hvac > Reset","title":"Reset"},{"location":"api/hvac/Reset/#inheritance","text":"sys::Obj sys::Virtual sys::Component hvac::Reset public class Reset [niagaraIcon=\"module://icons/x16/control/math/reset.png\"] Reset re-scales in value to out value object This function performs a \"reset\" on the input value. \"Reset\" is a HVAC term for scaling a number between two limits. When inMin < inA < inMax, the output value scales linearly between outMin and outMax. If inA < inMin, the value is capped at outMin. If inA > inMax, the value is capped at outMax. To calculate out, the following equation is used: (outMax-outMin) out = --------------- * (in - inMin) + outMin (inMax-inMin)","title":"Inheritance"},{"location":"api/hvac/Reset/#fields","text":"","title":"Fields"},{"location":"api/hvac/Reset/#in","text":"public property float in input","title":"in"},{"location":"api/hvac/Reset/#inmax","text":"public property float inMax [config] scaling constant inMax","title":"inMax"},{"location":"api/hvac/Reset/#inmin","text":"public property float inMin [config] scaling constant inMin","title":"inMin"},{"location":"api/hvac/Reset/#out","text":"public property float out [readonly] re-scaled output","title":"out"},{"location":"api/hvac/Reset/#outmax","text":"public property float outMax [config] scaling constant outMax","title":"outMax"},{"location":"api/hvac/Reset/#outmin","text":"public property float outMin [config] scaling constant outMin","title":"outMin"},{"location":"api/hvac/Reset/#methods","text":"","title":"Methods"},{"location":"api/hvac/Reset/#changed","text":"public override void changed( Slot slot) Behavior to execute when a property is changed externally","title":"changed"},{"location":"api/hvac/Reset/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/hvac/Reset/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > hvac > Reset","title":"start"},{"location":"api/hvac/Tstat/","text":"Tstat \u00b6 Doc Home > API Index > hvac > Tstat Inheritance \u00b6 sys::Obj sys::Virtual sys::Component hvac::Tstat public class Tstat [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] Tstat Provides On/Off or Floating Thermostat control raise & lower outputs operate independently of isHeating mode. lower will be set to true if cv > (sp + diff/2) and will remain set until cv < (sp - diff/2). raise will be set to true if cv < (sp - diff/2) and will remain set until CV > (sp + diff/2). out will be set based on isHeating mode. if isHeating out = raise else out = lower Fields \u00b6 cv \u00b6 public property float cv actual diff \u00b6 public property float diff [summary, config] deadband centered around sp isHeating \u00b6 public property bool isHeating [summary, config] set true to put into heating mode, false for cooling mode lower \u00b6 public property bool lower [readonly] need to lower out \u00b6 public property bool out [readonly] calls for cooling or heating as required by sp/cv/isheating raise \u00b6 public property bool raise [readonly] need to raise sp \u00b6 public property float sp [summary, config] the setpoint Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > hvac > Tstat","title":"Tstat"},{"location":"api/hvac/Tstat/#tstat","text":"Doc Home > API Index > hvac > Tstat","title":"Tstat"},{"location":"api/hvac/Tstat/#inheritance","text":"sys::Obj sys::Virtual sys::Component hvac::Tstat public class Tstat [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] Tstat Provides On/Off or Floating Thermostat control raise & lower outputs operate independently of isHeating mode. lower will be set to true if cv > (sp + diff/2) and will remain set until cv < (sp - diff/2). raise will be set to true if cv < (sp - diff/2) and will remain set until CV > (sp + diff/2). out will be set based on isHeating mode. if isHeating out = raise else out = lower","title":"Inheritance"},{"location":"api/hvac/Tstat/#fields","text":"","title":"Fields"},{"location":"api/hvac/Tstat/#cv","text":"public property float cv actual","title":"cv"},{"location":"api/hvac/Tstat/#diff","text":"public property float diff [summary, config] deadband centered around sp","title":"diff"},{"location":"api/hvac/Tstat/#isheating","text":"public property bool isHeating [summary, config] set true to put into heating mode, false for cooling mode","title":"isHeating"},{"location":"api/hvac/Tstat/#lower","text":"public property bool lower [readonly] need to lower","title":"lower"},{"location":"api/hvac/Tstat/#out","text":"public property bool out [readonly] calls for cooling or heating as required by sp/cv/isheating","title":"out"},{"location":"api/hvac/Tstat/#raise","text":"public property bool raise [readonly] need to raise","title":"raise"},{"location":"api/hvac/Tstat/#sp","text":"public property float sp [summary, config] the setpoint","title":"sp"},{"location":"api/hvac/Tstat/#methods","text":"","title":"Methods"},{"location":"api/hvac/Tstat/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > hvac > Tstat","title":"execute"},{"location":"api/inet/","text":"inet \u00b6 Doc Home > API Index > inet IP and UDP/TCP Socket APIs Crypto \u00b6 IpAddr \u00b6 SocketAddr \u00b6 TcpServerSocket \u00b6 TcpSocket \u00b6 UdpDatagram \u00b6 UdpSocket \u00b6 Doc Home > API Index > inet","title":"Index"},{"location":"api/inet/#inet","text":"Doc Home > API Index > inet IP and UDP/TCP Socket APIs","title":"inet"},{"location":"api/inet/#crypto","text":"","title":"Crypto"},{"location":"api/inet/#ipaddr","text":"","title":"IpAddr"},{"location":"api/inet/#socketaddr","text":"","title":"SocketAddr"},{"location":"api/inet/#tcpserversocket","text":"","title":"TcpServerSocket"},{"location":"api/inet/#tcpsocket","text":"","title":"TcpSocket"},{"location":"api/inet/#udpdatagram","text":"","title":"UdpDatagram"},{"location":"api/inet/#udpsocket","text":"Doc Home > API Index > inet","title":"UdpSocket"},{"location":"api/inet/Crypto/","text":"Crypto \u00b6 Doc Home > API Index > inet > Crypto Inheritance \u00b6 sys::Obj inet::Crypto public class Crypto Crypto provides some cryptographic utility functions used by DASP. Fields \u00b6 Methods \u00b6 sha1 \u00b6 public static native void sha1(byte[] in, int inOff, int len, byte[] output, int outOff) Generate the SHA-1 hash for the input bytes. The 20 byte result is stored in the output pointer. Doc Home > API Index > inet > Crypto","title":"Crypto"},{"location":"api/inet/Crypto/#crypto","text":"Doc Home > API Index > inet > Crypto","title":"Crypto"},{"location":"api/inet/Crypto/#inheritance","text":"sys::Obj inet::Crypto public class Crypto Crypto provides some cryptographic utility functions used by DASP.","title":"Inheritance"},{"location":"api/inet/Crypto/#fields","text":"","title":"Fields"},{"location":"api/inet/Crypto/#methods","text":"","title":"Methods"},{"location":"api/inet/Crypto/#sha1","text":"public static native void sha1(byte[] in, int inOff, int len, byte[] output, int outOff) Generate the SHA-1 hash for the input bytes. The 20 byte result is stored in the output pointer. Doc Home > API Index > inet > Crypto","title":"sha1"},{"location":"api/inet/IpAddr/","text":"IpAddr \u00b6 Doc Home > API Index > inet > IpAddr Inheritance \u00b6 sys::Obj inet::IpAddr public class IpAddr IpAddr models an Internet IPv4 or IPv6 address. Fields \u00b6 Methods \u00b6 equals \u00b6 public bool equals( IpAddr that) Return if this address is equivalent to that address. isIPv4 \u00b6 public bool isIPv4() Return if this is a IPv4 mapped address. IPv4 addresses have the first 80 bits set to zero, the next 16 set to one, and the last 32 bits represent the IPv4 address. loadBuf \u00b6 public bool loadBuf( Buf addr) Convenience for loadBytes(addr.bytes, addr.size) loadBytes \u00b6 public bool loadBytes(byte[] addr, int len) Set the IpAddr using a raw byte array. Returns true if the length of the addr is 4-bytes (IPv4) or 16 bytes (IPv6). No validation is done on the raw addr. parse \u00b6 public bool parse( Str notation) Parse the specified string from an IPv4 dotted-quad notation or IPv6 colon-hexdecimal notation into this IpAddr. This method will not resolve a hostname. Return true on success, or false on failure (if the address is illegally formatted). set \u00b6 public void set( IpAddr addr) This method is used to copy the address of \"addr\" into this instance. toStr \u00b6 public Str toStr() Get the address in string format - dotted-quad notation for IPv4 or colon-hexidecimal notation for IPv6. The string is stored in a static shared buffer. Doc Home > API Index > inet > IpAddr","title":"IpAddr"},{"location":"api/inet/IpAddr/#ipaddr","text":"Doc Home > API Index > inet > IpAddr","title":"IpAddr"},{"location":"api/inet/IpAddr/#inheritance","text":"sys::Obj inet::IpAddr public class IpAddr IpAddr models an Internet IPv4 or IPv6 address.","title":"Inheritance"},{"location":"api/inet/IpAddr/#fields","text":"","title":"Fields"},{"location":"api/inet/IpAddr/#methods","text":"","title":"Methods"},{"location":"api/inet/IpAddr/#equals","text":"public bool equals( IpAddr that) Return if this address is equivalent to that address.","title":"equals"},{"location":"api/inet/IpAddr/#isipv4","text":"public bool isIPv4() Return if this is a IPv4 mapped address. IPv4 addresses have the first 80 bits set to zero, the next 16 set to one, and the last 32 bits represent the IPv4 address.","title":"isIPv4"},{"location":"api/inet/IpAddr/#loadbuf","text":"public bool loadBuf( Buf addr) Convenience for loadBytes(addr.bytes, addr.size)","title":"loadBuf"},{"location":"api/inet/IpAddr/#loadbytes","text":"public bool loadBytes(byte[] addr, int len) Set the IpAddr using a raw byte array. Returns true if the length of the addr is 4-bytes (IPv4) or 16 bytes (IPv6). No validation is done on the raw addr.","title":"loadBytes"},{"location":"api/inet/IpAddr/#parse","text":"public bool parse( Str notation) Parse the specified string from an IPv4 dotted-quad notation or IPv6 colon-hexdecimal notation into this IpAddr. This method will not resolve a hostname. Return true on success, or false on failure (if the address is illegally formatted).","title":"parse"},{"location":"api/inet/IpAddr/#set","text":"public void set( IpAddr addr) This method is used to copy the address of \"addr\" into this instance.","title":"set"},{"location":"api/inet/IpAddr/#tostr","text":"public Str toStr() Get the address in string format - dotted-quad notation for IPv4 or colon-hexidecimal notation for IPv6. The string is stored in a static shared buffer. Doc Home > API Index > inet > IpAddr","title":"toStr"},{"location":"api/inet/SocketAddr/","text":"SocketAddr \u00b6 Doc Home > API Index > inet > SocketAddr Inheritance \u00b6 sys::Obj inet::SocketAddr public class SocketAddr SocketAddr is a combination of the IpAddr host and 16-bit port number. Fields \u00b6 addr \u00b6 public inline IpAddr addr IP host address port \u00b6 public short port IP port number Methods \u00b6 equals \u00b6 public bool equals( SocketAddr that) Return if this address is equivalent to that address. Doc Home > API Index > inet > SocketAddr","title":"SocketAddr"},{"location":"api/inet/SocketAddr/#socketaddr","text":"Doc Home > API Index > inet > SocketAddr","title":"SocketAddr"},{"location":"api/inet/SocketAddr/#inheritance","text":"sys::Obj inet::SocketAddr public class SocketAddr SocketAddr is a combination of the IpAddr host and 16-bit port number.","title":"Inheritance"},{"location":"api/inet/SocketAddr/#fields","text":"","title":"Fields"},{"location":"api/inet/SocketAddr/#addr","text":"public inline IpAddr addr IP host address","title":"addr"},{"location":"api/inet/SocketAddr/#port","text":"public short port IP port number","title":"port"},{"location":"api/inet/SocketAddr/#methods","text":"","title":"Methods"},{"location":"api/inet/SocketAddr/#equals","text":"public bool equals( SocketAddr that) Return if this address is equivalent to that address. Doc Home > API Index > inet > SocketAddr","title":"equals"},{"location":"api/inet/TcpServerSocket/","text":"TcpServerSocket \u00b6 Doc Home > API Index > inet > TcpServerSocket Inheritance \u00b6 sys::Obj inet::TcpServerSocket public class TcpServerSocket [javaPeer] TcpServerSocket is used to open a socket for listening and accepting incoming TCP connections. Fields \u00b6 Methods \u00b6 accept \u00b6 public native bool accept( TcpSocket socket) Poll the server socket to see if there are any pending connections. If a connection is pending then setup the specified socket instance to handle the incoming connection. The socket passed in must be closed, and if successful will be open on return. Return true if a connection was successfully accepted or false if there are no pending connections. bind \u00b6 public native bool bind(int port) Bind this socket the specified well-known port on this machine. Return true on success, false on failure. close \u00b6 public native void close() Shutdown and close this server socket. isClosed \u00b6 public bool isClosed() Is this server socket closed. Doc Home > API Index > inet > TcpServerSocket","title":"TcpServerSocket"},{"location":"api/inet/TcpServerSocket/#tcpserversocket","text":"Doc Home > API Index > inet > TcpServerSocket","title":"TcpServerSocket"},{"location":"api/inet/TcpServerSocket/#inheritance","text":"sys::Obj inet::TcpServerSocket public class TcpServerSocket [javaPeer] TcpServerSocket is used to open a socket for listening and accepting incoming TCP connections.","title":"Inheritance"},{"location":"api/inet/TcpServerSocket/#fields","text":"","title":"Fields"},{"location":"api/inet/TcpServerSocket/#methods","text":"","title":"Methods"},{"location":"api/inet/TcpServerSocket/#accept","text":"public native bool accept( TcpSocket socket) Poll the server socket to see if there are any pending connections. If a connection is pending then setup the specified socket instance to handle the incoming connection. The socket passed in must be closed, and if successful will be open on return. Return true if a connection was successfully accepted or false if there are no pending connections.","title":"accept"},{"location":"api/inet/TcpServerSocket/#bind","text":"public native bool bind(int port) Bind this socket the specified well-known port on this machine. Return true on success, false on failure.","title":"bind"},{"location":"api/inet/TcpServerSocket/#close","text":"public native void close() Shutdown and close this server socket.","title":"close"},{"location":"api/inet/TcpServerSocket/#isclosed","text":"public bool isClosed() Is this server socket closed. Doc Home > API Index > inet > TcpServerSocket","title":"isClosed"},{"location":"api/inet/TcpSocket/","text":"TcpSocket \u00b6 Doc Home > API Index > inet > TcpSocket Inheritance \u00b6 sys::Obj inet::TcpSocket public class TcpSocket [javaPeer] TcpSocket models a bi-directional TCP stream. Client side sockets are opened using TcpSocket.connect(). Server side sockets opened via TcpServerSocket.bind() and accept(). The Sedona socket APIs are all asynchronous to be used in a single threaded environment. Fields \u00b6 READ \u00b6 public static const define int READ Bitmask for select when socket is readable WRITE \u00b6 public static const define int WRITE Bitmask for select when socket is writable Methods \u00b6 close \u00b6 public native void close() Shutdown and close this socket. connect \u00b6 public native bool connect( IpAddr addr, int port) Connect this socket to the specified IP address and port. This method is non-blocking. Poll the socket using finishConnect() to determine when the connection been completed (either successfully or not). Return false if there is an immediate failure, or true if this call succeeds. finishConnect \u00b6 public native bool finishConnect() Poll the socket to see if the connection has completed. Return false if the connection is still in-progress. If the connection attempt has completed then return true and check isClosed() for success. - Pending: return false - Success: return true, closed=false - Failed: return true, closed=true In the case that the state after a finishConnect() call is Failed, you must still call close() to properly free the socket that was opened in the connect() call. isClosed \u00b6 public bool isClosed() Is this socket closed. read \u00b6 public native int read(byte[] b, int off, int len) Receive the specified bytes from the socket. Return the number of bytes actually read which may be equal to or less than len. If the connection is terminated or there is any other error close the socket and return -1. write \u00b6 public native int write(byte[] b, int off, int len) Send the specified bytes over the socket. Return the number of bytes actually written which may be equal to or less than len. If the connection is terminated or there is any other error close the socket and return -1. Doc Home > API Index > inet > TcpSocket","title":"TcpSocket"},{"location":"api/inet/TcpSocket/#tcpsocket","text":"Doc Home > API Index > inet > TcpSocket","title":"TcpSocket"},{"location":"api/inet/TcpSocket/#inheritance","text":"sys::Obj inet::TcpSocket public class TcpSocket [javaPeer] TcpSocket models a bi-directional TCP stream. Client side sockets are opened using TcpSocket.connect(). Server side sockets opened via TcpServerSocket.bind() and accept(). The Sedona socket APIs are all asynchronous to be used in a single threaded environment.","title":"Inheritance"},{"location":"api/inet/TcpSocket/#fields","text":"","title":"Fields"},{"location":"api/inet/TcpSocket/#read","text":"public static const define int READ Bitmask for select when socket is readable","title":"READ"},{"location":"api/inet/TcpSocket/#write","text":"public static const define int WRITE Bitmask for select when socket is writable","title":"WRITE"},{"location":"api/inet/TcpSocket/#methods","text":"","title":"Methods"},{"location":"api/inet/TcpSocket/#close","text":"public native void close() Shutdown and close this socket.","title":"close"},{"location":"api/inet/TcpSocket/#connect","text":"public native bool connect( IpAddr addr, int port) Connect this socket to the specified IP address and port. This method is non-blocking. Poll the socket using finishConnect() to determine when the connection been completed (either successfully or not). Return false if there is an immediate failure, or true if this call succeeds.","title":"connect"},{"location":"api/inet/TcpSocket/#finishconnect","text":"public native bool finishConnect() Poll the socket to see if the connection has completed. Return false if the connection is still in-progress. If the connection attempt has completed then return true and check isClosed() for success. - Pending: return false - Success: return true, closed=false - Failed: return true, closed=true In the case that the state after a finishConnect() call is Failed, you must still call close() to properly free the socket that was opened in the connect() call.","title":"finishConnect"},{"location":"api/inet/TcpSocket/#isclosed","text":"public bool isClosed() Is this socket closed.","title":"isClosed"},{"location":"api/inet/TcpSocket/#read_1","text":"public native int read(byte[] b, int off, int len) Receive the specified bytes from the socket. Return the number of bytes actually read which may be equal to or less than len. If the connection is terminated or there is any other error close the socket and return -1.","title":"read"},{"location":"api/inet/TcpSocket/#write_1","text":"public native int write(byte[] b, int off, int len) Send the specified bytes over the socket. Return the number of bytes actually written which may be equal to or less than len. If the connection is terminated or there is any other error close the socket and return -1. Doc Home > API Index > inet > TcpSocket","title":"write"},{"location":"api/inet/UdpDatagram/","text":"UdpDatagram \u00b6 Doc Home > API Index > inet > UdpDatagram Inheritance \u00b6 sys::Obj inet::UdpDatagram public class UdpDatagram UdpDatagram is used to encapsulate the buffer of data and the IP address for sending and receiving UDP packets with a UdpSocket. Fields \u00b6 addr \u00b6 public IpAddr addr The IP address to send this packet to, or the address we received this packet from. Note this is a shared instance during receive and must be copied to a new memory location if you wish to keep it. buf \u00b6 public byte[] buf The buffer of data to send (must never be null) flowinfo \u00b6 public int flowinfo IPv6 address flow info len \u00b6 public int len Number of bytes past buf+off to send or receive, after receive() specified the number of bytes actually read off \u00b6 public int off Offset into buffer port \u00b6 public int port The IP port for address to send or receive scopeId \u00b6 public int scopeId IPv6 address scope ID Methods \u00b6 getSocketAddr \u00b6 public void getSocketAddr( SocketAddr sockAddr) Copy the datagram to the socket address (makes a deep copy of the host addr). setSocketAddr \u00b6 public void setSocketAddr( SocketAddr sockAddr) Copy this address to the datagram (makes a shallow copy of the host addr). Doc Home > API Index > inet > UdpDatagram","title":"UdpDatagram"},{"location":"api/inet/UdpDatagram/#udpdatagram","text":"Doc Home > API Index > inet > UdpDatagram","title":"UdpDatagram"},{"location":"api/inet/UdpDatagram/#inheritance","text":"sys::Obj inet::UdpDatagram public class UdpDatagram UdpDatagram is used to encapsulate the buffer of data and the IP address for sending and receiving UDP packets with a UdpSocket.","title":"Inheritance"},{"location":"api/inet/UdpDatagram/#fields","text":"","title":"Fields"},{"location":"api/inet/UdpDatagram/#addr","text":"public IpAddr addr The IP address to send this packet to, or the address we received this packet from. Note this is a shared instance during receive and must be copied to a new memory location if you wish to keep it.","title":"addr"},{"location":"api/inet/UdpDatagram/#buf","text":"public byte[] buf The buffer of data to send (must never be null)","title":"buf"},{"location":"api/inet/UdpDatagram/#flowinfo","text":"public int flowinfo IPv6 address flow info","title":"flowinfo"},{"location":"api/inet/UdpDatagram/#len","text":"public int len Number of bytes past buf+off to send or receive, after receive() specified the number of bytes actually read","title":"len"},{"location":"api/inet/UdpDatagram/#off","text":"public int off Offset into buffer","title":"off"},{"location":"api/inet/UdpDatagram/#port","text":"public int port The IP port for address to send or receive","title":"port"},{"location":"api/inet/UdpDatagram/#scopeid","text":"public int scopeId IPv6 address scope ID","title":"scopeId"},{"location":"api/inet/UdpDatagram/#methods","text":"","title":"Methods"},{"location":"api/inet/UdpDatagram/#getsocketaddr","text":"public void getSocketAddr( SocketAddr sockAddr) Copy the datagram to the socket address (makes a deep copy of the host addr).","title":"getSocketAddr"},{"location":"api/inet/UdpDatagram/#setsocketaddr","text":"public void setSocketAddr( SocketAddr sockAddr) Copy this address to the datagram (makes a shallow copy of the host addr). Doc Home > API Index > inet > UdpDatagram","title":"setSocketAddr"},{"location":"api/inet/UdpSocket/","text":"UdpSocket \u00b6 Doc Home > API Index > inet > UdpSocket Inheritance \u00b6 sys::Obj inet::UdpSocket public class UdpSocket [javaPeer] UdpSocket is used to send and receive UDP datagrams. The Sedona socket APIs are all asynchronous to be used in a single threaded environment. Fields \u00b6 READ \u00b6 public static const define int READ Bitmask for select when socket is readable WRITE \u00b6 public static const define int WRITE Bitmask for select when socket is writable Methods \u00b6 bind \u00b6 public native bool bind(int port) Bind this socket the specified well-known port on this host. Return true on success, false on failure. close \u00b6 public native void close() Shutdown and close this socket. idealPacketSize \u00b6 public static native int idealPacketSize() What is the ideal maximum number of bytes to send by this UDP implementation. This is typically driven by the lower levels of the IP stack - for instance when running 6LoWPAN over 802.15.4, this is the max UDP packet size which doesn't require fragmenting across multiple 802.15.4 frames. isClosed \u00b6 public bool isClosed() Is this socket closed. join \u00b6 public native bool join() Join this socket to a multicast group. (Address is defined at native level.) Return true on success, false on failure. maxPacketSize \u00b6 public static native int maxPacketSize() What is the maximum number of bytes which can be sent by this UDP implementation. open \u00b6 public native bool open() Initialize this socket which allocates a socket handle for this instance. This method must be called before using the socket. Return true on success, false on failure. receive \u00b6 public native bool receive( UdpDatagram datagram) Receive a datagram into the specified structure. The datagram.buf must reference a valid byte buffer - bytes are read in starting at datagram.buf[0] with at most datagram.len bytes being received. If successful then return true, datagram.len reflects the actual number of bytes received, and datagram.addr/datagram.port reflect the source socket address. Note datagram.addr is only valid until the next call to receive(). On failure or if no packets are pending to read, then return false, len=0, port=-1, and addr=null. Note if the number of bytes available to be read is greater then len than this call works differently dependent on the platform. In Java it silently ignores the remainder of the bytes (wrong way), and in C++ it returns false since the message received is not the same as the message sent. send \u00b6 public native bool send( UdpDatagram datagram) Send the specified datagram which encapsulates both the destination address and the data to send. Return true on success, false on failure. If the number of bytes sent does not match datagram.len then this call will fail and return false. Doc Home > API Index > inet > UdpSocket","title":"UdpSocket"},{"location":"api/inet/UdpSocket/#udpsocket","text":"Doc Home > API Index > inet > UdpSocket","title":"UdpSocket"},{"location":"api/inet/UdpSocket/#inheritance","text":"sys::Obj inet::UdpSocket public class UdpSocket [javaPeer] UdpSocket is used to send and receive UDP datagrams. The Sedona socket APIs are all asynchronous to be used in a single threaded environment.","title":"Inheritance"},{"location":"api/inet/UdpSocket/#fields","text":"","title":"Fields"},{"location":"api/inet/UdpSocket/#read","text":"public static const define int READ Bitmask for select when socket is readable","title":"READ"},{"location":"api/inet/UdpSocket/#write","text":"public static const define int WRITE Bitmask for select when socket is writable","title":"WRITE"},{"location":"api/inet/UdpSocket/#methods","text":"","title":"Methods"},{"location":"api/inet/UdpSocket/#bind","text":"public native bool bind(int port) Bind this socket the specified well-known port on this host. Return true on success, false on failure.","title":"bind"},{"location":"api/inet/UdpSocket/#close","text":"public native void close() Shutdown and close this socket.","title":"close"},{"location":"api/inet/UdpSocket/#idealpacketsize","text":"public static native int idealPacketSize() What is the ideal maximum number of bytes to send by this UDP implementation. This is typically driven by the lower levels of the IP stack - for instance when running 6LoWPAN over 802.15.4, this is the max UDP packet size which doesn't require fragmenting across multiple 802.15.4 frames.","title":"idealPacketSize"},{"location":"api/inet/UdpSocket/#isclosed","text":"public bool isClosed() Is this socket closed.","title":"isClosed"},{"location":"api/inet/UdpSocket/#join","text":"public native bool join() Join this socket to a multicast group. (Address is defined at native level.) Return true on success, false on failure.","title":"join"},{"location":"api/inet/UdpSocket/#maxpacketsize","text":"public static native int maxPacketSize() What is the maximum number of bytes which can be sent by this UDP implementation.","title":"maxPacketSize"},{"location":"api/inet/UdpSocket/#open","text":"public native bool open() Initialize this socket which allocates a socket handle for this instance. This method must be called before using the socket. Return true on success, false on failure.","title":"open"},{"location":"api/inet/UdpSocket/#receive","text":"public native bool receive( UdpDatagram datagram) Receive a datagram into the specified structure. The datagram.buf must reference a valid byte buffer - bytes are read in starting at datagram.buf[0] with at most datagram.len bytes being received. If successful then return true, datagram.len reflects the actual number of bytes received, and datagram.addr/datagram.port reflect the source socket address. Note datagram.addr is only valid until the next call to receive(). On failure or if no packets are pending to read, then return false, len=0, port=-1, and addr=null. Note if the number of bytes available to be read is greater then len than this call works differently dependent on the platform. In Java it silently ignores the remainder of the bytes (wrong way), and in C++ it returns false since the message received is not the same as the message sent.","title":"receive"},{"location":"api/inet/UdpSocket/#send","text":"public native bool send( UdpDatagram datagram) Send the specified datagram which encapsulates both the destination address and the data to send. Return true on success, false on failure. If the number of bytes sent does not match datagram.len then this call will fail and return false. Doc Home > API Index > inet > UdpSocket","title":"send"},{"location":"api/logManager/","text":"logManager \u00b6 Doc Home > API Index > logManager Support for managing logs LogCfg \u00b6 LogMgr \u00b6 Doc Home > API Index > logManager","title":"Index"},{"location":"api/logManager/#logmanager","text":"Doc Home > API Index > logManager Support for managing logs","title":"logManager"},{"location":"api/logManager/#logcfg","text":"","title":"LogCfg"},{"location":"api/logManager/#logmgr","text":"Doc Home > API Index > logManager","title":"LogMgr"},{"location":"api/logManager/LogCfg/","text":"LogCfg \u00b6 Doc Home > API Index > logManager > LogCfg Inheritance \u00b6 sys::Obj sys::Virtual sys::Component logManager::LogCfg public final class LogCfg [palette=false] Fields \u00b6 logLevel \u00b6 public property int logLevel [range=\"none, error, warning, message, trace\", config] logLevels \u00b6 public static const define Str logLevels logName \u00b6 public inline property Buf logName [asStr, readonly, config, max=64] Methods \u00b6 changed \u00b6 public virtual override void changed( Slot slot) start \u00b6 public virtual override void start() Doc Home > API Index > logManager > LogCfg","title":"LogCfg"},{"location":"api/logManager/LogCfg/#logcfg","text":"Doc Home > API Index > logManager > LogCfg","title":"LogCfg"},{"location":"api/logManager/LogCfg/#inheritance","text":"sys::Obj sys::Virtual sys::Component logManager::LogCfg public final class LogCfg [palette=false]","title":"Inheritance"},{"location":"api/logManager/LogCfg/#fields","text":"","title":"Fields"},{"location":"api/logManager/LogCfg/#loglevel","text":"public property int logLevel [range=\"none, error, warning, message, trace\", config]","title":"logLevel"},{"location":"api/logManager/LogCfg/#loglevels","text":"public static const define Str logLevels","title":"logLevels"},{"location":"api/logManager/LogCfg/#logname","text":"public inline property Buf logName [asStr, readonly, config, max=64]","title":"logName"},{"location":"api/logManager/LogCfg/#methods","text":"","title":"Methods"},{"location":"api/logManager/LogCfg/#changed","text":"public virtual override void changed( Slot slot)","title":"changed"},{"location":"api/logManager/LogCfg/#start","text":"public virtual override void start() Doc Home > API Index > logManager > LogCfg","title":"start"},{"location":"api/logManager/LogMgr/","text":"LogMgr \u00b6 Doc Home > API Index > logManager > LogMgr Inheritance \u00b6 sys::Obj sys::Virtual sys::Component logManager::LogMgr public final class LogMgr [niagaraIcon=\"module://icons/x16/wrench.png\"] The log manager exposes the logs present in the scode and allows for persisting changes to log settings. Fields \u00b6 log \u00b6 public static const define Log log Methods \u00b6 start \u00b6 public virtual override void start() Doc Home > API Index > logManager > LogMgr","title":"LogMgr"},{"location":"api/logManager/LogMgr/#logmgr","text":"Doc Home > API Index > logManager > LogMgr","title":"LogMgr"},{"location":"api/logManager/LogMgr/#inheritance","text":"sys::Obj sys::Virtual sys::Component logManager::LogMgr public final class LogMgr [niagaraIcon=\"module://icons/x16/wrench.png\"] The log manager exposes the logs present in the scode and allows for persisting changes to log settings.","title":"Inheritance"},{"location":"api/logManager/LogMgr/#fields","text":"","title":"Fields"},{"location":"api/logManager/LogMgr/#log","text":"public static const define Log log","title":"log"},{"location":"api/logManager/LogMgr/#methods","text":"","title":"Methods"},{"location":"api/logManager/LogMgr/#start","text":"public virtual override void start() Doc Home > API Index > logManager > LogMgr","title":"start"},{"location":"api/logic/","text":"logic \u00b6 Doc Home > API Index > logic Logic function block library ADemux2 \u00b6 ASW \u00b6 ASW4 \u00b6 And2 \u00b6 And4 \u00b6 B2P \u00b6 BSW \u00b6 DemuxI2B4 \u00b6 ISW \u00b6 Not \u00b6 Or2 \u00b6 Or4 \u00b6 Xor \u00b6 Doc Home > API Index > logic","title":"Index"},{"location":"api/logic/#logic","text":"Doc Home > API Index > logic Logic function block library","title":"logic"},{"location":"api/logic/#ademux2","text":"","title":"ADemux2"},{"location":"api/logic/#asw","text":"","title":"ASW"},{"location":"api/logic/#asw4","text":"","title":"ASW4"},{"location":"api/logic/#and2","text":"","title":"And2"},{"location":"api/logic/#and4","text":"","title":"And4"},{"location":"api/logic/#b2p","text":"","title":"B2P"},{"location":"api/logic/#bsw","text":"","title":"BSW"},{"location":"api/logic/#demuxi2b4","text":"","title":"DemuxI2B4"},{"location":"api/logic/#isw","text":"","title":"ISW"},{"location":"api/logic/#not","text":"","title":"Not"},{"location":"api/logic/#or2","text":"","title":"Or2"},{"location":"api/logic/#or4","text":"","title":"Or4"},{"location":"api/logic/#xor","text":"Doc Home > API Index > logic","title":"Xor"},{"location":"api/logic/ADemux2/","text":"ADemux2 \u00b6 Doc Home > API Index > logic > ADemux2 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component logic::ADemux2 public class ADemux2 [niagaraIcon=\"module://icons/x16/control/util/split.png\"] ADemux2 object selects one of two outputs to receive the input value, depending on the value of boolean switch input. The value of the other output remains unchanged. If s1 is false, then out1 is updated with in, and out2 value remains constant at previous value If s2 is true, then out2 is updated with in, and out1 value remains constant at previous value Fields \u00b6 in \u00b6 public property float in value to get routed to out1 or out2 out1 \u00b6 public property float out1 [readonly] output 1 out2 \u00b6 public property float out2 [readonly] output 2 s1 \u00b6 public property bool s1 s1 selects whether 'in' gets routed to 'out1' (if false) or 'out2' (if true) Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > ADemux2","title":"ADemux2"},{"location":"api/logic/ADemux2/#ademux2","text":"Doc Home > API Index > logic > ADemux2","title":"ADemux2"},{"location":"api/logic/ADemux2/#inheritance","text":"sys::Obj sys::Virtual sys::Component logic::ADemux2 public class ADemux2 [niagaraIcon=\"module://icons/x16/control/util/split.png\"] ADemux2 object selects one of two outputs to receive the input value, depending on the value of boolean switch input. The value of the other output remains unchanged. If s1 is false, then out1 is updated with in, and out2 value remains constant at previous value If s2 is true, then out2 is updated with in, and out1 value remains constant at previous value","title":"Inheritance"},{"location":"api/logic/ADemux2/#fields","text":"","title":"Fields"},{"location":"api/logic/ADemux2/#in","text":"public property float in value to get routed to out1 or out2","title":"in"},{"location":"api/logic/ADemux2/#out1","text":"public property float out1 [readonly] output 1","title":"out1"},{"location":"api/logic/ADemux2/#out2","text":"public property float out2 [readonly] output 2","title":"out2"},{"location":"api/logic/ADemux2/#s1","text":"public property bool s1 s1 selects whether 'in' gets routed to 'out1' (if false) or 'out2' (if true)","title":"s1"},{"location":"api/logic/ADemux2/#methods","text":"","title":"Methods"},{"location":"api/logic/ADemux2/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > ADemux2","title":"execute"},{"location":"api/logic/ASW/","text":"ASW \u00b6 Doc Home > API Index > logic > ASW Inheritance \u00b6 sys::Obj sys::Virtual sys::Component logic::ASW public class ASW [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] ASW Analog Switch object switches one of two inputs to the output out = s1 ? in2 : in1 Fields \u00b6 in1 \u00b6 public property float in1 input 1 in2 \u00b6 public property float in2 input 2 out \u00b6 public property float out [readonly] output s1 \u00b6 public property bool s1 s1 switches in1 or in2 to out Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > ASW","title":"ASW"},{"location":"api/logic/ASW/#asw","text":"Doc Home > API Index > logic > ASW","title":"ASW"},{"location":"api/logic/ASW/#inheritance","text":"sys::Obj sys::Virtual sys::Component logic::ASW public class ASW [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] ASW Analog Switch object switches one of two inputs to the output out = s1 ? in2 : in1","title":"Inheritance"},{"location":"api/logic/ASW/#fields","text":"","title":"Fields"},{"location":"api/logic/ASW/#in1","text":"public property float in1 input 1","title":"in1"},{"location":"api/logic/ASW/#in2","text":"public property float in2 input 2","title":"in2"},{"location":"api/logic/ASW/#out","text":"public property float out [readonly] output","title":"out"},{"location":"api/logic/ASW/#s1","text":"public property bool s1 s1 switches in1 or in2 to out","title":"s1"},{"location":"api/logic/ASW/#methods","text":"","title":"Methods"},{"location":"api/logic/ASW/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > ASW","title":"execute"},{"location":"api/logic/ASW4/","text":"ASW4 \u00b6 Doc Home > API Index > logic > ASW4 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component logic::ASW4 public class ASW4 [niagaraIcon=\"module://icons/x16/control/util/select.png\"] Selects 1 of 4 inputs to route to output based on selector value if (sel - startsAt) <= 0, out = in1 if (sel - startsAt) == 1, out = in2 if (sel - startsAt) == 2, out = in3 if (sel - startsAt) >= 3, out = in4 Fields \u00b6 in1 \u00b6 public property float in1 input 1 in2 \u00b6 public property float in2 input 2 in3 \u00b6 public property float in3 input 3 in4 \u00b6 public property float in4 input 4 out \u00b6 public property float out [readonly] output sel \u00b6 public property int sel sel, the difference of sel - startsAt is used to select the output startsAt \u00b6 public property int startsAt [config] startsAt, the difference of sel - startsAt is used to select the output Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > ASW4","title":"ASW4"},{"location":"api/logic/ASW4/#asw4","text":"Doc Home > API Index > logic > ASW4","title":"ASW4"},{"location":"api/logic/ASW4/#inheritance","text":"sys::Obj sys::Virtual sys::Component logic::ASW4 public class ASW4 [niagaraIcon=\"module://icons/x16/control/util/select.png\"] Selects 1 of 4 inputs to route to output based on selector value if (sel - startsAt) <= 0, out = in1 if (sel - startsAt) == 1, out = in2 if (sel - startsAt) == 2, out = in3 if (sel - startsAt) >= 3, out = in4","title":"Inheritance"},{"location":"api/logic/ASW4/#fields","text":"","title":"Fields"},{"location":"api/logic/ASW4/#in1","text":"public property float in1 input 1","title":"in1"},{"location":"api/logic/ASW4/#in2","text":"public property float in2 input 2","title":"in2"},{"location":"api/logic/ASW4/#in3","text":"public property float in3 input 3","title":"in3"},{"location":"api/logic/ASW4/#in4","text":"public property float in4 input 4","title":"in4"},{"location":"api/logic/ASW4/#out","text":"public property float out [readonly] output","title":"out"},{"location":"api/logic/ASW4/#sel","text":"public property int sel sel, the difference of sel - startsAt is used to select the output","title":"sel"},{"location":"api/logic/ASW4/#startsat","text":"public property int startsAt [config] startsAt, the difference of sel - startsAt is used to select the output","title":"startsAt"},{"location":"api/logic/ASW4/#methods","text":"","title":"Methods"},{"location":"api/logic/ASW4/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > ASW4","title":"execute"},{"location":"api/logic/And2/","text":"And2 \u00b6 Doc Home > API Index > logic > And2 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component logic::And2 public class And2 [niagaraIcon=\"module://icons/x16/control/logic/and.png\"] And2 And logic object Ignores null inputs. If both inputs are null output is null. out = in1 && in2 Fields \u00b6 in1 \u00b6 public property bool in1 input 1 in2 \u00b6 public property bool in2 input 2 out \u00b6 public property bool out [readonly] output Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > And2","title":"And2"},{"location":"api/logic/And2/#and2","text":"Doc Home > API Index > logic > And2","title":"And2"},{"location":"api/logic/And2/#inheritance","text":"sys::Obj sys::Virtual sys::Component logic::And2 public class And2 [niagaraIcon=\"module://icons/x16/control/logic/and.png\"] And2 And logic object Ignores null inputs. If both inputs are null output is null. out = in1 && in2","title":"Inheritance"},{"location":"api/logic/And2/#fields","text":"","title":"Fields"},{"location":"api/logic/And2/#in1","text":"public property bool in1 input 1","title":"in1"},{"location":"api/logic/And2/#in2","text":"public property bool in2 input 2","title":"in2"},{"location":"api/logic/And2/#out","text":"public property bool out [readonly] output","title":"out"},{"location":"api/logic/And2/#methods","text":"","title":"Methods"},{"location":"api/logic/And2/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > And2","title":"execute"},{"location":"api/logic/And4/","text":"And4 \u00b6 Doc Home > API Index > logic > And4 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component logic::And2 logic::And4 public class And4 And4 4 input AND logic object Null inputs are ignored. If all inputs are null output is null out = in1 && in2 && in3 && in4 Fields \u00b6 in3 \u00b6 public property bool in3 input 3 in4 \u00b6 public property bool in4 input 4 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > And4","title":"And4"},{"location":"api/logic/And4/#and4","text":"Doc Home > API Index > logic > And4","title":"And4"},{"location":"api/logic/And4/#inheritance","text":"sys::Obj sys::Virtual sys::Component logic::And2 logic::And4 public class And4 And4 4 input AND logic object Null inputs are ignored. If all inputs are null output is null out = in1 && in2 && in3 && in4","title":"Inheritance"},{"location":"api/logic/And4/#fields","text":"","title":"Fields"},{"location":"api/logic/And4/#in3","text":"public property bool in3 input 3","title":"in3"},{"location":"api/logic/And4/#in4","text":"public property bool in4 input 4","title":"in4"},{"location":"api/logic/And4/#methods","text":"","title":"Methods"},{"location":"api/logic/And4/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > And4","title":"execute"},{"location":"api/logic/B2P/","text":"B2P \u00b6 Doc Home > API Index > logic > B2P Inheritance \u00b6 sys::Obj sys::Virtual sys::Component logic::B2P public class B2P [niagaraIcon=\"module://icons/x16/control/control.png\"] B2P Boolean to pulse object out = in for one scan cycle, on rising edge of in Fields \u00b6 in \u00b6 public property bool in rising edge of in causes out to go true for one cycle out \u00b6 public property bool out [readonly] out = in for one scan cycle, on rising edge of in Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > logic > B2P","title":"B2P"},{"location":"api/logic/B2P/#b2p","text":"Doc Home > API Index > logic > B2P","title":"B2P"},{"location":"api/logic/B2P/#inheritance","text":"sys::Obj sys::Virtual sys::Component logic::B2P public class B2P [niagaraIcon=\"module://icons/x16/control/control.png\"] B2P Boolean to pulse object out = in for one scan cycle, on rising edge of in","title":"Inheritance"},{"location":"api/logic/B2P/#fields","text":"","title":"Fields"},{"location":"api/logic/B2P/#in","text":"public property bool in rising edge of in causes out to go true for one cycle","title":"in"},{"location":"api/logic/B2P/#out","text":"public property bool out [readonly] out = in for one scan cycle, on rising edge of in","title":"out"},{"location":"api/logic/B2P/#methods","text":"","title":"Methods"},{"location":"api/logic/B2P/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/logic/B2P/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > logic > B2P","title":"start"},{"location":"api/logic/BSW/","text":"BSW \u00b6 Doc Home > API Index > logic > BSW Inheritance \u00b6 sys::Obj sys::Virtual sys::Component logic::BSW public class BSW [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] BSW: Boolean Switch object if s1 is null output is null if (s1) out = in2 else out = in1 Fields \u00b6 in1 \u00b6 public property bool in1 boolean input 1 in2 \u00b6 public property bool in2 boolean input 2 out \u00b6 public property bool out [readonly] boolean output s1 \u00b6 public property bool s1 if s1 is null output is null if (s1) out = in2 else out = in1 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > BSW","title":"BSW"},{"location":"api/logic/BSW/#bsw","text":"Doc Home > API Index > logic > BSW","title":"BSW"},{"location":"api/logic/BSW/#inheritance","text":"sys::Obj sys::Virtual sys::Component logic::BSW public class BSW [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] BSW: Boolean Switch object if s1 is null output is null if (s1) out = in2 else out = in1","title":"Inheritance"},{"location":"api/logic/BSW/#fields","text":"","title":"Fields"},{"location":"api/logic/BSW/#in1","text":"public property bool in1 boolean input 1","title":"in1"},{"location":"api/logic/BSW/#in2","text":"public property bool in2 boolean input 2","title":"in2"},{"location":"api/logic/BSW/#out","text":"public property bool out [readonly] boolean output","title":"out"},{"location":"api/logic/BSW/#s1","text":"public property bool s1 if s1 is null output is null if (s1) out = in2 else out = in1","title":"s1"},{"location":"api/logic/BSW/#methods","text":"","title":"Methods"},{"location":"api/logic/BSW/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > BSW","title":"execute"},{"location":"api/logic/DemuxI2B4/","text":"DemuxI2B4 \u00b6 Doc Home > API Index > logic > DemuxI2B4 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component logic::DemuxI2B4 public class DemuxI2B4 [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] Demuxes an integer count input into 4 boolean outputs. By setting \"startsAt\" appropriately, N objects can demux to N*4 outputs (ie, you can create a 4x, 8x, 16x, etc demux) if in == startsAt + 0, out1 is true, else false if in == startsAt + 1, out2 is true, else false if in == startsAt + 2, out3 is true, else false if in == startsAt + 3, out4 is true, else false Fields \u00b6 in \u00b6 public property int in input out1 \u00b6 public property bool out1 [readonly] if in == startsAt + 0, out1 is true, else false out2 \u00b6 public property bool out2 [readonly] if in == startsAt + 1, out2 is true, else false out3 \u00b6 public property bool out3 [readonly] if in == startsAt + 2, out3 is true, else false out4 \u00b6 public property bool out4 [readonly] if in == startsAt + 3, out4 is true, else false startsAt \u00b6 public property int startsAt [config] starting value for in Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > DemuxI2B4","title":"DemuxI2B4"},{"location":"api/logic/DemuxI2B4/#demuxi2b4","text":"Doc Home > API Index > logic > DemuxI2B4","title":"DemuxI2B4"},{"location":"api/logic/DemuxI2B4/#inheritance","text":"sys::Obj sys::Virtual sys::Component logic::DemuxI2B4 public class DemuxI2B4 [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] Demuxes an integer count input into 4 boolean outputs. By setting \"startsAt\" appropriately, N objects can demux to N*4 outputs (ie, you can create a 4x, 8x, 16x, etc demux) if in == startsAt + 0, out1 is true, else false if in == startsAt + 1, out2 is true, else false if in == startsAt + 2, out3 is true, else false if in == startsAt + 3, out4 is true, else false","title":"Inheritance"},{"location":"api/logic/DemuxI2B4/#fields","text":"","title":"Fields"},{"location":"api/logic/DemuxI2B4/#in","text":"public property int in input","title":"in"},{"location":"api/logic/DemuxI2B4/#out1","text":"public property bool out1 [readonly] if in == startsAt + 0, out1 is true, else false","title":"out1"},{"location":"api/logic/DemuxI2B4/#out2","text":"public property bool out2 [readonly] if in == startsAt + 1, out2 is true, else false","title":"out2"},{"location":"api/logic/DemuxI2B4/#out3","text":"public property bool out3 [readonly] if in == startsAt + 2, out3 is true, else false","title":"out3"},{"location":"api/logic/DemuxI2B4/#out4","text":"public property bool out4 [readonly] if in == startsAt + 3, out4 is true, else false","title":"out4"},{"location":"api/logic/DemuxI2B4/#startsat","text":"public property int startsAt [config] starting value for in","title":"startsAt"},{"location":"api/logic/DemuxI2B4/#methods","text":"","title":"Methods"},{"location":"api/logic/DemuxI2B4/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > DemuxI2B4","title":"execute"},{"location":"api/logic/ISW/","text":"ISW \u00b6 Doc Home > API Index > logic > ISW Inheritance \u00b6 sys::Obj sys::Virtual sys::Component logic::ISW public class ISW [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] ISW Integer Switch object out = s1 ? in2 : in1 Fields \u00b6 in1 \u00b6 public property int in1 input 1 in2 \u00b6 public property int in2 input 2 out \u00b6 public property int out [readonly] out = s1 ? in2 : in1 s1 \u00b6 public property bool s1 switch input Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > ISW","title":"ISW"},{"location":"api/logic/ISW/#isw","text":"Doc Home > API Index > logic > ISW","title":"ISW"},{"location":"api/logic/ISW/#inheritance","text":"sys::Obj sys::Virtual sys::Component logic::ISW public class ISW [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] ISW Integer Switch object out = s1 ? in2 : in1","title":"Inheritance"},{"location":"api/logic/ISW/#fields","text":"","title":"Fields"},{"location":"api/logic/ISW/#in1","text":"public property int in1 input 1","title":"in1"},{"location":"api/logic/ISW/#in2","text":"public property int in2 input 2","title":"in2"},{"location":"api/logic/ISW/#out","text":"public property int out [readonly] out = s1 ? in2 : in1","title":"out"},{"location":"api/logic/ISW/#s1","text":"public property bool s1 switch input","title":"s1"},{"location":"api/logic/ISW/#methods","text":"","title":"Methods"},{"location":"api/logic/ISW/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > ISW","title":"execute"},{"location":"api/logic/Not/","text":"Not \u00b6 Doc Home > API Index > logic > Not Inheritance \u00b6 sys::Obj sys::Virtual sys::Component logic::Not public class Not [niagaraIcon=\"module://icons/x16/control/logic/not.png\"] Not logic object if in == null, out = null else out = !in Fields \u00b6 in \u00b6 public property bool in input out \u00b6 public property bool out [readonly] output is !input Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > Not","title":"Not"},{"location":"api/logic/Not/#not","text":"Doc Home > API Index > logic > Not","title":"Not"},{"location":"api/logic/Not/#inheritance","text":"sys::Obj sys::Virtual sys::Component logic::Not public class Not [niagaraIcon=\"module://icons/x16/control/logic/not.png\"] Not logic object if in == null, out = null else out = !in","title":"Inheritance"},{"location":"api/logic/Not/#fields","text":"","title":"Fields"},{"location":"api/logic/Not/#in","text":"public property bool in input","title":"in"},{"location":"api/logic/Not/#out","text":"public property bool out [readonly] output is !input","title":"out"},{"location":"api/logic/Not/#methods","text":"","title":"Methods"},{"location":"api/logic/Not/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > Not","title":"execute"},{"location":"api/logic/Or2/","text":"Or2 \u00b6 Doc Home > API Index > logic > Or2 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component logic::Or2 public class Or2 [niagaraIcon=\"module://icons/x16/control/logic/or.png\"] Or2 Two input Or logic object null inputs ignored. If all inputs null, output is null out = in1 || in2 Fields \u00b6 in1 \u00b6 public property bool in1 input 1 in2 \u00b6 public property bool in2 input 2 out \u00b6 public property bool out [readonly] output = in1 || in2 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > Or2","title":"Or2"},{"location":"api/logic/Or2/#or2","text":"Doc Home > API Index > logic > Or2","title":"Or2"},{"location":"api/logic/Or2/#inheritance","text":"sys::Obj sys::Virtual sys::Component logic::Or2 public class Or2 [niagaraIcon=\"module://icons/x16/control/logic/or.png\"] Or2 Two input Or logic object null inputs ignored. If all inputs null, output is null out = in1 || in2","title":"Inheritance"},{"location":"api/logic/Or2/#fields","text":"","title":"Fields"},{"location":"api/logic/Or2/#in1","text":"public property bool in1 input 1","title":"in1"},{"location":"api/logic/Or2/#in2","text":"public property bool in2 input 2","title":"in2"},{"location":"api/logic/Or2/#out","text":"public property bool out [readonly] output = in1 || in2","title":"out"},{"location":"api/logic/Or2/#methods","text":"","title":"Methods"},{"location":"api/logic/Or2/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > Or2","title":"execute"},{"location":"api/logic/Or4/","text":"Or4 \u00b6 Doc Home > API Index > logic > Or4 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component logic::Or2 logic::Or4 public class Or4 Or4 4 input OR logic object null inputs ignored. If all inputs null, output is null out = in1 || in2 || in3 || in4 in1 and in2 are inherited from Or2 class Fields \u00b6 in3 \u00b6 public property bool in3 input 3 in4 \u00b6 public property bool in4 input 4 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > Or4","title":"Or4"},{"location":"api/logic/Or4/#or4","text":"Doc Home > API Index > logic > Or4","title":"Or4"},{"location":"api/logic/Or4/#inheritance","text":"sys::Obj sys::Virtual sys::Component logic::Or2 logic::Or4 public class Or4 Or4 4 input OR logic object null inputs ignored. If all inputs null, output is null out = in1 || in2 || in3 || in4 in1 and in2 are inherited from Or2 class","title":"Inheritance"},{"location":"api/logic/Or4/#fields","text":"","title":"Fields"},{"location":"api/logic/Or4/#in3","text":"public property bool in3 input 3","title":"in3"},{"location":"api/logic/Or4/#in4","text":"public property bool in4 input 4","title":"in4"},{"location":"api/logic/Or4/#methods","text":"","title":"Methods"},{"location":"api/logic/Or4/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > Or4","title":"execute"},{"location":"api/logic/Xor/","text":"Xor \u00b6 Doc Home > API Index > logic > Xor Inheritance \u00b6 sys::Obj sys::Virtual sys::Component logic::Xor public class Xor [niagaraIcon=\"module://icons/x16/control/logic/xor.png\"] Xor Exclusive Or logic object if either input null output is null out = in1 xor in2 Fields \u00b6 in1 \u00b6 public property bool in1 input 1 in2 \u00b6 public property bool in2 input 2 out \u00b6 public property bool out [readonly] output value Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > Xor","title":"Xor"},{"location":"api/logic/Xor/#xor","text":"Doc Home > API Index > logic > Xor","title":"Xor"},{"location":"api/logic/Xor/#inheritance","text":"sys::Obj sys::Virtual sys::Component logic::Xor public class Xor [niagaraIcon=\"module://icons/x16/control/logic/xor.png\"] Xor Exclusive Or logic object if either input null output is null out = in1 xor in2","title":"Inheritance"},{"location":"api/logic/Xor/#fields","text":"","title":"Fields"},{"location":"api/logic/Xor/#in1","text":"public property bool in1 input 1","title":"in1"},{"location":"api/logic/Xor/#in2","text":"public property bool in2 input 2","title":"in2"},{"location":"api/logic/Xor/#out","text":"public property bool out [readonly] output value","title":"out"},{"location":"api/logic/Xor/#methods","text":"","title":"Methods"},{"location":"api/logic/Xor/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > logic > Xor","title":"execute"},{"location":"api/math/","text":"math \u00b6 Doc Home > API Index > math Math function block library Add2 \u00b6 Add4 \u00b6 Avg10 \u00b6 AvgN \u00b6 Div2 \u00b6 FloatOffset \u00b6 Max \u00b6 Min \u00b6 MinMax \u00b6 Mul2 \u00b6 Mul4 \u00b6 Neg \u00b6 Round \u00b6 Sub2 \u00b6 Sub4 \u00b6 TimeAvg \u00b6 Doc Home > API Index > math","title":"Index"},{"location":"api/math/#math","text":"Doc Home > API Index > math Math function block library","title":"math"},{"location":"api/math/#add2","text":"","title":"Add2"},{"location":"api/math/#add4","text":"","title":"Add4"},{"location":"api/math/#avg10","text":"","title":"Avg10"},{"location":"api/math/#avgn","text":"","title":"AvgN"},{"location":"api/math/#div2","text":"","title":"Div2"},{"location":"api/math/#floatoffset","text":"","title":"FloatOffset"},{"location":"api/math/#max","text":"","title":"Max"},{"location":"api/math/#min","text":"","title":"Min"},{"location":"api/math/#minmax","text":"","title":"MinMax"},{"location":"api/math/#mul2","text":"","title":"Mul2"},{"location":"api/math/#mul4","text":"","title":"Mul4"},{"location":"api/math/#neg","text":"","title":"Neg"},{"location":"api/math/#round","text":"","title":"Round"},{"location":"api/math/#sub2","text":"","title":"Sub2"},{"location":"api/math/#sub4","text":"","title":"Sub4"},{"location":"api/math/#timeavg","text":"Doc Home > API Index > math","title":"TimeAvg"},{"location":"api/math/Add2/","text":"Add2 \u00b6 Doc Home > API Index > math > Add2 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component math::Add2 public class Add2 [niagaraIcon=\"module://icons/x16/control/math/add.png\"] Add2 adds two float inputs and writes the results to a float output out = in1 + in2 Fields \u00b6 in1 \u00b6 public property float in1 input 1 in2 \u00b6 public property float in2 input 2 out \u00b6 public property float out [readonly] out is the sum of all inputs Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > Add2","title":"Add2"},{"location":"api/math/Add2/#add2","text":"Doc Home > API Index > math > Add2","title":"Add2"},{"location":"api/math/Add2/#inheritance","text":"sys::Obj sys::Virtual sys::Component math::Add2 public class Add2 [niagaraIcon=\"module://icons/x16/control/math/add.png\"] Add2 adds two float inputs and writes the results to a float output out = in1 + in2","title":"Inheritance"},{"location":"api/math/Add2/#fields","text":"","title":"Fields"},{"location":"api/math/Add2/#in1","text":"public property float in1 input 1","title":"in1"},{"location":"api/math/Add2/#in2","text":"public property float in2 input 2","title":"in2"},{"location":"api/math/Add2/#out","text":"public property float out [readonly] out is the sum of all inputs","title":"out"},{"location":"api/math/Add2/#methods","text":"","title":"Methods"},{"location":"api/math/Add2/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > Add2","title":"execute"},{"location":"api/math/Add4/","text":"Add4 \u00b6 Doc Home > API Index > math > Add4 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component math::Add2 math::Add4 public class Add4 Add4 adds four float inputs and writes the results to a float output out = in1 + in2 + in3 + in4 Fields \u00b6 in3 \u00b6 public property float in3 input 3 in4 \u00b6 public property float in4 input 4 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > Add4","title":"Add4"},{"location":"api/math/Add4/#add4","text":"Doc Home > API Index > math > Add4","title":"Add4"},{"location":"api/math/Add4/#inheritance","text":"sys::Obj sys::Virtual sys::Component math::Add2 math::Add4 public class Add4 Add4 adds four float inputs and writes the results to a float output out = in1 + in2 + in3 + in4","title":"Inheritance"},{"location":"api/math/Add4/#fields","text":"","title":"Fields"},{"location":"api/math/Add4/#in3","text":"public property float in3 input 3","title":"in3"},{"location":"api/math/Add4/#in4","text":"public property float in4 input 4","title":"in4"},{"location":"api/math/Add4/#methods","text":"","title":"Methods"},{"location":"api/math/Add4/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > Add4","title":"execute"},{"location":"api/math/Avg10/","text":"Avg10 \u00b6 Doc Home > API Index > math > Avg10 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component math::Avg10 public class Avg10 [niagaraIcon=\"module://icons/x16/control/math/average.png\"] Avg Running Average math object out = (sum last 10 value)/10 Samples current value again if value has not changed in maxTime msec. For first ten samples, averages only the samples recd. Fields \u00b6 in \u00b6 public property float in input value to be averaged maxTime \u00b6 public property int maxTime [unit=\"millisecond\", config] if maxTime == 0, then average every scan if maxTime > 0, then average a new sample every maxTime milliseconds or every scan, whichever is greater. out \u00b6 public property float out [readonly] averaged output Methods \u00b6 changed \u00b6 public override void changed( Slot slot) Behavior to execute when a property is changed externally execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app, before the first call to propagateLinksTo() or execute(). Doc Home > API Index > math > Avg10","title":"Avg10"},{"location":"api/math/Avg10/#avg10","text":"Doc Home > API Index > math > Avg10","title":"Avg10"},{"location":"api/math/Avg10/#inheritance","text":"sys::Obj sys::Virtual sys::Component math::Avg10 public class Avg10 [niagaraIcon=\"module://icons/x16/control/math/average.png\"] Avg Running Average math object out = (sum last 10 value)/10 Samples current value again if value has not changed in maxTime msec. For first ten samples, averages only the samples recd.","title":"Inheritance"},{"location":"api/math/Avg10/#fields","text":"","title":"Fields"},{"location":"api/math/Avg10/#in","text":"public property float in input value to be averaged","title":"in"},{"location":"api/math/Avg10/#maxtime","text":"public property int maxTime [unit=\"millisecond\", config] if maxTime == 0, then average every scan if maxTime > 0, then average a new sample every maxTime milliseconds or every scan, whichever is greater.","title":"maxTime"},{"location":"api/math/Avg10/#out","text":"public property float out [readonly] averaged output","title":"out"},{"location":"api/math/Avg10/#methods","text":"","title":"Methods"},{"location":"api/math/Avg10/#changed","text":"public override void changed( Slot slot) Behavior to execute when a property is changed externally","title":"changed"},{"location":"api/math/Avg10/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/math/Avg10/#start","text":"public virtual override void start() Callback when component is first started in an app, before the first call to propagateLinksTo() or execute(). Doc Home > API Index > math > Avg10","title":"start"},{"location":"api/math/AvgN/","text":"AvgN \u00b6 Doc Home > API Index > math > AvgN Inheritance \u00b6 sys::Obj sys::Virtual sys::Component math::AvgN public class AvgN [niagaraIcon=\"module://icons/x16/control/math/average.png\"] Modified Moving Average math object out = [(n-1)*out + in]/n = (total + in - avg)/n where total = approx. running total of last n samples avg = last computed average = total/n Note: 1) the \"avg\" value is \"seeded\" with the \"in\" value at startup or whenever \"n\" changes 2) the \"total\" value is \"seeded\" with (in * n) at startup or whenever \"n\" changes 3) boolean input \"reset\" resets the object to return to first execute cycle state, and avg and total are re \"seeded\". This may be useful to invoke in an application where large step changes of \"in\" are expected and \"n\" is a high value, to prevent output lag of the input. For large step changes in values, the \"out\" value will asymptotically approach the \"in\" value. Fields \u00b6 in \u00b6 public property float in value of in is added to average computation every execute cycle numSamplesToAvg \u00b6 public property int numSamplesToAvg [min=1, config] number of samples to average. One new sample is read every execute cycle. out \u00b6 public property float out [readonly] the average value updated every execute cycle reset \u00b6 public property bool reset [readonly] reset is invoked to re-initialize the averaging Methods \u00b6 changed \u00b6 public virtual override void changed( Slot slot) Behavior to execute when a property is changed externally computeAverage \u00b6 public void computeAverage() average in a new sample execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app, before the first call to propagateLinksTo() or execute(). Doc Home > API Index > math > AvgN","title":"AvgN"},{"location":"api/math/AvgN/#avgn","text":"Doc Home > API Index > math > AvgN","title":"AvgN"},{"location":"api/math/AvgN/#inheritance","text":"sys::Obj sys::Virtual sys::Component math::AvgN public class AvgN [niagaraIcon=\"module://icons/x16/control/math/average.png\"] Modified Moving Average math object out = [(n-1)*out + in]/n = (total + in - avg)/n where total = approx. running total of last n samples avg = last computed average = total/n Note: 1) the \"avg\" value is \"seeded\" with the \"in\" value at startup or whenever \"n\" changes 2) the \"total\" value is \"seeded\" with (in * n) at startup or whenever \"n\" changes 3) boolean input \"reset\" resets the object to return to first execute cycle state, and avg and total are re \"seeded\". This may be useful to invoke in an application where large step changes of \"in\" are expected and \"n\" is a high value, to prevent output lag of the input. For large step changes in values, the \"out\" value will asymptotically approach the \"in\" value.","title":"Inheritance"},{"location":"api/math/AvgN/#fields","text":"","title":"Fields"},{"location":"api/math/AvgN/#in","text":"public property float in value of in is added to average computation every execute cycle","title":"in"},{"location":"api/math/AvgN/#numsamplestoavg","text":"public property int numSamplesToAvg [min=1, config] number of samples to average. One new sample is read every execute cycle.","title":"numSamplesToAvg"},{"location":"api/math/AvgN/#out","text":"public property float out [readonly] the average value updated every execute cycle","title":"out"},{"location":"api/math/AvgN/#reset","text":"public property bool reset [readonly] reset is invoked to re-initialize the averaging","title":"reset"},{"location":"api/math/AvgN/#methods","text":"","title":"Methods"},{"location":"api/math/AvgN/#changed","text":"public virtual override void changed( Slot slot) Behavior to execute when a property is changed externally","title":"changed"},{"location":"api/math/AvgN/#computeaverage","text":"public void computeAverage() average in a new sample","title":"computeAverage"},{"location":"api/math/AvgN/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/math/AvgN/#start","text":"public virtual override void start() Callback when component is first started in an app, before the first call to propagateLinksTo() or execute(). Doc Home > API Index > math > AvgN","title":"start"},{"location":"api/math/Div2/","text":"Div2 \u00b6 Doc Home > API Index > math > Div2 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component math::Div2 public class Div2 [niagaraIcon=\"module://icons/x16/control/math/divide.png\"] Div2 Two Input Division object out = in1 / in2 Fields \u00b6 div0 \u00b6 public property bool div0 [readonly] if in2 is 0, div0 is true and out gets set to 0.0 in1 \u00b6 public property float in1 numerator value in2 \u00b6 public property float in2 denominator value out \u00b6 public property float out [readonly] output value Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > Div2","title":"Div2"},{"location":"api/math/Div2/#div2","text":"Doc Home > API Index > math > Div2","title":"Div2"},{"location":"api/math/Div2/#inheritance","text":"sys::Obj sys::Virtual sys::Component math::Div2 public class Div2 [niagaraIcon=\"module://icons/x16/control/math/divide.png\"] Div2 Two Input Division object out = in1 / in2","title":"Inheritance"},{"location":"api/math/Div2/#fields","text":"","title":"Fields"},{"location":"api/math/Div2/#div0","text":"public property bool div0 [readonly] if in2 is 0, div0 is true and out gets set to 0.0","title":"div0"},{"location":"api/math/Div2/#in1","text":"public property float in1 numerator value","title":"in1"},{"location":"api/math/Div2/#in2","text":"public property float in2 denominator value","title":"in2"},{"location":"api/math/Div2/#out","text":"public property float out [readonly] output value","title":"out"},{"location":"api/math/Div2/#methods","text":"","title":"Methods"},{"location":"api/math/Div2/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > Div2","title":"execute"},{"location":"api/math/FloatOffset/","text":"FloatOffset \u00b6 Doc Home > API Index > math > FloatOffset Inheritance \u00b6 sys::Obj sys::Virtual sys::Component math::FloatOffset public class FloatOffset [niagaraIcon=\"module://icons/x16/control/math/add.png\"] FloatOffset: adds an offset value to the input value out = in + offset Fields \u00b6 in \u00b6 public property float in input value offset \u00b6 public property float offset [config] constant value to add to the input to get output out \u00b6 public property float out [readonly] out = in + offset Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > FloatOffset","title":"FloatOffset"},{"location":"api/math/FloatOffset/#floatoffset","text":"Doc Home > API Index > math > FloatOffset","title":"FloatOffset"},{"location":"api/math/FloatOffset/#inheritance","text":"sys::Obj sys::Virtual sys::Component math::FloatOffset public class FloatOffset [niagaraIcon=\"module://icons/x16/control/math/add.png\"] FloatOffset: adds an offset value to the input value out = in + offset","title":"Inheritance"},{"location":"api/math/FloatOffset/#fields","text":"","title":"Fields"},{"location":"api/math/FloatOffset/#in","text":"public property float in input value","title":"in"},{"location":"api/math/FloatOffset/#offset","text":"public property float offset [config] constant value to add to the input to get output","title":"offset"},{"location":"api/math/FloatOffset/#out","text":"public property float out [readonly] out = in + offset","title":"out"},{"location":"api/math/FloatOffset/#methods","text":"","title":"Methods"},{"location":"api/math/FloatOffset/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > FloatOffset","title":"execute"},{"location":"api/math/Max/","text":"Max \u00b6 Doc Home > API Index > math > Max Inheritance \u00b6 sys::Obj sys::Virtual sys::Component math::Max public class Max [niagaraIcon=\"module://icons/x16/control/control.png\"] Max selects the highest of 2 inputs to send to the output Fields \u00b6 in1 \u00b6 public property float in1 first value for comparison in2 \u00b6 public property float in2 second value for comparison out \u00b6 public property float out [readonly] the minimum of in1 and in2 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute the comparison Doc Home > API Index > math > Max","title":"Max"},{"location":"api/math/Max/#max","text":"Doc Home > API Index > math > Max","title":"Max"},{"location":"api/math/Max/#inheritance","text":"sys::Obj sys::Virtual sys::Component math::Max public class Max [niagaraIcon=\"module://icons/x16/control/control.png\"] Max selects the highest of 2 inputs to send to the output","title":"Inheritance"},{"location":"api/math/Max/#fields","text":"","title":"Fields"},{"location":"api/math/Max/#in1","text":"public property float in1 first value for comparison","title":"in1"},{"location":"api/math/Max/#in2","text":"public property float in2 second value for comparison","title":"in2"},{"location":"api/math/Max/#out","text":"public property float out [readonly] the minimum of in1 and in2","title":"out"},{"location":"api/math/Max/#methods","text":"","title":"Methods"},{"location":"api/math/Max/#execute","text":"public virtual override void execute() Execute the comparison Doc Home > API Index > math > Max","title":"execute"},{"location":"api/math/Min/","text":"Min \u00b6 Doc Home > API Index > math > Min Inheritance \u00b6 sys::Obj sys::Virtual sys::Component math::Min public class Min [niagaraIcon=\"module://icons/x16/control/control.png\"] Min selects the lowest of 2 inputs to send to the output Fields \u00b6 in1 \u00b6 public property float in1 first value for comparison in2 \u00b6 public property float in2 second value for comparison out \u00b6 public property float out [readonly] the minimum of in1 and in2 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute the comparison Doc Home > API Index > math > Min","title":"Min"},{"location":"api/math/Min/#min","text":"Doc Home > API Index > math > Min","title":"Min"},{"location":"api/math/Min/#inheritance","text":"sys::Obj sys::Virtual sys::Component math::Min public class Min [niagaraIcon=\"module://icons/x16/control/control.png\"] Min selects the lowest of 2 inputs to send to the output","title":"Inheritance"},{"location":"api/math/Min/#fields","text":"","title":"Fields"},{"location":"api/math/Min/#in1","text":"public property float in1 first value for comparison","title":"in1"},{"location":"api/math/Min/#in2","text":"public property float in2 second value for comparison","title":"in2"},{"location":"api/math/Min/#out","text":"public property float out [readonly] the minimum of in1 and in2","title":"out"},{"location":"api/math/Min/#methods","text":"","title":"Methods"},{"location":"api/math/Min/#execute","text":"public virtual override void execute() Execute the comparison Doc Home > API Index > math > Min","title":"execute"},{"location":"api/math/MinMax/","text":"MinMax \u00b6 Doc Home > API Index > math > MinMax Inheritance \u00b6 sys::Obj sys::Virtual sys::Component math::MinMax public class MinMax [niagaraIcon=\"module://icons/x16/control/control.png\"] Min/Max object computes min and max of an input value every execute cycle Resets min/max to input value if r == true Fields \u00b6 in \u00b6 public property float in the value on which to track the min and max value maxOut \u00b6 public property float maxOut [readonly] the computed max of all in's minOut \u00b6 public property float minOut [readonly] the computed min of all in's r \u00b6 public property bool r reset input. If r = true, then minOut and maxOut are forced to \"in\" value Methods \u00b6 execute \u00b6 public virtual override void execute() Execute computes the min/max reset \u00b6 public action void reset() reset action sets the initial values start \u00b6 public virtual override void start() Start sets the initial values Doc Home > API Index > math > MinMax","title":"MinMax"},{"location":"api/math/MinMax/#minmax","text":"Doc Home > API Index > math > MinMax","title":"MinMax"},{"location":"api/math/MinMax/#inheritance","text":"sys::Obj sys::Virtual sys::Component math::MinMax public class MinMax [niagaraIcon=\"module://icons/x16/control/control.png\"] Min/Max object computes min and max of an input value every execute cycle Resets min/max to input value if r == true","title":"Inheritance"},{"location":"api/math/MinMax/#fields","text":"","title":"Fields"},{"location":"api/math/MinMax/#in","text":"public property float in the value on which to track the min and max value","title":"in"},{"location":"api/math/MinMax/#maxout","text":"public property float maxOut [readonly] the computed max of all in's","title":"maxOut"},{"location":"api/math/MinMax/#minout","text":"public property float minOut [readonly] the computed min of all in's","title":"minOut"},{"location":"api/math/MinMax/#r","text":"public property bool r reset input. If r = true, then minOut and maxOut are forced to \"in\" value","title":"r"},{"location":"api/math/MinMax/#methods","text":"","title":"Methods"},{"location":"api/math/MinMax/#execute","text":"public virtual override void execute() Execute computes the min/max","title":"execute"},{"location":"api/math/MinMax/#reset","text":"public action void reset() reset action sets the initial values","title":"reset"},{"location":"api/math/MinMax/#start","text":"public virtual override void start() Start sets the initial values Doc Home > API Index > math > MinMax","title":"start"},{"location":"api/math/Mul2/","text":"Mul2 \u00b6 Doc Home > API Index > math > Mul2 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component math::Mul2 public class Mul2 [niagaraIcon=\"module://icons/x16/control/math/multiply.png\"] Mul2 Two Input Multiplication object out = in1 * in2 Fields \u00b6 in1 \u00b6 public property float in1 input 1 in2 \u00b6 public property float in2 input 2 out \u00b6 public property float out [readonly] out = in1 * in2 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > Mul2","title":"Mul2"},{"location":"api/math/Mul2/#mul2","text":"Doc Home > API Index > math > Mul2","title":"Mul2"},{"location":"api/math/Mul2/#inheritance","text":"sys::Obj sys::Virtual sys::Component math::Mul2 public class Mul2 [niagaraIcon=\"module://icons/x16/control/math/multiply.png\"] Mul2 Two Input Multiplication object out = in1 * in2","title":"Inheritance"},{"location":"api/math/Mul2/#fields","text":"","title":"Fields"},{"location":"api/math/Mul2/#in1","text":"public property float in1 input 1","title":"in1"},{"location":"api/math/Mul2/#in2","text":"public property float in2 input 2","title":"in2"},{"location":"api/math/Mul2/#out","text":"public property float out [readonly] out = in1 * in2","title":"out"},{"location":"api/math/Mul2/#methods","text":"","title":"Methods"},{"location":"api/math/Mul2/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > Mul2","title":"execute"},{"location":"api/math/Mul4/","text":"Mul4 \u00b6 Doc Home > API Index > math > Mul4 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component math::Mul2 math::Mul4 public class Mul4 Mul4 Four Input Multiplication object out = in1 * in2 * in3 * in4 Fields \u00b6 in3 \u00b6 public property float in3 input 3 in4 \u00b6 public property float in4 input 4 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > Mul4","title":"Mul4"},{"location":"api/math/Mul4/#mul4","text":"Doc Home > API Index > math > Mul4","title":"Mul4"},{"location":"api/math/Mul4/#inheritance","text":"sys::Obj sys::Virtual sys::Component math::Mul2 math::Mul4 public class Mul4 Mul4 Four Input Multiplication object out = in1 * in2 * in3 * in4","title":"Inheritance"},{"location":"api/math/Mul4/#fields","text":"","title":"Fields"},{"location":"api/math/Mul4/#in3","text":"public property float in3 input 3","title":"in3"},{"location":"api/math/Mul4/#in4","text":"public property float in4 input 4","title":"in4"},{"location":"api/math/Mul4/#methods","text":"","title":"Methods"},{"location":"api/math/Mul4/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > Mul4","title":"execute"},{"location":"api/math/Neg/","text":"Neg \u00b6 Doc Home > API Index > math > Neg Inheritance \u00b6 sys::Obj sys::Virtual sys::Component math::Neg public class Neg [niagaraIcon=\"module://icons/x16/control/math/subtract.png\"] Neg Negate math object out = -in Fields \u00b6 in \u00b6 public property float in input out \u00b6 public property float out [readonly] output is negative of the input Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > Neg","title":"Neg"},{"location":"api/math/Neg/#neg","text":"Doc Home > API Index > math > Neg","title":"Neg"},{"location":"api/math/Neg/#inheritance","text":"sys::Obj sys::Virtual sys::Component math::Neg public class Neg [niagaraIcon=\"module://icons/x16/control/math/subtract.png\"] Neg Negate math object out = -in","title":"Inheritance"},{"location":"api/math/Neg/#fields","text":"","title":"Fields"},{"location":"api/math/Neg/#in","text":"public property float in input","title":"in"},{"location":"api/math/Neg/#out","text":"public property float out [readonly] output is negative of the input","title":"out"},{"location":"api/math/Neg/#methods","text":"","title":"Methods"},{"location":"api/math/Neg/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > Neg","title":"execute"},{"location":"api/math/Round/","text":"Round \u00b6 Doc Home > API Index > math > Round Inheritance \u00b6 sys::Obj sys::Virtual sys::Component math::Round public class Round [niagaraIcon=\"module://icons/x16/control/numericPoint.png\"] Rounds a float to nearest n places. Uses the tie-breaker rule that positive number are rounded up if a tie-break situation exists, and negative numbers are rounded down (\"more negative\") if a tie-break situation exists. Example: 123.456 with n = 0 : rounds to 123.000 with n = 1 : rounds to 123.500 with n = -1: rounds to 120.000 Example: -123.456 with n = 0 : rounds to -123.000 with n = 1 : rounds to -123.500 with n = -1: rounds to -120.000 Positive numbers: 1) multiply by 10^n 2) add 0.5 and truncate (convert to integer) 3) divide by 10^n Negative numbers: 1) multiply by 10^n 2) subtract 0.5 and truncate (convert to integer) 3) divide by 10^n where n = number of decimal places to round out = round(in) Fields \u00b6 decimalPlaces \u00b6 public property int decimalPlaces [min=-1, max=3, config] number of decimal places to round in \u00b6 public property float in [precision=3] input value out \u00b6 public property float out [readonly, precision=1] out = in rounded to a precision Methods \u00b6 changed \u00b6 public virtual override void changed( Slot slot) Component override of changed execute \u00b6 public virtual override void execute() Execute start \u00b6 public virtual override void start() Component override of start sets up a multiplier factor Doc Home > API Index > math > Round","title":"Round"},{"location":"api/math/Round/#round","text":"Doc Home > API Index > math > Round","title":"Round"},{"location":"api/math/Round/#inheritance","text":"sys::Obj sys::Virtual sys::Component math::Round public class Round [niagaraIcon=\"module://icons/x16/control/numericPoint.png\"] Rounds a float to nearest n places. Uses the tie-breaker rule that positive number are rounded up if a tie-break situation exists, and negative numbers are rounded down (\"more negative\") if a tie-break situation exists. Example: 123.456 with n = 0 : rounds to 123.000 with n = 1 : rounds to 123.500 with n = -1: rounds to 120.000 Example: -123.456 with n = 0 : rounds to -123.000 with n = 1 : rounds to -123.500 with n = -1: rounds to -120.000 Positive numbers: 1) multiply by 10^n 2) add 0.5 and truncate (convert to integer) 3) divide by 10^n Negative numbers: 1) multiply by 10^n 2) subtract 0.5 and truncate (convert to integer) 3) divide by 10^n where n = number of decimal places to round out = round(in)","title":"Inheritance"},{"location":"api/math/Round/#fields","text":"","title":"Fields"},{"location":"api/math/Round/#decimalplaces","text":"public property int decimalPlaces [min=-1, max=3, config] number of decimal places to round","title":"decimalPlaces"},{"location":"api/math/Round/#in","text":"public property float in [precision=3] input value","title":"in"},{"location":"api/math/Round/#out","text":"public property float out [readonly, precision=1] out = in rounded to a precision","title":"out"},{"location":"api/math/Round/#methods","text":"","title":"Methods"},{"location":"api/math/Round/#changed","text":"public virtual override void changed( Slot slot) Component override of changed","title":"changed"},{"location":"api/math/Round/#execute","text":"public virtual override void execute() Execute","title":"execute"},{"location":"api/math/Round/#start","text":"public virtual override void start() Component override of start sets up a multiplier factor Doc Home > API Index > math > Round","title":"start"},{"location":"api/math/Sub2/","text":"Sub2 \u00b6 Doc Home > API Index > math > Sub2 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component math::Sub2 public class Sub2 [niagaraIcon=\"module://icons/x16/control/math/subtract.png\"] Sub2 Two Input Subtract object out = in1 - in2 Fields \u00b6 in1 \u00b6 public property float in1 in1 in2 \u00b6 public property float in2 in2 out \u00b6 public property float out [readonly] result o subracting in1 - in2 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > Sub2","title":"Sub2"},{"location":"api/math/Sub2/#sub2","text":"Doc Home > API Index > math > Sub2","title":"Sub2"},{"location":"api/math/Sub2/#inheritance","text":"sys::Obj sys::Virtual sys::Component math::Sub2 public class Sub2 [niagaraIcon=\"module://icons/x16/control/math/subtract.png\"] Sub2 Two Input Subtract object out = in1 - in2","title":"Inheritance"},{"location":"api/math/Sub2/#fields","text":"","title":"Fields"},{"location":"api/math/Sub2/#in1","text":"public property float in1 in1","title":"in1"},{"location":"api/math/Sub2/#in2","text":"public property float in2 in2","title":"in2"},{"location":"api/math/Sub2/#out","text":"public property float out [readonly] result o subracting in1 - in2","title":"out"},{"location":"api/math/Sub2/#methods","text":"","title":"Methods"},{"location":"api/math/Sub2/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > Sub2","title":"execute"},{"location":"api/math/Sub4/","text":"Sub4 \u00b6 Doc Home > API Index > math > Sub4 Inheritance \u00b6 sys::Obj sys::Virtual sys::Component math::Sub2 math::Sub4 public class Sub4 Sub4 Four Input Subtract object out = in1 - in2 - in3 - in4 out, in1, and in2 are inherited from Sub2 class Fields \u00b6 in3 \u00b6 public property float in3 in3 in4 \u00b6 public property float in4 in4 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > Sub4","title":"Sub4"},{"location":"api/math/Sub4/#sub4","text":"Doc Home > API Index > math > Sub4","title":"Sub4"},{"location":"api/math/Sub4/#inheritance","text":"sys::Obj sys::Virtual sys::Component math::Sub2 math::Sub4 public class Sub4 Sub4 Four Input Subtract object out = in1 - in2 - in3 - in4 out, in1, and in2 are inherited from Sub2 class","title":"Inheritance"},{"location":"api/math/Sub4/#fields","text":"","title":"Fields"},{"location":"api/math/Sub4/#in3","text":"public property float in3 in3","title":"in3"},{"location":"api/math/Sub4/#in4","text":"public property float in4 in4","title":"in4"},{"location":"api/math/Sub4/#methods","text":"","title":"Methods"},{"location":"api/math/Sub4/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > math > Sub4","title":"execute"},{"location":"api/math/TimeAvg/","text":"TimeAvg \u00b6 Doc Home > API Index > math > TimeAvg Inheritance \u00b6 sys::Obj sys::Virtual sys::Component math::TimeAvg public class TimeAvg [niagaraIcon=\"module://icons/x16/control/math/average.png\"] TimeAvg object averages \"in\" over the configured time. Note that this is NOT a running or moving average - this object caches the average over the previous time as the out value, and updates out every \"time\" ms. Until the first full cycle has elapsed, out is set to average of all samples so far. The average may be reset/restarted at any time using the \"reset\" action. Fields \u00b6 in \u00b6 public property float in The value to average out \u00b6 public property float out [readonly] Value averaged over last \"time\" period time \u00b6 public property int time [summary, unit=\"millisecond\", config] The time period over which to average the in value to get the out value Methods \u00b6 execute \u00b6 public virtual override void execute() calculate the average. If not enough samples collected, then average the ones we have. reset \u00b6 public action void reset() Reset the average computation start \u00b6 public virtual override void start() Override start to initialize averaging variables Doc Home > API Index > math > TimeAvg","title":"TimeAvg"},{"location":"api/math/TimeAvg/#timeavg","text":"Doc Home > API Index > math > TimeAvg","title":"TimeAvg"},{"location":"api/math/TimeAvg/#inheritance","text":"sys::Obj sys::Virtual sys::Component math::TimeAvg public class TimeAvg [niagaraIcon=\"module://icons/x16/control/math/average.png\"] TimeAvg object averages \"in\" over the configured time. Note that this is NOT a running or moving average - this object caches the average over the previous time as the out value, and updates out every \"time\" ms. Until the first full cycle has elapsed, out is set to average of all samples so far. The average may be reset/restarted at any time using the \"reset\" action.","title":"Inheritance"},{"location":"api/math/TimeAvg/#fields","text":"","title":"Fields"},{"location":"api/math/TimeAvg/#in","text":"public property float in The value to average","title":"in"},{"location":"api/math/TimeAvg/#out","text":"public property float out [readonly] Value averaged over last \"time\" period","title":"out"},{"location":"api/math/TimeAvg/#time","text":"public property int time [summary, unit=\"millisecond\", config] The time period over which to average the in value to get the out value","title":"time"},{"location":"api/math/TimeAvg/#methods","text":"","title":"Methods"},{"location":"api/math/TimeAvg/#execute","text":"public virtual override void execute() calculate the average. If not enough samples collected, then average the ones we have.","title":"execute"},{"location":"api/math/TimeAvg/#reset","text":"public action void reset() Reset the average computation","title":"reset"},{"location":"api/math/TimeAvg/#start","text":"public virtual override void start() Override start to initialize averaging variables Doc Home > API Index > math > TimeAvg","title":"start"},{"location":"api/platUnix/","text":"platUnix \u00b6 Doc Home > API Index > platUnix Platform support for Unix based devices UnixPlatformService \u00b6 UnixProvDbFileStore \u00b6 Doc Home > API Index > platUnix","title":"Index"},{"location":"api/platUnix/#platunix","text":"Doc Home > API Index > platUnix Platform support for Unix based devices","title":"platUnix"},{"location":"api/platUnix/#unixplatformservice","text":"","title":"UnixPlatformService"},{"location":"api/platUnix/#unixprovdbfilestore","text":"Doc Home > API Index > platUnix","title":"UnixProvDbFileStore"},{"location":"api/platUnix/UnixPlatformService/","text":"UnixPlatformService \u00b6 Doc Home > API Index > platUnix > UnixPlatformService Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::Service sys::PlatformService platUnix::UnixPlatformService public class UnixPlatformService Generic Unix Platform Service Doc Home > API Index > platUnix > UnixPlatformService","title":"UnixPlatformService"},{"location":"api/platUnix/UnixPlatformService/#unixplatformservice","text":"Doc Home > API Index > platUnix > UnixPlatformService","title":"UnixPlatformService"},{"location":"api/platUnix/UnixPlatformService/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::Service sys::PlatformService platUnix::UnixPlatformService public class UnixPlatformService Generic Unix Platform Service Doc Home > API Index > platUnix > UnixPlatformService","title":"Inheritance"},{"location":"api/platUnix/UnixProvDbFileStore/","text":"UnixProvDbFileStore \u00b6 Doc Home > API Index > platUnix > UnixProvDbFileStore Inheritance \u00b6 sys::Obj sys::Virtual sys::FileStore platUnix::UnixProvDbFileStore public final class UnixProvDbFileStore UnixProvDbFileStore converts filenames for the Manifest (or Kit) Database. Fields \u00b6 fullpath \u00b6 public static inline BufOutStream fullpath maxPathLen \u00b6 public static const define int maxPathLen mfStore \u00b6 public static inline UnixProvDbFileStore mfStore pathBuf \u00b6 public static inline Buf pathBuf pathStr \u00b6 public Str pathStr prefix \u00b6 public Str prefix Methods \u00b6 UnixProvDbFileStore \u00b6 public void UnixProvDbFileStore( Str pre, Str path) Constructor sets instance fields and inserts self into FileStore list. Note: assume args are (const) string literals, no need to copy. accept \u00b6 public virtual override bool accept( Str filename) Parse the given filename, and return true if this is the appropriate FileStore instance to handle it. open \u00b6 public virtual override bool open( File f, Str mode) Implementation for 'File.open'. size \u00b6 public virtual override int size( File f) Implementation for 'File.size'. Must work without opening the file. Doc Home > API Index > platUnix > UnixProvDbFileStore","title":"UnixProvDbFileStore"},{"location":"api/platUnix/UnixProvDbFileStore/#unixprovdbfilestore","text":"Doc Home > API Index > platUnix > UnixProvDbFileStore","title":"UnixProvDbFileStore"},{"location":"api/platUnix/UnixProvDbFileStore/#inheritance","text":"sys::Obj sys::Virtual sys::FileStore platUnix::UnixProvDbFileStore public final class UnixProvDbFileStore UnixProvDbFileStore converts filenames for the Manifest (or Kit) Database.","title":"Inheritance"},{"location":"api/platUnix/UnixProvDbFileStore/#fields","text":"","title":"Fields"},{"location":"api/platUnix/UnixProvDbFileStore/#fullpath","text":"public static inline BufOutStream fullpath","title":"fullpath"},{"location":"api/platUnix/UnixProvDbFileStore/#maxpathlen","text":"public static const define int maxPathLen","title":"maxPathLen"},{"location":"api/platUnix/UnixProvDbFileStore/#mfstore","text":"public static inline UnixProvDbFileStore mfStore","title":"mfStore"},{"location":"api/platUnix/UnixProvDbFileStore/#pathbuf","text":"public static inline Buf pathBuf","title":"pathBuf"},{"location":"api/platUnix/UnixProvDbFileStore/#pathstr","text":"public Str pathStr","title":"pathStr"},{"location":"api/platUnix/UnixProvDbFileStore/#prefix","text":"public Str prefix","title":"prefix"},{"location":"api/platUnix/UnixProvDbFileStore/#methods","text":"","title":"Methods"},{"location":"api/platUnix/UnixProvDbFileStore/#unixprovdbfilestore_1","text":"public void UnixProvDbFileStore( Str pre, Str path) Constructor sets instance fields and inserts self into FileStore list. Note: assume args are (const) string literals, no need to copy.","title":"UnixProvDbFileStore"},{"location":"api/platUnix/UnixProvDbFileStore/#accept","text":"public virtual override bool accept( Str filename) Parse the given filename, and return true if this is the appropriate FileStore instance to handle it.","title":"accept"},{"location":"api/platUnix/UnixProvDbFileStore/#open","text":"public virtual override bool open( File f, Str mode) Implementation for 'File.open'.","title":"open"},{"location":"api/platUnix/UnixProvDbFileStore/#size","text":"public virtual override int size( File f) Implementation for 'File.size'. Must work without opening the file. Doc Home > API Index > platUnix > UnixProvDbFileStore","title":"size"},{"location":"api/platWin32/","text":"platWin32 \u00b6 Doc Home > API Index > platWin32 Platform support for Windows based devices PlatformManifestServer \u00b6 Win32HibPlatformService \u00b6 Win32PlatformService \u00b6 Win32ProvDbFileStore \u00b6 Win32WdftPlatformService \u00b6 Win32YieldPlatformService \u00b6 Doc Home > API Index > platWin32","title":"Index"},{"location":"api/platWin32/#platwin32","text":"Doc Home > API Index > platWin32 Platform support for Windows based devices","title":"platWin32"},{"location":"api/platWin32/#platformmanifestserver","text":"","title":"PlatformManifestServer"},{"location":"api/platWin32/#win32hibplatformservice","text":"","title":"Win32HibPlatformService"},{"location":"api/platWin32/#win32platformservice","text":"","title":"Win32PlatformService"},{"location":"api/platWin32/#win32provdbfilestore","text":"","title":"Win32ProvDbFileStore"},{"location":"api/platWin32/#win32wdftplatformservice","text":"","title":"Win32WdftPlatformService"},{"location":"api/platWin32/#win32yieldplatformservice","text":"Doc Home > API Index > platWin32","title":"Win32YieldPlatformService"},{"location":"api/platWin32/PlatformManifestServer/","text":"PlatformManifestServer \u00b6 Doc Home > API Index > platWin32 > PlatformManifestServer Inheritance \u00b6 sys::Obj sys::Virtual sys::FileStore sys::MemoryFileStore platWin32::PlatformManifestServer public final class PlatformManifestServer Reference implementation for an in-memory platform manifest file store Fields \u00b6 Methods \u00b6 PlatformManifestServer \u00b6 public void PlatformManifestServer() accept \u00b6 public override bool accept( Str name) getMemorySize \u00b6 public override int getMemorySize( File f) openMemoryFile \u00b6 public override bool openMemoryFile( MemoryFile m) Doc Home > API Index > platWin32 > PlatformManifestServer","title":"PlatformManifestServer"},{"location":"api/platWin32/PlatformManifestServer/#platformmanifestserver","text":"Doc Home > API Index > platWin32 > PlatformManifestServer","title":"PlatformManifestServer"},{"location":"api/platWin32/PlatformManifestServer/#inheritance","text":"sys::Obj sys::Virtual sys::FileStore sys::MemoryFileStore platWin32::PlatformManifestServer public final class PlatformManifestServer Reference implementation for an in-memory platform manifest file store","title":"Inheritance"},{"location":"api/platWin32/PlatformManifestServer/#fields","text":"","title":"Fields"},{"location":"api/platWin32/PlatformManifestServer/#methods","text":"","title":"Methods"},{"location":"api/platWin32/PlatformManifestServer/#platformmanifestserver_1","text":"public void PlatformManifestServer()","title":"PlatformManifestServer"},{"location":"api/platWin32/PlatformManifestServer/#accept","text":"public override bool accept( Str name)","title":"accept"},{"location":"api/platWin32/PlatformManifestServer/#getmemorysize","text":"public override int getMemorySize( File f)","title":"getMemorySize"},{"location":"api/platWin32/PlatformManifestServer/#openmemoryfile","text":"public override bool openMemoryFile( MemoryFile m) Doc Home > API Index > platWin32 > PlatformManifestServer","title":"openMemoryFile"},{"location":"api/platWin32/Win32HibPlatformService/","text":"Win32HibPlatformService \u00b6 Doc Home > API Index > platWin32 > Win32HibPlatformService Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::Service sys::PlatformService platWin32::Win32PlatformService platWin32::Win32HibPlatformService public class Win32HibPlatformService Win32 Platform Service demonstrating use of hibernate. App will hibernate once per execute cycle. Fields \u00b6 Methods \u00b6 work \u00b6 public override bool work() Perform a chunk of background work. Return true is there is pending work or false if the Service is done working this cycle. Doc Home > API Index > platWin32 > Win32HibPlatformService","title":"Win32HibPlatformService"},{"location":"api/platWin32/Win32HibPlatformService/#win32hibplatformservice","text":"Doc Home > API Index > platWin32 > Win32HibPlatformService","title":"Win32HibPlatformService"},{"location":"api/platWin32/Win32HibPlatformService/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::Service sys::PlatformService platWin32::Win32PlatformService platWin32::Win32HibPlatformService public class Win32HibPlatformService Win32 Platform Service demonstrating use of hibernate. App will hibernate once per execute cycle.","title":"Inheritance"},{"location":"api/platWin32/Win32HibPlatformService/#fields","text":"","title":"Fields"},{"location":"api/platWin32/Win32HibPlatformService/#methods","text":"","title":"Methods"},{"location":"api/platWin32/Win32HibPlatformService/#work","text":"public override bool work() Perform a chunk of background work. Return true is there is pending work or false if the Service is done working this cycle. Doc Home > API Index > platWin32 > Win32HibPlatformService","title":"work"},{"location":"api/platWin32/Win32PlatformService/","text":"Win32PlatformService \u00b6 Doc Home > API Index > platWin32 > Win32PlatformService Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::Service sys::PlatformService platWin32::Win32PlatformService public class Win32PlatformService Generic Win32 Platform Service Fields \u00b6 pmServer \u00b6 public inline PlatformManifestServer pmServer Doc Home > API Index > platWin32 > Win32PlatformService","title":"Win32PlatformService"},{"location":"api/platWin32/Win32PlatformService/#win32platformservice","text":"Doc Home > API Index > platWin32 > Win32PlatformService","title":"Win32PlatformService"},{"location":"api/platWin32/Win32PlatformService/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::Service sys::PlatformService platWin32::Win32PlatformService public class Win32PlatformService Generic Win32 Platform Service","title":"Inheritance"},{"location":"api/platWin32/Win32PlatformService/#fields","text":"","title":"Fields"},{"location":"api/platWin32/Win32PlatformService/#pmserver","text":"public inline PlatformManifestServer pmServer Doc Home > API Index > platWin32 > Win32PlatformService","title":"pmServer"},{"location":"api/platWin32/Win32ProvDbFileStore/","text":"Win32ProvDbFileStore \u00b6 Doc Home > API Index > platWin32 > Win32ProvDbFileStore Inheritance \u00b6 sys::Obj sys::Virtual sys::FileStore platWin32::Win32ProvDbFileStore public final class Win32ProvDbFileStore Win32ProvDbFileStore converts filenames for the Manifest (or Kit) Database. Fields \u00b6 fullpath \u00b6 public static inline BufOutStream fullpath maxPathLen \u00b6 public static const define int maxPathLen mfStore \u00b6 public static inline Win32ProvDbFileStore mfStore pathBuf \u00b6 public static inline Buf pathBuf pathStr \u00b6 public Str pathStr prefix \u00b6 public Str prefix Methods \u00b6 Win32ProvDbFileStore \u00b6 public void Win32ProvDbFileStore( Str pre, Str path) Constructor sets instance fields and inserts self into FileStore list. Note: assume args are (const) string literals, no need to copy. accept \u00b6 public virtual override bool accept( Str filename) Parse the given filename, and return true if this is the appropriate FileStore instance to handle it. open \u00b6 public virtual override bool open( File f, Str mode) Implementation for 'File.open'. size \u00b6 public virtual override int size( File f) Implementation for 'File.size'. Must work without opening the file. Doc Home > API Index > platWin32 > Win32ProvDbFileStore","title":"Win32ProvDbFileStore"},{"location":"api/platWin32/Win32ProvDbFileStore/#win32provdbfilestore","text":"Doc Home > API Index > platWin32 > Win32ProvDbFileStore","title":"Win32ProvDbFileStore"},{"location":"api/platWin32/Win32ProvDbFileStore/#inheritance","text":"sys::Obj sys::Virtual sys::FileStore platWin32::Win32ProvDbFileStore public final class Win32ProvDbFileStore Win32ProvDbFileStore converts filenames for the Manifest (or Kit) Database.","title":"Inheritance"},{"location":"api/platWin32/Win32ProvDbFileStore/#fields","text":"","title":"Fields"},{"location":"api/platWin32/Win32ProvDbFileStore/#fullpath","text":"public static inline BufOutStream fullpath","title":"fullpath"},{"location":"api/platWin32/Win32ProvDbFileStore/#maxpathlen","text":"public static const define int maxPathLen","title":"maxPathLen"},{"location":"api/platWin32/Win32ProvDbFileStore/#mfstore","text":"public static inline Win32ProvDbFileStore mfStore","title":"mfStore"},{"location":"api/platWin32/Win32ProvDbFileStore/#pathbuf","text":"public static inline Buf pathBuf","title":"pathBuf"},{"location":"api/platWin32/Win32ProvDbFileStore/#pathstr","text":"public Str pathStr","title":"pathStr"},{"location":"api/platWin32/Win32ProvDbFileStore/#prefix","text":"public Str prefix","title":"prefix"},{"location":"api/platWin32/Win32ProvDbFileStore/#methods","text":"","title":"Methods"},{"location":"api/platWin32/Win32ProvDbFileStore/#win32provdbfilestore_1","text":"public void Win32ProvDbFileStore( Str pre, Str path) Constructor sets instance fields and inserts self into FileStore list. Note: assume args are (const) string literals, no need to copy.","title":"Win32ProvDbFileStore"},{"location":"api/platWin32/Win32ProvDbFileStore/#accept","text":"public virtual override bool accept( Str filename) Parse the given filename, and return true if this is the appropriate FileStore instance to handle it.","title":"accept"},{"location":"api/platWin32/Win32ProvDbFileStore/#open","text":"public virtual override bool open( File f, Str mode) Implementation for 'File.open'.","title":"open"},{"location":"api/platWin32/Win32ProvDbFileStore/#size","text":"public virtual override int size( File f) Implementation for 'File.size'. Must work without opening the file. Doc Home > API Index > platWin32 > Win32ProvDbFileStore","title":"size"},{"location":"api/platWin32/Win32WdftPlatformService/","text":"Win32WdftPlatformService \u00b6 Doc Home > API Index > platWin32 > Win32WdftPlatformService Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::Service sys::PlatformService platWin32::Win32PlatformService platWin32::Win32WdftPlatformService public class Win32WdftPlatformService Win32 Platform Service demonstrating use of Platform workDuringFreeTime() call Fields \u00b6 Methods \u00b6 workDuringFreeTime \u00b6 public override bool workDuringFreeTime(long nsUntilDeadline) Doc Home > API Index > platWin32 > Win32WdftPlatformService","title":"Win32WdftPlatformService"},{"location":"api/platWin32/Win32WdftPlatformService/#win32wdftplatformservice","text":"Doc Home > API Index > platWin32 > Win32WdftPlatformService","title":"Win32WdftPlatformService"},{"location":"api/platWin32/Win32WdftPlatformService/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::Service sys::PlatformService platWin32::Win32PlatformService platWin32::Win32WdftPlatformService public class Win32WdftPlatformService Win32 Platform Service demonstrating use of Platform workDuringFreeTime() call","title":"Inheritance"},{"location":"api/platWin32/Win32WdftPlatformService/#fields","text":"","title":"Fields"},{"location":"api/platWin32/Win32WdftPlatformService/#methods","text":"","title":"Methods"},{"location":"api/platWin32/Win32WdftPlatformService/#workduringfreetime","text":"public override bool workDuringFreeTime(long nsUntilDeadline) Doc Home > API Index > platWin32 > Win32WdftPlatformService","title":"workDuringFreeTime"},{"location":"api/platWin32/Win32YieldPlatformService/","text":"Win32YieldPlatformService \u00b6 Doc Home > API Index > platWin32 > Win32YieldPlatformService Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::Service sys::PlatformService platWin32::Win32PlatformService platWin32::Win32YieldPlatformService public class Win32YieldPlatformService Win32 Platform Service demonstrating use of yield APIs. Instead of calling Sys.sleep() each App execute cycle, VM will exit with Err.yield code and sleep will be called by native code in main.c, followed by a call to resume(). Note that yield is NOT required for Win32 - this is just sample code. Fields \u00b6 Methods \u00b6 yield \u00b6 public virtual override void yield(long yieldTime) yieldRequired \u00b6 public virtual override bool yieldRequired() Doc Home > API Index > platWin32 > Win32YieldPlatformService","title":"Win32YieldPlatformService"},{"location":"api/platWin32/Win32YieldPlatformService/#win32yieldplatformservice","text":"Doc Home > API Index > platWin32 > Win32YieldPlatformService","title":"Win32YieldPlatformService"},{"location":"api/platWin32/Win32YieldPlatformService/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::Service sys::PlatformService platWin32::Win32PlatformService platWin32::Win32YieldPlatformService public class Win32YieldPlatformService Win32 Platform Service demonstrating use of yield APIs. Instead of calling Sys.sleep() each App execute cycle, VM will exit with Err.yield code and sleep will be called by native code in main.c, followed by a call to resume(). Note that yield is NOT required for Win32 - this is just sample code.","title":"Inheritance"},{"location":"api/platWin32/Win32YieldPlatformService/#fields","text":"","title":"Fields"},{"location":"api/platWin32/Win32YieldPlatformService/#methods","text":"","title":"Methods"},{"location":"api/platWin32/Win32YieldPlatformService/#yield","text":"public virtual override void yield(long yieldTime)","title":"yield"},{"location":"api/platWin32/Win32YieldPlatformService/#yieldrequired","text":"public virtual override bool yieldRequired() Doc Home > API Index > platWin32 > Win32YieldPlatformService","title":"yieldRequired"},{"location":"api/pricomp/","text":"pricomp \u00b6 Doc Home > API Index > pricomp Priority array component Prioritized \u00b6 PrioritizedBool \u00b6 PrioritizedFloat \u00b6 PrioritizedInt \u00b6 Doc Home > API Index > pricomp","title":"Index"},{"location":"api/pricomp/#pricomp","text":"Doc Home > API Index > pricomp Priority array component","title":"pricomp"},{"location":"api/pricomp/#prioritized","text":"","title":"Prioritized"},{"location":"api/pricomp/#prioritizedbool","text":"","title":"PrioritizedBool"},{"location":"api/pricomp/#prioritizedfloat","text":"","title":"PrioritizedFloat"},{"location":"api/pricomp/#prioritizedint","text":"Doc Home > API Index > pricomp","title":"PrioritizedInt"},{"location":"api/pricomp/Prioritized/","text":"Prioritized \u00b6 Doc Home > API Index > pricomp > Prioritized Inheritance \u00b6 sys::Obj sys::Virtual sys::Component pricomp::Prioritized public abstract class Prioritized Prioritized Fields \u00b6 FB_LEVEL \u00b6 public static const define int FB_LEVEL overrideExpTime \u00b6 public property long overrideExpTime [summary=false, unit=\"nanosecond\", readonly] sourceLevel \u00b6 public property int sourceLevel [summary=false, range=\"in0, emergency, in2, in3, in4, in5, in6, in7, override, in9, in10, in11, in12, in13, in14, in15, in16, fallback\", readonly] srcLevelStr \u00b6 public static const define Str srcLevelStr Methods \u00b6 setToDefault \u00b6 public virtual override void setToDefault( Slot slot) Set a property to its default value. This overrides the base class method to set slots to \"null\" instead of zero. Doc Home > API Index > pricomp > Prioritized","title":"Prioritized"},{"location":"api/pricomp/Prioritized/#prioritized","text":"Doc Home > API Index > pricomp > Prioritized","title":"Prioritized"},{"location":"api/pricomp/Prioritized/#inheritance","text":"sys::Obj sys::Virtual sys::Component pricomp::Prioritized public abstract class Prioritized Prioritized","title":"Inheritance"},{"location":"api/pricomp/Prioritized/#fields","text":"","title":"Fields"},{"location":"api/pricomp/Prioritized/#fb_level","text":"public static const define int FB_LEVEL","title":"FB_LEVEL"},{"location":"api/pricomp/Prioritized/#overrideexptime","text":"public property long overrideExpTime [summary=false, unit=\"nanosecond\", readonly]","title":"overrideExpTime"},{"location":"api/pricomp/Prioritized/#sourcelevel","text":"public property int sourceLevel [summary=false, range=\"in0, emergency, in2, in3, in4, in5, in6, in7, override, in9, in10, in11, in12, in13, in14, in15, in16, fallback\", readonly]","title":"sourceLevel"},{"location":"api/pricomp/Prioritized/#srclevelstr","text":"public static const define Str srcLevelStr","title":"srcLevelStr"},{"location":"api/pricomp/Prioritized/#methods","text":"","title":"Methods"},{"location":"api/pricomp/Prioritized/#settodefault","text":"public virtual override void setToDefault( Slot slot) Set a property to its default value. This overrides the base class method to set slots to \"null\" instead of zero. Doc Home > API Index > pricomp > Prioritized","title":"setToDefault"},{"location":"api/pricomp/PrioritizedBool/","text":"PrioritizedBool \u00b6 Doc Home > API Index > pricomp > PrioritizedBool Inheritance \u00b6 sys::Obj sys::Virtual sys::Component pricomp::Prioritized pricomp::PrioritizedBool public class PrioritizedBool PrioritizedBool Fields \u00b6 NULLVAL \u00b6 public static const define bool NULLVAL fallback \u00b6 public property bool fallback [summary=false, config] in1 \u00b6 public property bool in1 [summary=false, readonly] in10 \u00b6 public property bool in10 [summary] in11 \u00b6 public property bool in11 [summary=false] in12 \u00b6 public property bool in12 [summary=false] in13 \u00b6 public property bool in13 [summary=false] in14 \u00b6 public property bool in14 [summary=false] in15 \u00b6 public property bool in15 [summary=false] in16 \u00b6 public property bool in16 [summary] in2 \u00b6 public property bool in2 [summary=false] in3 \u00b6 public property bool in3 [summary=false] in4 \u00b6 public property bool in4 [summary=false] in5 \u00b6 public property bool in5 [summary=false] in6 \u00b6 public property bool in6 [summary=false, readonly] in7 \u00b6 public property bool in7 [summary=false] in8 \u00b6 public property bool in8 [summary=false, readonly] in9 \u00b6 public property bool in9 [summary=false] minActiveEndTime \u00b6 public long minActiveEndTime minActiveTime \u00b6 public property int minActiveTime [summary=false, unit=\"millisecond\", config] minInactiveEndTime \u00b6 public long minInactiveEndTime minInactiveTime \u00b6 public property int minInactiveTime [summary=false, unit=\"millisecond\", config] out \u00b6 public property bool out [summary, readonly] prevOut \u00b6 public bool prevOut Methods \u00b6 emergencyAuto \u00b6 public action void emergencyAuto() emergencySetActive \u00b6 public action void emergencySetActive() emergencySetInactive \u00b6 public action void emergencySetInactive() execute \u00b6 public virtual override void execute() Execute is called once every scan using the simple round-robin scan engine. manualAuto \u00b6 public action void manualAuto() manualSetActive \u00b6 public action void manualSetActive(int expTime) manualSetInactive \u00b6 public action void manualSetInactive(int expTime) Doc Home > API Index > pricomp > PrioritizedBool","title":"PrioritizedBool"},{"location":"api/pricomp/PrioritizedBool/#prioritizedbool","text":"Doc Home > API Index > pricomp > PrioritizedBool","title":"PrioritizedBool"},{"location":"api/pricomp/PrioritizedBool/#inheritance","text":"sys::Obj sys::Virtual sys::Component pricomp::Prioritized pricomp::PrioritizedBool public class PrioritizedBool PrioritizedBool","title":"Inheritance"},{"location":"api/pricomp/PrioritizedBool/#fields","text":"","title":"Fields"},{"location":"api/pricomp/PrioritizedBool/#nullval","text":"public static const define bool NULLVAL","title":"NULLVAL"},{"location":"api/pricomp/PrioritizedBool/#fallback","text":"public property bool fallback [summary=false, config]","title":"fallback"},{"location":"api/pricomp/PrioritizedBool/#in1","text":"public property bool in1 [summary=false, readonly]","title":"in1"},{"location":"api/pricomp/PrioritizedBool/#in10","text":"public property bool in10 [summary]","title":"in10"},{"location":"api/pricomp/PrioritizedBool/#in11","text":"public property bool in11 [summary=false]","title":"in11"},{"location":"api/pricomp/PrioritizedBool/#in12","text":"public property bool in12 [summary=false]","title":"in12"},{"location":"api/pricomp/PrioritizedBool/#in13","text":"public property bool in13 [summary=false]","title":"in13"},{"location":"api/pricomp/PrioritizedBool/#in14","text":"public property bool in14 [summary=false]","title":"in14"},{"location":"api/pricomp/PrioritizedBool/#in15","text":"public property bool in15 [summary=false]","title":"in15"},{"location":"api/pricomp/PrioritizedBool/#in16","text":"public property bool in16 [summary]","title":"in16"},{"location":"api/pricomp/PrioritizedBool/#in2","text":"public property bool in2 [summary=false]","title":"in2"},{"location":"api/pricomp/PrioritizedBool/#in3","text":"public property bool in3 [summary=false]","title":"in3"},{"location":"api/pricomp/PrioritizedBool/#in4","text":"public property bool in4 [summary=false]","title":"in4"},{"location":"api/pricomp/PrioritizedBool/#in5","text":"public property bool in5 [summary=false]","title":"in5"},{"location":"api/pricomp/PrioritizedBool/#in6","text":"public property bool in6 [summary=false, readonly]","title":"in6"},{"location":"api/pricomp/PrioritizedBool/#in7","text":"public property bool in7 [summary=false]","title":"in7"},{"location":"api/pricomp/PrioritizedBool/#in8","text":"public property bool in8 [summary=false, readonly]","title":"in8"},{"location":"api/pricomp/PrioritizedBool/#in9","text":"public property bool in9 [summary=false]","title":"in9"},{"location":"api/pricomp/PrioritizedBool/#minactiveendtime","text":"public long minActiveEndTime","title":"minActiveEndTime"},{"location":"api/pricomp/PrioritizedBool/#minactivetime","text":"public property int minActiveTime [summary=false, unit=\"millisecond\", config]","title":"minActiveTime"},{"location":"api/pricomp/PrioritizedBool/#mininactiveendtime","text":"public long minInactiveEndTime","title":"minInactiveEndTime"},{"location":"api/pricomp/PrioritizedBool/#mininactivetime","text":"public property int minInactiveTime [summary=false, unit=\"millisecond\", config]","title":"minInactiveTime"},{"location":"api/pricomp/PrioritizedBool/#out","text":"public property bool out [summary, readonly]","title":"out"},{"location":"api/pricomp/PrioritizedBool/#prevout","text":"public bool prevOut","title":"prevOut"},{"location":"api/pricomp/PrioritizedBool/#methods","text":"","title":"Methods"},{"location":"api/pricomp/PrioritizedBool/#emergencyauto","text":"public action void emergencyAuto()","title":"emergencyAuto"},{"location":"api/pricomp/PrioritizedBool/#emergencysetactive","text":"public action void emergencySetActive()","title":"emergencySetActive"},{"location":"api/pricomp/PrioritizedBool/#emergencysetinactive","text":"public action void emergencySetInactive()","title":"emergencySetInactive"},{"location":"api/pricomp/PrioritizedBool/#execute","text":"public virtual override void execute() Execute is called once every scan using the simple round-robin scan engine.","title":"execute"},{"location":"api/pricomp/PrioritizedBool/#manualauto","text":"public action void manualAuto()","title":"manualAuto"},{"location":"api/pricomp/PrioritizedBool/#manualsetactive","text":"public action void manualSetActive(int expTime)","title":"manualSetActive"},{"location":"api/pricomp/PrioritizedBool/#manualsetinactive","text":"public action void manualSetInactive(int expTime) Doc Home > API Index > pricomp > PrioritizedBool","title":"manualSetInactive"},{"location":"api/pricomp/PrioritizedFloat/","text":"PrioritizedFloat \u00b6 Doc Home > API Index > pricomp > PrioritizedFloat Inheritance \u00b6 sys::Obj sys::Virtual sys::Component pricomp::Prioritized pricomp::PrioritizedFloat public class PrioritizedFloat PrioritizedFloat Fields \u00b6 NULLVAL \u00b6 public static const define float NULLVAL fallback \u00b6 public property float fallback [summary=false, config] in1 \u00b6 public property float in1 [summary=false, readonly] in10 \u00b6 public property float in10 [summary] in11 \u00b6 public property float in11 [summary=false] in12 \u00b6 public property float in12 [summary=false] in13 \u00b6 public property float in13 [summary=false] in14 \u00b6 public property float in14 [summary=false] in15 \u00b6 public property float in15 [summary=false] in16 \u00b6 public property float in16 [summary] in2 \u00b6 public property float in2 [summary=false] in3 \u00b6 public property float in3 [summary=false] in4 \u00b6 public property float in4 [summary=false] in5 \u00b6 public property float in5 [summary=false] in6 \u00b6 public property float in6 [summary=false] in7 \u00b6 public property float in7 [summary=false] in8 \u00b6 public property float in8 [summary=false, readonly] in9 \u00b6 public property float in9 [summary=false] out \u00b6 public property float out [summary, readonly] Methods \u00b6 emergencyAuto \u00b6 public action void emergencyAuto() emergencySet \u00b6 public action void emergencySet(float newValue) execute \u00b6 public virtual override void execute() Execute is called once every scan using the simple round-robin scan engine. manualAuto \u00b6 public action void manualAuto() manualSet \u00b6 public action void manualSet(long valAndExpTime) Doc Home > API Index > pricomp > PrioritizedFloat","title":"PrioritizedFloat"},{"location":"api/pricomp/PrioritizedFloat/#prioritizedfloat","text":"Doc Home > API Index > pricomp > PrioritizedFloat","title":"PrioritizedFloat"},{"location":"api/pricomp/PrioritizedFloat/#inheritance","text":"sys::Obj sys::Virtual sys::Component pricomp::Prioritized pricomp::PrioritizedFloat public class PrioritizedFloat PrioritizedFloat","title":"Inheritance"},{"location":"api/pricomp/PrioritizedFloat/#fields","text":"","title":"Fields"},{"location":"api/pricomp/PrioritizedFloat/#nullval","text":"public static const define float NULLVAL","title":"NULLVAL"},{"location":"api/pricomp/PrioritizedFloat/#fallback","text":"public property float fallback [summary=false, config]","title":"fallback"},{"location":"api/pricomp/PrioritizedFloat/#in1","text":"public property float in1 [summary=false, readonly]","title":"in1"},{"location":"api/pricomp/PrioritizedFloat/#in10","text":"public property float in10 [summary]","title":"in10"},{"location":"api/pricomp/PrioritizedFloat/#in11","text":"public property float in11 [summary=false]","title":"in11"},{"location":"api/pricomp/PrioritizedFloat/#in12","text":"public property float in12 [summary=false]","title":"in12"},{"location":"api/pricomp/PrioritizedFloat/#in13","text":"public property float in13 [summary=false]","title":"in13"},{"location":"api/pricomp/PrioritizedFloat/#in14","text":"public property float in14 [summary=false]","title":"in14"},{"location":"api/pricomp/PrioritizedFloat/#in15","text":"public property float in15 [summary=false]","title":"in15"},{"location":"api/pricomp/PrioritizedFloat/#in16","text":"public property float in16 [summary]","title":"in16"},{"location":"api/pricomp/PrioritizedFloat/#in2","text":"public property float in2 [summary=false]","title":"in2"},{"location":"api/pricomp/PrioritizedFloat/#in3","text":"public property float in3 [summary=false]","title":"in3"},{"location":"api/pricomp/PrioritizedFloat/#in4","text":"public property float in4 [summary=false]","title":"in4"},{"location":"api/pricomp/PrioritizedFloat/#in5","text":"public property float in5 [summary=false]","title":"in5"},{"location":"api/pricomp/PrioritizedFloat/#in6","text":"public property float in6 [summary=false]","title":"in6"},{"location":"api/pricomp/PrioritizedFloat/#in7","text":"public property float in7 [summary=false]","title":"in7"},{"location":"api/pricomp/PrioritizedFloat/#in8","text":"public property float in8 [summary=false, readonly]","title":"in8"},{"location":"api/pricomp/PrioritizedFloat/#in9","text":"public property float in9 [summary=false]","title":"in9"},{"location":"api/pricomp/PrioritizedFloat/#out","text":"public property float out [summary, readonly]","title":"out"},{"location":"api/pricomp/PrioritizedFloat/#methods","text":"","title":"Methods"},{"location":"api/pricomp/PrioritizedFloat/#emergencyauto","text":"public action void emergencyAuto()","title":"emergencyAuto"},{"location":"api/pricomp/PrioritizedFloat/#emergencyset","text":"public action void emergencySet(float newValue)","title":"emergencySet"},{"location":"api/pricomp/PrioritizedFloat/#execute","text":"public virtual override void execute() Execute is called once every scan using the simple round-robin scan engine.","title":"execute"},{"location":"api/pricomp/PrioritizedFloat/#manualauto","text":"public action void manualAuto()","title":"manualAuto"},{"location":"api/pricomp/PrioritizedFloat/#manualset","text":"public action void manualSet(long valAndExpTime) Doc Home > API Index > pricomp > PrioritizedFloat","title":"manualSet"},{"location":"api/pricomp/PrioritizedInt/","text":"PrioritizedInt \u00b6 Doc Home > API Index > pricomp > PrioritizedInt Inheritance \u00b6 sys::Obj sys::Virtual sys::Component pricomp::Prioritized pricomp::PrioritizedInt public class PrioritizedInt PrioritizedInt Fields \u00b6 NULLVAL \u00b6 public static const define int NULLVAL Sys.minInt Min value of a 32-bit signed integer: -2,147,483,648 fallback \u00b6 public property int fallback [summary=false, config] in1 \u00b6 public property int in1 [summary=false, readonly] in10 \u00b6 public property int in10 [summary] in11 \u00b6 public property int in11 [summary=false] in12 \u00b6 public property int in12 [summary=false] in13 \u00b6 public property int in13 [summary=false] in14 \u00b6 public property int in14 [summary=false] in15 \u00b6 public property int in15 [summary=false] in16 \u00b6 public property int in16 [summary] in2 \u00b6 public property int in2 [summary=false] in3 \u00b6 public property int in3 [summary=false] in4 \u00b6 public property int in4 [summary=false] in5 \u00b6 public property int in5 [summary=false] in6 \u00b6 public property int in6 [summary=false] in7 \u00b6 public property int in7 [summary=false] in8 \u00b6 public property int in8 [summary=false, readonly] in9 \u00b6 public property int in9 [summary=false] out \u00b6 public property int out [summary, readonly] Methods \u00b6 emergencyAuto \u00b6 public action void emergencyAuto() emergencySet \u00b6 public action void emergencySet(int newValue) execute \u00b6 public virtual override void execute() Execute is called once every scan using the simple round-robin scan engine. manualAuto \u00b6 public action void manualAuto() manualSet \u00b6 public action void manualSet(long valAndExpTime) manualSet - Override value. Arg to action is 8-byte long; first 4 bytes are new value, last 4 are override duration in milliseconds. Doc Home > API Index > pricomp > PrioritizedInt","title":"PrioritizedInt"},{"location":"api/pricomp/PrioritizedInt/#prioritizedint","text":"Doc Home > API Index > pricomp > PrioritizedInt","title":"PrioritizedInt"},{"location":"api/pricomp/PrioritizedInt/#inheritance","text":"sys::Obj sys::Virtual sys::Component pricomp::Prioritized pricomp::PrioritizedInt public class PrioritizedInt PrioritizedInt","title":"Inheritance"},{"location":"api/pricomp/PrioritizedInt/#fields","text":"","title":"Fields"},{"location":"api/pricomp/PrioritizedInt/#nullval","text":"public static const define int NULLVAL Sys.minInt Min value of a 32-bit signed integer: -2,147,483,648","title":"NULLVAL"},{"location":"api/pricomp/PrioritizedInt/#fallback","text":"public property int fallback [summary=false, config]","title":"fallback"},{"location":"api/pricomp/PrioritizedInt/#in1","text":"public property int in1 [summary=false, readonly]","title":"in1"},{"location":"api/pricomp/PrioritizedInt/#in10","text":"public property int in10 [summary]","title":"in10"},{"location":"api/pricomp/PrioritizedInt/#in11","text":"public property int in11 [summary=false]","title":"in11"},{"location":"api/pricomp/PrioritizedInt/#in12","text":"public property int in12 [summary=false]","title":"in12"},{"location":"api/pricomp/PrioritizedInt/#in13","text":"public property int in13 [summary=false]","title":"in13"},{"location":"api/pricomp/PrioritizedInt/#in14","text":"public property int in14 [summary=false]","title":"in14"},{"location":"api/pricomp/PrioritizedInt/#in15","text":"public property int in15 [summary=false]","title":"in15"},{"location":"api/pricomp/PrioritizedInt/#in16","text":"public property int in16 [summary]","title":"in16"},{"location":"api/pricomp/PrioritizedInt/#in2","text":"public property int in2 [summary=false]","title":"in2"},{"location":"api/pricomp/PrioritizedInt/#in3","text":"public property int in3 [summary=false]","title":"in3"},{"location":"api/pricomp/PrioritizedInt/#in4","text":"public property int in4 [summary=false]","title":"in4"},{"location":"api/pricomp/PrioritizedInt/#in5","text":"public property int in5 [summary=false]","title":"in5"},{"location":"api/pricomp/PrioritizedInt/#in6","text":"public property int in6 [summary=false]","title":"in6"},{"location":"api/pricomp/PrioritizedInt/#in7","text":"public property int in7 [summary=false]","title":"in7"},{"location":"api/pricomp/PrioritizedInt/#in8","text":"public property int in8 [summary=false, readonly]","title":"in8"},{"location":"api/pricomp/PrioritizedInt/#in9","text":"public property int in9 [summary=false]","title":"in9"},{"location":"api/pricomp/PrioritizedInt/#out","text":"public property int out [summary, readonly]","title":"out"},{"location":"api/pricomp/PrioritizedInt/#methods","text":"","title":"Methods"},{"location":"api/pricomp/PrioritizedInt/#emergencyauto","text":"public action void emergencyAuto()","title":"emergencyAuto"},{"location":"api/pricomp/PrioritizedInt/#emergencyset","text":"public action void emergencySet(int newValue)","title":"emergencySet"},{"location":"api/pricomp/PrioritizedInt/#execute","text":"public virtual override void execute() Execute is called once every scan using the simple round-robin scan engine.","title":"execute"},{"location":"api/pricomp/PrioritizedInt/#manualauto","text":"public action void manualAuto()","title":"manualAuto"},{"location":"api/pricomp/PrioritizedInt/#manualset","text":"public action void manualSet(long valAndExpTime) manualSet - Override value. Arg to action is 8-byte long; first 4 bytes are new value, last 4 are override duration in milliseconds. Doc Home > API Index > pricomp > PrioritizedInt","title":"manualSet"},{"location":"api/pstore/","text":"pstore \u00b6 Doc Home > API Index > pstore Persistent random access, block storage for app data PstoreFile \u00b6 PstoreService \u00b6 Doc Home > API Index > pstore","title":"Index"},{"location":"api/pstore/#pstore","text":"Doc Home > API Index > pstore Persistent random access, block storage for app data","title":"pstore"},{"location":"api/pstore/#pstorefile","text":"","title":"PstoreFile"},{"location":"api/pstore/#pstoreservice","text":"Doc Home > API Index > pstore","title":"PstoreService"},{"location":"api/pstore/PstoreFile/","text":"PstoreFile \u00b6 Doc Home > API Index > pstore > PstoreFile Inheritance \u00b6 sys::Obj sys::Virtual sys::Component pstore::PstoreFile public class PstoreFile [niagaraIcon=\"module://icons/x16/file.png\"] PstoreFile is added as a direct child of a PstoreService to reserves a range of bytes for application use as determined by the \"resvOffset\" and \"resvSize\" properties. Fields \u00b6 resvOffset \u00b6 public property int resvOffset [defaultOnClone, config] Offset of this file's storage reservation relative to the storage device modeled by the parent PstoreService. resvSize \u00b6 public property int resvSize [config] Size of this file's reservation in bytes. status \u00b6 public property byte status [range=\"ok, inactive, badParent, serviceErr, badOffset, badSize, dupRange, formatErr\", readonly] Status code for storage file access, see the statusXXX defines for the various codes. statusBadOffset \u00b6 public static const define int statusBadOffset Reservation offset is out of range statusBadParent \u00b6 public static const define int statusBadParent Indicates that PstoreFile is not directly mounted under PstoreService statusBadSize \u00b6 public static const define int statusBadSize Reservation size is out of range statusDupRange \u00b6 public static const define int statusDupRange Reservation overlaps with another PstoreFile statusFormatErr \u00b6 public static const define int statusFormatErr Used by subclasses when an format error is detected statusInactive \u00b6 public static const define int statusInactive File component is not actively running statusOk \u00b6 public static const define int statusOk File is mapped to storage correctly statusRange \u00b6 public static const define Str statusRange File is mapped to storage correctly statusServiceErr \u00b6 public static const define int statusServiceErr Indicates that the parent PstoreService is in an error state. Methods \u00b6 changed \u00b6 public virtual override void changed( Slot slot) If the reservation props are changed, re-validate. If this method is override, must call super! claim \u00b6 public bool claim() Claim temporary ownership ofthe backing store file to perform IO. Return true on success, false on failure. in \u00b6 public InStream in() Get the input stream used to read this PstoreFile's reserved range from the backing store file. If this PstoreFile is not the current owner, then return Sys.nullIn . No validation is performed to prevent reading past the end of this PstoreFile's reserved range. isOwner \u00b6 public bool isOwner() Is this PstoreFile currently the owner of the backing store file. See the claim method to claim ownership. out \u00b6 public OutStream out() Get an output stream to write this PstoreFile's reserved range to the backing store file. If this PstoreFile is not the current owner, then return Sys.nullOut . No validation is performed to prevent writing past the end of this PstoreFile's reserved range. seek \u00b6 public bool seek(int pos) Seek to a specific byte offset position in the service's backing store file relative to this PstoreFile's reserved offset. This PstoreFile must the current owner. Return false on error. start \u00b6 public virtual override void start() On startup we need to validate our reservation range. If this method is override, must call super! tell \u00b6 public int tell() Get the backing store file's pointer relative to this PstoreFile's reserved offset. This PstoreFile must the current owner. Return -1 on error. validate \u00b6 public virtual void validate() Validate this file's reservation range and update its status. Doc Home > API Index > pstore > PstoreFile","title":"PstoreFile"},{"location":"api/pstore/PstoreFile/#pstorefile","text":"Doc Home > API Index > pstore > PstoreFile","title":"PstoreFile"},{"location":"api/pstore/PstoreFile/#inheritance","text":"sys::Obj sys::Virtual sys::Component pstore::PstoreFile public class PstoreFile [niagaraIcon=\"module://icons/x16/file.png\"] PstoreFile is added as a direct child of a PstoreService to reserves a range of bytes for application use as determined by the \"resvOffset\" and \"resvSize\" properties.","title":"Inheritance"},{"location":"api/pstore/PstoreFile/#fields","text":"","title":"Fields"},{"location":"api/pstore/PstoreFile/#resvoffset","text":"public property int resvOffset [defaultOnClone, config] Offset of this file's storage reservation relative to the storage device modeled by the parent PstoreService.","title":"resvOffset"},{"location":"api/pstore/PstoreFile/#resvsize","text":"public property int resvSize [config] Size of this file's reservation in bytes.","title":"resvSize"},{"location":"api/pstore/PstoreFile/#status","text":"public property byte status [range=\"ok, inactive, badParent, serviceErr, badOffset, badSize, dupRange, formatErr\", readonly] Status code for storage file access, see the statusXXX defines for the various codes.","title":"status"},{"location":"api/pstore/PstoreFile/#statusbadoffset","text":"public static const define int statusBadOffset Reservation offset is out of range","title":"statusBadOffset"},{"location":"api/pstore/PstoreFile/#statusbadparent","text":"public static const define int statusBadParent Indicates that PstoreFile is not directly mounted under PstoreService","title":"statusBadParent"},{"location":"api/pstore/PstoreFile/#statusbadsize","text":"public static const define int statusBadSize Reservation size is out of range","title":"statusBadSize"},{"location":"api/pstore/PstoreFile/#statusduprange","text":"public static const define int statusDupRange Reservation overlaps with another PstoreFile","title":"statusDupRange"},{"location":"api/pstore/PstoreFile/#statusformaterr","text":"public static const define int statusFormatErr Used by subclasses when an format error is detected","title":"statusFormatErr"},{"location":"api/pstore/PstoreFile/#statusinactive","text":"public static const define int statusInactive File component is not actively running","title":"statusInactive"},{"location":"api/pstore/PstoreFile/#statusok","text":"public static const define int statusOk File is mapped to storage correctly","title":"statusOk"},{"location":"api/pstore/PstoreFile/#statusrange","text":"public static const define Str statusRange File is mapped to storage correctly","title":"statusRange"},{"location":"api/pstore/PstoreFile/#statusserviceerr","text":"public static const define int statusServiceErr Indicates that the parent PstoreService is in an error state.","title":"statusServiceErr"},{"location":"api/pstore/PstoreFile/#methods","text":"","title":"Methods"},{"location":"api/pstore/PstoreFile/#changed","text":"public virtual override void changed( Slot slot) If the reservation props are changed, re-validate. If this method is override, must call super!","title":"changed"},{"location":"api/pstore/PstoreFile/#claim","text":"public bool claim() Claim temporary ownership ofthe backing store file to perform IO. Return true on success, false on failure.","title":"claim"},{"location":"api/pstore/PstoreFile/#in","text":"public InStream in() Get the input stream used to read this PstoreFile's reserved range from the backing store file. If this PstoreFile is not the current owner, then return Sys.nullIn . No validation is performed to prevent reading past the end of this PstoreFile's reserved range.","title":"in"},{"location":"api/pstore/PstoreFile/#isowner","text":"public bool isOwner() Is this PstoreFile currently the owner of the backing store file. See the claim method to claim ownership.","title":"isOwner"},{"location":"api/pstore/PstoreFile/#out","text":"public OutStream out() Get an output stream to write this PstoreFile's reserved range to the backing store file. If this PstoreFile is not the current owner, then return Sys.nullOut . No validation is performed to prevent writing past the end of this PstoreFile's reserved range.","title":"out"},{"location":"api/pstore/PstoreFile/#seek","text":"public bool seek(int pos) Seek to a specific byte offset position in the service's backing store file relative to this PstoreFile's reserved offset. This PstoreFile must the current owner. Return false on error.","title":"seek"},{"location":"api/pstore/PstoreFile/#start","text":"public virtual override void start() On startup we need to validate our reservation range. If this method is override, must call super!","title":"start"},{"location":"api/pstore/PstoreFile/#tell","text":"public int tell() Get the backing store file's pointer relative to this PstoreFile's reserved offset. This PstoreFile must the current owner. Return -1 on error.","title":"tell"},{"location":"api/pstore/PstoreFile/#validate","text":"public virtual void validate() Validate this file's reservation range and update its status. Doc Home > API Index > pstore > PstoreFile","title":"validate"},{"location":"api/pstore/PstoreService/","text":"PstoreService \u00b6 Doc Home > API Index > pstore > PstoreService Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::Service pstore::PstoreService public class PstoreService [niagaraIcon=\"module://icons/x16/database.png\"] PstoreService is used to manage a block of random access persistent storage. Pstores are typically backed by EEPROM, static-RAM, or a file system. PstoreFiles are added as direct children of the service to reserve a range of bytes for application functionality. Fields \u00b6 file \u00b6 public inline File file File instance used to manage this PstoreService. Most developers should access the backing store through the methods on PstoreFile. fileSize \u00b6 public property int fileSize [defaultOnClone, config] Configured size of file made available for storage. If the backing file store has a fixed size, then this configuration value is ignored. filename \u00b6 public inline property Buf filename [asStr, defaultOnClone, config, max=32] File name used as the backing store. size \u00b6 public property int size [readonly] Size in bytes of storage available. A zero or negative value indicates an error condition or that the no storage is available. This value must be initialized by the service in the loaded() callback so that is available for error checking in the PStoreFile.start callback. Methods \u00b6 loaded \u00b6 public override void loaded() stop \u00b6 public override void stop() validateAll \u00b6 public action void validateAll() Validate all my child PstoreFiles Doc Home > API Index > pstore > PstoreService","title":"PstoreService"},{"location":"api/pstore/PstoreService/#pstoreservice","text":"Doc Home > API Index > pstore > PstoreService","title":"PstoreService"},{"location":"api/pstore/PstoreService/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::Service pstore::PstoreService public class PstoreService [niagaraIcon=\"module://icons/x16/database.png\"] PstoreService is used to manage a block of random access persistent storage. Pstores are typically backed by EEPROM, static-RAM, or a file system. PstoreFiles are added as direct children of the service to reserve a range of bytes for application functionality.","title":"Inheritance"},{"location":"api/pstore/PstoreService/#fields","text":"","title":"Fields"},{"location":"api/pstore/PstoreService/#file","text":"public inline File file File instance used to manage this PstoreService. Most developers should access the backing store through the methods on PstoreFile.","title":"file"},{"location":"api/pstore/PstoreService/#filesize","text":"public property int fileSize [defaultOnClone, config] Configured size of file made available for storage. If the backing file store has a fixed size, then this configuration value is ignored.","title":"fileSize"},{"location":"api/pstore/PstoreService/#filename","text":"public inline property Buf filename [asStr, defaultOnClone, config, max=32] File name used as the backing store.","title":"filename"},{"location":"api/pstore/PstoreService/#size","text":"public property int size [readonly] Size in bytes of storage available. A zero or negative value indicates an error condition or that the no storage is available. This value must be initialized by the service in the loaded() callback so that is available for error checking in the PStoreFile.start callback.","title":"size"},{"location":"api/pstore/PstoreService/#methods","text":"","title":"Methods"},{"location":"api/pstore/PstoreService/#loaded","text":"public override void loaded()","title":"loaded"},{"location":"api/pstore/PstoreService/#stop","text":"public override void stop()","title":"stop"},{"location":"api/pstore/PstoreService/#validateall","text":"public action void validateAll() Validate all my child PstoreFiles Doc Home > API Index > pstore > PstoreService","title":"validateAll"},{"location":"api/serial/","text":"serial \u00b6 Doc Home > API Index > serial Serial I/O support SerialPort \u00b6 SerialPortEmu \u00b6 SerialPortGeneric \u00b6 SerialPortNative \u00b6 Doc Home > API Index > serial","title":"Index"},{"location":"api/serial/#serial","text":"Doc Home > API Index > serial Serial I/O support","title":"serial"},{"location":"api/serial/#serialport","text":"","title":"SerialPort"},{"location":"api/serial/#serialportemu","text":"","title":"SerialPortEmu"},{"location":"api/serial/#serialportgeneric","text":"","title":"SerialPortGeneric"},{"location":"api/serial/#serialportnative","text":"Doc Home > API Index > serial","title":"SerialPortNative"},{"location":"api/serial/SerialPort/","text":"SerialPort \u00b6 Doc Home > API Index > serial > SerialPort Inheritance \u00b6 sys::Obj sys::Virtual serial::SerialPortGeneric serial::SerialPortNative serial::SerialPortEmu serial::SerialPort public final class SerialPort SerialPort models a serial I/O port without software buffering. Fields \u00b6 Methods \u00b6 SerialPort \u00b6 public void SerialPort() SerialPort constructor sets up in/outstream refs. Note that existence of cstr forces class to be final. Doc Home > API Index > serial > SerialPort","title":"SerialPort"},{"location":"api/serial/SerialPort/#serialport","text":"Doc Home > API Index > serial > SerialPort","title":"SerialPort"},{"location":"api/serial/SerialPort/#inheritance","text":"sys::Obj sys::Virtual serial::SerialPortGeneric serial::SerialPortNative serial::SerialPortEmu serial::SerialPort public final class SerialPort SerialPort models a serial I/O port without software buffering.","title":"Inheritance"},{"location":"api/serial/SerialPort/#fields","text":"","title":"Fields"},{"location":"api/serial/SerialPort/#methods","text":"","title":"Methods"},{"location":"api/serial/SerialPort/#serialport_1","text":"public void SerialPort() SerialPort constructor sets up in/outstream refs. Note that existence of cstr forces class to be final. Doc Home > API Index > serial > SerialPort","title":"SerialPort"},{"location":"api/serial/SerialPortEmu/","text":"SerialPortEmu \u00b6 Doc Home > API Index > serial > SerialPortEmu Inheritance \u00b6 sys::Obj sys::Virtual serial::SerialPortGeneric serial::SerialPortNative serial::SerialPortEmu public class SerialPortEmu Fields \u00b6 buf \u00b6 public static inline int[] buf bufferSize \u00b6 public static const define int bufferSize inIndx \u00b6 public static byte inIndx indxMask \u00b6 public static byte indxMask outIndx \u00b6 public static byte outIndx Methods \u00b6 doClose \u00b6 public override int doClose(int port) doInit \u00b6 public override int doInit(int port, int baud, int dataB, int stopB, int par, int rts, bool rs485) doRead \u00b6 public override int doRead(int port) doReadBytes \u00b6 public override int doReadBytes(int port, byte[] y, int off, int len) doWrite \u00b6 public override int doWrite(int port, int b) doWriteBytes \u00b6 public override int doWriteBytes(int port, byte[] y, int off, int len) isVirtualPort \u00b6 public bool isVirtualPort() Doc Home > API Index > serial > SerialPortEmu","title":"SerialPortEmu"},{"location":"api/serial/SerialPortEmu/#serialportemu","text":"Doc Home > API Index > serial > SerialPortEmu","title":"SerialPortEmu"},{"location":"api/serial/SerialPortEmu/#inheritance","text":"sys::Obj sys::Virtual serial::SerialPortGeneric serial::SerialPortNative serial::SerialPortEmu public class SerialPortEmu","title":"Inheritance"},{"location":"api/serial/SerialPortEmu/#fields","text":"","title":"Fields"},{"location":"api/serial/SerialPortEmu/#buf","text":"public static inline int[] buf","title":"buf"},{"location":"api/serial/SerialPortEmu/#buffersize","text":"public static const define int bufferSize","title":"bufferSize"},{"location":"api/serial/SerialPortEmu/#inindx","text":"public static byte inIndx","title":"inIndx"},{"location":"api/serial/SerialPortEmu/#indxmask","text":"public static byte indxMask","title":"indxMask"},{"location":"api/serial/SerialPortEmu/#outindx","text":"public static byte outIndx","title":"outIndx"},{"location":"api/serial/SerialPortEmu/#methods","text":"","title":"Methods"},{"location":"api/serial/SerialPortEmu/#doclose","text":"public override int doClose(int port)","title":"doClose"},{"location":"api/serial/SerialPortEmu/#doinit","text":"public override int doInit(int port, int baud, int dataB, int stopB, int par, int rts, bool rs485)","title":"doInit"},{"location":"api/serial/SerialPortEmu/#doread","text":"public override int doRead(int port)","title":"doRead"},{"location":"api/serial/SerialPortEmu/#doreadbytes","text":"public override int doReadBytes(int port, byte[] y, int off, int len)","title":"doReadBytes"},{"location":"api/serial/SerialPortEmu/#dowrite","text":"public override int doWrite(int port, int b)","title":"doWrite"},{"location":"api/serial/SerialPortEmu/#dowritebytes","text":"public override int doWriteBytes(int port, byte[] y, int off, int len)","title":"doWriteBytes"},{"location":"api/serial/SerialPortEmu/#isvirtualport","text":"public bool isVirtualPort() Doc Home > API Index > serial > SerialPortEmu","title":"isVirtualPort"},{"location":"api/serial/SerialPortGeneric/","text":"SerialPortGeneric \u00b6 Doc Home > API Index > serial > SerialPortGeneric Inheritance \u00b6 sys::Obj sys::Virtual serial::SerialPortGeneric public abstract class SerialPortGeneric SerialPort models a serial I/O port without software buffering. Fields \u00b6 PARITY_DISABLED \u00b6 public static const define int PARITY_DISABLED Value of parity field when parity is disabled PARITY_EVEN \u00b6 public static const define int PARITY_EVEN Value of parity field for even parity PARITY_MARK \u00b6 public static const define int PARITY_MARK Value of parity field for mark parity PARITY_NONE \u00b6 public static const define int PARITY_NONE Value of parity field for no parity PARITY_ODD \u00b6 public static const define int PARITY_ODD Value of parity field for odd parity PARITY_SPACE \u00b6 public static const define int PARITY_SPACE Value of parity field for space parity RTS_HIGH \u00b6 public static const define int RTS_HIGH Value of rtsLevel field if RTS should initially be high (active low) RTS_LOW \u00b6 public static const define int RTS_LOW Value of rtsLevel field if RTS should initially be low (active high) baudRate \u00b6 public int baudRate Integer value of baud rate; set of permissible values is platform-dependent. Defaults to 38400. dataBits \u00b6 public int dataBits Integer number of data bits. Defaults to 8. in \u00b6 public inline InStream in Stream interface for reading from port. out \u00b6 public inline OutStream out Stream interface for writing to port. parity \u00b6 public int parity Parity: DISABLED/NONE/ODD/EVEN/MARK/SPACE (use consts provided). Defaults to NONE. portNum \u00b6 public int portNum Hardware address of port (meaning may vary w/platform). rs485 \u00b6 public bool rs485 Is this rs485 interface? RTS signal is used to control DE signal for RS485 driver rtsLevel \u00b6 public int rtsLevel Initial RTS level: HIGH or LOW. Defaults to LOW. This value is also assumed to be the RTS inactive level. (e.g. RTS_LOW implies RTS active high) stopBits \u00b6 public int stopBits Integer number of stop bits. Defaults to 1. Methods \u00b6 close \u00b6 public int close() Closes the port. Subsequent attempts to read or write from the port will return errors. doClose \u00b6 public abstract int doClose(int port) Shut down the serial port. Return 0 if successful. doInit \u00b6 public abstract int doInit(int port, int baud, int datab, int stopb, int par, int rts, bool rs485) Set the serial parameters for the port. If any params are bad, do nothing and return -1, otherwise return 0. doRead \u00b6 public abstract int doRead(int port) Read one byte from port. Return byte value, or -1 if no byte was available. (non-blocking) doReadBytes \u00b6 public abstract int doReadBytes(int port, byte[] y, int off, int len) Read up to n bytes from port into array y. Return number of bytes read, or -1 if an error occurred. (non-blocking) doWrite \u00b6 public abstract int doWrite(int port, int c) Write one byte to port. Return -1 if any error, or 0 if successful. doWriteBytes \u00b6 public abstract int doWriteBytes(int port, byte[] y, int off, int len) Write up to n bytes to port from array y. Return number of bytes written, or -1 if an error occurred. open \u00b6 public int open() Opens/initializes serial port using current values of config params. setParams \u00b6 public int setParams(int port, int baud, int dataB, int stopB, int par, int rts, bool rs485) Sets all params at once - no error checking at this time Doc Home > API Index > serial > SerialPortGeneric","title":"SerialPortGeneric"},{"location":"api/serial/SerialPortGeneric/#serialportgeneric","text":"Doc Home > API Index > serial > SerialPortGeneric","title":"SerialPortGeneric"},{"location":"api/serial/SerialPortGeneric/#inheritance","text":"sys::Obj sys::Virtual serial::SerialPortGeneric public abstract class SerialPortGeneric SerialPort models a serial I/O port without software buffering.","title":"Inheritance"},{"location":"api/serial/SerialPortGeneric/#fields","text":"","title":"Fields"},{"location":"api/serial/SerialPortGeneric/#parity_disabled","text":"public static const define int PARITY_DISABLED Value of parity field when parity is disabled","title":"PARITY_DISABLED"},{"location":"api/serial/SerialPortGeneric/#parity_even","text":"public static const define int PARITY_EVEN Value of parity field for even parity","title":"PARITY_EVEN"},{"location":"api/serial/SerialPortGeneric/#parity_mark","text":"public static const define int PARITY_MARK Value of parity field for mark parity","title":"PARITY_MARK"},{"location":"api/serial/SerialPortGeneric/#parity_none","text":"public static const define int PARITY_NONE Value of parity field for no parity","title":"PARITY_NONE"},{"location":"api/serial/SerialPortGeneric/#parity_odd","text":"public static const define int PARITY_ODD Value of parity field for odd parity","title":"PARITY_ODD"},{"location":"api/serial/SerialPortGeneric/#parity_space","text":"public static const define int PARITY_SPACE Value of parity field for space parity","title":"PARITY_SPACE"},{"location":"api/serial/SerialPortGeneric/#rts_high","text":"public static const define int RTS_HIGH Value of rtsLevel field if RTS should initially be high (active low)","title":"RTS_HIGH"},{"location":"api/serial/SerialPortGeneric/#rts_low","text":"public static const define int RTS_LOW Value of rtsLevel field if RTS should initially be low (active high)","title":"RTS_LOW"},{"location":"api/serial/SerialPortGeneric/#baudrate","text":"public int baudRate Integer value of baud rate; set of permissible values is platform-dependent. Defaults to 38400.","title":"baudRate"},{"location":"api/serial/SerialPortGeneric/#databits","text":"public int dataBits Integer number of data bits. Defaults to 8.","title":"dataBits"},{"location":"api/serial/SerialPortGeneric/#in","text":"public inline InStream in Stream interface for reading from port.","title":"in"},{"location":"api/serial/SerialPortGeneric/#out","text":"public inline OutStream out Stream interface for writing to port.","title":"out"},{"location":"api/serial/SerialPortGeneric/#parity","text":"public int parity Parity: DISABLED/NONE/ODD/EVEN/MARK/SPACE (use consts provided). Defaults to NONE.","title":"parity"},{"location":"api/serial/SerialPortGeneric/#portnum","text":"public int portNum Hardware address of port (meaning may vary w/platform).","title":"portNum"},{"location":"api/serial/SerialPortGeneric/#rs485","text":"public bool rs485 Is this rs485 interface? RTS signal is used to control DE signal for RS485 driver","title":"rs485"},{"location":"api/serial/SerialPortGeneric/#rtslevel","text":"public int rtsLevel Initial RTS level: HIGH or LOW. Defaults to LOW. This value is also assumed to be the RTS inactive level. (e.g. RTS_LOW implies RTS active high)","title":"rtsLevel"},{"location":"api/serial/SerialPortGeneric/#stopbits","text":"public int stopBits Integer number of stop bits. Defaults to 1.","title":"stopBits"},{"location":"api/serial/SerialPortGeneric/#methods","text":"","title":"Methods"},{"location":"api/serial/SerialPortGeneric/#close","text":"public int close() Closes the port. Subsequent attempts to read or write from the port will return errors.","title":"close"},{"location":"api/serial/SerialPortGeneric/#doclose","text":"public abstract int doClose(int port) Shut down the serial port. Return 0 if successful.","title":"doClose"},{"location":"api/serial/SerialPortGeneric/#doinit","text":"public abstract int doInit(int port, int baud, int datab, int stopb, int par, int rts, bool rs485) Set the serial parameters for the port. If any params are bad, do nothing and return -1, otherwise return 0.","title":"doInit"},{"location":"api/serial/SerialPortGeneric/#doread","text":"public abstract int doRead(int port) Read one byte from port. Return byte value, or -1 if no byte was available. (non-blocking)","title":"doRead"},{"location":"api/serial/SerialPortGeneric/#doreadbytes","text":"public abstract int doReadBytes(int port, byte[] y, int off, int len) Read up to n bytes from port into array y. Return number of bytes read, or -1 if an error occurred. (non-blocking)","title":"doReadBytes"},{"location":"api/serial/SerialPortGeneric/#dowrite","text":"public abstract int doWrite(int port, int c) Write one byte to port. Return -1 if any error, or 0 if successful.","title":"doWrite"},{"location":"api/serial/SerialPortGeneric/#dowritebytes","text":"public abstract int doWriteBytes(int port, byte[] y, int off, int len) Write up to n bytes to port from array y. Return number of bytes written, or -1 if an error occurred.","title":"doWriteBytes"},{"location":"api/serial/SerialPortGeneric/#open","text":"public int open() Opens/initializes serial port using current values of config params.","title":"open"},{"location":"api/serial/SerialPortGeneric/#setparams","text":"public int setParams(int port, int baud, int dataB, int stopB, int par, int rts, bool rs485) Sets all params at once - no error checking at this time Doc Home > API Index > serial > SerialPortGeneric","title":"setParams"},{"location":"api/serial/SerialPortNative/","text":"SerialPortNative \u00b6 Doc Home > API Index > serial > SerialPortNative Inheritance \u00b6 sys::Obj sys::Virtual serial::SerialPortGeneric serial::SerialPortNative public class SerialPortNative Fields \u00b6 Methods \u00b6 doClose \u00b6 public virtual override int doClose(int port) doInit \u00b6 public virtual override int doInit(int port, int baud, int datab, int stopb, int par, int rts, bool rs485) doRead \u00b6 public virtual override int doRead(int port) doReadBytes \u00b6 public virtual override int doReadBytes(int port, byte[] y, int off, int len) doWrite \u00b6 public virtual override int doWrite(int port, int c) doWriteBytes \u00b6 public virtual override int doWriteBytes(int port, byte[] y, int off, int len) Doc Home > API Index > serial > SerialPortNative","title":"SerialPortNative"},{"location":"api/serial/SerialPortNative/#serialportnative","text":"Doc Home > API Index > serial > SerialPortNative","title":"SerialPortNative"},{"location":"api/serial/SerialPortNative/#inheritance","text":"sys::Obj sys::Virtual serial::SerialPortGeneric serial::SerialPortNative public class SerialPortNative","title":"Inheritance"},{"location":"api/serial/SerialPortNative/#fields","text":"","title":"Fields"},{"location":"api/serial/SerialPortNative/#methods","text":"","title":"Methods"},{"location":"api/serial/SerialPortNative/#doclose","text":"public virtual override int doClose(int port)","title":"doClose"},{"location":"api/serial/SerialPortNative/#doinit","text":"public virtual override int doInit(int port, int baud, int datab, int stopb, int par, int rts, bool rs485)","title":"doInit"},{"location":"api/serial/SerialPortNative/#doread","text":"public virtual override int doRead(int port)","title":"doRead"},{"location":"api/serial/SerialPortNative/#doreadbytes","text":"public virtual override int doReadBytes(int port, byte[] y, int off, int len)","title":"doReadBytes"},{"location":"api/serial/SerialPortNative/#dowrite","text":"public virtual override int doWrite(int port, int c)","title":"doWrite"},{"location":"api/serial/SerialPortNative/#dowritebytes","text":"public virtual override int doWriteBytes(int port, byte[] y, int off, int len) Doc Home > API Index > serial > SerialPortNative","title":"doWriteBytes"},{"location":"api/sox/","text":"sox \u00b6 Doc Home > API Index > sox Sox service for remote management Dasp \u00b6 FileTransfer \u00b6 ReceiveWindow \u00b6 SendPacket \u00b6 SendWindow \u00b6 SoxCert \u00b6 SoxCommands \u00b6 SoxService \u00b6 SoxSession \u00b6 Doc Home > API Index > sox","title":"Index"},{"location":"api/sox/#sox","text":"Doc Home > API Index > sox Sox service for remote management","title":"sox"},{"location":"api/sox/#dasp","text":"","title":"Dasp"},{"location":"api/sox/#filetransfer","text":"","title":"FileTransfer"},{"location":"api/sox/#receivewindow","text":"","title":"ReceiveWindow"},{"location":"api/sox/#sendpacket","text":"","title":"SendPacket"},{"location":"api/sox/#sendwindow","text":"","title":"SendWindow"},{"location":"api/sox/#soxcert","text":"","title":"SoxCert"},{"location":"api/sox/#soxcommands","text":"","title":"SoxCommands"},{"location":"api/sox/#soxservice","text":"","title":"SoxService"},{"location":"api/sox/#soxsession","text":"Doc Home > API Index > sox","title":"SoxSession"},{"location":"api/sox/Dasp/","text":"Dasp \u00b6 Doc Home > API Index > sox > Dasp Inheritance \u00b6 sys::Obj sox::Dasp public class Dasp Dasp constants Fields \u00b6 ABS_MAX \u00b6 public static const define int ABS_MAX ABS_MAX_DEF \u00b6 public static const define int ABS_MAX_DEF ABS_MAX_VAL \u00b6 public static const define int ABS_MAX_VAL ACK \u00b6 public static const define int ACK ACK_MORE \u00b6 public static const define int ACK_MORE AUTHENTICATE \u00b6 public static const define int AUTHENTICATE BUSY \u00b6 public static const define int BUSY BYTES \u00b6 public static const define int BYTES CHALLENGE \u00b6 public static const define int CHALLENGE CLOSE \u00b6 public static const define int CLOSE DATAGRAM \u00b6 public static const define int DATAGRAM DIGEST \u00b6 public static const define int DIGEST DIGEST_ALGORITHM \u00b6 public static const define int DIGEST_ALGORITHM DIGEST_NOT_SUPPORTED \u00b6 public static const define int DIGEST_NOT_SUPPORTED DISCOVER \u00b6 public static const define int DISCOVER ERROR_CODE \u00b6 public static const define int ERROR_CODE HELLO \u00b6 public static const define int HELLO IDEAL_MAX \u00b6 public static const define int IDEAL_MAX IDEAL_MAX_DEF \u00b6 public static const define int IDEAL_MAX_DEF IDEAL_MAX_VAL \u00b6 public static short IDEAL_MAX_VAL INCOMPATIBLE_VERSION \u00b6 public static const define int INCOMPATIBLE_VERSION KEEPALIVE \u00b6 public static const define int KEEPALIVE NIL \u00b6 public static const define int NIL NONCE \u00b6 public static const define int NONCE NOT_AUTHENTICATED \u00b6 public static const define int NOT_AUTHENTICATED PLATFORM_ID \u00b6 public static const define int PLATFORM_ID RECEIVE_MAX \u00b6 public static const define int RECEIVE_MAX RECEIVE_MAX_DEF \u00b6 public static const define int RECEIVE_MAX_DEF RECEIVE_MAX_VAL \u00b6 public static const define int RECEIVE_MAX_VAL RECEIVE_TIMEOUT \u00b6 public static const define int RECEIVE_TIMEOUT RECEIVE_TIMEOUT_DEF \u00b6 public static const define int RECEIVE_TIMEOUT_DEF RECEIVE_TIMEOUT_MIN \u00b6 public static const define int RECEIVE_TIMEOUT_MIN REMOTE_ID \u00b6 public static const define int REMOTE_ID STR \u00b6 public static const define int STR TIMEOUT \u00b6 public static const define int TIMEOUT U2 \u00b6 public static const define int U2 USERNAME \u00b6 public static const define int USERNAME VERSION \u00b6 public static const define int VERSION VERSION_VAL \u00b6 public static const define int VERSION_VAL WELCOME \u00b6 public static const define int WELCOME Doc Home > API Index > sox > Dasp","title":"Dasp"},{"location":"api/sox/Dasp/#dasp","text":"Doc Home > API Index > sox > Dasp","title":"Dasp"},{"location":"api/sox/Dasp/#inheritance","text":"sys::Obj sox::Dasp public class Dasp Dasp constants","title":"Inheritance"},{"location":"api/sox/Dasp/#fields","text":"","title":"Fields"},{"location":"api/sox/Dasp/#abs_max","text":"public static const define int ABS_MAX","title":"ABS_MAX"},{"location":"api/sox/Dasp/#abs_max_def","text":"public static const define int ABS_MAX_DEF","title":"ABS_MAX_DEF"},{"location":"api/sox/Dasp/#abs_max_val","text":"public static const define int ABS_MAX_VAL","title":"ABS_MAX_VAL"},{"location":"api/sox/Dasp/#ack","text":"public static const define int ACK","title":"ACK"},{"location":"api/sox/Dasp/#ack_more","text":"public static const define int ACK_MORE","title":"ACK_MORE"},{"location":"api/sox/Dasp/#authenticate","text":"public static const define int AUTHENTICATE","title":"AUTHENTICATE"},{"location":"api/sox/Dasp/#busy","text":"public static const define int BUSY","title":"BUSY"},{"location":"api/sox/Dasp/#bytes","text":"public static const define int BYTES","title":"BYTES"},{"location":"api/sox/Dasp/#challenge","text":"public static const define int CHALLENGE","title":"CHALLENGE"},{"location":"api/sox/Dasp/#close","text":"public static const define int CLOSE","title":"CLOSE"},{"location":"api/sox/Dasp/#datagram","text":"public static const define int DATAGRAM","title":"DATAGRAM"},{"location":"api/sox/Dasp/#digest","text":"public static const define int DIGEST","title":"DIGEST"},{"location":"api/sox/Dasp/#digest_algorithm","text":"public static const define int DIGEST_ALGORITHM","title":"DIGEST_ALGORITHM"},{"location":"api/sox/Dasp/#digest_not_supported","text":"public static const define int DIGEST_NOT_SUPPORTED","title":"DIGEST_NOT_SUPPORTED"},{"location":"api/sox/Dasp/#discover","text":"public static const define int DISCOVER","title":"DISCOVER"},{"location":"api/sox/Dasp/#error_code","text":"public static const define int ERROR_CODE","title":"ERROR_CODE"},{"location":"api/sox/Dasp/#hello","text":"public static const define int HELLO","title":"HELLO"},{"location":"api/sox/Dasp/#ideal_max","text":"public static const define int IDEAL_MAX","title":"IDEAL_MAX"},{"location":"api/sox/Dasp/#ideal_max_def","text":"public static const define int IDEAL_MAX_DEF","title":"IDEAL_MAX_DEF"},{"location":"api/sox/Dasp/#ideal_max_val","text":"public static short IDEAL_MAX_VAL","title":"IDEAL_MAX_VAL"},{"location":"api/sox/Dasp/#incompatible_version","text":"public static const define int INCOMPATIBLE_VERSION","title":"INCOMPATIBLE_VERSION"},{"location":"api/sox/Dasp/#keepalive","text":"public static const define int KEEPALIVE","title":"KEEPALIVE"},{"location":"api/sox/Dasp/#nil","text":"public static const define int NIL","title":"NIL"},{"location":"api/sox/Dasp/#nonce","text":"public static const define int NONCE","title":"NONCE"},{"location":"api/sox/Dasp/#not_authenticated","text":"public static const define int NOT_AUTHENTICATED","title":"NOT_AUTHENTICATED"},{"location":"api/sox/Dasp/#platform_id","text":"public static const define int PLATFORM_ID","title":"PLATFORM_ID"},{"location":"api/sox/Dasp/#receive_max","text":"public static const define int RECEIVE_MAX","title":"RECEIVE_MAX"},{"location":"api/sox/Dasp/#receive_max_def","text":"public static const define int RECEIVE_MAX_DEF","title":"RECEIVE_MAX_DEF"},{"location":"api/sox/Dasp/#receive_max_val","text":"public static const define int RECEIVE_MAX_VAL","title":"RECEIVE_MAX_VAL"},{"location":"api/sox/Dasp/#receive_timeout","text":"public static const define int RECEIVE_TIMEOUT","title":"RECEIVE_TIMEOUT"},{"location":"api/sox/Dasp/#receive_timeout_def","text":"public static const define int RECEIVE_TIMEOUT_DEF","title":"RECEIVE_TIMEOUT_DEF"},{"location":"api/sox/Dasp/#receive_timeout_min","text":"public static const define int RECEIVE_TIMEOUT_MIN","title":"RECEIVE_TIMEOUT_MIN"},{"location":"api/sox/Dasp/#remote_id","text":"public static const define int REMOTE_ID","title":"REMOTE_ID"},{"location":"api/sox/Dasp/#str","text":"public static const define int STR","title":"STR"},{"location":"api/sox/Dasp/#timeout","text":"public static const define int TIMEOUT","title":"TIMEOUT"},{"location":"api/sox/Dasp/#u2","text":"public static const define int U2","title":"U2"},{"location":"api/sox/Dasp/#username","text":"public static const define int USERNAME","title":"USERNAME"},{"location":"api/sox/Dasp/#version","text":"public static const define int VERSION","title":"VERSION"},{"location":"api/sox/Dasp/#version_val","text":"public static const define int VERSION_VAL","title":"VERSION_VAL"},{"location":"api/sox/Dasp/#welcome","text":"public static const define int WELCOME Doc Home > API Index > sox > Dasp","title":"WELCOME"},{"location":"api/sox/FileTransfer/","text":"FileTransfer \u00b6 Doc Home > API Index > sox > FileTransfer Inheritance \u00b6 sys::Obj sox::FileTransfer public class FileTransfer FileTransfer manages the state of a session's file transfer. Fields \u00b6 chunkSize \u00b6 public short chunkSize file \u00b6 public inline File file fileSize \u00b6 public int fileSize get \u00b6 public static const define int get mode \u00b6 public byte mode nextChunk \u00b6 public short nextChunk numChunks \u00b6 public short numChunks offset \u00b6 public int offset put \u00b6 public static const define int put unused \u00b6 public static const define int unused Methods \u00b6 checkGet \u00b6 public bool checkGet( SoxService service, SoxSession session) Poll for work on a get. Attempt to send the next chunk of a file get. checkPut \u00b6 public bool checkPut( SoxService service, SoxSession session) Poll for work on a put. Check if we need to send the close. reset \u00b6 public void reset() Reset into a clean state for new session. Doc Home > API Index > sox > FileTransfer","title":"FileTransfer"},{"location":"api/sox/FileTransfer/#filetransfer","text":"Doc Home > API Index > sox > FileTransfer","title":"FileTransfer"},{"location":"api/sox/FileTransfer/#inheritance","text":"sys::Obj sox::FileTransfer public class FileTransfer FileTransfer manages the state of a session's file transfer.","title":"Inheritance"},{"location":"api/sox/FileTransfer/#fields","text":"","title":"Fields"},{"location":"api/sox/FileTransfer/#chunksize","text":"public short chunkSize","title":"chunkSize"},{"location":"api/sox/FileTransfer/#file","text":"public inline File file","title":"file"},{"location":"api/sox/FileTransfer/#filesize","text":"public int fileSize","title":"fileSize"},{"location":"api/sox/FileTransfer/#get","text":"public static const define int get","title":"get"},{"location":"api/sox/FileTransfer/#mode","text":"public byte mode","title":"mode"},{"location":"api/sox/FileTransfer/#nextchunk","text":"public short nextChunk","title":"nextChunk"},{"location":"api/sox/FileTransfer/#numchunks","text":"public short numChunks","title":"numChunks"},{"location":"api/sox/FileTransfer/#offset","text":"public int offset","title":"offset"},{"location":"api/sox/FileTransfer/#put","text":"public static const define int put","title":"put"},{"location":"api/sox/FileTransfer/#unused","text":"public static const define int unused","title":"unused"},{"location":"api/sox/FileTransfer/#methods","text":"","title":"Methods"},{"location":"api/sox/FileTransfer/#checkget","text":"public bool checkGet( SoxService service, SoxSession session) Poll for work on a get. Attempt to send the next chunk of a file get.","title":"checkGet"},{"location":"api/sox/FileTransfer/#checkput","text":"public bool checkPut( SoxService service, SoxSession session) Poll for work on a put. Check if we need to send the close.","title":"checkPut"},{"location":"api/sox/FileTransfer/#reset","text":"public void reset() Reset into a clean state for new session. Doc Home > API Index > sox > FileTransfer","title":"reset"},{"location":"api/sox/ReceiveWindow/","text":"ReceiveWindow \u00b6 Doc Home > API Index > sox > ReceiveWindow Inheritance \u00b6 sys::Obj sox::ReceiveWindow public class ReceiveWindow ReceiveWindow manages the incoming message sequences and acknowledgements. Fields \u00b6 max \u00b6 public static const define int max Methods \u00b6 init \u00b6 public void init(int num) Initialize the receive window with the handshake seqNum. receive \u00b6 public bool receive(int num) Receive the given sequence number. Return true if the message should be processed. Return false if outside of the receiving window or we have already processed it. reset \u00b6 public void reset() Reset into a clean state for new session. setAckHeaders \u00b6 public void setAckHeaders( SoxService service) If add the ack and ackMore headers if needed. Doc Home > API Index > sox > ReceiveWindow","title":"ReceiveWindow"},{"location":"api/sox/ReceiveWindow/#receivewindow","text":"Doc Home > API Index > sox > ReceiveWindow","title":"ReceiveWindow"},{"location":"api/sox/ReceiveWindow/#inheritance","text":"sys::Obj sox::ReceiveWindow public class ReceiveWindow ReceiveWindow manages the incoming message sequences and acknowledgements.","title":"Inheritance"},{"location":"api/sox/ReceiveWindow/#fields","text":"","title":"Fields"},{"location":"api/sox/ReceiveWindow/#max","text":"public static const define int max","title":"max"},{"location":"api/sox/ReceiveWindow/#methods","text":"","title":"Methods"},{"location":"api/sox/ReceiveWindow/#init","text":"public void init(int num) Initialize the receive window with the handshake seqNum.","title":"init"},{"location":"api/sox/ReceiveWindow/#receive","text":"public bool receive(int num) Receive the given sequence number. Return true if the message should be processed. Return false if outside of the receiving window or we have already processed it.","title":"receive"},{"location":"api/sox/ReceiveWindow/#reset","text":"public void reset() Reset into a clean state for new session.","title":"reset"},{"location":"api/sox/ReceiveWindow/#setackheaders","text":"public void setAckHeaders( SoxService service) If add the ack and ackMore headers if needed. Doc Home > API Index > sox > ReceiveWindow","title":"setAckHeaders"},{"location":"api/sox/SendPacket/","text":"SendPacket \u00b6 Doc Home > API Index > sox > SendPacket Inheritance \u00b6 sys::Obj sox::SendPacket public class SendPacket SendPacket Fields \u00b6 age \u00b6 public byte age cmd \u00b6 public byte cmd refData \u00b6 public Obj refData replyNum \u00b6 public byte replyNum seqNum \u00b6 public short seqNum u2Data1 \u00b6 public short u2Data1 u2Data2 \u00b6 public short u2Data2 Methods \u00b6 error \u00b6 public void error( Str cause) Doc Home > API Index > sox > SendPacket","title":"SendPacket"},{"location":"api/sox/SendPacket/#sendpacket","text":"Doc Home > API Index > sox > SendPacket","title":"SendPacket"},{"location":"api/sox/SendPacket/#inheritance","text":"sys::Obj sox::SendPacket public class SendPacket SendPacket","title":"Inheritance"},{"location":"api/sox/SendPacket/#fields","text":"","title":"Fields"},{"location":"api/sox/SendPacket/#age","text":"public byte age","title":"age"},{"location":"api/sox/SendPacket/#cmd","text":"public byte cmd","title":"cmd"},{"location":"api/sox/SendPacket/#refdata","text":"public Obj refData","title":"refData"},{"location":"api/sox/SendPacket/#replynum","text":"public byte replyNum","title":"replyNum"},{"location":"api/sox/SendPacket/#seqnum","text":"public short seqNum","title":"seqNum"},{"location":"api/sox/SendPacket/#u2data1","text":"public short u2Data1","title":"u2Data1"},{"location":"api/sox/SendPacket/#u2data2","text":"public short u2Data2","title":"u2Data2"},{"location":"api/sox/SendPacket/#methods","text":"","title":"Methods"},{"location":"api/sox/SendPacket/#error","text":"public void error( Str cause) Doc Home > API Index > sox > SendPacket","title":"error"},{"location":"api/sox/SendWindow/","text":"SendWindow \u00b6 Doc Home > API Index > sox > SendWindow Inheritance \u00b6 sys::Obj sox::SendWindow public class SendWindow SendWindow manages the outgoing messages and keeps enough information needed to recreate the message on a retry. Fields \u00b6 PKT_RETRY_INTERVAL \u00b6 public static const define int PKT_RETRY_INTERVAL max \u00b6 public static const define int max numUnacked \u00b6 public byte numUnacked packets \u00b6 public inline SendPacket [] packets seqNum \u00b6 public short seqNum Methods \u00b6 checkAckHeaders \u00b6 public bool checkAckHeaders( SoxService service, int numFields) If we have any ack headers then process them. Return true if the sending window isn't full - if we return false, then we don't have room to store any additional outgoing messages. isAcked \u00b6 public bool isAcked(int unackStart, int unackEnd, int ackNum, byte[] ackMore, int ackMoreOff, int ackMoreLen, int seqNum) Return if the specified seqNum should be considered acked. The unackStart and unackEnd define the inclusive range of what the remote endpoint has not acked (which means anything outside of that range is immediately considered acked). We also check our ackMore mask for unordered acks. nextPacket \u00b6 public SendPacket nextPacket() Allocate a SendPacket which stores how to resend the message. nextSeqNum \u00b6 public int nextSeqNum() Allocate the next outgoing sequence number. reset \u00b6 public void reset() Reset into a clean state for new session. sendRetries \u00b6 public bool sendRetries( SoxService service, SoxSession session, int houseKeepingTicks) If we have any unacked outgoing messages, then resend them. Return if we did work. Doc Home > API Index > sox > SendWindow","title":"SendWindow"},{"location":"api/sox/SendWindow/#sendwindow","text":"Doc Home > API Index > sox > SendWindow","title":"SendWindow"},{"location":"api/sox/SendWindow/#inheritance","text":"sys::Obj sox::SendWindow public class SendWindow SendWindow manages the outgoing messages and keeps enough information needed to recreate the message on a retry.","title":"Inheritance"},{"location":"api/sox/SendWindow/#fields","text":"","title":"Fields"},{"location":"api/sox/SendWindow/#pkt_retry_interval","text":"public static const define int PKT_RETRY_INTERVAL","title":"PKT_RETRY_INTERVAL"},{"location":"api/sox/SendWindow/#max","text":"public static const define int max","title":"max"},{"location":"api/sox/SendWindow/#numunacked","text":"public byte numUnacked","title":"numUnacked"},{"location":"api/sox/SendWindow/#packets","text":"public inline SendPacket [] packets","title":"packets"},{"location":"api/sox/SendWindow/#seqnum","text":"public short seqNum","title":"seqNum"},{"location":"api/sox/SendWindow/#methods","text":"","title":"Methods"},{"location":"api/sox/SendWindow/#checkackheaders","text":"public bool checkAckHeaders( SoxService service, int numFields) If we have any ack headers then process them. Return true if the sending window isn't full - if we return false, then we don't have room to store any additional outgoing messages.","title":"checkAckHeaders"},{"location":"api/sox/SendWindow/#isacked","text":"public bool isAcked(int unackStart, int unackEnd, int ackNum, byte[] ackMore, int ackMoreOff, int ackMoreLen, int seqNum) Return if the specified seqNum should be considered acked. The unackStart and unackEnd define the inclusive range of what the remote endpoint has not acked (which means anything outside of that range is immediately considered acked). We also check our ackMore mask for unordered acks.","title":"isAcked"},{"location":"api/sox/SendWindow/#nextpacket","text":"public SendPacket nextPacket() Allocate a SendPacket which stores how to resend the message.","title":"nextPacket"},{"location":"api/sox/SendWindow/#nextseqnum","text":"public int nextSeqNum() Allocate the next outgoing sequence number.","title":"nextSeqNum"},{"location":"api/sox/SendWindow/#reset","text":"public void reset() Reset into a clean state for new session.","title":"reset"},{"location":"api/sox/SendWindow/#sendretries","text":"public bool sendRetries( SoxService service, SoxSession session, int houseKeepingTicks) If we have any unacked outgoing messages, then resend them. Return if we did work. Doc Home > API Index > sox > SendWindow","title":"sendRetries"},{"location":"api/sox/SoxCert/","text":"SoxCert \u00b6 Doc Home > API Index > sox > SoxCert Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sox::SoxCert public class SoxCert [palette=false] SoxCert is used as the Sedona side component of the Sox certification testing. Fields \u00b6 b \u00b6 public property byte b [config] buf \u00b6 public inline property Buf buf [max=4] d \u00b6 public property double d f \u00b6 public property float f i \u00b6 public property int i l \u00b6 public property long l s \u00b6 public property short s z \u00b6 public property bool z [config] Methods \u00b6 abuf \u00b6 public action void abuf( Buf b) ad \u00b6 public action void ad(double d) ai \u00b6 public action void ai(int i) av \u00b6 public action void av() name2buf \u00b6 public action void name2buf() Doc Home > API Index > sox > SoxCert","title":"SoxCert"},{"location":"api/sox/SoxCert/#soxcert","text":"Doc Home > API Index > sox > SoxCert","title":"SoxCert"},{"location":"api/sox/SoxCert/#inheritance","text":"sys::Obj sys::Virtual sys::Component sox::SoxCert public class SoxCert [palette=false] SoxCert is used as the Sedona side component of the Sox certification testing.","title":"Inheritance"},{"location":"api/sox/SoxCert/#fields","text":"","title":"Fields"},{"location":"api/sox/SoxCert/#b","text":"public property byte b [config]","title":"b"},{"location":"api/sox/SoxCert/#buf","text":"public inline property Buf buf [max=4]","title":"buf"},{"location":"api/sox/SoxCert/#d","text":"public property double d","title":"d"},{"location":"api/sox/SoxCert/#f","text":"public property float f","title":"f"},{"location":"api/sox/SoxCert/#i","text":"public property int i","title":"i"},{"location":"api/sox/SoxCert/#l","text":"public property long l","title":"l"},{"location":"api/sox/SoxCert/#s","text":"public property short s","title":"s"},{"location":"api/sox/SoxCert/#z","text":"public property bool z [config]","title":"z"},{"location":"api/sox/SoxCert/#methods","text":"","title":"Methods"},{"location":"api/sox/SoxCert/#abuf","text":"public action void abuf( Buf b)","title":"abuf"},{"location":"api/sox/SoxCert/#ad","text":"public action void ad(double d)","title":"ad"},{"location":"api/sox/SoxCert/#ai","text":"public action void ai(int i)","title":"ai"},{"location":"api/sox/SoxCert/#av","text":"public action void av()","title":"av"},{"location":"api/sox/SoxCert/#name2buf","text":"public action void name2buf() Doc Home > API Index > sox > SoxCert","title":"name2buf"},{"location":"api/sox/SoxCommands/","text":"SoxCommands \u00b6 Doc Home > API Index > sox > SoxCommands Inheritance \u00b6 sys::Obj sox::SoxCommands public class SoxCommands SoxCommands processes all the sox command request/response. Fields \u00b6 tempKey \u00b6 public static Str tempKey tempStr1 \u00b6 public static Str tempStr1 tempStr2 \u00b6 public static Str tempStr2 tempVal \u00b6 public static Str tempVal Methods \u00b6 addReq \u00b6 public static void addReq( SoxService service, SoxSession session, SendPacket res) req { u1 'a' u1 replyNum u2 parentId u1 kitId u1 typeId str name val[] configProps } addRes \u00b6 public static void addRes( SoxService service, SoxSession session, SendPacket res) res { u1 'A' u1 replyNum u2 compId } deleteReq \u00b6 public static void deleteReq( SoxService service, SoxSession session, SendPacket res) req { u1 'd' u1 replyNum u2 compId } eventRes \u00b6 public static void eventRes( SoxService service, SoxSession session, SendPacket p) req { u1 'e' u1 replyNum u2 componentId compTree | compProps | compLinks } fileCloseReq \u00b6 public static void fileCloseReq( SoxService service, SoxSession session, SendPacket res) req { u1 'z' u1 replyNum } fileCloseRes \u00b6 public static void fileCloseRes( SoxService service, SoxSession session, SendPacket res) res { u1 'Z' u1 replyNum } fileOpenReq \u00b6 public static void fileOpenReq( SoxService service, SoxSession session, SendPacket res) req { u1 'f' u1 replyNum str method (\"g\" for get, \"p\" for put) str uri u4 fileSize u2 suggestedChunkSize (suggested by client) headers[] { str name str value } u1 end of headers '\\0' } On a put, the fileSize is the number of bytes that will be written. On a get, the fileSize is the maximum number of bytes to read. You can read the whole file on a get by specifying fileSize as 0. The actual number of bytes read might be less if there are not fileSize bytes available (taking into account the size of the actual file, and the potential offset). Supported Headers: Name Value Method Default Description ---- ----- ------ ------- ----------- offset int get, put 0 Byte offset to use when reading/writing the uri mode \"w\", \"m\" put \"w\" File mode to use (see sys::File) fileOpenRes \u00b6 public static void fileOpenRes( SoxService service, SoxSession session, SendPacket res) res { u1 'F' u1 replyNum u4 fileSize u2 actualChunkSize headers[] { str name str value } u1 end of headers '\\0' } fileReceiveChunk \u00b6 public static void fileReceiveChunk( SoxService service, SoxSession session) Service a file chunk request (being put from client to me). NOTE: used by put (get uses fileSendChunk). client -> k -> me req { u1 'k' u1 replyNum (ignored) u2 chunkNum u2 chunkSize u1[chunkSize] chunk } fileRenameReq \u00b6 public static void fileRenameReq( SoxService service, SoxSession session, SendPacket res) req { u1 'b' u1 replyNum str from str to } fileSendChunk \u00b6 public static void fileSendChunk( SoxService service, SoxSession session, SendPacket res) Send the client the next chunk of the file. NOTE: used by get (put uses fileReceiveChunk). me -> k -> client req { u1 'k' u1 replyNum (ignored) u2 chunkNum u2 chunkSize u1[chunkSize] chunk } invokeReq \u00b6 public static void invokeReq( SoxService service, SoxSession session, SendPacket res) req { u1 'i' u1 replyNum u2 componentId u1 slotId val argument } linkReq \u00b6 public static void linkReq( SoxService service, SoxSession session, SendPacket res) req { u1 'l' u1 replyNum u1 'a' | 'd' (add/delete) u2 fromCompId u1 fromSlotId u2 toCompId u1 toSlotId } process \u00b6 public static void process( SoxService service, SoxSession session) Process the current message just received queryReq \u00b6 public static void queryReq( SoxService service, SoxSession session, SendPacket res) req { u1 'q' u1 replyNum u1 queryType u1[] queryReq } queryType 's': query service req-service { u1 kitId u1 typeId } queryRes \u00b6 public static void queryRes( SoxService service, SoxSession session, SendPacket res) res { u1 'Q' u1 replyNum u1[] queryRes } queryType 's': query service res-service { u2[num] compIds u2 0xffff end marker } readCompReq \u00b6 public static void readCompReq( SoxService service, SoxSession session, SendPacket res) req { u1 'c' u1 replyNum u2 componentId u1 what: 't', 'c', 'r', 'l' (tree, config, runtime, links) } readCompRes \u00b6 public static void readCompRes( SoxService service, SoxSession session, SendPacket res) res { u1 'C' u1 replyNum u2 componentId compTree | compProps | compLinks } readPropReq \u00b6 public static void readPropReq( SoxService service, SoxSession session, SendPacket res) req { u1 'r' u1 replyNum u2 compId u1 propId } readPropRes \u00b6 public static void readPropRes( SoxService service, SoxSession session, SendPacket res) res { u1 'R' u1 replyNum u1 any code var propValue } renameReq \u00b6 public static void renameReq( SoxService service, SoxSession session, SendPacket res) req { u1 'n' u1 replyNum u2 compId str newName } reorderReq \u00b6 public static void reorderReq( SoxService service, SoxSession session, SendPacket res) req { u1 'o' u1 replyNum u2 compId u1 numChildren u2[] childrenIds } send \u00b6 public static void send( SoxService service, SoxSession session, SendPacket res) subscribeReq \u00b6 public static void subscribeReq( SoxService service, SoxSession session, SendPacket res) req { u1 's' u1 replyNum u1 whatMask: tree=0x01 config=0x02 rt=0x04 links=0x8 0xff all tree u1 size u2[] compIds } subscribeRes \u00b6 public static void subscribeRes( SoxService service, SoxSession session, SendPacket res) res { u1 'S' u1 replyNum u1 numSubscribed } unsubscribeReq \u00b6 public static void unsubscribeReq( SoxService service, SoxSession session, SendPacket res) req { u1 'u' u1 replyNum u2 componentId u1 whatMask: tree=0x1 config=0x2 rt=0x4 links=0x8 0xff all tree } versionMoreRes \u00b6 public static void versionMoreRes( SoxService service, SoxSession session, SendPacket res) res { u1 'Y' u1 replyNum str platformId u1 scodeFlags kitVersions[kitCount] { str version } u1 pairs pairs { str key str val } } versionRes \u00b6 public static void versionRes( SoxService service, SoxSession session, SendPacket res) versionRes { u1 'V' u1 replyNum u1 kitCount kits[kitCount] { str name i4 checksum } } writeComp \u00b6 public static bool writeComp( SoxService service, SoxSession session, Component c, int what) Write a component - 't': writeCompTree - 'c': writeCompProps - 'r': writeCompProps - 'l': writeCompLinks writeCompLinks \u00b6 public static bool writeCompLinks( SoxService service, SoxSession session, Component c) Write component links compLinks { u1 'l' Link[] links u2 0xffff end marker } writeCompProps \u00b6 public static bool writeCompProps( SoxService service, SoxSession session, Component c, int what) Write component props (config or runtime) compProps { u1 'c' or 'r' for config or runtime, 'C'/'R' if operator only val[] propValues } writeCompTree \u00b6 public static bool writeCompTree( SoxService service, SoxSession session, Component c) Write component tree information compTree { u1 't' u1 kitId u1 typeId str name u2 parent u1 permissions u1 numKids u2[numKids] kidIds } writeReq \u00b6 public static void writeReq( SoxService service, SoxSession session, SendPacket res) req { u1 'w' u1 replyNum u2 componentId u1 slotId val value } Doc Home > API Index > sox > SoxCommands","title":"SoxCommands"},{"location":"api/sox/SoxCommands/#soxcommands","text":"Doc Home > API Index > sox > SoxCommands","title":"SoxCommands"},{"location":"api/sox/SoxCommands/#inheritance","text":"sys::Obj sox::SoxCommands public class SoxCommands SoxCommands processes all the sox command request/response.","title":"Inheritance"},{"location":"api/sox/SoxCommands/#fields","text":"","title":"Fields"},{"location":"api/sox/SoxCommands/#tempkey","text":"public static Str tempKey","title":"tempKey"},{"location":"api/sox/SoxCommands/#tempstr1","text":"public static Str tempStr1","title":"tempStr1"},{"location":"api/sox/SoxCommands/#tempstr2","text":"public static Str tempStr2","title":"tempStr2"},{"location":"api/sox/SoxCommands/#tempval","text":"public static Str tempVal","title":"tempVal"},{"location":"api/sox/SoxCommands/#methods","text":"","title":"Methods"},{"location":"api/sox/SoxCommands/#addreq","text":"public static void addReq( SoxService service, SoxSession session, SendPacket res) req { u1 'a' u1 replyNum u2 parentId u1 kitId u1 typeId str name val[] configProps }","title":"addReq"},{"location":"api/sox/SoxCommands/#addres","text":"public static void addRes( SoxService service, SoxSession session, SendPacket res) res { u1 'A' u1 replyNum u2 compId }","title":"addRes"},{"location":"api/sox/SoxCommands/#deletereq","text":"public static void deleteReq( SoxService service, SoxSession session, SendPacket res) req { u1 'd' u1 replyNum u2 compId }","title":"deleteReq"},{"location":"api/sox/SoxCommands/#eventres","text":"public static void eventRes( SoxService service, SoxSession session, SendPacket p) req { u1 'e' u1 replyNum u2 componentId compTree | compProps | compLinks }","title":"eventRes"},{"location":"api/sox/SoxCommands/#fileclosereq","text":"public static void fileCloseReq( SoxService service, SoxSession session, SendPacket res) req { u1 'z' u1 replyNum }","title":"fileCloseReq"},{"location":"api/sox/SoxCommands/#filecloseres","text":"public static void fileCloseRes( SoxService service, SoxSession session, SendPacket res) res { u1 'Z' u1 replyNum }","title":"fileCloseRes"},{"location":"api/sox/SoxCommands/#fileopenreq","text":"public static void fileOpenReq( SoxService service, SoxSession session, SendPacket res) req { u1 'f' u1 replyNum str method (\"g\" for get, \"p\" for put) str uri u4 fileSize u2 suggestedChunkSize (suggested by client) headers[] { str name str value } u1 end of headers '\\0' } On a put, the fileSize is the number of bytes that will be written. On a get, the fileSize is the maximum number of bytes to read. You can read the whole file on a get by specifying fileSize as 0. The actual number of bytes read might be less if there are not fileSize bytes available (taking into account the size of the actual file, and the potential offset). Supported Headers: Name Value Method Default Description ---- ----- ------ ------- ----------- offset int get, put 0 Byte offset to use when reading/writing the uri mode \"w\", \"m\" put \"w\" File mode to use (see sys::File)","title":"fileOpenReq"},{"location":"api/sox/SoxCommands/#fileopenres","text":"public static void fileOpenRes( SoxService service, SoxSession session, SendPacket res) res { u1 'F' u1 replyNum u4 fileSize u2 actualChunkSize headers[] { str name str value } u1 end of headers '\\0' }","title":"fileOpenRes"},{"location":"api/sox/SoxCommands/#filereceivechunk","text":"public static void fileReceiveChunk( SoxService service, SoxSession session) Service a file chunk request (being put from client to me). NOTE: used by put (get uses fileSendChunk). client -> k -> me req { u1 'k' u1 replyNum (ignored) u2 chunkNum u2 chunkSize u1[chunkSize] chunk }","title":"fileReceiveChunk"},{"location":"api/sox/SoxCommands/#filerenamereq","text":"public static void fileRenameReq( SoxService service, SoxSession session, SendPacket res) req { u1 'b' u1 replyNum str from str to }","title":"fileRenameReq"},{"location":"api/sox/SoxCommands/#filesendchunk","text":"public static void fileSendChunk( SoxService service, SoxSession session, SendPacket res) Send the client the next chunk of the file. NOTE: used by get (put uses fileReceiveChunk). me -> k -> client req { u1 'k' u1 replyNum (ignored) u2 chunkNum u2 chunkSize u1[chunkSize] chunk }","title":"fileSendChunk"},{"location":"api/sox/SoxCommands/#invokereq","text":"public static void invokeReq( SoxService service, SoxSession session, SendPacket res) req { u1 'i' u1 replyNum u2 componentId u1 slotId val argument }","title":"invokeReq"},{"location":"api/sox/SoxCommands/#linkreq","text":"public static void linkReq( SoxService service, SoxSession session, SendPacket res) req { u1 'l' u1 replyNum u1 'a' | 'd' (add/delete) u2 fromCompId u1 fromSlotId u2 toCompId u1 toSlotId }","title":"linkReq"},{"location":"api/sox/SoxCommands/#process","text":"public static void process( SoxService service, SoxSession session) Process the current message just received","title":"process"},{"location":"api/sox/SoxCommands/#queryreq","text":"public static void queryReq( SoxService service, SoxSession session, SendPacket res) req { u1 'q' u1 replyNum u1 queryType u1[] queryReq } queryType 's': query service req-service { u1 kitId u1 typeId }","title":"queryReq"},{"location":"api/sox/SoxCommands/#queryres","text":"public static void queryRes( SoxService service, SoxSession session, SendPacket res) res { u1 'Q' u1 replyNum u1[] queryRes } queryType 's': query service res-service { u2[num] compIds u2 0xffff end marker }","title":"queryRes"},{"location":"api/sox/SoxCommands/#readcompreq","text":"public static void readCompReq( SoxService service, SoxSession session, SendPacket res) req { u1 'c' u1 replyNum u2 componentId u1 what: 't', 'c', 'r', 'l' (tree, config, runtime, links) }","title":"readCompReq"},{"location":"api/sox/SoxCommands/#readcompres","text":"public static void readCompRes( SoxService service, SoxSession session, SendPacket res) res { u1 'C' u1 replyNum u2 componentId compTree | compProps | compLinks }","title":"readCompRes"},{"location":"api/sox/SoxCommands/#readpropreq","text":"public static void readPropReq( SoxService service, SoxSession session, SendPacket res) req { u1 'r' u1 replyNum u2 compId u1 propId }","title":"readPropReq"},{"location":"api/sox/SoxCommands/#readpropres","text":"public static void readPropRes( SoxService service, SoxSession session, SendPacket res) res { u1 'R' u1 replyNum u1 any code var propValue }","title":"readPropRes"},{"location":"api/sox/SoxCommands/#renamereq","text":"public static void renameReq( SoxService service, SoxSession session, SendPacket res) req { u1 'n' u1 replyNum u2 compId str newName }","title":"renameReq"},{"location":"api/sox/SoxCommands/#reorderreq","text":"public static void reorderReq( SoxService service, SoxSession session, SendPacket res) req { u1 'o' u1 replyNum u2 compId u1 numChildren u2[] childrenIds }","title":"reorderReq"},{"location":"api/sox/SoxCommands/#send","text":"public static void send( SoxService service, SoxSession session, SendPacket res)","title":"send"},{"location":"api/sox/SoxCommands/#subscribereq","text":"public static void subscribeReq( SoxService service, SoxSession session, SendPacket res) req { u1 's' u1 replyNum u1 whatMask: tree=0x01 config=0x02 rt=0x04 links=0x8 0xff all tree u1 size u2[] compIds }","title":"subscribeReq"},{"location":"api/sox/SoxCommands/#subscriberes","text":"public static void subscribeRes( SoxService service, SoxSession session, SendPacket res) res { u1 'S' u1 replyNum u1 numSubscribed }","title":"subscribeRes"},{"location":"api/sox/SoxCommands/#unsubscribereq","text":"public static void unsubscribeReq( SoxService service, SoxSession session, SendPacket res) req { u1 'u' u1 replyNum u2 componentId u1 whatMask: tree=0x1 config=0x2 rt=0x4 links=0x8 0xff all tree }","title":"unsubscribeReq"},{"location":"api/sox/SoxCommands/#versionmoreres","text":"public static void versionMoreRes( SoxService service, SoxSession session, SendPacket res) res { u1 'Y' u1 replyNum str platformId u1 scodeFlags kitVersions[kitCount] { str version } u1 pairs pairs { str key str val } }","title":"versionMoreRes"},{"location":"api/sox/SoxCommands/#versionres","text":"public static void versionRes( SoxService service, SoxSession session, SendPacket res) versionRes { u1 'V' u1 replyNum u1 kitCount kits[kitCount] { str name i4 checksum } }","title":"versionRes"},{"location":"api/sox/SoxCommands/#writecomp","text":"public static bool writeComp( SoxService service, SoxSession session, Component c, int what) Write a component - 't': writeCompTree - 'c': writeCompProps - 'r': writeCompProps - 'l': writeCompLinks","title":"writeComp"},{"location":"api/sox/SoxCommands/#writecomplinks","text":"public static bool writeCompLinks( SoxService service, SoxSession session, Component c) Write component links compLinks { u1 'l' Link[] links u2 0xffff end marker }","title":"writeCompLinks"},{"location":"api/sox/SoxCommands/#writecompprops","text":"public static bool writeCompProps( SoxService service, SoxSession session, Component c, int what) Write component props (config or runtime) compProps { u1 'c' or 'r' for config or runtime, 'C'/'R' if operator only val[] propValues }","title":"writeCompProps"},{"location":"api/sox/SoxCommands/#writecomptree","text":"public static bool writeCompTree( SoxService service, SoxSession session, Component c) Write component tree information compTree { u1 't' u1 kitId u1 typeId str name u2 parent u1 permissions u1 numKids u2[numKids] kidIds }","title":"writeCompTree"},{"location":"api/sox/SoxCommands/#writereq","text":"public static void writeReq( SoxService service, SoxSession session, SendPacket res) req { u1 'w' u1 replyNum u2 componentId u1 slotId val value } Doc Home > API Index > sox > SoxCommands","title":"writeReq"},{"location":"api/sox/SoxService/","text":"SoxService \u00b6 Doc Home > API Index > sox > SoxService Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::Service sox::SoxService public class SoxService SoxService implements the Dasp/Sox protocol for network provisioning, programming, and data access to a Sedona device. Fields \u00b6 HOUSE_KEEPING_INTERVAL \u00b6 public static const define int HOUSE_KEEPING_INTERVAL datagram \u00b6 public inline UdpDatagram datagram eventsPerSec \u00b6 public property short eventsPerSec [config] Max of number of async events sent per second. Tuning this number down towards zero will decrease the number of messages sent, but increase the latency of real-time change propogation. If set all the way down to zero, then no change of value events are sent. in \u00b6 public inline BufInStream in isPortOpen \u00b6 public bool isPortOpen lastCompId \u00b6 public short lastCompId lastHouseKeeping \u00b6 public long lastHouseKeeping log \u00b6 public static const define Log log numEventsThisPeriod \u00b6 public short numEventsThisPeriod out \u00b6 public inline BufOutStream out packet \u00b6 public inline Buf packet periodEnd \u00b6 public long periodEnd port \u00b6 public property short port [defaultOnClone, config] UDP port for listening receiveMax \u00b6 public property byte receiveMax [config] Max of number of messages in receiving window. sessions \u00b6 public inline SoxSession [] sessions socket \u00b6 public inline UdpSocket socket userService \u00b6 public UserService userService Methods \u00b6 canHibernate \u00b6 public virtual override bool canHibernate() Return true if this Service will allow hibernation. The SoxService should not allow hibernation if any SoxSessions are open. dispatch \u00b6 public void dispatch() Dispatch a received dasp/sox message. execute \u00b6 public virtual override void execute() Execute - called once per cycle. send \u00b6 public bool send( SoxSession s) Send the packet over the network to the specified session. Return true on success, false on failure. session \u00b6 public SoxSession session(int sessionId) Lookup the session by id, update the receive ticks and return it. If the session id is invalid or has been closed then return null. start \u00b6 public virtual override void start() Start the SoxService: - init datagram.buf to use packet.bytes - initWatches - initTransfers - open UDP port - lookup user service stop \u00b6 public virtual override void stop() Stop the SoxService. work \u00b6 public virtual override bool work() Check for service work: - check if we should retry port open - check for received packet - if received process it - check watches - check events Doc Home > API Index > sox > SoxService","title":"SoxService"},{"location":"api/sox/SoxService/#soxservice","text":"Doc Home > API Index > sox > SoxService","title":"SoxService"},{"location":"api/sox/SoxService/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::Service sox::SoxService public class SoxService SoxService implements the Dasp/Sox protocol for network provisioning, programming, and data access to a Sedona device.","title":"Inheritance"},{"location":"api/sox/SoxService/#fields","text":"","title":"Fields"},{"location":"api/sox/SoxService/#house_keeping_interval","text":"public static const define int HOUSE_KEEPING_INTERVAL","title":"HOUSE_KEEPING_INTERVAL"},{"location":"api/sox/SoxService/#datagram","text":"public inline UdpDatagram datagram","title":"datagram"},{"location":"api/sox/SoxService/#eventspersec","text":"public property short eventsPerSec [config] Max of number of async events sent per second. Tuning this number down towards zero will decrease the number of messages sent, but increase the latency of real-time change propogation. If set all the way down to zero, then no change of value events are sent.","title":"eventsPerSec"},{"location":"api/sox/SoxService/#in","text":"public inline BufInStream in","title":"in"},{"location":"api/sox/SoxService/#isportopen","text":"public bool isPortOpen","title":"isPortOpen"},{"location":"api/sox/SoxService/#lastcompid","text":"public short lastCompId","title":"lastCompId"},{"location":"api/sox/SoxService/#lasthousekeeping","text":"public long lastHouseKeeping","title":"lastHouseKeeping"},{"location":"api/sox/SoxService/#log","text":"public static const define Log log","title":"log"},{"location":"api/sox/SoxService/#numeventsthisperiod","text":"public short numEventsThisPeriod","title":"numEventsThisPeriod"},{"location":"api/sox/SoxService/#out","text":"public inline BufOutStream out","title":"out"},{"location":"api/sox/SoxService/#packet","text":"public inline Buf packet","title":"packet"},{"location":"api/sox/SoxService/#periodend","text":"public long periodEnd","title":"periodEnd"},{"location":"api/sox/SoxService/#port","text":"public property short port [defaultOnClone, config] UDP port for listening","title":"port"},{"location":"api/sox/SoxService/#receivemax","text":"public property byte receiveMax [config] Max of number of messages in receiving window.","title":"receiveMax"},{"location":"api/sox/SoxService/#sessions","text":"public inline SoxSession [] sessions","title":"sessions"},{"location":"api/sox/SoxService/#socket","text":"public inline UdpSocket socket","title":"socket"},{"location":"api/sox/SoxService/#userservice","text":"public UserService userService","title":"userService"},{"location":"api/sox/SoxService/#methods","text":"","title":"Methods"},{"location":"api/sox/SoxService/#canhibernate","text":"public virtual override bool canHibernate() Return true if this Service will allow hibernation. The SoxService should not allow hibernation if any SoxSessions are open.","title":"canHibernate"},{"location":"api/sox/SoxService/#dispatch","text":"public void dispatch() Dispatch a received dasp/sox message.","title":"dispatch"},{"location":"api/sox/SoxService/#execute","text":"public virtual override void execute() Execute - called once per cycle.","title":"execute"},{"location":"api/sox/SoxService/#send","text":"public bool send( SoxSession s) Send the packet over the network to the specified session. Return true on success, false on failure.","title":"send"},{"location":"api/sox/SoxService/#session","text":"public SoxSession session(int sessionId) Lookup the session by id, update the receive ticks and return it. If the session id is invalid or has been closed then return null.","title":"session"},{"location":"api/sox/SoxService/#start","text":"public virtual override void start() Start the SoxService: - init datagram.buf to use packet.bytes - initWatches - initTransfers - open UDP port - lookup user service","title":"start"},{"location":"api/sox/SoxService/#stop","text":"public virtual override void stop() Stop the SoxService.","title":"stop"},{"location":"api/sox/SoxService/#work","text":"public virtual override bool work() Check for service work: - check if we should retry port open - check for received packet - if received process it - check watches - check events Doc Home > API Index > sox > SoxService","title":"work"},{"location":"api/sox/SoxSession/","text":"SoxSession \u00b6 Doc Home > API Index > sox > SoxSession Inheritance \u00b6 sys::Obj sys::Virtual sys::Watch sox::SoxSession public class SoxSession SoxSession models a Dasp/Sox session. Fields \u00b6 addr \u00b6 public inline SocketAddr addr allTreeEvents \u00b6 public bool allTreeEvents errStr \u00b6 public inline Str errStr idealMax \u00b6 public short idealMax lastReceiveTicks \u00b6 public long lastReceiveTicks lastSendTicks \u00b6 public long lastSendTicks nonce \u00b6 public long nonce receiveTimeout \u00b6 public short receiveTimeout receiveWindow \u00b6 public inline ReceiveWindow receiveWindow remoteId \u00b6 public short remoteId sendWindow \u00b6 public inline SendWindow sendWindow transfer \u00b6 public inline FileTransfer transfer user \u00b6 public User user Methods \u00b6 authenticate \u00b6 public bool authenticate( SoxService service, Str username, byte[] digest, int digestOff, int digestLen) If authenticated, then update user field and return true, or return false if rejected. challenge \u00b6 public void challenge( SoxService service, int numFields) Receive hello and respond with challenge. close \u00b6 public void close( SoxService service, int errorCode) Close the dasp/sox session. discoverResponse \u00b6 public void discoverResponse( SoxService service) Send a discovery response. houseKeeping \u00b6 public bool houseKeeping( SoxService service, long now, int houseKeepingTicks) House keeping is used to check for retries, acks, keep-alives, and timeouts. Ideally it is called every SoxService.HOUSE_KEEPING_INTERVAL, but call rate may very based on App scanPeriod. It is never called more often then HOUSE_KEEPING_INTERVAL ms, but it may be called less frequently. houseKeepingTicks represents the number of intervals that have elapsed (rounded up) since the last time houseKeeping was called For example, if HOUSE_KEEPING_INTERVAL is 100ms and 160 ms have elapsed since the last time the method was called, houseKeepingTicks = 2 keepAlive \u00b6 public void keepAlive( SoxService service) Send a keep alive message reset \u00b6 public void reset() Reset into a clean state for new session. skipHeader \u00b6 public static void skipHeader( BufInStream in, int typeId) Skip a Dasp header field based on its typeId. welcome \u00b6 public void welcome( SoxService service, int numFields) Receive authenticate and respond with welcome. Doc Home > API Index > sox > SoxSession","title":"SoxSession"},{"location":"api/sox/SoxSession/#soxsession","text":"Doc Home > API Index > sox > SoxSession","title":"SoxSession"},{"location":"api/sox/SoxSession/#inheritance","text":"sys::Obj sys::Virtual sys::Watch sox::SoxSession public class SoxSession SoxSession models a Dasp/Sox session.","title":"Inheritance"},{"location":"api/sox/SoxSession/#fields","text":"","title":"Fields"},{"location":"api/sox/SoxSession/#addr","text":"public inline SocketAddr addr","title":"addr"},{"location":"api/sox/SoxSession/#alltreeevents","text":"public bool allTreeEvents","title":"allTreeEvents"},{"location":"api/sox/SoxSession/#errstr","text":"public inline Str errStr","title":"errStr"},{"location":"api/sox/SoxSession/#idealmax","text":"public short idealMax","title":"idealMax"},{"location":"api/sox/SoxSession/#lastreceiveticks","text":"public long lastReceiveTicks","title":"lastReceiveTicks"},{"location":"api/sox/SoxSession/#lastsendticks","text":"public long lastSendTicks","title":"lastSendTicks"},{"location":"api/sox/SoxSession/#nonce","text":"public long nonce","title":"nonce"},{"location":"api/sox/SoxSession/#receivetimeout","text":"public short receiveTimeout","title":"receiveTimeout"},{"location":"api/sox/SoxSession/#receivewindow","text":"public inline ReceiveWindow receiveWindow","title":"receiveWindow"},{"location":"api/sox/SoxSession/#remoteid","text":"public short remoteId","title":"remoteId"},{"location":"api/sox/SoxSession/#sendwindow","text":"public inline SendWindow sendWindow","title":"sendWindow"},{"location":"api/sox/SoxSession/#transfer","text":"public inline FileTransfer transfer","title":"transfer"},{"location":"api/sox/SoxSession/#user","text":"public User user","title":"user"},{"location":"api/sox/SoxSession/#methods","text":"","title":"Methods"},{"location":"api/sox/SoxSession/#authenticate","text":"public bool authenticate( SoxService service, Str username, byte[] digest, int digestOff, int digestLen) If authenticated, then update user field and return true, or return false if rejected.","title":"authenticate"},{"location":"api/sox/SoxSession/#challenge","text":"public void challenge( SoxService service, int numFields) Receive hello and respond with challenge.","title":"challenge"},{"location":"api/sox/SoxSession/#close","text":"public void close( SoxService service, int errorCode) Close the dasp/sox session.","title":"close"},{"location":"api/sox/SoxSession/#discoverresponse","text":"public void discoverResponse( SoxService service) Send a discovery response.","title":"discoverResponse"},{"location":"api/sox/SoxSession/#housekeeping","text":"public bool houseKeeping( SoxService service, long now, int houseKeepingTicks) House keeping is used to check for retries, acks, keep-alives, and timeouts. Ideally it is called every SoxService.HOUSE_KEEPING_INTERVAL, but call rate may very based on App scanPeriod. It is never called more often then HOUSE_KEEPING_INTERVAL ms, but it may be called less frequently. houseKeepingTicks represents the number of intervals that have elapsed (rounded up) since the last time houseKeeping was called For example, if HOUSE_KEEPING_INTERVAL is 100ms and 160 ms have elapsed since the last time the method was called, houseKeepingTicks = 2","title":"houseKeeping"},{"location":"api/sox/SoxSession/#keepalive","text":"public void keepAlive( SoxService service) Send a keep alive message","title":"keepAlive"},{"location":"api/sox/SoxSession/#reset","text":"public void reset() Reset into a clean state for new session.","title":"reset"},{"location":"api/sox/SoxSession/#skipheader","text":"public static void skipHeader( BufInStream in, int typeId) Skip a Dasp header field based on its typeId.","title":"skipHeader"},{"location":"api/sox/SoxSession/#welcome","text":"public void welcome( SoxService service, int numFields) Receive authenticate and respond with welcome. Doc Home > API Index > sox > SoxSession","title":"welcome"},{"location":"api/soxcert/","text":"soxcert \u00b6 Doc Home > API Index > soxcert Kit for use in sox certification tests CertComp \u00b6 Doc Home > API Index > soxcert","title":"Index"},{"location":"api/soxcert/#soxcert","text":"Doc Home > API Index > soxcert Kit for use in sox certification tests","title":"soxcert"},{"location":"api/soxcert/#certcomp","text":"Doc Home > API Index > soxcert","title":"CertComp"},{"location":"api/soxcert/CertComp/","text":"CertComp \u00b6 Doc Home > API Index > soxcert > CertComp Inheritance \u00b6 sys::Obj sys::Virtual sys::Component soxcert::CertComp public final class CertComp [palette=false] This component is used by the soxcert test suite. Fields \u00b6 certInt \u00b6 public property int certInt [config] Doc Home > API Index > soxcert > CertComp","title":"CertComp"},{"location":"api/soxcert/CertComp/#certcomp","text":"Doc Home > API Index > soxcert > CertComp","title":"CertComp"},{"location":"api/soxcert/CertComp/#inheritance","text":"sys::Obj sys::Virtual sys::Component soxcert::CertComp public final class CertComp [palette=false] This component is used by the soxcert test suite.","title":"Inheritance"},{"location":"api/soxcert/CertComp/#fields","text":"","title":"Fields"},{"location":"api/soxcert/CertComp/#certint","text":"public property int certInt [config] Doc Home > API Index > soxcert > CertComp","title":"certInt"},{"location":"api/sys/","text":"sys \u00b6 Doc Home > API Index > sys Sedona core system module App \u00b6 Buf \u00b6 BufInStream \u00b6 BufOutStream \u00b6 Component \u00b6 Err \u00b6 File \u00b6 FileStore \u00b6 Folder \u00b6 InStream \u00b6 Kit \u00b6 Link \u00b6 Log \u00b6 MemoryFile \u00b6 MemoryFileStore \u00b6 Obj \u00b6 OutStream \u00b6 PlatformService \u00b6 RateFolder \u00b6 Service \u00b6 Slot \u00b6 Str \u00b6 Sys \u00b6 Test \u00b6 Type \u00b6 Units \u00b6 User \u00b6 UserService \u00b6 Virtual \u00b6 Watch \u00b6 Doc Home > API Index > sys","title":"Index"},{"location":"api/sys/#sys","text":"Doc Home > API Index > sys Sedona core system module","title":"sys"},{"location":"api/sys/#app","text":"","title":"App"},{"location":"api/sys/#buf","text":"","title":"Buf"},{"location":"api/sys/#bufinstream","text":"","title":"BufInStream"},{"location":"api/sys/#bufoutstream","text":"","title":"BufOutStream"},{"location":"api/sys/#component","text":"","title":"Component"},{"location":"api/sys/#err","text":"","title":"Err"},{"location":"api/sys/#file","text":"","title":"File"},{"location":"api/sys/#filestore","text":"","title":"FileStore"},{"location":"api/sys/#folder","text":"","title":"Folder"},{"location":"api/sys/#instream","text":"","title":"InStream"},{"location":"api/sys/#kit","text":"","title":"Kit"},{"location":"api/sys/#link","text":"","title":"Link"},{"location":"api/sys/#log","text":"","title":"Log"},{"location":"api/sys/#memoryfile","text":"","title":"MemoryFile"},{"location":"api/sys/#memoryfilestore","text":"","title":"MemoryFileStore"},{"location":"api/sys/#obj","text":"","title":"Obj"},{"location":"api/sys/#outstream","text":"","title":"OutStream"},{"location":"api/sys/#platformservice","text":"","title":"PlatformService"},{"location":"api/sys/#ratefolder","text":"","title":"RateFolder"},{"location":"api/sys/#service","text":"","title":"Service"},{"location":"api/sys/#slot","text":"","title":"Slot"},{"location":"api/sys/#str","text":"","title":"Str"},{"location":"api/sys/#sys_1","text":"","title":"Sys"},{"location":"api/sys/#test","text":"","title":"Test"},{"location":"api/sys/#type","text":"","title":"Type"},{"location":"api/sys/#units","text":"","title":"Units"},{"location":"api/sys/#user","text":"","title":"User"},{"location":"api/sys/#userservice","text":"","title":"UserService"},{"location":"api/sys/#virtual","text":"","title":"Virtual"},{"location":"api/sys/#watch","text":"Doc Home > API Index > sys","title":"Watch"},{"location":"api/sys/App/","text":"App \u00b6 Doc Home > API Index > sys > App Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::App public class App [niagaraIcon=\"module://icons/x16/database.png\", palette=false] App encapsulates an application database which includes the list of available Types, the Component instances, their configuration, and the Links. Fields \u00b6 appName \u00b6 public inline property Buf appName [asStr, config, max=16] Name of the app, up to 15 ASCII chars long backupAppName \u00b6 public static const define Str backupAppName comps \u00b6 public Component [] comps List of application component indexed by id (may be sparse with null items). compsLen \u00b6 public int compsLen Size of the components array cycleCount \u00b6 public long cycleCount This counter is incremented at the start of each engine cycle deviceName \u00b6 public inline property Buf deviceName [asStr, config, max=16] Logical name for the device, up to 15 ASCII chars long guardTime \u00b6 public property int guardTime [unit=\"millisecond\", config] Time before the end of the scan period in which no new services work should be started in order to allow work in progress to finish before the end of scan. hibernationResetsSteadyState \u00b6 public property bool hibernationResetsSteadyState [config] If true, when the App returns from hibernation then the steady state will be reset and the App will not return to steady state until timeToSteadyState has elapsed. kitIdMap \u00b6 public int[] kitIdMap lastEndWork \u00b6 public long lastEndWork Timestamp of end of service's work (also start of sleep time). This timestamp corresponds to the PREVIOUS scan. lastEndWork - lastStartWork = work time of previous scan lastStartExec \u00b6 public long lastStartExec Cache of the timestamp of the start of the component tree execution of the PREVIOUS scan. It is intended that that timing statistics to be computed within the execute method of a component dropped into the component tree, so we need to cache the start of the last component tree execution. Also marks the time that sleep ends on previous scan. lastStartWork - lastStartExec = execution time of previous scan lastStartWork \u00b6 public long lastStartWork Timestamp of start of service work (also marks the end of component tree execution). If timing statistics computed during component tree execution, this timestamp corresponds to the PREVIOUS scan. lastEndWork - lastStartWork = work time of previous scan log \u00b6 public static const define Log log Application level logging newStartExec \u00b6 public long newStartExec End of previous scan sleep time is also the start of a new component tree execution This marks start of he CURRENT scan, such that: newStartExec - lastStartExec = scan time of PREVIOUS scan platform \u00b6 public PlatformService platform PlatformService installed in this application scanPeriod \u00b6 public property int scanPeriod [unit=\"millisecond\", config] Scan cycle period in milliseconds. services \u00b6 public Service services Linked list of services timeToSteadyState \u00b6 public property int timeToSteadyState [unit=\"millisecond\", config] Time from app start to steady state, in milliseconds. watches \u00b6 public inline Watch [] watches This array references the active watches by referencing the application specific subclasses currently open. Methods \u00b6 add \u00b6 public Component add( Component parent, Str name, Type t) Add a component to the application. Return the new Component on success, null on failure. addLink \u00b6 public Link addLink( Component from, Slot fromSlot, Component to, Slot toSlot) Add a new Link into the application by registering it in both the \"to\" and \"from\" component's linked-list of Links. Return the new Link or null on error. backup \u00b6 public void backup() Backup application cleanupApp \u00b6 public void cleanupApp() Free all the dynamic memory associated with this application. closeWatch \u00b6 public void closeWatch( Watch watch) Close the specific watch by freeing its id to be used again and setting its closed field to false. getFirstChildOfType \u00b6 public Component getFirstChildOfType( Component parent, Type t) Gets first child component of a given type. Returns null if no objects found, otherwise returns a Component getNextSiblingOfType \u00b6 public Component getNextSiblingOfType( Component component, Type t) Gets next sibling of a component that is of type t. Returns null if end of sibling list is reached without finding one. hibernate \u00b6 public action void hibernate() [confirmRequired] Action to request hibernation. Current execute loop will complete and all services will get a chance to work before hibernation occurs initApp \u00b6 public bool initApp(int initCompsLen) Prepare the applications data structures to begin configuration. initWatches \u00b6 public void initWatches( Watch [] subclasses) Each service which uses watches, should call this method on startup with it's service specific array of Watch subclasses. isRunning \u00b6 public bool isRunning() Is the application currently running isSteadyState \u00b6 public bool isSteadyState() Has the application reached steady state (as defined by timeToSteadyState) load \u00b6 public int load() Load the application from persistent storage loadApp \u00b6 public int loadApp( InStream in) Load the app from a binary format input stream. Return 0 on success or non-zero on error. loadFile \u00b6 public int loadFile( Str name) loadSchema \u00b6 public bool loadSchema( InStream in) Check that the schema on the input stream matches the schema of the current runtime. In this version, we allow the app to depend on fewer kits than the scode, as long as all the app's kits are in the scode. lookup \u00b6 public Component lookup(int id) Lookup a component by id or null. lookupLink \u00b6 public Link lookupLink(int fromCompId, int fromSlotId, int toCompId, int toSlotId) Find a link with the specified from and to ids or return null if not found. lookupService \u00b6 public Service lookupService( Type type) Lookup a service by type (or base type). Return null if there are no registered services which implement the specified type. maxId \u00b6 public int maxId() Get the maximum component id used by the application. openWatch \u00b6 public Watch openWatch( Watch [] subclasses) Allocate a watch for a service using watches. The service should pass in its service specific array of Watch subclasses. If a watch is opened then it is reserved, its closed field is set to false, and the subclass instance is returned. If all the watches are currently open, then return null. quit \u00b6 public action void quit() [confirmRequired] Save the application and then exit the main loop. reboot \u00b6 public action void reboot() [confirmRequired] Action to invoke Platform.reboot. remove \u00b6 public bool remove( Component c) Remove the specified component and free it's memory. This method automatically recursively removes any children of the component first. Return true on success, false on failure. removeLink \u00b6 public bool removeLink( Link link) Remove a Link from the application by unregistering it from both the \"to\" and \"from\" component's list linked of Links. Return true on success, false on failure. restart \u00b6 public action void restart() [confirmRequired] Action to invoke Platform.restart. resumeApp \u00b6 public int resumeApp() Run this application - right now this is a simple round robin execution. runApp \u00b6 public int runApp() Run this application - right now this is a simple round robin execution. save \u00b6 public action void save() Backup old application and save running application back to persistent storage saveApp \u00b6 public int saveApp( OutStream out) Save the app in binary format to the output stream: app { u4 magic 0x73617070 \"sapp\" u4 version 0x0002 0.2 Schema schema Component[] comps u2 0xffff end of comps marker Link[] links u2 0xffff end of links marker u1 '.' end of app marker } Return 0 on success, non-zero on failure. saveRunningApp \u00b6 public void saveRunningApp() Save the application back to persistent storage saveSchema \u00b6 public void saveSchema( OutStream out) Schema is the list of kit names and checksums: schema { u1 count kits[count] { str name u4 checksum } } startApp \u00b6 public int startApp( Str [] args, int argsLen) Start all the components. Return 0 on success, error code on failure. stopApp \u00b6 public void stopApp() Stop all the components. Doc Home > API Index > sys > App","title":"App"},{"location":"api/sys/App/#app","text":"Doc Home > API Index > sys > App","title":"App"},{"location":"api/sys/App/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::App public class App [niagaraIcon=\"module://icons/x16/database.png\", palette=false] App encapsulates an application database which includes the list of available Types, the Component instances, their configuration, and the Links.","title":"Inheritance"},{"location":"api/sys/App/#fields","text":"","title":"Fields"},{"location":"api/sys/App/#appname","text":"public inline property Buf appName [asStr, config, max=16] Name of the app, up to 15 ASCII chars long","title":"appName"},{"location":"api/sys/App/#backupappname","text":"public static const define Str backupAppName","title":"backupAppName"},{"location":"api/sys/App/#comps","text":"public Component [] comps List of application component indexed by id (may be sparse with null items).","title":"comps"},{"location":"api/sys/App/#compslen","text":"public int compsLen Size of the components array","title":"compsLen"},{"location":"api/sys/App/#cyclecount","text":"public long cycleCount This counter is incremented at the start of each engine cycle","title":"cycleCount"},{"location":"api/sys/App/#devicename","text":"public inline property Buf deviceName [asStr, config, max=16] Logical name for the device, up to 15 ASCII chars long","title":"deviceName"},{"location":"api/sys/App/#guardtime","text":"public property int guardTime [unit=\"millisecond\", config] Time before the end of the scan period in which no new services work should be started in order to allow work in progress to finish before the end of scan.","title":"guardTime"},{"location":"api/sys/App/#hibernationresetssteadystate","text":"public property bool hibernationResetsSteadyState [config] If true, when the App returns from hibernation then the steady state will be reset and the App will not return to steady state until timeToSteadyState has elapsed.","title":"hibernationResetsSteadyState"},{"location":"api/sys/App/#kitidmap","text":"public int[] kitIdMap","title":"kitIdMap"},{"location":"api/sys/App/#lastendwork","text":"public long lastEndWork Timestamp of end of service's work (also start of sleep time). This timestamp corresponds to the PREVIOUS scan. lastEndWork - lastStartWork = work time of previous scan","title":"lastEndWork"},{"location":"api/sys/App/#laststartexec","text":"public long lastStartExec Cache of the timestamp of the start of the component tree execution of the PREVIOUS scan. It is intended that that timing statistics to be computed within the execute method of a component dropped into the component tree, so we need to cache the start of the last component tree execution. Also marks the time that sleep ends on previous scan. lastStartWork - lastStartExec = execution time of previous scan","title":"lastStartExec"},{"location":"api/sys/App/#laststartwork","text":"public long lastStartWork Timestamp of start of service work (also marks the end of component tree execution). If timing statistics computed during component tree execution, this timestamp corresponds to the PREVIOUS scan. lastEndWork - lastStartWork = work time of previous scan","title":"lastStartWork"},{"location":"api/sys/App/#log","text":"public static const define Log log Application level logging","title":"log"},{"location":"api/sys/App/#newstartexec","text":"public long newStartExec End of previous scan sleep time is also the start of a new component tree execution This marks start of he CURRENT scan, such that: newStartExec - lastStartExec = scan time of PREVIOUS scan","title":"newStartExec"},{"location":"api/sys/App/#platform","text":"public PlatformService platform PlatformService installed in this application","title":"platform"},{"location":"api/sys/App/#scanperiod","text":"public property int scanPeriod [unit=\"millisecond\", config] Scan cycle period in milliseconds.","title":"scanPeriod"},{"location":"api/sys/App/#services","text":"public Service services Linked list of services","title":"services"},{"location":"api/sys/App/#timetosteadystate","text":"public property int timeToSteadyState [unit=\"millisecond\", config] Time from app start to steady state, in milliseconds.","title":"timeToSteadyState"},{"location":"api/sys/App/#watches","text":"public inline Watch [] watches This array references the active watches by referencing the application specific subclasses currently open.","title":"watches"},{"location":"api/sys/App/#methods","text":"","title":"Methods"},{"location":"api/sys/App/#add","text":"public Component add( Component parent, Str name, Type t) Add a component to the application. Return the new Component on success, null on failure.","title":"add"},{"location":"api/sys/App/#addlink","text":"public Link addLink( Component from, Slot fromSlot, Component to, Slot toSlot) Add a new Link into the application by registering it in both the \"to\" and \"from\" component's linked-list of Links. Return the new Link or null on error.","title":"addLink"},{"location":"api/sys/App/#backup","text":"public void backup() Backup application","title":"backup"},{"location":"api/sys/App/#cleanupapp","text":"public void cleanupApp() Free all the dynamic memory associated with this application.","title":"cleanupApp"},{"location":"api/sys/App/#closewatch","text":"public void closeWatch( Watch watch) Close the specific watch by freeing its id to be used again and setting its closed field to false.","title":"closeWatch"},{"location":"api/sys/App/#getfirstchildoftype","text":"public Component getFirstChildOfType( Component parent, Type t) Gets first child component of a given type. Returns null if no objects found, otherwise returns a Component","title":"getFirstChildOfType"},{"location":"api/sys/App/#getnextsiblingoftype","text":"public Component getNextSiblingOfType( Component component, Type t) Gets next sibling of a component that is of type t. Returns null if end of sibling list is reached without finding one.","title":"getNextSiblingOfType"},{"location":"api/sys/App/#hibernate","text":"public action void hibernate() [confirmRequired] Action to request hibernation. Current execute loop will complete and all services will get a chance to work before hibernation occurs","title":"hibernate"},{"location":"api/sys/App/#initapp","text":"public bool initApp(int initCompsLen) Prepare the applications data structures to begin configuration.","title":"initApp"},{"location":"api/sys/App/#initwatches","text":"public void initWatches( Watch [] subclasses) Each service which uses watches, should call this method on startup with it's service specific array of Watch subclasses.","title":"initWatches"},{"location":"api/sys/App/#isrunning","text":"public bool isRunning() Is the application currently running","title":"isRunning"},{"location":"api/sys/App/#issteadystate","text":"public bool isSteadyState() Has the application reached steady state (as defined by timeToSteadyState)","title":"isSteadyState"},{"location":"api/sys/App/#load","text":"public int load() Load the application from persistent storage","title":"load"},{"location":"api/sys/App/#loadapp","text":"public int loadApp( InStream in) Load the app from a binary format input stream. Return 0 on success or non-zero on error.","title":"loadApp"},{"location":"api/sys/App/#loadfile","text":"public int loadFile( Str name)","title":"loadFile"},{"location":"api/sys/App/#loadschema","text":"public bool loadSchema( InStream in) Check that the schema on the input stream matches the schema of the current runtime. In this version, we allow the app to depend on fewer kits than the scode, as long as all the app's kits are in the scode.","title":"loadSchema"},{"location":"api/sys/App/#lookup","text":"public Component lookup(int id) Lookup a component by id or null.","title":"lookup"},{"location":"api/sys/App/#lookuplink","text":"public Link lookupLink(int fromCompId, int fromSlotId, int toCompId, int toSlotId) Find a link with the specified from and to ids or return null if not found.","title":"lookupLink"},{"location":"api/sys/App/#lookupservice","text":"public Service lookupService( Type type) Lookup a service by type (or base type). Return null if there are no registered services which implement the specified type.","title":"lookupService"},{"location":"api/sys/App/#maxid","text":"public int maxId() Get the maximum component id used by the application.","title":"maxId"},{"location":"api/sys/App/#openwatch","text":"public Watch openWatch( Watch [] subclasses) Allocate a watch for a service using watches. The service should pass in its service specific array of Watch subclasses. If a watch is opened then it is reserved, its closed field is set to false, and the subclass instance is returned. If all the watches are currently open, then return null.","title":"openWatch"},{"location":"api/sys/App/#quit","text":"public action void quit() [confirmRequired] Save the application and then exit the main loop.","title":"quit"},{"location":"api/sys/App/#reboot","text":"public action void reboot() [confirmRequired] Action to invoke Platform.reboot.","title":"reboot"},{"location":"api/sys/App/#remove","text":"public bool remove( Component c) Remove the specified component and free it's memory. This method automatically recursively removes any children of the component first. Return true on success, false on failure.","title":"remove"},{"location":"api/sys/App/#removelink","text":"public bool removeLink( Link link) Remove a Link from the application by unregistering it from both the \"to\" and \"from\" component's list linked of Links. Return true on success, false on failure.","title":"removeLink"},{"location":"api/sys/App/#restart","text":"public action void restart() [confirmRequired] Action to invoke Platform.restart.","title":"restart"},{"location":"api/sys/App/#resumeapp","text":"public int resumeApp() Run this application - right now this is a simple round robin execution.","title":"resumeApp"},{"location":"api/sys/App/#runapp","text":"public int runApp() Run this application - right now this is a simple round robin execution.","title":"runApp"},{"location":"api/sys/App/#save","text":"public action void save() Backup old application and save running application back to persistent storage","title":"save"},{"location":"api/sys/App/#saveapp","text":"public int saveApp( OutStream out) Save the app in binary format to the output stream: app { u4 magic 0x73617070 \"sapp\" u4 version 0x0002 0.2 Schema schema Component[] comps u2 0xffff end of comps marker Link[] links u2 0xffff end of links marker u1 '.' end of app marker } Return 0 on success, non-zero on failure.","title":"saveApp"},{"location":"api/sys/App/#saverunningapp","text":"public void saveRunningApp() Save the application back to persistent storage","title":"saveRunningApp"},{"location":"api/sys/App/#saveschema","text":"public void saveSchema( OutStream out) Schema is the list of kit names and checksums: schema { u1 count kits[count] { str name u4 checksum } }","title":"saveSchema"},{"location":"api/sys/App/#startapp","text":"public int startApp( Str [] args, int argsLen) Start all the components. Return 0 on success, error code on failure.","title":"startApp"},{"location":"api/sys/App/#stopapp","text":"public void stopApp() Stop all the components. Doc Home > API Index > sys > App","title":"stopApp"},{"location":"api/sys/Buf/","text":"Buf \u00b6 Doc Home > API Index > sys > Buf Inheritance \u00b6 sys::Obj sys::Buf public final class Buf Buf encapsulates a fixed capacity byte[]. The fixed capacity is available via the 'bytesLen' field. At any time a variable number of bytes are actually used as defined by the 'size' field. Use the BufInStream and BufOutStream classes to perform memory based IO against a Buf instance. Fields \u00b6 bytes \u00b6 public inline byte[] bytes bytesLen \u00b6 public short bytesLen size \u00b6 public short size Methods \u00b6 Buf \u00b6 public void Buf(int maxBufLen) Construct a buffer with the specified maximum size. clear \u00b6 public void clear() Set size to zero. The data remains untouched, but the buffer is ready to be used to begin writing from scratch. copyFromBuf \u00b6 public void copyFromBuf( Buf that) Copy the specified buffer bytes into this buffer's bytes and update size. If the specified buffer contains more than bytesLen bytes then the copy is truncated. copyFromBytes \u00b6 public void copyFromBytes(byte[] that, int off, int len) Copy the specified byte array into this buffer's bytes and update size. If the specified length is greater than bytesLen bytes then the copy is truncated. copyFromStr \u00b6 public bool copyFromStr( Str s) Copy the specified string including its null terminator into this buffer bytes field and update size accordingly. If the specified string contains more than bytesLen characters including the null terminator then return false and truncate the copy. If truncated we still add a null terminator. get \u00b6 public int get(int index) Get the byte at the specified index. toStr \u00b6 public Str toStr() [javaNative] Return the bytes cast to a Str reference. No guarantee is made whether the string is actually null terminated. Doc Home > API Index > sys > Buf","title":"Buf"},{"location":"api/sys/Buf/#buf","text":"Doc Home > API Index > sys > Buf","title":"Buf"},{"location":"api/sys/Buf/#inheritance","text":"sys::Obj sys::Buf public final class Buf Buf encapsulates a fixed capacity byte[]. The fixed capacity is available via the 'bytesLen' field. At any time a variable number of bytes are actually used as defined by the 'size' field. Use the BufInStream and BufOutStream classes to perform memory based IO against a Buf instance.","title":"Inheritance"},{"location":"api/sys/Buf/#fields","text":"","title":"Fields"},{"location":"api/sys/Buf/#bytes","text":"public inline byte[] bytes","title":"bytes"},{"location":"api/sys/Buf/#byteslen","text":"public short bytesLen","title":"bytesLen"},{"location":"api/sys/Buf/#size","text":"public short size","title":"size"},{"location":"api/sys/Buf/#methods","text":"","title":"Methods"},{"location":"api/sys/Buf/#buf_1","text":"public void Buf(int maxBufLen) Construct a buffer with the specified maximum size.","title":"Buf"},{"location":"api/sys/Buf/#clear","text":"public void clear() Set size to zero. The data remains untouched, but the buffer is ready to be used to begin writing from scratch.","title":"clear"},{"location":"api/sys/Buf/#copyfrombuf","text":"public void copyFromBuf( Buf that) Copy the specified buffer bytes into this buffer's bytes and update size. If the specified buffer contains more than bytesLen bytes then the copy is truncated.","title":"copyFromBuf"},{"location":"api/sys/Buf/#copyfrombytes","text":"public void copyFromBytes(byte[] that, int off, int len) Copy the specified byte array into this buffer's bytes and update size. If the specified length is greater than bytesLen bytes then the copy is truncated.","title":"copyFromBytes"},{"location":"api/sys/Buf/#copyfromstr","text":"public bool copyFromStr( Str s) Copy the specified string including its null terminator into this buffer bytes field and update size accordingly. If the specified string contains more than bytesLen characters including the null terminator then return false and truncate the copy. If truncated we still add a null terminator.","title":"copyFromStr"},{"location":"api/sys/Buf/#get","text":"public int get(int index) Get the byte at the specified index.","title":"get"},{"location":"api/sys/Buf/#tostr","text":"public Str toStr() [javaNative] Return the bytes cast to a Str reference. No guarantee is made whether the string is actually null terminated. Doc Home > API Index > sys > Buf","title":"toStr"},{"location":"api/sys/BufInStream/","text":"BufInStream \u00b6 Doc Home > API Index > sys > BufInStream Inheritance \u00b6 sys::Obj sys::Virtual sys::InStream sys::BufInStream public final class BufInStream BufInStream is used to read bytes from a memory Buf. Fields \u00b6 buf \u00b6 public Buf buf pos \u00b6 public short pos Methods \u00b6 BufInStream \u00b6 public void BufInStream( Buf buf) Construct for specified Buf instance. read \u00b6 public override int read() Read the next byte at pos and increment pos. Return -1 if pos >= size. readBytes \u00b6 public override int readBytes(byte[] b, int off, int len) Read the next block of available bytes starting from pos. Return the number of bytes copied into b and advance the position likewise. readStrInPlace \u00b6 public Str readStrInPlace( Str str) Read the current position as a null terminated string. Return null on error. rewind \u00b6 public void rewind() Rewind sets the pos back to zero to begin reading the Buf from the beginning. Doc Home > API Index > sys > BufInStream","title":"BufInStream"},{"location":"api/sys/BufInStream/#bufinstream","text":"Doc Home > API Index > sys > BufInStream","title":"BufInStream"},{"location":"api/sys/BufInStream/#inheritance","text":"sys::Obj sys::Virtual sys::InStream sys::BufInStream public final class BufInStream BufInStream is used to read bytes from a memory Buf.","title":"Inheritance"},{"location":"api/sys/BufInStream/#fields","text":"","title":"Fields"},{"location":"api/sys/BufInStream/#buf","text":"public Buf buf","title":"buf"},{"location":"api/sys/BufInStream/#pos","text":"public short pos","title":"pos"},{"location":"api/sys/BufInStream/#methods","text":"","title":"Methods"},{"location":"api/sys/BufInStream/#bufinstream_1","text":"public void BufInStream( Buf buf) Construct for specified Buf instance.","title":"BufInStream"},{"location":"api/sys/BufInStream/#read","text":"public override int read() Read the next byte at pos and increment pos. Return -1 if pos >= size.","title":"read"},{"location":"api/sys/BufInStream/#readbytes","text":"public override int readBytes(byte[] b, int off, int len) Read the next block of available bytes starting from pos. Return the number of bytes copied into b and advance the position likewise.","title":"readBytes"},{"location":"api/sys/BufInStream/#readstrinplace","text":"public Str readStrInPlace( Str str) Read the current position as a null terminated string. Return null on error.","title":"readStrInPlace"},{"location":"api/sys/BufInStream/#rewind","text":"public void rewind() Rewind sets the pos back to zero to begin reading the Buf from the beginning. Doc Home > API Index > sys > BufInStream","title":"rewind"},{"location":"api/sys/BufOutStream/","text":"BufOutStream \u00b6 Doc Home > API Index > sys > BufOutStream Inheritance \u00b6 sys::Obj sys::Virtual sys::OutStream sys::BufOutStream public final class BufOutStream BufOutStream is used to write bytes to a memory Buf. Fields \u00b6 buf \u00b6 public Buf buf Methods \u00b6 BufOutStream \u00b6 public void BufOutStream( Buf buf) Construct for specified Buf instance. write \u00b6 public override bool write(int x) Write a byte to the end of the buffer at buf[size]. Return true on success, false if buffer is full. writeBytes \u00b6 public override bool writeBytes(byte[] b, int off, int len) Write a block of bytes to the end of the buffer. buffer size. Return true on success, false if there is not enough room in the buffer. Doc Home > API Index > sys > BufOutStream","title":"BufOutStream"},{"location":"api/sys/BufOutStream/#bufoutstream","text":"Doc Home > API Index > sys > BufOutStream","title":"BufOutStream"},{"location":"api/sys/BufOutStream/#inheritance","text":"sys::Obj sys::Virtual sys::OutStream sys::BufOutStream public final class BufOutStream BufOutStream is used to write bytes to a memory Buf.","title":"Inheritance"},{"location":"api/sys/BufOutStream/#fields","text":"","title":"Fields"},{"location":"api/sys/BufOutStream/#buf","text":"public Buf buf","title":"buf"},{"location":"api/sys/BufOutStream/#methods","text":"","title":"Methods"},{"location":"api/sys/BufOutStream/#bufoutstream_1","text":"public void BufOutStream( Buf buf) Construct for specified Buf instance.","title":"BufOutStream"},{"location":"api/sys/BufOutStream/#write","text":"public override bool write(int x) Write a byte to the end of the buffer at buf[size]. Return true on success, false if buffer is full.","title":"write"},{"location":"api/sys/BufOutStream/#writebytes","text":"public override bool writeBytes(byte[] b, int off, int len) Write a block of bytes to the end of the buffer. buffer size. Return true on success, false if there is not enough room in the buffer. Doc Home > API Index > sys > BufOutStream","title":"writeBytes"},{"location":"api/sys/Component/","text":"Component \u00b6 Doc Home > API Index > sys > Component Inheritance \u00b6 sys::Obj sys::Virtual sys::Component public class Component Component is the base class for all Sedona component classes. Fields \u00b6 ADDED \u00b6 public static const define int ADDED REMOVED \u00b6 public static const define int REMOVED REORDERED \u00b6 public static const define int REORDERED children \u00b6 public short children First child id in linked list of children (do not modify directly) id \u00b6 public short id Identifier in application (do not modify directly) linksFrom \u00b6 public Link linksFrom Linked list of Links where this is the \"from\" component linksTo \u00b6 public Link linksTo Linked list of Links where this is the \"to\" component meta \u00b6 public property int meta [config] Metadata common to all components is packed into 32-bits: 00-03: nibble for security groups 16-23: byte logical x coordinate on wiresheet 23-31: byte logical y coordinate on wiresheet name \u00b6 public inline Str name nameLen \u00b6 public static const define int nameLen Human name for this component which is unique within its parent (do not modify directly) nextSibling \u00b6 public short nextSibling Next sibling id for linked list of components under a given parent (do not modify directly) nullId \u00b6 public static const define int nullId This value represents a null two byte id as 0xffff parent \u00b6 public short parent Parent id or nullId if root App or unmounted (do not modify directly) type \u00b6 public const Type type Reference to the Type instance which describes this Component. watchFlags \u00b6 public inline byte[] watchFlags Bitmask for each watch's subscriptions and events Methods \u00b6 allowChildExecute \u00b6 public virtual bool allowChildExecute() allowChildExecute returns false if child components of this should not have execute() called this app cycle. changed \u00b6 public virtual void changed( Slot slot) The changed method must be called when a slot is modified. It is automatically called whenever setting a property field with a primitive type (bool, byte, short, int, and float). However it must be manually called after updating the contents of a Buf property. If you override this method, you MUST call super! childEvent \u00b6 public virtual int childEvent(int eType, Component child) Called on parent when a child event occurs. Only called if app is running. Defined event types are: REMOVED - notification that child has been removed from component. Should always return 0. Called after stop() on child. ADDED - notification that child has been added to component. Should always return 0. Called prior to loaded() / start() on child. REORDERED - notification that component's children have been reordered. Should always return 0. Called after the reordering is complete. Only called once per reorder event; child arg is always null. Future event types may make use of return code. execute \u00b6 public virtual void execute() Execute is called once every scan using the simple round-robin scan engine. fireLinksChanged \u00b6 public void fireLinksChanged() Fire the links changed event on this component by marking the link event bit for each watch's bitmask. fireTreeChanged \u00b6 public void fireTreeChanged() Fire a tree changed event on this component by marking the tree event bit for each watch's bitmask. getBool \u00b6 public native bool getBool( Slot slot) Get a bool property using reflection. getBuf \u00b6 public native Buf getBuf( Slot slot) Get a Buf property using reflection. getDouble \u00b6 public native double getDouble( Slot slot) Get a double property using reflection. getFloat \u00b6 public native float getFloat( Slot slot) Get a float property using reflection. getInt \u00b6 public native int getInt( Slot slot) Get an integer (byte, short, or int) property using reflection. getLong \u00b6 public native long getLong( Slot slot) Get a long property using reflection. invokeAction \u00b6 public void invokeAction( InStream in, Slot slot) Decode a value from the input stream and invoke for the specified action. invokeBool \u00b6 public native void invokeBool( Slot slot, bool arg) Invoke an action which takes a boolean argument. invokeBuf \u00b6 public native void invokeBuf( Slot slot, Buf arg) Invoke an action which takes a Buf argument. invokeDouble \u00b6 public native void invokeDouble( Slot slot, double arg) Invoke an action which takes a double argument. invokeFloat \u00b6 public native void invokeFloat( Slot slot, float arg) Invoke an action which takes a float argument. invokeInt \u00b6 public native void invokeInt( Slot slot, int arg) Invoke an action which takes an int argument. invokeLong \u00b6 public native void invokeLong( Slot slot, long arg) Invoke an action which takes a long argument. invokeVoid \u00b6 public native void invokeVoid( Slot slot) Invoke an action which takes no arguments. linkEvent \u00b6 public virtual int linkEvent(int eType, Link link) Called on a component when a link event occurs. Only called if app is running. Defined event types are: REMOVED - link has been removed from the component. Should always return 0 ADDED - link has been added to the component. Should always return 0. Future event types may make use of return code. loadAppComp \u00b6 public int loadAppComp( InStream in) Load the component's configuration from a binary format input stream - see saveAppComp() for format. We assume component id and type id have already been read. Return 0 on success or non-zero on error. loadProp \u00b6 public void loadProp( InStream in, Slot slot) Decode a value from the input stream and set for the specified property. loadProps \u00b6 public void loadProps( InStream in, int filter) Load the property values to the output stream. Filter: 0 = all 'c' = config only 'r' = runtime only loaded \u00b6 public virtual void loaded() Callback when component is loaded into an app. This occurs before the start phase. Only called if app is running. lookupByName \u00b6 public Component lookupByName( Str name) Lookup a child by name or return null. parentEvent \u00b6 public virtual int parentEvent(int eType, Component parent) Called on a child when a parent event occurs. Only called if app is running. Defined event types are: REMOVED - notification that child has been removed/unparented. Should always return 0. Called after stop() on child. ADDED - notification this child has been parented. Should always return 0. Called prior to loaded() / start() on child. Future event types may make use of return code. path \u00b6 public Component [] path() Get the path of this component from the root App. The end of the path is denoted by null. The list is a shared static buffer. Return null on error or if not mounted under an Sys.app. saveAppComp \u00b6 public void saveAppComp( OutStream out) Save the component's application information in binary format to the output stream: appComp { u2 id u1 kitId u1 typeId str name u2 parent u2 children u2 nextSibling val[] configProps u1 ';' end marker } saveProp \u00b6 public void saveProp( OutStream out, Slot prop) Save a property value to the output stream. saveProps \u00b6 public void saveProps( OutStream out, int filter) Save the property values to the output stream. Filter: 0 = all 'c' = config only 'r' = runtime only setBool \u00b6 public void setBool( Slot slot, bool val) Set a bool property using reflection. setDouble \u00b6 public void setDouble( Slot slot, double val) Set a double property using reflection. setFloat \u00b6 public void setFloat( Slot slot, float val) Set a float property using reflection. setInt \u00b6 public void setInt( Slot slot, int val) Set an integer (byte, short, or int) property using reflection. setLong \u00b6 public void setLong( Slot slot, long val) Set a long property using reflection. setToDefault \u00b6 public virtual void setToDefault( Slot slot) Set property to a default value. Called when a link is removed from an input slot. start \u00b6 public virtual void start() Callback when component is first started in an app. This occurs only after all components have had their loaded callback invoked. Only called if app is running stop \u00b6 public virtual void stop() Callback when component is first stopped in an app. Only called if app is running. Doc Home > API Index > sys > Component","title":"Component"},{"location":"api/sys/Component/#component","text":"Doc Home > API Index > sys > Component","title":"Component"},{"location":"api/sys/Component/#inheritance","text":"sys::Obj sys::Virtual sys::Component public class Component Component is the base class for all Sedona component classes.","title":"Inheritance"},{"location":"api/sys/Component/#fields","text":"","title":"Fields"},{"location":"api/sys/Component/#added","text":"public static const define int ADDED","title":"ADDED"},{"location":"api/sys/Component/#removed","text":"public static const define int REMOVED","title":"REMOVED"},{"location":"api/sys/Component/#reordered","text":"public static const define int REORDERED","title":"REORDERED"},{"location":"api/sys/Component/#children","text":"public short children First child id in linked list of children (do not modify directly)","title":"children"},{"location":"api/sys/Component/#id","text":"public short id Identifier in application (do not modify directly)","title":"id"},{"location":"api/sys/Component/#linksfrom","text":"public Link linksFrom Linked list of Links where this is the \"from\" component","title":"linksFrom"},{"location":"api/sys/Component/#linksto","text":"public Link linksTo Linked list of Links where this is the \"to\" component","title":"linksTo"},{"location":"api/sys/Component/#meta","text":"public property int meta [config] Metadata common to all components is packed into 32-bits: 00-03: nibble for security groups 16-23: byte logical x coordinate on wiresheet 23-31: byte logical y coordinate on wiresheet","title":"meta"},{"location":"api/sys/Component/#name","text":"public inline Str name","title":"name"},{"location":"api/sys/Component/#namelen","text":"public static const define int nameLen Human name for this component which is unique within its parent (do not modify directly)","title":"nameLen"},{"location":"api/sys/Component/#nextsibling","text":"public short nextSibling Next sibling id for linked list of components under a given parent (do not modify directly)","title":"nextSibling"},{"location":"api/sys/Component/#nullid","text":"public static const define int nullId This value represents a null two byte id as 0xffff","title":"nullId"},{"location":"api/sys/Component/#parent","text":"public short parent Parent id or nullId if root App or unmounted (do not modify directly)","title":"parent"},{"location":"api/sys/Component/#type","text":"public const Type type Reference to the Type instance which describes this Component.","title":"type"},{"location":"api/sys/Component/#watchflags","text":"public inline byte[] watchFlags Bitmask for each watch's subscriptions and events","title":"watchFlags"},{"location":"api/sys/Component/#methods","text":"","title":"Methods"},{"location":"api/sys/Component/#allowchildexecute","text":"public virtual bool allowChildExecute() allowChildExecute returns false if child components of this should not have execute() called this app cycle.","title":"allowChildExecute"},{"location":"api/sys/Component/#changed","text":"public virtual void changed( Slot slot) The changed method must be called when a slot is modified. It is automatically called whenever setting a property field with a primitive type (bool, byte, short, int, and float). However it must be manually called after updating the contents of a Buf property. If you override this method, you MUST call super!","title":"changed"},{"location":"api/sys/Component/#childevent","text":"public virtual int childEvent(int eType, Component child) Called on parent when a child event occurs. Only called if app is running. Defined event types are: REMOVED - notification that child has been removed from component. Should always return 0. Called after stop() on child. ADDED - notification that child has been added to component. Should always return 0. Called prior to loaded() / start() on child. REORDERED - notification that component's children have been reordered. Should always return 0. Called after the reordering is complete. Only called once per reorder event; child arg is always null. Future event types may make use of return code.","title":"childEvent"},{"location":"api/sys/Component/#execute","text":"public virtual void execute() Execute is called once every scan using the simple round-robin scan engine.","title":"execute"},{"location":"api/sys/Component/#firelinkschanged","text":"public void fireLinksChanged() Fire the links changed event on this component by marking the link event bit for each watch's bitmask.","title":"fireLinksChanged"},{"location":"api/sys/Component/#firetreechanged","text":"public void fireTreeChanged() Fire a tree changed event on this component by marking the tree event bit for each watch's bitmask.","title":"fireTreeChanged"},{"location":"api/sys/Component/#getbool","text":"public native bool getBool( Slot slot) Get a bool property using reflection.","title":"getBool"},{"location":"api/sys/Component/#getbuf","text":"public native Buf getBuf( Slot slot) Get a Buf property using reflection.","title":"getBuf"},{"location":"api/sys/Component/#getdouble","text":"public native double getDouble( Slot slot) Get a double property using reflection.","title":"getDouble"},{"location":"api/sys/Component/#getfloat","text":"public native float getFloat( Slot slot) Get a float property using reflection.","title":"getFloat"},{"location":"api/sys/Component/#getint","text":"public native int getInt( Slot slot) Get an integer (byte, short, or int) property using reflection.","title":"getInt"},{"location":"api/sys/Component/#getlong","text":"public native long getLong( Slot slot) Get a long property using reflection.","title":"getLong"},{"location":"api/sys/Component/#invokeaction","text":"public void invokeAction( InStream in, Slot slot) Decode a value from the input stream and invoke for the specified action.","title":"invokeAction"},{"location":"api/sys/Component/#invokebool","text":"public native void invokeBool( Slot slot, bool arg) Invoke an action which takes a boolean argument.","title":"invokeBool"},{"location":"api/sys/Component/#invokebuf","text":"public native void invokeBuf( Slot slot, Buf arg) Invoke an action which takes a Buf argument.","title":"invokeBuf"},{"location":"api/sys/Component/#invokedouble","text":"public native void invokeDouble( Slot slot, double arg) Invoke an action which takes a double argument.","title":"invokeDouble"},{"location":"api/sys/Component/#invokefloat","text":"public native void invokeFloat( Slot slot, float arg) Invoke an action which takes a float argument.","title":"invokeFloat"},{"location":"api/sys/Component/#invokeint","text":"public native void invokeInt( Slot slot, int arg) Invoke an action which takes an int argument.","title":"invokeInt"},{"location":"api/sys/Component/#invokelong","text":"public native void invokeLong( Slot slot, long arg) Invoke an action which takes a long argument.","title":"invokeLong"},{"location":"api/sys/Component/#invokevoid","text":"public native void invokeVoid( Slot slot) Invoke an action which takes no arguments.","title":"invokeVoid"},{"location":"api/sys/Component/#linkevent","text":"public virtual int linkEvent(int eType, Link link) Called on a component when a link event occurs. Only called if app is running. Defined event types are: REMOVED - link has been removed from the component. Should always return 0 ADDED - link has been added to the component. Should always return 0. Future event types may make use of return code.","title":"linkEvent"},{"location":"api/sys/Component/#loadappcomp","text":"public int loadAppComp( InStream in) Load the component's configuration from a binary format input stream - see saveAppComp() for format. We assume component id and type id have already been read. Return 0 on success or non-zero on error.","title":"loadAppComp"},{"location":"api/sys/Component/#loadprop","text":"public void loadProp( InStream in, Slot slot) Decode a value from the input stream and set for the specified property.","title":"loadProp"},{"location":"api/sys/Component/#loadprops","text":"public void loadProps( InStream in, int filter) Load the property values to the output stream. Filter: 0 = all 'c' = config only 'r' = runtime only","title":"loadProps"},{"location":"api/sys/Component/#loaded","text":"public virtual void loaded() Callback when component is loaded into an app. This occurs before the start phase. Only called if app is running.","title":"loaded"},{"location":"api/sys/Component/#lookupbyname","text":"public Component lookupByName( Str name) Lookup a child by name or return null.","title":"lookupByName"},{"location":"api/sys/Component/#parentevent","text":"public virtual int parentEvent(int eType, Component parent) Called on a child when a parent event occurs. Only called if app is running. Defined event types are: REMOVED - notification that child has been removed/unparented. Should always return 0. Called after stop() on child. ADDED - notification this child has been parented. Should always return 0. Called prior to loaded() / start() on child. Future event types may make use of return code.","title":"parentEvent"},{"location":"api/sys/Component/#path","text":"public Component [] path() Get the path of this component from the root App. The end of the path is denoted by null. The list is a shared static buffer. Return null on error or if not mounted under an Sys.app.","title":"path"},{"location":"api/sys/Component/#saveappcomp","text":"public void saveAppComp( OutStream out) Save the component's application information in binary format to the output stream: appComp { u2 id u1 kitId u1 typeId str name u2 parent u2 children u2 nextSibling val[] configProps u1 ';' end marker }","title":"saveAppComp"},{"location":"api/sys/Component/#saveprop","text":"public void saveProp( OutStream out, Slot prop) Save a property value to the output stream.","title":"saveProp"},{"location":"api/sys/Component/#saveprops","text":"public void saveProps( OutStream out, int filter) Save the property values to the output stream. Filter: 0 = all 'c' = config only 'r' = runtime only","title":"saveProps"},{"location":"api/sys/Component/#setbool","text":"public void setBool( Slot slot, bool val) Set a bool property using reflection.","title":"setBool"},{"location":"api/sys/Component/#setdouble","text":"public void setDouble( Slot slot, double val) Set a double property using reflection.","title":"setDouble"},{"location":"api/sys/Component/#setfloat","text":"public void setFloat( Slot slot, float val) Set a float property using reflection.","title":"setFloat"},{"location":"api/sys/Component/#setint","text":"public void setInt( Slot slot, int val) Set an integer (byte, short, or int) property using reflection.","title":"setInt"},{"location":"api/sys/Component/#setlong","text":"public void setLong( Slot slot, long val) Set a long property using reflection.","title":"setLong"},{"location":"api/sys/Component/#settodefault","text":"public virtual void setToDefault( Slot slot) Set property to a default value. Called when a link is removed from an input slot.","title":"setToDefault"},{"location":"api/sys/Component/#start","text":"public virtual void start() Callback when component is first started in an app. This occurs only after all components have had their loaded callback invoked. Only called if app is running","title":"start"},{"location":"api/sys/Component/#stop","text":"public virtual void stop() Callback when component is first stopped in an app. Only called if app is running. Doc Home > API Index > sys > Component","title":"stop"},{"location":"api/sys/Err/","text":"Err \u00b6 Doc Home > API Index > sys > Err Inheritance \u00b6 sys::Obj sys::Err public class Err Errors codes are assigned as follows: Non-recoverable: [C code: 1-39] [Sedona: 40-99] - don't attempt to auto-restart application because the vm, scode, or app itself is invalid Recoverable: [C code: 100-139] [Sedona: 140-249] - something went wrong at runtime, but if we auto-restart the app things will probably start working again (at least for a little while) Special: [250-255] - special codes shared b/w C and Sedona code Fields \u00b6 badPlatformService \u00b6 public static const define int badPlatformService cannotInitApp \u00b6 public static const define int cannotInitApp cannotInsert \u00b6 public static const define int cannotInsert cannotLoadLink \u00b6 public static const define int cannotLoadLink cannotMalloc \u00b6 public static const define int cannotMalloc cannotOpenFile \u00b6 public static const define int cannotOpenFile hibernate \u00b6 public static const define int hibernate invalidAppEndMarker \u00b6 public static const define int invalidAppEndMarker invalidArgs \u00b6 public static const define int invalidArgs invalidCompEndMarker \u00b6 public static const define int invalidCompEndMarker invalidKitId \u00b6 public static const define int invalidKitId invalidMagic \u00b6 public static const define int invalidMagic invalidSchema \u00b6 public static const define int invalidSchema invalidTypeId \u00b6 public static const define int invalidTypeId invalidVersion \u00b6 public static const define int invalidVersion nameTooLong \u00b6 public static const define int nameTooLong noPlatformService \u00b6 public static const define int noPlatformService restart \u00b6 public static const define int restart unexpectedEOF \u00b6 public static const define int unexpectedEOF yield \u00b6 public static const define int yield Doc Home > API Index > sys > Err","title":"Err"},{"location":"api/sys/Err/#err","text":"Doc Home > API Index > sys > Err","title":"Err"},{"location":"api/sys/Err/#inheritance","text":"sys::Obj sys::Err public class Err Errors codes are assigned as follows: Non-recoverable: [C code: 1-39] [Sedona: 40-99] - don't attempt to auto-restart application because the vm, scode, or app itself is invalid Recoverable: [C code: 100-139] [Sedona: 140-249] - something went wrong at runtime, but if we auto-restart the app things will probably start working again (at least for a little while) Special: [250-255] - special codes shared b/w C and Sedona code","title":"Inheritance"},{"location":"api/sys/Err/#fields","text":"","title":"Fields"},{"location":"api/sys/Err/#badplatformservice","text":"public static const define int badPlatformService","title":"badPlatformService"},{"location":"api/sys/Err/#cannotinitapp","text":"public static const define int cannotInitApp","title":"cannotInitApp"},{"location":"api/sys/Err/#cannotinsert","text":"public static const define int cannotInsert","title":"cannotInsert"},{"location":"api/sys/Err/#cannotloadlink","text":"public static const define int cannotLoadLink","title":"cannotLoadLink"},{"location":"api/sys/Err/#cannotmalloc","text":"public static const define int cannotMalloc","title":"cannotMalloc"},{"location":"api/sys/Err/#cannotopenfile","text":"public static const define int cannotOpenFile","title":"cannotOpenFile"},{"location":"api/sys/Err/#hibernate","text":"public static const define int hibernate","title":"hibernate"},{"location":"api/sys/Err/#invalidappendmarker","text":"public static const define int invalidAppEndMarker","title":"invalidAppEndMarker"},{"location":"api/sys/Err/#invalidargs","text":"public static const define int invalidArgs","title":"invalidArgs"},{"location":"api/sys/Err/#invalidcompendmarker","text":"public static const define int invalidCompEndMarker","title":"invalidCompEndMarker"},{"location":"api/sys/Err/#invalidkitid","text":"public static const define int invalidKitId","title":"invalidKitId"},{"location":"api/sys/Err/#invalidmagic","text":"public static const define int invalidMagic","title":"invalidMagic"},{"location":"api/sys/Err/#invalidschema","text":"public static const define int invalidSchema","title":"invalidSchema"},{"location":"api/sys/Err/#invalidtypeid","text":"public static const define int invalidTypeId","title":"invalidTypeId"},{"location":"api/sys/Err/#invalidversion","text":"public static const define int invalidVersion","title":"invalidVersion"},{"location":"api/sys/Err/#nametoolong","text":"public static const define int nameTooLong","title":"nameTooLong"},{"location":"api/sys/Err/#noplatformservice","text":"public static const define int noPlatformService","title":"noPlatformService"},{"location":"api/sys/Err/#restart","text":"public static const define int restart","title":"restart"},{"location":"api/sys/Err/#unexpectedeof","text":"public static const define int unexpectedEOF","title":"unexpectedEOF"},{"location":"api/sys/Err/#yield","text":"public static const define int yield Doc Home > API Index > sys > Err","title":"yield"},{"location":"api/sys/File/","text":"File \u00b6 Doc Home > API Index > sys > File Inheritance \u00b6 sys::Obj sys::File public final class File File is used to manage I/O to a \"file\". A Sedona VM may support multiple file backing storage devices via FileStore subclasses. Fields \u00b6 fp \u00b6 public Obj fp in \u00b6 public inline InStream in name \u00b6 public Str name out \u00b6 public inline OutStream out store \u00b6 public FileStore store Methods \u00b6 File \u00b6 public void File() File constructor. close \u00b6 public bool close() Close this file. Return true on success or false on failure. exists \u00b6 public bool exists() Return if the file identified by name exists on the file system. This method may used without opening the file. fsync \u00b6 public void fsync() Flush libc buffers and sync all pending writes to persistent storage. open \u00b6 public bool open( Str mode) Open the file using the configured name field. Mode is a string how IO will be performed: - \"r\": open for reading - \"w\": open for writing (truncate existing) - \"m\": open for modification and read/writing (don't truncate) Return true on success or false on error. Note although the mode strings are passed as simply \"r\", \"w\", or \"m\", it is expected that files are always opened for binary IO - for example \"w\" maps to the C fopen mode of \"wb\". seek \u00b6 public bool seek(int pos) Seek to a specific byte offset position in the file. Return true on success or false on failure. A failure typically indicates a seek past the file limit of the device's \"file system\". Use tell to read the current position. size \u00b6 public int size() Return the size in bytes of the file, or -1 if the file does not exist or cannot currently be accessed (e.g. if open for writing). This method may used without opening the file. tell \u00b6 public int tell() Return the current byte offset position of the file. Use seek to change the current position. Returns -1 on an error. Doc Home > API Index > sys > File","title":"File"},{"location":"api/sys/File/#file","text":"Doc Home > API Index > sys > File","title":"File"},{"location":"api/sys/File/#inheritance","text":"sys::Obj sys::File public final class File File is used to manage I/O to a \"file\". A Sedona VM may support multiple file backing storage devices via FileStore subclasses.","title":"Inheritance"},{"location":"api/sys/File/#fields","text":"","title":"Fields"},{"location":"api/sys/File/#fp","text":"public Obj fp","title":"fp"},{"location":"api/sys/File/#in","text":"public inline InStream in","title":"in"},{"location":"api/sys/File/#name","text":"public Str name","title":"name"},{"location":"api/sys/File/#out","text":"public inline OutStream out","title":"out"},{"location":"api/sys/File/#store","text":"public FileStore store","title":"store"},{"location":"api/sys/File/#methods","text":"","title":"Methods"},{"location":"api/sys/File/#file_1","text":"public void File() File constructor.","title":"File"},{"location":"api/sys/File/#close","text":"public bool close() Close this file. Return true on success or false on failure.","title":"close"},{"location":"api/sys/File/#exists","text":"public bool exists() Return if the file identified by name exists on the file system. This method may used without opening the file.","title":"exists"},{"location":"api/sys/File/#fsync","text":"public void fsync() Flush libc buffers and sync all pending writes to persistent storage.","title":"fsync"},{"location":"api/sys/File/#open","text":"public bool open( Str mode) Open the file using the configured name field. Mode is a string how IO will be performed: - \"r\": open for reading - \"w\": open for writing (truncate existing) - \"m\": open for modification and read/writing (don't truncate) Return true on success or false on error. Note although the mode strings are passed as simply \"r\", \"w\", or \"m\", it is expected that files are always opened for binary IO - for example \"w\" maps to the C fopen mode of \"wb\".","title":"open"},{"location":"api/sys/File/#seek","text":"public bool seek(int pos) Seek to a specific byte offset position in the file. Return true on success or false on failure. A failure typically indicates a seek past the file limit of the device's \"file system\". Use tell to read the current position.","title":"seek"},{"location":"api/sys/File/#size","text":"public int size() Return the size in bytes of the file, or -1 if the file does not exist or cannot currently be accessed (e.g. if open for writing). This method may used without opening the file.","title":"size"},{"location":"api/sys/File/#tell","text":"public int tell() Return the current byte offset position of the file. Use seek to change the current position. Returns -1 on an error. Doc Home > API Index > sys > File","title":"tell"},{"location":"api/sys/FileStore/","text":"FileStore \u00b6 Doc Home > API Index > sys > FileStore Inheritance \u00b6 sys::Obj sys::Virtual sys::FileStore public class FileStore FileStore is used to implement the backing storage of File based I/O. Typically each storage device such as static RAM or EEPROM implements a subclass of FileStore and declares a singleton instance, inserting it into the FileStore static linked list at runtime. Filenames are mapped to a FileStore instance via 'FileStore.lookup', which steps through the static linked list and calls accept() on each one, returning the first instance that returns true. Fields \u00b6 next \u00b6 public FileStore next Pointer to next FileStore object in linked list. sys \u00b6 public static inline FileStore sys Built-in system file storage implementation. Also head of linked list of other FileStores, if any Methods \u00b6 accept \u00b6 public virtual bool accept( Str filename) Parse the given filename, and return true if this is the appropriate FileStore instance to handle it. Default is to return false. close \u00b6 public virtual bool close( File f) Implementation for 'File.close'. doClose \u00b6 public static native bool doClose( Obj fp) doFlush \u00b6 public static native void doFlush( Obj fp) doFsync \u00b6 public static native void doFsync( Obj fp) doOpen \u00b6 public static native Obj doOpen( Str name, Str mode) doRead \u00b6 public static native int doRead( Obj fp) doReadBytes \u00b6 public static native int doReadBytes( Obj fp, byte[] b, int off, int len) doSeek \u00b6 public static native bool doSeek( Obj fp, int pos) doSize \u00b6 public static native int doSize( Str name) doTell \u00b6 public static native int doTell( Obj fp) doWrite \u00b6 public static native bool doWrite( Obj fp, int b) doWriteBytes \u00b6 public static native bool doWriteBytes( Obj fp, byte[] b, int off, int len) flush \u00b6 public virtual void flush( File f) Implementation for 'File.out.flush'. fsync \u00b6 public virtual void fsync( File f) Implementation for 'File.out.fsync'. insert \u00b6 public static bool insert( FileStore fsObj) Insert fsObj at end of FileStore list. This function should be called by the constructor of an instance of a FileStore subclass, to insert itself into the list. Always returns true. No protection against adding an instance multiple times. lookup \u00b6 public static FileStore lookup( Str filename) Return first FileStore instance from list that returns true from accept(). Returns FileStore.sys if no instance returns true. open \u00b6 public virtual bool open( File f, Str mode) Implementation for 'File.open'. read \u00b6 public virtual int read( File f) Implementation for 'File.in.read'. readBytes \u00b6 public virtual int readBytes( File f, byte[] b, int off, int len) Implementation for 'File.in.readBytes'. remove \u00b6 public static native bool remove( Str filename) Unlink/Delete a file. Return true on success, false on failure. rename \u00b6 public static native bool rename( Str from, Str to) Rename a file. Return true on success, false on failure. seek \u00b6 public virtual bool seek( File f, int pos) Implementation for 'File.seek'. size \u00b6 public virtual int size( File f) Implementation for 'File.size'. Must work without opening the file. tell \u00b6 public virtual int tell( File f) Implementation for 'File.tell'. write \u00b6 public virtual bool write( File f, int b) Implementation for 'File.out.write'. writeBytes \u00b6 public virtual bool writeBytes( File f, byte[] b, int off, int len) Implementation for 'File.out.writeBytes'. Doc Home > API Index > sys > FileStore","title":"FileStore"},{"location":"api/sys/FileStore/#filestore","text":"Doc Home > API Index > sys > FileStore","title":"FileStore"},{"location":"api/sys/FileStore/#inheritance","text":"sys::Obj sys::Virtual sys::FileStore public class FileStore FileStore is used to implement the backing storage of File based I/O. Typically each storage device such as static RAM or EEPROM implements a subclass of FileStore and declares a singleton instance, inserting it into the FileStore static linked list at runtime. Filenames are mapped to a FileStore instance via 'FileStore.lookup', which steps through the static linked list and calls accept() on each one, returning the first instance that returns true.","title":"Inheritance"},{"location":"api/sys/FileStore/#fields","text":"","title":"Fields"},{"location":"api/sys/FileStore/#next","text":"public FileStore next Pointer to next FileStore object in linked list.","title":"next"},{"location":"api/sys/FileStore/#sys","text":"public static inline FileStore sys Built-in system file storage implementation. Also head of linked list of other FileStores, if any","title":"sys"},{"location":"api/sys/FileStore/#methods","text":"","title":"Methods"},{"location":"api/sys/FileStore/#accept","text":"public virtual bool accept( Str filename) Parse the given filename, and return true if this is the appropriate FileStore instance to handle it. Default is to return false.","title":"accept"},{"location":"api/sys/FileStore/#close","text":"public virtual bool close( File f) Implementation for 'File.close'.","title":"close"},{"location":"api/sys/FileStore/#doclose","text":"public static native bool doClose( Obj fp)","title":"doClose"},{"location":"api/sys/FileStore/#doflush","text":"public static native void doFlush( Obj fp)","title":"doFlush"},{"location":"api/sys/FileStore/#dofsync","text":"public static native void doFsync( Obj fp)","title":"doFsync"},{"location":"api/sys/FileStore/#doopen","text":"public static native Obj doOpen( Str name, Str mode)","title":"doOpen"},{"location":"api/sys/FileStore/#doread","text":"public static native int doRead( Obj fp)","title":"doRead"},{"location":"api/sys/FileStore/#doreadbytes","text":"public static native int doReadBytes( Obj fp, byte[] b, int off, int len)","title":"doReadBytes"},{"location":"api/sys/FileStore/#doseek","text":"public static native bool doSeek( Obj fp, int pos)","title":"doSeek"},{"location":"api/sys/FileStore/#dosize","text":"public static native int doSize( Str name)","title":"doSize"},{"location":"api/sys/FileStore/#dotell","text":"public static native int doTell( Obj fp)","title":"doTell"},{"location":"api/sys/FileStore/#dowrite","text":"public static native bool doWrite( Obj fp, int b)","title":"doWrite"},{"location":"api/sys/FileStore/#dowritebytes","text":"public static native bool doWriteBytes( Obj fp, byte[] b, int off, int len)","title":"doWriteBytes"},{"location":"api/sys/FileStore/#flush","text":"public virtual void flush( File f) Implementation for 'File.out.flush'.","title":"flush"},{"location":"api/sys/FileStore/#fsync","text":"public virtual void fsync( File f) Implementation for 'File.out.fsync'.","title":"fsync"},{"location":"api/sys/FileStore/#insert","text":"public static bool insert( FileStore fsObj) Insert fsObj at end of FileStore list. This function should be called by the constructor of an instance of a FileStore subclass, to insert itself into the list. Always returns true. No protection against adding an instance multiple times.","title":"insert"},{"location":"api/sys/FileStore/#lookup","text":"public static FileStore lookup( Str filename) Return first FileStore instance from list that returns true from accept(). Returns FileStore.sys if no instance returns true.","title":"lookup"},{"location":"api/sys/FileStore/#open","text":"public virtual bool open( File f, Str mode) Implementation for 'File.open'.","title":"open"},{"location":"api/sys/FileStore/#read","text":"public virtual int read( File f) Implementation for 'File.in.read'.","title":"read"},{"location":"api/sys/FileStore/#readbytes","text":"public virtual int readBytes( File f, byte[] b, int off, int len) Implementation for 'File.in.readBytes'.","title":"readBytes"},{"location":"api/sys/FileStore/#remove","text":"public static native bool remove( Str filename) Unlink/Delete a file. Return true on success, false on failure.","title":"remove"},{"location":"api/sys/FileStore/#rename","text":"public static native bool rename( Str from, Str to) Rename a file. Return true on success, false on failure.","title":"rename"},{"location":"api/sys/FileStore/#seek","text":"public virtual bool seek( File f, int pos) Implementation for 'File.seek'.","title":"seek"},{"location":"api/sys/FileStore/#size","text":"public virtual int size( File f) Implementation for 'File.size'. Must work without opening the file.","title":"size"},{"location":"api/sys/FileStore/#tell","text":"public virtual int tell( File f) Implementation for 'File.tell'.","title":"tell"},{"location":"api/sys/FileStore/#write","text":"public virtual bool write( File f, int b) Implementation for 'File.out.write'.","title":"write"},{"location":"api/sys/FileStore/#writebytes","text":"public virtual bool writeBytes( File f, byte[] b, int off, int len) Implementation for 'File.out.writeBytes'. Doc Home > API Index > sys > FileStore","title":"writeBytes"},{"location":"api/sys/Folder/","text":"Folder \u00b6 Doc Home > API Index > sys > Folder Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::Folder public class Folder [niagaraIcon=\"module://icons/x16/folder.png\"] Folder is a component used to group other components. Doc Home > API Index > sys > Folder","title":"Folder"},{"location":"api/sys/Folder/#folder","text":"Doc Home > API Index > sys > Folder","title":"Folder"},{"location":"api/sys/Folder/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::Folder public class Folder [niagaraIcon=\"module://icons/x16/folder.png\"] Folder is a component used to group other components. Doc Home > API Index > sys > Folder","title":"Inheritance"},{"location":"api/sys/InStream/","text":"InStream \u00b6 Doc Home > API Index > sys > InStream Inheritance \u00b6 sys::Obj sys::Virtual sys::InStream public abstract class InStream InStream is used to input text or binary data. Fields \u00b6 Methods \u00b6 close \u00b6 public virtual void close() Close the stream. Default implementation does nothing. read \u00b6 public abstract int read() Read an unsigned single byte. Return -1 if end of stream is reached. readBool \u00b6 public bool readBool() Read a boolean value of zero or non-zero. readBytes \u00b6 public abstract int readBytes(byte[] b, int off, int len) Read a block of bytes. Return number of bytes read into b, or -1 if end of stream. readChar \u00b6 public int readChar() Read a single character (right now we only read ASCII). readF4 \u00b6 public float readF4() Read a four byte (32-bit) floating point value in network byte order readF8 \u00b6 public double readF8() Read a eight byte (64-bit) floating point value in network byte order readS4 \u00b6 public int readS4() Read an signed four byte (32-bit) integer in network byte order. Return -1 if end of stream. readS8 \u00b6 public long readS8() Read an signed eight byte (64-bit) integer in network byte order. Return -1 if end of stream. readStr \u00b6 public bool readStr( Str s, int max) Read a null terminated string into a buffer. Return true on success, false on error or end of stream. readU2 \u00b6 public int readU2() Read an unsigned two byte integer in network byte order. Return -1 if end of stream. skip \u00b6 public void skip(int n) Skip n number of bytes. Doc Home > API Index > sys > InStream","title":"InStream"},{"location":"api/sys/InStream/#instream","text":"Doc Home > API Index > sys > InStream","title":"InStream"},{"location":"api/sys/InStream/#inheritance","text":"sys::Obj sys::Virtual sys::InStream public abstract class InStream InStream is used to input text or binary data.","title":"Inheritance"},{"location":"api/sys/InStream/#fields","text":"","title":"Fields"},{"location":"api/sys/InStream/#methods","text":"","title":"Methods"},{"location":"api/sys/InStream/#close","text":"public virtual void close() Close the stream. Default implementation does nothing.","title":"close"},{"location":"api/sys/InStream/#read","text":"public abstract int read() Read an unsigned single byte. Return -1 if end of stream is reached.","title":"read"},{"location":"api/sys/InStream/#readbool","text":"public bool readBool() Read a boolean value of zero or non-zero.","title":"readBool"},{"location":"api/sys/InStream/#readbytes","text":"public abstract int readBytes(byte[] b, int off, int len) Read a block of bytes. Return number of bytes read into b, or -1 if end of stream.","title":"readBytes"},{"location":"api/sys/InStream/#readchar","text":"public int readChar() Read a single character (right now we only read ASCII).","title":"readChar"},{"location":"api/sys/InStream/#readf4","text":"public float readF4() Read a four byte (32-bit) floating point value in network byte order","title":"readF4"},{"location":"api/sys/InStream/#readf8","text":"public double readF8() Read a eight byte (64-bit) floating point value in network byte order","title":"readF8"},{"location":"api/sys/InStream/#reads4","text":"public int readS4() Read an signed four byte (32-bit) integer in network byte order. Return -1 if end of stream.","title":"readS4"},{"location":"api/sys/InStream/#reads8","text":"public long readS8() Read an signed eight byte (64-bit) integer in network byte order. Return -1 if end of stream.","title":"readS8"},{"location":"api/sys/InStream/#readstr","text":"public bool readStr( Str s, int max) Read a null terminated string into a buffer. Return true on success, false on error or end of stream.","title":"readStr"},{"location":"api/sys/InStream/#readu2","text":"public int readU2() Read an unsigned two byte integer in network byte order. Return -1 if end of stream.","title":"readU2"},{"location":"api/sys/InStream/#skip","text":"public void skip(int n) Skip n number of bytes. Doc Home > API Index > sys > InStream","title":"skip"},{"location":"api/sys/Kit/","text":"Kit \u00b6 Doc Home > API Index > sys > Kit Inheritance \u00b6 sys::Obj sys::Kit public const class Kit Kit is a top unit of modularity in a Sedona environment and serves as the container for Types. Fields \u00b6 checksum \u00b6 public const int checksum Checksum of this kit. id \u00b6 public const byte id Unique id for kit within a given environment; index into Sys.kits name \u00b6 public const Str name Name string of this kit. types \u00b6 public const inline Type [] types List of types this kit contains, bounded by typesLen. typesLen \u00b6 public const byte typesLen Length of the types array. version \u00b6 public const Str version Version of this kit. Methods \u00b6 findType \u00b6 public Type findType( Str name) Find a type by its simple name unique to this kit or return null if not found. type \u00b6 public Type type(int id) Get the type for the specified id or return null if out of range. Doc Home > API Index > sys > Kit","title":"Kit"},{"location":"api/sys/Kit/#kit","text":"Doc Home > API Index > sys > Kit","title":"Kit"},{"location":"api/sys/Kit/#inheritance","text":"sys::Obj sys::Kit public const class Kit Kit is a top unit of modularity in a Sedona environment and serves as the container for Types.","title":"Inheritance"},{"location":"api/sys/Kit/#fields","text":"","title":"Fields"},{"location":"api/sys/Kit/#checksum","text":"public const int checksum Checksum of this kit.","title":"checksum"},{"location":"api/sys/Kit/#id","text":"public const byte id Unique id for kit within a given environment; index into Sys.kits","title":"id"},{"location":"api/sys/Kit/#name","text":"public const Str name Name string of this kit.","title":"name"},{"location":"api/sys/Kit/#types","text":"public const inline Type [] types List of types this kit contains, bounded by typesLen.","title":"types"},{"location":"api/sys/Kit/#typeslen","text":"public const byte typesLen Length of the types array.","title":"typesLen"},{"location":"api/sys/Kit/#version","text":"public const Str version Version of this kit.","title":"version"},{"location":"api/sys/Kit/#methods","text":"","title":"Methods"},{"location":"api/sys/Kit/#findtype","text":"public Type findType( Str name) Find a type by its simple name unique to this kit or return null if not found.","title":"findType"},{"location":"api/sys/Kit/#type","text":"public Type type(int id) Get the type for the specified id or return null if out of range. Doc Home > API Index > sys > Kit","title":"type"},{"location":"api/sys/Link/","text":"Link \u00b6 Doc Home > API Index > sys > Link Inheritance \u00b6 sys::Obj sys::Link public class Link Link models an execution relationship between a source component's slot to a target component's slot. Fields \u00b6 fromComp \u00b6 public short fromComp fromSlot \u00b6 public byte fromSlot nextFrom \u00b6 public Link nextFrom nextTo \u00b6 public Link nextTo toComp \u00b6 public short toComp toSlot \u00b6 public byte toSlot Methods \u00b6 load \u00b6 public bool load( InStream in, int fromComp) Load the link from a binary format input stream. Return true on success, false on error. propagate \u00b6 public void propagate() Propage the link save \u00b6 public void save( OutStream out) Save the link in binary format to the output stream. Doc Home > API Index > sys > Link","title":"Link"},{"location":"api/sys/Link/#link","text":"Doc Home > API Index > sys > Link","title":"Link"},{"location":"api/sys/Link/#inheritance","text":"sys::Obj sys::Link public class Link Link models an execution relationship between a source component's slot to a target component's slot.","title":"Inheritance"},{"location":"api/sys/Link/#fields","text":"","title":"Fields"},{"location":"api/sys/Link/#fromcomp","text":"public short fromComp","title":"fromComp"},{"location":"api/sys/Link/#fromslot","text":"public byte fromSlot","title":"fromSlot"},{"location":"api/sys/Link/#nextfrom","text":"public Link nextFrom","title":"nextFrom"},{"location":"api/sys/Link/#nextto","text":"public Link nextTo","title":"nextTo"},{"location":"api/sys/Link/#tocomp","text":"public short toComp","title":"toComp"},{"location":"api/sys/Link/#toslot","text":"public byte toSlot","title":"toSlot"},{"location":"api/sys/Link/#methods","text":"","title":"Methods"},{"location":"api/sys/Link/#load","text":"public bool load( InStream in, int fromComp) Load the link from a binary format input stream. Return true on success, false on error.","title":"load"},{"location":"api/sys/Link/#propagate","text":"public void propagate() Propage the link","title":"propagate"},{"location":"api/sys/Link/#save","text":"public void save( OutStream out) Save the link in binary format to the output stream. Doc Home > API Index > sys > Link","title":"save"},{"location":"api/sys/Log/","text":"Log \u00b6 Doc Home > API Index > sys > Log Inheritance \u00b6 sys::Obj sys::Log public const class Log Log is used to embed error, warning, message, and trace logging into Sedona software. Fields \u00b6 ERROR \u00b6 public static const define int ERROR Logging is enabled only for errors MESSAGE \u00b6 public static const define int MESSAGE Logging is enabled for errors, warning, and messages NONE \u00b6 public static const define int NONE Logging is disabled TRACE \u00b6 public static const define int TRACE Logging is enabled for all levels WARNING \u00b6 public static const define int WARNING Logging is enabled for errors and warning id \u00b6 public const short id Index of this log in the Sys.logs array. qname \u00b6 public const Str qname Unique qualified name of this log in the VM. Methods \u00b6 error \u00b6 public OutStream error( Str msg) Log an error record. isError \u00b6 public bool isError() Is current level error or greater. isMessage \u00b6 public bool isMessage() Is current level message or greater. isTrace \u00b6 public bool isTrace() Is current level trace or greater. isWarning \u00b6 public bool isWarning() Is current level warning or greater. level \u00b6 public int level() Get the currently configured severity level enabled for this Log. The level is NONE, ERROR, WARNING, MESSAGE, and TRACE. levelStr \u00b6 public static Str levelStr(int logLevel) Return the currently configured severity level enabled for this Log. The level is NONE, ERROR, WARNING, MESSAGE, and TRACE. message \u00b6 public OutStream message( Str msg) Log a message record. setLevel \u00b6 public void setLevel(int newLevel) Set the severity level for this Log. Possible levels are NONE, ERROR, WARNING, MESSAGE, and TRACE. (no error checking on arg) trace \u00b6 public OutStream trace( Str msg) Log a trace record. warning \u00b6 public OutStream warning( Str msg) Log a warning record. Doc Home > API Index > sys > Log","title":"Log"},{"location":"api/sys/Log/#log","text":"Doc Home > API Index > sys > Log","title":"Log"},{"location":"api/sys/Log/#inheritance","text":"sys::Obj sys::Log public const class Log Log is used to embed error, warning, message, and trace logging into Sedona software.","title":"Inheritance"},{"location":"api/sys/Log/#fields","text":"","title":"Fields"},{"location":"api/sys/Log/#error","text":"public static const define int ERROR Logging is enabled only for errors","title":"ERROR"},{"location":"api/sys/Log/#message","text":"public static const define int MESSAGE Logging is enabled for errors, warning, and messages","title":"MESSAGE"},{"location":"api/sys/Log/#none","text":"public static const define int NONE Logging is disabled","title":"NONE"},{"location":"api/sys/Log/#trace","text":"public static const define int TRACE Logging is enabled for all levels","title":"TRACE"},{"location":"api/sys/Log/#warning","text":"public static const define int WARNING Logging is enabled for errors and warning","title":"WARNING"},{"location":"api/sys/Log/#id","text":"public const short id Index of this log in the Sys.logs array.","title":"id"},{"location":"api/sys/Log/#qname","text":"public const Str qname Unique qualified name of this log in the VM.","title":"qname"},{"location":"api/sys/Log/#methods","text":"","title":"Methods"},{"location":"api/sys/Log/#error_1","text":"public OutStream error( Str msg) Log an error record.","title":"error"},{"location":"api/sys/Log/#iserror","text":"public bool isError() Is current level error or greater.","title":"isError"},{"location":"api/sys/Log/#ismessage","text":"public bool isMessage() Is current level message or greater.","title":"isMessage"},{"location":"api/sys/Log/#istrace","text":"public bool isTrace() Is current level trace or greater.","title":"isTrace"},{"location":"api/sys/Log/#iswarning","text":"public bool isWarning() Is current level warning or greater.","title":"isWarning"},{"location":"api/sys/Log/#level","text":"public int level() Get the currently configured severity level enabled for this Log. The level is NONE, ERROR, WARNING, MESSAGE, and TRACE.","title":"level"},{"location":"api/sys/Log/#levelstr","text":"public static Str levelStr(int logLevel) Return the currently configured severity level enabled for this Log. The level is NONE, ERROR, WARNING, MESSAGE, and TRACE.","title":"levelStr"},{"location":"api/sys/Log/#message_1","text":"public OutStream message( Str msg) Log a message record.","title":"message"},{"location":"api/sys/Log/#setlevel","text":"public void setLevel(int newLevel) Set the severity level for this Log. Possible levels are NONE, ERROR, WARNING, MESSAGE, and TRACE. (no error checking on arg)","title":"setLevel"},{"location":"api/sys/Log/#trace_1","text":"public OutStream trace( Str msg) Log a trace record.","title":"trace"},{"location":"api/sys/Log/#warning_1","text":"public OutStream warning( Str msg) Log a warning record. Doc Home > API Index > sys > Log","title":"warning"},{"location":"api/sys/MemoryFile/","text":"MemoryFile \u00b6 Doc Home > API Index > sys > MemoryFile Inheritance \u00b6 sys::Obj sys::MemoryFile public final class MemoryFile Fields \u00b6 file \u00b6 public File file reference to containing File instance mem \u00b6 public byte[] mem the contents of the memory file. Modify at your peril. mode \u00b6 public byte mode 'r', 'w', 'm' or 0 if an error pos \u00b6 public int pos current read/write position in the memory file. size \u00b6 public int size size of the memory file. Less than zero indicates an error. Modify at your peril. Methods \u00b6 eof \u00b6 public bool eof() returns true if the position is past the end of file. writable \u00b6 public bool writable() returns true if the memory file was opened for writing. Doc Home > API Index > sys > MemoryFile","title":"MemoryFile"},{"location":"api/sys/MemoryFile/#memoryfile","text":"Doc Home > API Index > sys > MemoryFile","title":"MemoryFile"},{"location":"api/sys/MemoryFile/#inheritance","text":"sys::Obj sys::MemoryFile public final class MemoryFile","title":"Inheritance"},{"location":"api/sys/MemoryFile/#fields","text":"","title":"Fields"},{"location":"api/sys/MemoryFile/#file","text":"public File file reference to containing File instance","title":"file"},{"location":"api/sys/MemoryFile/#mem","text":"public byte[] mem the contents of the memory file. Modify at your peril.","title":"mem"},{"location":"api/sys/MemoryFile/#mode","text":"public byte mode 'r', 'w', 'm' or 0 if an error","title":"mode"},{"location":"api/sys/MemoryFile/#pos","text":"public int pos current read/write position in the memory file.","title":"pos"},{"location":"api/sys/MemoryFile/#size","text":"public int size size of the memory file. Less than zero indicates an error. Modify at your peril.","title":"size"},{"location":"api/sys/MemoryFile/#methods","text":"","title":"Methods"},{"location":"api/sys/MemoryFile/#eof","text":"public bool eof() returns true if the position is past the end of file.","title":"eof"},{"location":"api/sys/MemoryFile/#writable","text":"public bool writable() returns true if the memory file was opened for writing. Doc Home > API Index > sys > MemoryFile","title":"writable"},{"location":"api/sys/MemoryFileStore/","text":"MemoryFileStore \u00b6 Doc Home > API Index > sys > MemoryFileStore Inheritance \u00b6 sys::Obj sys::Virtual sys::FileStore sys::MemoryFileStore public abstract class MemoryFileStore A file store implementation where the file contents are backed by an in- memory byte[]. The memory file is modeled by a MemoryFile object. When a sys::File is opened by this file store, the \"fp\" field of the File will be assigned to a MemoryFile. Therefore, any open memory file can be accessed by casting the fp field of the sys::File to a MemoryFile. Sub-classes must implement the following abstract methods: int getMemorySize(File f) bool openMemoryFile(MemoryFile m) Fields \u00b6 Methods \u00b6 close \u00b6 public override bool close( File f) flush \u00b6 public virtual override void flush( File f) getMemorySize \u00b6 public abstract int getMemorySize( File f) Return the size of the memory buffer back the file represented by \"f\". open \u00b6 public override bool open( File f, Str mode) openMemoryFile \u00b6 public abstract bool openMemoryFile( MemoryFile m) Given a MemoryFile, the implementation must set the mem byte[] to point to the contents being backed by the memory file. Pre-Condition: all fields of the MemoryFile are initialized except for the mem field. return true on success, false on error. read \u00b6 public virtual override int read( File f) readBytes \u00b6 public virtual override int readBytes( File f, byte[] b, int off, int len) seek \u00b6 public virtual override bool seek( File f, int pos) size \u00b6 public override int size( File f) Must be implemented by getMemorySize(File f) tell \u00b6 public virtual override int tell( File f) write \u00b6 public virtual override bool write( File f, int b) writeBytes \u00b6 public virtual override bool writeBytes( File f, byte[] b, int off, int len) Doc Home > API Index > sys > MemoryFileStore","title":"MemoryFileStore"},{"location":"api/sys/MemoryFileStore/#memoryfilestore","text":"Doc Home > API Index > sys > MemoryFileStore","title":"MemoryFileStore"},{"location":"api/sys/MemoryFileStore/#inheritance","text":"sys::Obj sys::Virtual sys::FileStore sys::MemoryFileStore public abstract class MemoryFileStore A file store implementation where the file contents are backed by an in- memory byte[]. The memory file is modeled by a MemoryFile object. When a sys::File is opened by this file store, the \"fp\" field of the File will be assigned to a MemoryFile. Therefore, any open memory file can be accessed by casting the fp field of the sys::File to a MemoryFile. Sub-classes must implement the following abstract methods: int getMemorySize(File f) bool openMemoryFile(MemoryFile m)","title":"Inheritance"},{"location":"api/sys/MemoryFileStore/#fields","text":"","title":"Fields"},{"location":"api/sys/MemoryFileStore/#methods","text":"","title":"Methods"},{"location":"api/sys/MemoryFileStore/#close","text":"public override bool close( File f)","title":"close"},{"location":"api/sys/MemoryFileStore/#flush","text":"public virtual override void flush( File f)","title":"flush"},{"location":"api/sys/MemoryFileStore/#getmemorysize","text":"public abstract int getMemorySize( File f) Return the size of the memory buffer back the file represented by \"f\".","title":"getMemorySize"},{"location":"api/sys/MemoryFileStore/#open","text":"public override bool open( File f, Str mode)","title":"open"},{"location":"api/sys/MemoryFileStore/#openmemoryfile","text":"public abstract bool openMemoryFile( MemoryFile m) Given a MemoryFile, the implementation must set the mem byte[] to point to the contents being backed by the memory file. Pre-Condition: all fields of the MemoryFile are initialized except for the mem field. return true on success, false on error.","title":"openMemoryFile"},{"location":"api/sys/MemoryFileStore/#read","text":"public virtual override int read( File f)","title":"read"},{"location":"api/sys/MemoryFileStore/#readbytes","text":"public virtual override int readBytes( File f, byte[] b, int off, int len)","title":"readBytes"},{"location":"api/sys/MemoryFileStore/#seek","text":"public virtual override bool seek( File f, int pos)","title":"seek"},{"location":"api/sys/MemoryFileStore/#size","text":"public override int size( File f) Must be implemented by getMemorySize(File f)","title":"size"},{"location":"api/sys/MemoryFileStore/#tell","text":"public virtual override int tell( File f)","title":"tell"},{"location":"api/sys/MemoryFileStore/#write","text":"public virtual override bool write( File f, int b)","title":"write"},{"location":"api/sys/MemoryFileStore/#writebytes","text":"public virtual override bool writeBytes( File f, byte[] b, int off, int len) Doc Home > API Index > sys > MemoryFileStore","title":"writeBytes"},{"location":"api/sys/Obj/","text":"Obj \u00b6 Doc Home > API Index > sys > Obj Inheritance \u00b6 sys::Obj public class Obj Obj is the base class for all Sedona classes. Doc Home > API Index > sys > Obj","title":"Obj"},{"location":"api/sys/Obj/#obj","text":"Doc Home > API Index > sys > Obj","title":"Obj"},{"location":"api/sys/Obj/#inheritance","text":"sys::Obj public class Obj Obj is the base class for all Sedona classes. Doc Home > API Index > sys > Obj","title":"Inheritance"},{"location":"api/sys/OutStream/","text":"OutStream \u00b6 Doc Home > API Index > sys > OutStream Inheritance \u00b6 sys::Obj sys::Virtual sys::OutStream public abstract class OutStream OutStream is used to output printed text or binary encoded data. Fields \u00b6 Methods \u00b6 close \u00b6 public virtual void close() Close the stream. Default implementation does nothing. flush \u00b6 public virtual void flush() Flush the stream. Default implementation does nothing. fsync \u00b6 public virtual void fsync() Synchronize file's state with storage device. Default implementation does nothing. nl \u00b6 public OutStream nl() Print a newline character. Return this. print \u00b6 public OutStream print( Str s) Print the specified string. Return this. printBool \u00b6 public OutStream printBool(bool x) Print a string for the specified boolean. Return this. printChar \u00b6 public OutStream printChar(int x) Print the integer as a character. Return this. printDouble \u00b6 public OutStream printDouble(double x) Print the double as a string. printFloat \u00b6 public OutStream printFloat(float x) Print the float as a string. printHex \u00b6 public OutStream printHex(int x) Print the integer as an unsigned hexadecimal string. printInt \u00b6 public OutStream printInt(int x) Print the integer as a signed decimal string. Return this. printLong \u00b6 public OutStream printLong(long x) Print the long as a signed decimal string. Return this. printLongHex \u00b6 public OutStream printLongHex(long x) Print the long as an unsigned hexadecimal string. printPad \u00b6 public OutStream printPad( Str s, int width) Print the specified string left justified according the specified padding width. Return this. write \u00b6 public abstract bool write(int b) Write a single byte. Return true on success, false on failure. writeBool \u00b6 public bool writeBool(bool b) Write a bool 1 or 0. Return true on success or fail on failure. writeBytes \u00b6 public abstract bool writeBytes(byte[] b, int off, int len) Write a block of bytes. Return true on success, false on failure. writeChar \u00b6 public bool writeChar(int b) Write a character. Return true on success or fail on failure. writeF4 \u00b6 public bool writeF4(float v) Write a four byte (32-bit) floating point value in network byte order. Return true on success, false on failure. writeF8 \u00b6 public bool writeF8(double v) Write an eight byte (64-bit) floating point value in network byte order. Return true on success, false on failure. writeI2 \u00b6 public bool writeI2(int v) Write a two byte integer in network byte order. Return true on success, false on failure. writeI4 \u00b6 public bool writeI4(int v) Write a four byte (32-bit) integer in network byte order. Return true on success, false on failure. writeI8 \u00b6 public bool writeI8(long v) Write a eight byte (64-bit) integer in network byte order. Return true on success, false on failure. writeStr \u00b6 public bool writeStr( Str s) Write the null terminated string. Return true on success, false on failure. Doc Home > API Index > sys > OutStream","title":"OutStream"},{"location":"api/sys/OutStream/#outstream","text":"Doc Home > API Index > sys > OutStream","title":"OutStream"},{"location":"api/sys/OutStream/#inheritance","text":"sys::Obj sys::Virtual sys::OutStream public abstract class OutStream OutStream is used to output printed text or binary encoded data.","title":"Inheritance"},{"location":"api/sys/OutStream/#fields","text":"","title":"Fields"},{"location":"api/sys/OutStream/#methods","text":"","title":"Methods"},{"location":"api/sys/OutStream/#close","text":"public virtual void close() Close the stream. Default implementation does nothing.","title":"close"},{"location":"api/sys/OutStream/#flush","text":"public virtual void flush() Flush the stream. Default implementation does nothing.","title":"flush"},{"location":"api/sys/OutStream/#fsync","text":"public virtual void fsync() Synchronize file's state with storage device. Default implementation does nothing.","title":"fsync"},{"location":"api/sys/OutStream/#nl","text":"public OutStream nl() Print a newline character. Return this.","title":"nl"},{"location":"api/sys/OutStream/#print","text":"public OutStream print( Str s) Print the specified string. Return this.","title":"print"},{"location":"api/sys/OutStream/#printbool","text":"public OutStream printBool(bool x) Print a string for the specified boolean. Return this.","title":"printBool"},{"location":"api/sys/OutStream/#printchar","text":"public OutStream printChar(int x) Print the integer as a character. Return this.","title":"printChar"},{"location":"api/sys/OutStream/#printdouble","text":"public OutStream printDouble(double x) Print the double as a string.","title":"printDouble"},{"location":"api/sys/OutStream/#printfloat","text":"public OutStream printFloat(float x) Print the float as a string.","title":"printFloat"},{"location":"api/sys/OutStream/#printhex","text":"public OutStream printHex(int x) Print the integer as an unsigned hexadecimal string.","title":"printHex"},{"location":"api/sys/OutStream/#printint","text":"public OutStream printInt(int x) Print the integer as a signed decimal string. Return this.","title":"printInt"},{"location":"api/sys/OutStream/#printlong","text":"public OutStream printLong(long x) Print the long as a signed decimal string. Return this.","title":"printLong"},{"location":"api/sys/OutStream/#printlonghex","text":"public OutStream printLongHex(long x) Print the long as an unsigned hexadecimal string.","title":"printLongHex"},{"location":"api/sys/OutStream/#printpad","text":"public OutStream printPad( Str s, int width) Print the specified string left justified according the specified padding width. Return this.","title":"printPad"},{"location":"api/sys/OutStream/#write","text":"public abstract bool write(int b) Write a single byte. Return true on success, false on failure.","title":"write"},{"location":"api/sys/OutStream/#writebool","text":"public bool writeBool(bool b) Write a bool 1 or 0. Return true on success or fail on failure.","title":"writeBool"},{"location":"api/sys/OutStream/#writebytes","text":"public abstract bool writeBytes(byte[] b, int off, int len) Write a block of bytes. Return true on success, false on failure.","title":"writeBytes"},{"location":"api/sys/OutStream/#writechar","text":"public bool writeChar(int b) Write a character. Return true on success or fail on failure.","title":"writeChar"},{"location":"api/sys/OutStream/#writef4","text":"public bool writeF4(float v) Write a four byte (32-bit) floating point value in network byte order. Return true on success, false on failure.","title":"writeF4"},{"location":"api/sys/OutStream/#writef8","text":"public bool writeF8(double v) Write an eight byte (64-bit) floating point value in network byte order. Return true on success, false on failure.","title":"writeF8"},{"location":"api/sys/OutStream/#writei2","text":"public bool writeI2(int v) Write a two byte integer in network byte order. Return true on success, false on failure.","title":"writeI2"},{"location":"api/sys/OutStream/#writei4","text":"public bool writeI4(int v) Write a four byte (32-bit) integer in network byte order. Return true on success, false on failure.","title":"writeI4"},{"location":"api/sys/OutStream/#writei8","text":"public bool writeI8(long v) Write a eight byte (64-bit) integer in network byte order. Return true on success, false on failure.","title":"writeI8"},{"location":"api/sys/OutStream/#writestr","text":"public bool writeStr( Str s) Write the null terminated string. Return true on success, false on failure. Doc Home > API Index > sys > OutStream","title":"writeStr"},{"location":"api/sys/PlatformService/","text":"PlatformService \u00b6 Doc Home > API Index > sys > PlatformService Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::Service sys::PlatformService public class PlatformService [niagaraIcon=\"module://icons/x16/platform.png\"] PlatformService is a service designed for a specific hardware/OS platform. Fields \u00b6 memAvailable \u00b6 public property long memAvailable [readonly] The amount of available runtime memory, in bytes. This property must be updated during execute() netConfigError \u00b6 public static const define int netConfigError Network failed due to configuration error netFatal \u00b6 public static const define int netFatal Network interface has fatal error netInitializing \u00b6 public static const define int netInitializing Network interface is initializing i.e. acquiring DHCP address or joining RF network netOk \u00b6 public static const define int netOk Network interface is operational platformId \u00b6 public inline property Buf platformId [summary=false, asStr, readonly, max=128] The platform identifier which defines how this Sedona device should be provisioned. platformVer \u00b6 public inline property Buf platformVer [summary=false, asStr, readonly, max=17] The platform version. This should be a Dewey Decimal style version (x.y.z). The default value is \"0\" and should be used to indicate that the platform does not have a meaningful concept for platform version. Methods \u00b6 canHibernate \u00b6 public virtual override bool canHibernate() By default, a Platform Service assumes that the platform does not support hibernation, so this method always returns false. If your platform supports hibernation, you should override this method to return true. execute \u00b6 public virtual override void execute() getNetworkState \u00b6 public virtual int getNetworkState() Return the current state of the network interface. For devices that support multiple interfaces, return the state of the primary network interface on the platform. init \u00b6 public virtual int init( Str [] args, int argsLen) Initialize the platform with the command line arguments. Return 0 on success. Return non-zero on failure, which will terminate the process. lookup \u00b6 public static PlatformService lookup() Lookup the platform service for this VM. Return null if the application hasn't booted yet or is missing a platform service. notify \u00b6 public virtual void notify( Str key, Str val) Notify the platform of a name/value pair setting or state change. reboot \u00b6 public action void reboot() [confirmRequired] Action to reboot the entire host platform. This typically means to reboot the entire operating system. refreshMemory \u00b6 public virtual void refreshMemory() Update the memAvailable property to reflect the current amount of available memory. restart \u00b6 public action void restart() [confirmRequired] Action to restart the Sedona application on the host platform. This typically means restart just the Sedona process. start \u00b6 public virtual override void start() updatePlatformId \u00b6 public void updatePlatformId( Str id) Convenience to set the platformId property, and call changed() updatePlatformVer \u00b6 public void updatePlatformVer( Str ver) Convenience to set the platformVer property, and call changed() workDuringFreeTime \u00b6 public virtual bool workDuringFreeTime(long nsUntilDeadline) Returns true if the platform wants to the App to invoke work() again on all Services during free time before the next App execute needs to begin. For Apps with long scanPeriods (greater than 50ms), this allows Services to respond to network traffic or other asynchronous events multiple times during a single scanPeriod - even if the service didn't have any immediate work to do. i.e. - Sox services responds to a poll request, but then has no further work, nor doing any other services. A few ms later, another poll request comes in. If this method returns false, no further workd will be done until the beginning of the next scan period If this method returns true, work() will be called on all services again and the poll request will be handled before the next scanPeriod. nsUntilDeadline represents the time remaining before the next App execute() cycle again. Depending on the underlying OS/system architecture, the platform may want to sleep or otherwise relinquish the CPU for some fraction of nsUntilDeadline before returning and allowing App to call service work again. See also the Apps chapter in Sedona docs yield \u00b6 public virtual void yield(long yieldTime) Inform platform that SVM will be exiting with Err.yield and needs to be scheduled to run again (via resume in vm.c) in ns nanoseconds to meet the desired App.scanPeriod value. If the application overruns its scan period, yieldTime will be negative. In this case the VM should be scheduled to run again as soon as possible. See also the Apps chapter in Sedona docs yieldRequired \u00b6 public virtual bool yieldRequired() Return true if App must yield CPU by exiting VM each cycle. Platforms that support pre-emptive multitasking should return false since App can sleep to yield CPU. Cooperative multitasking platforms that expect tasks to run to completion and return so other tasks can execute should return true. See also the Apps chapter in Sedona docs Doc Home > API Index > sys > PlatformService","title":"PlatformService"},{"location":"api/sys/PlatformService/#platformservice","text":"Doc Home > API Index > sys > PlatformService","title":"PlatformService"},{"location":"api/sys/PlatformService/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::Service sys::PlatformService public class PlatformService [niagaraIcon=\"module://icons/x16/platform.png\"] PlatformService is a service designed for a specific hardware/OS platform.","title":"Inheritance"},{"location":"api/sys/PlatformService/#fields","text":"","title":"Fields"},{"location":"api/sys/PlatformService/#memavailable","text":"public property long memAvailable [readonly] The amount of available runtime memory, in bytes. This property must be updated during execute()","title":"memAvailable"},{"location":"api/sys/PlatformService/#netconfigerror","text":"public static const define int netConfigError Network failed due to configuration error","title":"netConfigError"},{"location":"api/sys/PlatformService/#netfatal","text":"public static const define int netFatal Network interface has fatal error","title":"netFatal"},{"location":"api/sys/PlatformService/#netinitializing","text":"public static const define int netInitializing Network interface is initializing i.e. acquiring DHCP address or joining RF network","title":"netInitializing"},{"location":"api/sys/PlatformService/#netok","text":"public static const define int netOk Network interface is operational","title":"netOk"},{"location":"api/sys/PlatformService/#platformid","text":"public inline property Buf platformId [summary=false, asStr, readonly, max=128] The platform identifier which defines how this Sedona device should be provisioned.","title":"platformId"},{"location":"api/sys/PlatformService/#platformver","text":"public inline property Buf platformVer [summary=false, asStr, readonly, max=17] The platform version. This should be a Dewey Decimal style version (x.y.z). The default value is \"0\" and should be used to indicate that the platform does not have a meaningful concept for platform version.","title":"platformVer"},{"location":"api/sys/PlatformService/#methods","text":"","title":"Methods"},{"location":"api/sys/PlatformService/#canhibernate","text":"public virtual override bool canHibernate() By default, a Platform Service assumes that the platform does not support hibernation, so this method always returns false. If your platform supports hibernation, you should override this method to return true.","title":"canHibernate"},{"location":"api/sys/PlatformService/#execute","text":"public virtual override void execute()","title":"execute"},{"location":"api/sys/PlatformService/#getnetworkstate","text":"public virtual int getNetworkState() Return the current state of the network interface. For devices that support multiple interfaces, return the state of the primary network interface on the platform.","title":"getNetworkState"},{"location":"api/sys/PlatformService/#init","text":"public virtual int init( Str [] args, int argsLen) Initialize the platform with the command line arguments. Return 0 on success. Return non-zero on failure, which will terminate the process.","title":"init"},{"location":"api/sys/PlatformService/#lookup","text":"public static PlatformService lookup() Lookup the platform service for this VM. Return null if the application hasn't booted yet or is missing a platform service.","title":"lookup"},{"location":"api/sys/PlatformService/#notify","text":"public virtual void notify( Str key, Str val) Notify the platform of a name/value pair setting or state change.","title":"notify"},{"location":"api/sys/PlatformService/#reboot","text":"public action void reboot() [confirmRequired] Action to reboot the entire host platform. This typically means to reboot the entire operating system.","title":"reboot"},{"location":"api/sys/PlatformService/#refreshmemory","text":"public virtual void refreshMemory() Update the memAvailable property to reflect the current amount of available memory.","title":"refreshMemory"},{"location":"api/sys/PlatformService/#restart","text":"public action void restart() [confirmRequired] Action to restart the Sedona application on the host platform. This typically means restart just the Sedona process.","title":"restart"},{"location":"api/sys/PlatformService/#start","text":"public virtual override void start()","title":"start"},{"location":"api/sys/PlatformService/#updateplatformid","text":"public void updatePlatformId( Str id) Convenience to set the platformId property, and call changed()","title":"updatePlatformId"},{"location":"api/sys/PlatformService/#updateplatformver","text":"public void updatePlatformVer( Str ver) Convenience to set the platformVer property, and call changed()","title":"updatePlatformVer"},{"location":"api/sys/PlatformService/#workduringfreetime","text":"public virtual bool workDuringFreeTime(long nsUntilDeadline) Returns true if the platform wants to the App to invoke work() again on all Services during free time before the next App execute needs to begin. For Apps with long scanPeriods (greater than 50ms), this allows Services to respond to network traffic or other asynchronous events multiple times during a single scanPeriod - even if the service didn't have any immediate work to do. i.e. - Sox services responds to a poll request, but then has no further work, nor doing any other services. A few ms later, another poll request comes in. If this method returns false, no further workd will be done until the beginning of the next scan period If this method returns true, work() will be called on all services again and the poll request will be handled before the next scanPeriod. nsUntilDeadline represents the time remaining before the next App execute() cycle again. Depending on the underlying OS/system architecture, the platform may want to sleep or otherwise relinquish the CPU for some fraction of nsUntilDeadline before returning and allowing App to call service work again. See also the Apps chapter in Sedona docs","title":"workDuringFreeTime"},{"location":"api/sys/PlatformService/#yield","text":"public virtual void yield(long yieldTime) Inform platform that SVM will be exiting with Err.yield and needs to be scheduled to run again (via resume in vm.c) in ns nanoseconds to meet the desired App.scanPeriod value. If the application overruns its scan period, yieldTime will be negative. In this case the VM should be scheduled to run again as soon as possible. See also the Apps chapter in Sedona docs","title":"yield"},{"location":"api/sys/PlatformService/#yieldrequired","text":"public virtual bool yieldRequired() Return true if App must yield CPU by exiting VM each cycle. Platforms that support pre-emptive multitasking should return false since App can sleep to yield CPU. Cooperative multitasking platforms that expect tasks to run to completion and return so other tasks can execute should return true. See also the Apps chapter in Sedona docs Doc Home > API Index > sys > PlatformService","title":"yieldRequired"},{"location":"api/sys/RateFolder/","text":"RateFolder \u00b6 Doc Home > API Index > sys > RateFolder Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::Folder sys::RateFolder public class RateFolder [niagaraIcon=\"module://icons/x16/folder.png\"] RateFolder is a folder that controls how often its children execute. It can be used to implement an app with components that execute at different rates. Fields \u00b6 appCyclesToSkip \u00b6 public property int appCyclesToSkip [min=0, config] How many app cycles to skip between child executes. Set to 0 to disable, i.e. children execute every cycle. Methods \u00b6 allowChildExecute \u00b6 public virtual override bool allowChildExecute() Calculate when to allow children to execute. loaded \u00b6 public virtual override void loaded() Override loaded() to init execCount. Doc Home > API Index > sys > RateFolder","title":"RateFolder"},{"location":"api/sys/RateFolder/#ratefolder","text":"Doc Home > API Index > sys > RateFolder","title":"RateFolder"},{"location":"api/sys/RateFolder/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::Folder sys::RateFolder public class RateFolder [niagaraIcon=\"module://icons/x16/folder.png\"] RateFolder is a folder that controls how often its children execute. It can be used to implement an app with components that execute at different rates.","title":"Inheritance"},{"location":"api/sys/RateFolder/#fields","text":"","title":"Fields"},{"location":"api/sys/RateFolder/#appcyclestoskip","text":"public property int appCyclesToSkip [min=0, config] How many app cycles to skip between child executes. Set to 0 to disable, i.e. children execute every cycle.","title":"appCyclesToSkip"},{"location":"api/sys/RateFolder/#methods","text":"","title":"Methods"},{"location":"api/sys/RateFolder/#allowchildexecute","text":"public virtual override bool allowChildExecute() Calculate when to allow children to execute.","title":"allowChildExecute"},{"location":"api/sys/RateFolder/#loaded","text":"public virtual override void loaded() Override loaded() to init execCount. Doc Home > API Index > sys > RateFolder","title":"loaded"},{"location":"api/sys/Service/","text":"Service \u00b6 Doc Home > API Index > sys > Service Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::Service public abstract class Service [niagaraIcon=\"module://icons/x16/gears.png\"] Service is a component which gets to execute background work between execution cycles. Services are also designed to be looked up by type within an application. Fields \u00b6 nextService \u00b6 public Service nextService Used for App's linked list of services Methods \u00b6 canHibernate \u00b6 public virtual bool canHibernate() Return true if this Service will allow hibernation. Default is to return true, subclass must override if it has a need to prevent hibernation. onHibernate \u00b6 public virtual void onHibernate() Callback when device is entering low-power sleep mode. onUnhibernate \u00b6 public virtual void onUnhibernate() Callback when device is exiting low-power sleep mode. work \u00b6 public virtual bool work() Perform a chunk of background work. Return true if there is pending work or false if the service is done working this cycle. A service should be designed to function correctly no matter how many times work is called per execution cycle. Returning false is not a guarantee that work will not be called again in a given execution cycle; rather, it is a hint to the App execution engine that this service does not have any more work to do. If you only want to do work once per execution cycle, you should consider: 1) Moving your work into the execute() callback. execute() will only be called once per execution cycle. 2) Set a \"newCycle\" flag in your execute() method and unset it after doing one work cycle. Only do your work if the newCycle flag is set. Doc Home > API Index > sys > Service","title":"Service"},{"location":"api/sys/Service/#service","text":"Doc Home > API Index > sys > Service","title":"Service"},{"location":"api/sys/Service/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::Service public abstract class Service [niagaraIcon=\"module://icons/x16/gears.png\"] Service is a component which gets to execute background work between execution cycles. Services are also designed to be looked up by type within an application.","title":"Inheritance"},{"location":"api/sys/Service/#fields","text":"","title":"Fields"},{"location":"api/sys/Service/#nextservice","text":"public Service nextService Used for App's linked list of services","title":"nextService"},{"location":"api/sys/Service/#methods","text":"","title":"Methods"},{"location":"api/sys/Service/#canhibernate","text":"public virtual bool canHibernate() Return true if this Service will allow hibernation. Default is to return true, subclass must override if it has a need to prevent hibernation.","title":"canHibernate"},{"location":"api/sys/Service/#onhibernate","text":"public virtual void onHibernate() Callback when device is entering low-power sleep mode.","title":"onHibernate"},{"location":"api/sys/Service/#onunhibernate","text":"public virtual void onUnhibernate() Callback when device is exiting low-power sleep mode.","title":"onUnhibernate"},{"location":"api/sys/Service/#work","text":"public virtual bool work() Perform a chunk of background work. Return true if there is pending work or false if the service is done working this cycle. A service should be designed to function correctly no matter how many times work is called per execution cycle. Returning false is not a guarantee that work will not be called again in a given execution cycle; rather, it is a hint to the App execution engine that this service does not have any more work to do. If you only want to do work once per execution cycle, you should consider: 1) Moving your work into the execute() callback. execute() will only be called once per execution cycle. 2) Set a \"newCycle\" flag in your execute() method and unset it after doing one work cycle. Only do your work if the newCycle flag is set. Doc Home > API Index > sys > Service","title":"work"},{"location":"api/sys/Slot/","text":"Slot \u00b6 Doc Home > API Index > sys > Slot Inheritance \u00b6 sys::Obj sys::Slot public const class Slot Slot models a property or action slot which is available to the runtime via the reflection APIs. Fields \u00b6 ACTION \u00b6 public static const define int ACTION Flag to indicate property versus action AS_STR \u00b6 public static const define int AS_STR Flag to indicate if a Buf should be treated as a Str CONFIG \u00b6 public static const define int CONFIG Flag to indicate configuration property versus runtime property OPERATOR \u00b6 public static const define int OPERATOR Flag to indicate if slot is operator level - if not operator then a slot is consider admin level. flags \u00b6 public const byte flags Bitmask for flags id \u00b6 public const byte id Index of this slot in its type slot list name \u00b6 public const Str name Unique name of this slot in its type type \u00b6 public const Type type Type of the slot. If the slot is a property this is the type the property stores. If the slot is an action this is the argument type. Methods \u00b6 isAction \u00b6 public bool isAction() Is this an action slot. isAsStr \u00b6 public bool isAsStr() Is this a Buf property which should be treated as a Str. isConfig \u00b6 public bool isConfig() Is this a config property. isOperator \u00b6 public bool isOperator() Is true if an operator level slot, or false if admin level. isProp \u00b6 public bool isProp() Is this a property slot. matchProp \u00b6 public bool matchProp(int filter) Return if this slot is a property against the specified filter: '*' = any property 'c' = only config properties 'r' = only runtime properties 'C' = only operator level config properties 'R' = only operator level runtime properties Doc Home > API Index > sys > Slot","title":"Slot"},{"location":"api/sys/Slot/#slot","text":"Doc Home > API Index > sys > Slot","title":"Slot"},{"location":"api/sys/Slot/#inheritance","text":"sys::Obj sys::Slot public const class Slot Slot models a property or action slot which is available to the runtime via the reflection APIs.","title":"Inheritance"},{"location":"api/sys/Slot/#fields","text":"","title":"Fields"},{"location":"api/sys/Slot/#action","text":"public static const define int ACTION Flag to indicate property versus action","title":"ACTION"},{"location":"api/sys/Slot/#as_str","text":"public static const define int AS_STR Flag to indicate if a Buf should be treated as a Str","title":"AS_STR"},{"location":"api/sys/Slot/#config","text":"public static const define int CONFIG Flag to indicate configuration property versus runtime property","title":"CONFIG"},{"location":"api/sys/Slot/#operator","text":"public static const define int OPERATOR Flag to indicate if slot is operator level - if not operator then a slot is consider admin level.","title":"OPERATOR"},{"location":"api/sys/Slot/#flags","text":"public const byte flags Bitmask for flags","title":"flags"},{"location":"api/sys/Slot/#id","text":"public const byte id Index of this slot in its type slot list","title":"id"},{"location":"api/sys/Slot/#name","text":"public const Str name Unique name of this slot in its type","title":"name"},{"location":"api/sys/Slot/#type","text":"public const Type type Type of the slot. If the slot is a property this is the type the property stores. If the slot is an action this is the argument type.","title":"type"},{"location":"api/sys/Slot/#methods","text":"","title":"Methods"},{"location":"api/sys/Slot/#isaction","text":"public bool isAction() Is this an action slot.","title":"isAction"},{"location":"api/sys/Slot/#isasstr","text":"public bool isAsStr() Is this a Buf property which should be treated as a Str.","title":"isAsStr"},{"location":"api/sys/Slot/#isconfig","text":"public bool isConfig() Is this a config property.","title":"isConfig"},{"location":"api/sys/Slot/#isoperator","text":"public bool isOperator() Is true if an operator level slot, or false if admin level.","title":"isOperator"},{"location":"api/sys/Slot/#isprop","text":"public bool isProp() Is this a property slot.","title":"isProp"},{"location":"api/sys/Slot/#matchprop","text":"public bool matchProp(int filter) Return if this slot is a property against the specified filter: '*' = any property 'c' = only config properties 'r' = only runtime properties 'C' = only operator level config properties 'R' = only operator level runtime properties Doc Home > API Index > sys > Slot","title":"matchProp"},{"location":"api/sys/Str/","text":"Str \u00b6 Doc Home > API Index > sys > Str Inheritance \u00b6 sys::Obj sys::Str public final class Str Str encapsulates a byte array which stores a string of ASCII characters terminated by the null character. The characters must be less then 128 (the high bit must clear) for future UTF-8 support. Fields \u00b6 Methods \u00b6 Str \u00b6 public void Str(int bufLen) The inline constructor for Str requires the max size of the character buffer including the space for the null terminator. For the following declaration declares a Str with enough memory to store 3 ASCII characters: inline Str(4) mystr copyFromStr \u00b6 public bool copyFromStr( Str from, int max) Copy the specified string into this string's memory buffer. If the specified string contains more than max characters including the null terminator then return false and truncate the copy. Max should always be the size of this string's buffer. equals \u00b6 public bool equals( Str that) Return if two strings contain the exact same characters. equalsRegion \u00b6 public bool equalsRegion( Str that, int start, int end) Return if this entire string equals a region within the specified string. Start index is inclusive and end index is exclusive. The start index must be a valid index into the specified string's memory space, but the end index can be larger than the memory size. fromBytes \u00b6 public static native Str fromBytes(byte[] buf, int off) Return a Str reference into the byte array at the specified offset. In the SVM we return a pointer to buf+off. In the JVM we return a new StrRef with the specified offset. No guarantee is made that the buffer contains the null terminator. get \u00b6 public int get(int index) Get the character at the specified index. index \u00b6 public int index(int ch) Return if the index of the specified character or -1 if not found in this string. length \u00b6 public int length() Return number of characters in the string not including the null terminating character. parseInt \u00b6 public int parseInt() Parse this string into an integer or return -1. set \u00b6 public void set(int index, int ch) Set the character at the specified index. startsWith \u00b6 public bool startsWith( Str that) Return if this string starts with the specified string. suffix \u00b6 public Str suffix(int newStart) Perform an in-place trim on the string pointer by removing leading characters up to index 'newStart'. Note this method will return a different reference, the starting position of the new string, but the underlying memory does not change. toBytes \u00b6 public byte[] toBytes() Get the backing byte array of this String. trim \u00b6 public Str trim() Perform an in-place trim on the string pointer by removing any leading or trailing space characters. Note this method will change the characters in the string's buffer and will return a different reference the starting position of the new string. Doc Home > API Index > sys > Str","title":"Str"},{"location":"api/sys/Str/#str","text":"Doc Home > API Index > sys > Str","title":"Str"},{"location":"api/sys/Str/#inheritance","text":"sys::Obj sys::Str public final class Str Str encapsulates a byte array which stores a string of ASCII characters terminated by the null character. The characters must be less then 128 (the high bit must clear) for future UTF-8 support.","title":"Inheritance"},{"location":"api/sys/Str/#fields","text":"","title":"Fields"},{"location":"api/sys/Str/#methods","text":"","title":"Methods"},{"location":"api/sys/Str/#str_1","text":"public void Str(int bufLen) The inline constructor for Str requires the max size of the character buffer including the space for the null terminator. For the following declaration declares a Str with enough memory to store 3 ASCII characters: inline Str(4) mystr","title":"Str"},{"location":"api/sys/Str/#copyfromstr","text":"public bool copyFromStr( Str from, int max) Copy the specified string into this string's memory buffer. If the specified string contains more than max characters including the null terminator then return false and truncate the copy. Max should always be the size of this string's buffer.","title":"copyFromStr"},{"location":"api/sys/Str/#equals","text":"public bool equals( Str that) Return if two strings contain the exact same characters.","title":"equals"},{"location":"api/sys/Str/#equalsregion","text":"public bool equalsRegion( Str that, int start, int end) Return if this entire string equals a region within the specified string. Start index is inclusive and end index is exclusive. The start index must be a valid index into the specified string's memory space, but the end index can be larger than the memory size.","title":"equalsRegion"},{"location":"api/sys/Str/#frombytes","text":"public static native Str fromBytes(byte[] buf, int off) Return a Str reference into the byte array at the specified offset. In the SVM we return a pointer to buf+off. In the JVM we return a new StrRef with the specified offset. No guarantee is made that the buffer contains the null terminator.","title":"fromBytes"},{"location":"api/sys/Str/#get","text":"public int get(int index) Get the character at the specified index.","title":"get"},{"location":"api/sys/Str/#index","text":"public int index(int ch) Return if the index of the specified character or -1 if not found in this string.","title":"index"},{"location":"api/sys/Str/#length","text":"public int length() Return number of characters in the string not including the null terminating character.","title":"length"},{"location":"api/sys/Str/#parseint","text":"public int parseInt() Parse this string into an integer or return -1.","title":"parseInt"},{"location":"api/sys/Str/#set","text":"public void set(int index, int ch) Set the character at the specified index.","title":"set"},{"location":"api/sys/Str/#startswith","text":"public bool startsWith( Str that) Return if this string starts with the specified string.","title":"startsWith"},{"location":"api/sys/Str/#suffix","text":"public Str suffix(int newStart) Perform an in-place trim on the string pointer by removing leading characters up to index 'newStart'. Note this method will return a different reference, the starting position of the new string, but the underlying memory does not change.","title":"suffix"},{"location":"api/sys/Str/#tobytes","text":"public byte[] toBytes() Get the backing byte array of this String.","title":"toBytes"},{"location":"api/sys/Str/#trim","text":"public Str trim() Perform an in-place trim on the string pointer by removing any leading or trailing space characters. Note this method will change the characters in the string's buffer and will return a different reference the starting position of the new string. Doc Home > API Index > sys > Str","title":"trim"},{"location":"api/sys/Sys/","text":"Sys \u00b6 Doc Home > API Index > sys Inheritance \u00b6 sys::Obj sys::Sys public class Sys Sys provides access to the system environment. Fields \u00b6 app \u00b6 public static inline App app The application instance for the VM bootTime \u00b6 public static long bootTime The time in nanosecond ticks the Sedona runtime was booted kits \u00b6 public static const Kit [] kits The list of kits installed in this environment. kitsLen \u00b6 public static const define int kitsLen The number of items in the kits array. logLevels \u00b6 public static inline byte[] logLevels The current severity level of each log logs \u00b6 public static const Log [] logs The list of logs installed in this environment. logsLen \u00b6 public static const define int logsLen The number of items in the logs array. maxInt \u00b6 public static const define int maxInt Max value of a 32-bit signed integer: 2,147,483,647 maxLong \u00b6 public static const define long maxLong Max value of a 64-bit signed integer: 9,223,372,036,854,775,807 minInt \u00b6 public static const define int minInt Min value of a 32-bit signed integer: -2,147,483,648 minLong \u00b6 public static const define long minLong Min value of a 64-bit signed integer: -9,223,372,036,854,775,808 nullIn \u00b6 public static inline InStream nullIn The null input stream is always at end of file. nullOut \u00b6 public static inline OutStream nullOut The null output stream sinks its output to nowhere. out \u00b6 public static inline OutStream out Standard output stream. sizeofRef \u00b6 public static const define int sizeofRef Size in bytes of a reference/pointer on this system. Methods \u00b6 andBytes \u00b6 public static native void andBytes(int mask, byte[] bytes, int off, int len) Perform a bitwise \"and\" using the specified mask on each byte in the bytes array. bitsToDouble \u00b6 public static native double bitsToDouble(long bits) Return a 64-bit floating point value according to the IEEE 754 floating-point \"double format\" bit layout. bitsToFloat \u00b6 public static native float bitsToFloat(int bits) Return a 32-bit floating point value according to the IEEE 754 floating-point \"single format\" bit layout. compareBytes \u00b6 public static native int compareBytes(byte[] a, int aOff, byte[] b, int bOff, int len) Compare two byte arrays for equality. If equal return 0, if a is less than b return -1, if a greater than b return 1. copy \u00b6 public static native void copy(byte[] src, int srcOff, byte[] dest, int destOff, int num) Copy num bytes from the source byte array to the destination byte array. The arrays may be overlapping (like memmove, not memcpy). doubleStr \u00b6 public static native Str doubleStr(double v) Format a double into a string. The string is stored in a static shared buffer. doubleToBits \u00b6 public static native long doubleToBits(double v) Return a long representation of a 64-bit floating point value according to the IEEE 754 floating-point \"double format\" bit layout. findKit \u00b6 public static Kit findKit( Str name) Find a kit by its unique name or return null if not found. findLog \u00b6 public static Log findLog( Str qname) Find a log by its qualified name or return null if not found. findType \u00b6 public static Type findType( Str qname) Find a type by its qualified name such as \"sys::Component\" or return null if not found. floatStr \u00b6 public static native Str floatStr(float v) Format a float into a string. The string is stored in a static shared buffer. floatToBits \u00b6 public static native int floatToBits(float v) Return an integer representation of a 32-bit floating point value according to the IEEE 754 floating-point \"single format\" bit layout. fromDigit \u00b6 public static int fromDigit(int digit) Return the numeric value of a decimal character: '0' -> 0 '9' -> 9 Return -1 if not a valid decimal digit. fromHexDigit \u00b6 public static int fromHexDigit(int digit) Return the numeric value of an decimal character: '0' -> 0 '9' -> 9 'a' or 'A' -> 10 'f' or 'F' -> 15 Return -1 if not a valid hex digit. hexStr \u00b6 public static native Str hexStr(int v) Format an integer as a hexadecimal string. The string is stored in a static shared buffer. intStr \u00b6 public static native Str intStr(int v) Format an integer as a decimal string. The string is stored in a static shared buffer. kit \u00b6 public static Kit kit(int id) Get the kit for the specified id or return null if out of range. log \u00b6 public static Log log(int id) Get the log for the specified id or return null if out of range. longHexStr \u00b6 public static native Str longHexStr(long v) Format the 64-bit integer into a hexidecimal string. The string is stored in a static shared buffer. longStr \u00b6 public static native Str longStr(long v) Format the 64-bit integer into a string. The string is stored in a static shared buffer. main \u00b6 public static int main( Str [] args, int argsLen) Standard main entry point. max \u00b6 public static int max(int a, int b) Return the max of two ints. min \u00b6 public static int min(int a, int b) Return the min of two ints. orBytes \u00b6 public static native void orBytes(int mask, byte[] bytes, int off, int len) Perform a bitwise \"or\" using the specified mask on each byte in the bytes array. printVer \u00b6 public static void printVer( OutStream out) Print version information to the output stream. rand \u00b6 public static native int rand() Generate a random 32-bit integer. resume \u00b6 public static int resume( Str [] args, int argsLen) This is the entry point where native code resumes the Sedona VM from a yield or hibernate state. VM heap remains intact. scodeAddr \u00b6 public static native byte[] scodeAddr() Get the base address of the scode image as a byte pointer. INTERNAL USE ONLY. setBytes \u00b6 public static native void setBytes(int val, byte[] bytes, int off, int len) Set all the bytes in the specified array to val. shutdown \u00b6 public static int shutdown(int result) This method unwinds the Sedona call stack and the VM exits with the given error code. If it returns 'Err.hibernate' or 'Err.yield', the Sedona heap remains intact and can be restarted via 'resume' entry point If the specified result is not the hibernate or yield error codes, then stop the application and cleanup memory. sleep \u00b6 public static native void sleep(long t) Sleep for the specified time in nanosecond ticks. If t <= 0, then sleep should return immediately. This method is for use by App and test code only. Do not call from within Component execute() or Service work() methods. ticks \u00b6 public static native long ticks() Get the current time as a 64-bit integer of nanosecond ticks. Ticks are not necessarily based on wall-time, but rather based on an arbitrary epoch (typically the boot time of the host) type \u00b6 public static Type type(int kitId, int typeId) Get the type for the specified kit and type id or return null if out of range. Doc Home > API Index > sys","title":"Sys"},{"location":"api/sys/Sys/#sys","text":"Doc Home > API Index > sys","title":"Sys"},{"location":"api/sys/Sys/#inheritance","text":"sys::Obj sys::Sys public class Sys Sys provides access to the system environment.","title":"Inheritance"},{"location":"api/sys/Sys/#fields","text":"","title":"Fields"},{"location":"api/sys/Sys/#app","text":"public static inline App app The application instance for the VM","title":"app"},{"location":"api/sys/Sys/#boottime","text":"public static long bootTime The time in nanosecond ticks the Sedona runtime was booted","title":"bootTime"},{"location":"api/sys/Sys/#kits","text":"public static const Kit [] kits The list of kits installed in this environment.","title":"kits"},{"location":"api/sys/Sys/#kitslen","text":"public static const define int kitsLen The number of items in the kits array.","title":"kitsLen"},{"location":"api/sys/Sys/#loglevels","text":"public static inline byte[] logLevels The current severity level of each log","title":"logLevels"},{"location":"api/sys/Sys/#logs","text":"public static const Log [] logs The list of logs installed in this environment.","title":"logs"},{"location":"api/sys/Sys/#logslen","text":"public static const define int logsLen The number of items in the logs array.","title":"logsLen"},{"location":"api/sys/Sys/#maxint","text":"public static const define int maxInt Max value of a 32-bit signed integer: 2,147,483,647","title":"maxInt"},{"location":"api/sys/Sys/#maxlong","text":"public static const define long maxLong Max value of a 64-bit signed integer: 9,223,372,036,854,775,807","title":"maxLong"},{"location":"api/sys/Sys/#minint","text":"public static const define int minInt Min value of a 32-bit signed integer: -2,147,483,648","title":"minInt"},{"location":"api/sys/Sys/#minlong","text":"public static const define long minLong Min value of a 64-bit signed integer: -9,223,372,036,854,775,808","title":"minLong"},{"location":"api/sys/Sys/#nullin","text":"public static inline InStream nullIn The null input stream is always at end of file.","title":"nullIn"},{"location":"api/sys/Sys/#nullout","text":"public static inline OutStream nullOut The null output stream sinks its output to nowhere.","title":"nullOut"},{"location":"api/sys/Sys/#out","text":"public static inline OutStream out Standard output stream.","title":"out"},{"location":"api/sys/Sys/#sizeofref","text":"public static const define int sizeofRef Size in bytes of a reference/pointer on this system.","title":"sizeofRef"},{"location":"api/sys/Sys/#methods","text":"","title":"Methods"},{"location":"api/sys/Sys/#andbytes","text":"public static native void andBytes(int mask, byte[] bytes, int off, int len) Perform a bitwise \"and\" using the specified mask on each byte in the bytes array.","title":"andBytes"},{"location":"api/sys/Sys/#bitstodouble","text":"public static native double bitsToDouble(long bits) Return a 64-bit floating point value according to the IEEE 754 floating-point \"double format\" bit layout.","title":"bitsToDouble"},{"location":"api/sys/Sys/#bitstofloat","text":"public static native float bitsToFloat(int bits) Return a 32-bit floating point value according to the IEEE 754 floating-point \"single format\" bit layout.","title":"bitsToFloat"},{"location":"api/sys/Sys/#comparebytes","text":"public static native int compareBytes(byte[] a, int aOff, byte[] b, int bOff, int len) Compare two byte arrays for equality. If equal return 0, if a is less than b return -1, if a greater than b return 1.","title":"compareBytes"},{"location":"api/sys/Sys/#copy","text":"public static native void copy(byte[] src, int srcOff, byte[] dest, int destOff, int num) Copy num bytes from the source byte array to the destination byte array. The arrays may be overlapping (like memmove, not memcpy).","title":"copy"},{"location":"api/sys/Sys/#doublestr","text":"public static native Str doubleStr(double v) Format a double into a string. The string is stored in a static shared buffer.","title":"doubleStr"},{"location":"api/sys/Sys/#doubletobits","text":"public static native long doubleToBits(double v) Return a long representation of a 64-bit floating point value according to the IEEE 754 floating-point \"double format\" bit layout.","title":"doubleToBits"},{"location":"api/sys/Sys/#findkit","text":"public static Kit findKit( Str name) Find a kit by its unique name or return null if not found.","title":"findKit"},{"location":"api/sys/Sys/#findlog","text":"public static Log findLog( Str qname) Find a log by its qualified name or return null if not found.","title":"findLog"},{"location":"api/sys/Sys/#findtype","text":"public static Type findType( Str qname) Find a type by its qualified name such as \"sys::Component\" or return null if not found.","title":"findType"},{"location":"api/sys/Sys/#floatstr","text":"public static native Str floatStr(float v) Format a float into a string. The string is stored in a static shared buffer.","title":"floatStr"},{"location":"api/sys/Sys/#floattobits","text":"public static native int floatToBits(float v) Return an integer representation of a 32-bit floating point value according to the IEEE 754 floating-point \"single format\" bit layout.","title":"floatToBits"},{"location":"api/sys/Sys/#fromdigit","text":"public static int fromDigit(int digit) Return the numeric value of a decimal character: '0' -> 0 '9' -> 9 Return -1 if not a valid decimal digit.","title":"fromDigit"},{"location":"api/sys/Sys/#fromhexdigit","text":"public static int fromHexDigit(int digit) Return the numeric value of an decimal character: '0' -> 0 '9' -> 9 'a' or 'A' -> 10 'f' or 'F' -> 15 Return -1 if not a valid hex digit.","title":"fromHexDigit"},{"location":"api/sys/Sys/#hexstr","text":"public static native Str hexStr(int v) Format an integer as a hexadecimal string. The string is stored in a static shared buffer.","title":"hexStr"},{"location":"api/sys/Sys/#intstr","text":"public static native Str intStr(int v) Format an integer as a decimal string. The string is stored in a static shared buffer.","title":"intStr"},{"location":"api/sys/Sys/#kit","text":"public static Kit kit(int id) Get the kit for the specified id or return null if out of range.","title":"kit"},{"location":"api/sys/Sys/#log","text":"public static Log log(int id) Get the log for the specified id or return null if out of range.","title":"log"},{"location":"api/sys/Sys/#longhexstr","text":"public static native Str longHexStr(long v) Format the 64-bit integer into a hexidecimal string. The string is stored in a static shared buffer.","title":"longHexStr"},{"location":"api/sys/Sys/#longstr","text":"public static native Str longStr(long v) Format the 64-bit integer into a string. The string is stored in a static shared buffer.","title":"longStr"},{"location":"api/sys/Sys/#main","text":"public static int main( Str [] args, int argsLen) Standard main entry point.","title":"main"},{"location":"api/sys/Sys/#max","text":"public static int max(int a, int b) Return the max of two ints.","title":"max"},{"location":"api/sys/Sys/#min","text":"public static int min(int a, int b) Return the min of two ints.","title":"min"},{"location":"api/sys/Sys/#orbytes","text":"public static native void orBytes(int mask, byte[] bytes, int off, int len) Perform a bitwise \"or\" using the specified mask on each byte in the bytes array.","title":"orBytes"},{"location":"api/sys/Sys/#printver","text":"public static void printVer( OutStream out) Print version information to the output stream.","title":"printVer"},{"location":"api/sys/Sys/#rand","text":"public static native int rand() Generate a random 32-bit integer.","title":"rand"},{"location":"api/sys/Sys/#resume","text":"public static int resume( Str [] args, int argsLen) This is the entry point where native code resumes the Sedona VM from a yield or hibernate state. VM heap remains intact.","title":"resume"},{"location":"api/sys/Sys/#scodeaddr","text":"public static native byte[] scodeAddr() Get the base address of the scode image as a byte pointer. INTERNAL USE ONLY.","title":"scodeAddr"},{"location":"api/sys/Sys/#setbytes","text":"public static native void setBytes(int val, byte[] bytes, int off, int len) Set all the bytes in the specified array to val.","title":"setBytes"},{"location":"api/sys/Sys/#shutdown","text":"public static int shutdown(int result) This method unwinds the Sedona call stack and the VM exits with the given error code. If it returns 'Err.hibernate' or 'Err.yield', the Sedona heap remains intact and can be restarted via 'resume' entry point If the specified result is not the hibernate or yield error codes, then stop the application and cleanup memory.","title":"shutdown"},{"location":"api/sys/Sys/#sleep","text":"public static native void sleep(long t) Sleep for the specified time in nanosecond ticks. If t <= 0, then sleep should return immediately. This method is for use by App and test code only. Do not call from within Component execute() or Service work() methods.","title":"sleep"},{"location":"api/sys/Sys/#ticks","text":"public static native long ticks() Get the current time as a 64-bit integer of nanosecond ticks. Ticks are not necessarily based on wall-time, but rather based on an arbitrary epoch (typically the boot time of the host)","title":"ticks"},{"location":"api/sys/Sys/#type","text":"public static Type type(int kitId, int typeId) Get the type for the specified kit and type id or return null if out of range. Doc Home > API Index > sys","title":"type"},{"location":"api/sys/Test/","text":"Test \u00b6 Doc Home > API Index > sys > Test Inheritance \u00b6 sys::Obj sys::Virtual sys::Test public abstract class Test Test is the base class for test classes which are automatically registered into the test suite. Any method which begins with \"test\" is automatically added as a test case for the test class. Tests themselves are written as a series of assert statements. Fields \u00b6 Methods \u00b6 main \u00b6 public static int main() This is the main routine for running the test suite. The compiler generates the table of test functions during scode compilation. startApp \u00b6 public static void startApp() Start the App. Helpful for calling tests individually unitTest \u00b6 public static int unitTest( Str qname) This is to call individual test of a given type Doc Home > API Index > sys > Test","title":"Test"},{"location":"api/sys/Test/#test","text":"Doc Home > API Index > sys > Test","title":"Test"},{"location":"api/sys/Test/#inheritance","text":"sys::Obj sys::Virtual sys::Test public abstract class Test Test is the base class for test classes which are automatically registered into the test suite. Any method which begins with \"test\" is automatically added as a test case for the test class. Tests themselves are written as a series of assert statements.","title":"Inheritance"},{"location":"api/sys/Test/#fields","text":"","title":"Fields"},{"location":"api/sys/Test/#methods","text":"","title":"Methods"},{"location":"api/sys/Test/#main","text":"public static int main() This is the main routine for running the test suite. The compiler generates the table of test functions during scode compilation.","title":"main"},{"location":"api/sys/Test/#startapp","text":"public static void startApp() Start the App. Helpful for calling tests individually","title":"startApp"},{"location":"api/sys/Test/#unittest","text":"public static int unitTest( Str qname) This is to call individual test of a given type Doc Home > API Index > sys > Test","title":"unitTest"},{"location":"api/sys/Type/","text":"Type \u00b6 Doc Home > API Index > sys > Type Inheritance \u00b6 sys::Obj sys::Type public const class Type Type models the meta-data of a Component including its virtual method tables and slot definitions. Fields \u00b6 base \u00b6 public const Type base Reference to the base class type or null if Component itself. boolId \u00b6 public static const define int boolId bufId \u00b6 public static const define int bufId byteId \u00b6 public static const define int byteId doubleId \u00b6 public static const define int doubleId errorId \u00b6 public static const define int errorId floatId \u00b6 public static const define int floatId id \u00b6 public const byte id Unique id within this type's kit; index into kit.types. intId \u00b6 public static const define int intId kit \u00b6 public const Kit kit Reference to the Kit which contains this type. longId \u00b6 public static const define int longId maxPrimitiveId \u00b6 public static const define int maxPrimitiveId name \u00b6 public const Str name Simple name string of this type which unique within the kit. shortId \u00b6 public static const define int shortId sizeof \u00b6 public const short sizeof Number of bytes in memory an instance of this type requires. slots \u00b6 public const inline Slot [] slots The list of this type's reflective slots (properties and actions) including inherited slots. slotsLen \u00b6 public const byte slotsLen The number of slots in the slots array. voidId \u00b6 public static const define int voidId Methods \u00b6 findSlot \u00b6 public Slot findSlot( Str name) Find a slot by its simple name within this Type or return null if not found. is \u00b6 public bool is( Type t) Return if this type is or extends from the specified type. isPrimitive \u00b6 public bool isPrimitive() Return if this one of the primitive types. slot \u00b6 public Slot slot(int id) Get the slot for the specified id or return null if out of range. Doc Home > API Index > sys > Type","title":"Type"},{"location":"api/sys/Type/#type","text":"Doc Home > API Index > sys > Type","title":"Type"},{"location":"api/sys/Type/#inheritance","text":"sys::Obj sys::Type public const class Type Type models the meta-data of a Component including its virtual method tables and slot definitions.","title":"Inheritance"},{"location":"api/sys/Type/#fields","text":"","title":"Fields"},{"location":"api/sys/Type/#base","text":"public const Type base Reference to the base class type or null if Component itself.","title":"base"},{"location":"api/sys/Type/#boolid","text":"public static const define int boolId","title":"boolId"},{"location":"api/sys/Type/#bufid","text":"public static const define int bufId","title":"bufId"},{"location":"api/sys/Type/#byteid","text":"public static const define int byteId","title":"byteId"},{"location":"api/sys/Type/#doubleid","text":"public static const define int doubleId","title":"doubleId"},{"location":"api/sys/Type/#errorid","text":"public static const define int errorId","title":"errorId"},{"location":"api/sys/Type/#floatid","text":"public static const define int floatId","title":"floatId"},{"location":"api/sys/Type/#id","text":"public const byte id Unique id within this type's kit; index into kit.types.","title":"id"},{"location":"api/sys/Type/#intid","text":"public static const define int intId","title":"intId"},{"location":"api/sys/Type/#kit","text":"public const Kit kit Reference to the Kit which contains this type.","title":"kit"},{"location":"api/sys/Type/#longid","text":"public static const define int longId","title":"longId"},{"location":"api/sys/Type/#maxprimitiveid","text":"public static const define int maxPrimitiveId","title":"maxPrimitiveId"},{"location":"api/sys/Type/#name","text":"public const Str name Simple name string of this type which unique within the kit.","title":"name"},{"location":"api/sys/Type/#shortid","text":"public static const define int shortId","title":"shortId"},{"location":"api/sys/Type/#sizeof","text":"public const short sizeof Number of bytes in memory an instance of this type requires.","title":"sizeof"},{"location":"api/sys/Type/#slots","text":"public const inline Slot [] slots The list of this type's reflective slots (properties and actions) including inherited slots.","title":"slots"},{"location":"api/sys/Type/#slotslen","text":"public const byte slotsLen The number of slots in the slots array.","title":"slotsLen"},{"location":"api/sys/Type/#voidid","text":"public static const define int voidId","title":"voidId"},{"location":"api/sys/Type/#methods","text":"","title":"Methods"},{"location":"api/sys/Type/#findslot","text":"public Slot findSlot( Str name) Find a slot by its simple name within this Type or return null if not found.","title":"findSlot"},{"location":"api/sys/Type/#is","text":"public bool is( Type t) Return if this type is or extends from the specified type.","title":"is"},{"location":"api/sys/Type/#isprimitive","text":"public bool isPrimitive() Return if this one of the primitive types.","title":"isPrimitive"},{"location":"api/sys/Type/#slot","text":"public Slot slot(int id) Get the slot for the specified id or return null if out of range. Doc Home > API Index > sys > Type","title":"slot"},{"location":"api/sys/Units/","text":"Units \u00b6 Doc Home > API Index > sys > Units Inheritance \u00b6 sys::Obj sys::Units public class Units Standard database of unit names to be used with the unit facet. These names are standardized by the oBIX OASIS specification. Fields \u00b6 acre \u00b6 public static const define Str acre ampere \u00b6 public static const define Str ampere ampere_square_meter \u00b6 public static const define Str ampere_square_meter amperes_per_meter \u00b6 public static const define Str amperes_per_meter amperes_per_square_meter \u00b6 public static const define Str amperes_per_square_meter atmosphere \u00b6 public static const define Str atmosphere bar \u00b6 public static const define Str bar btu \u00b6 public static const define Str btu btu_per_pound \u00b6 public static const define Str btu_per_pound btus_per_hour \u00b6 public static const define Str btus_per_hour btus_per_pound \u00b6 public static const define Str btus_per_pound btus_per_pound_dry_air \u00b6 public static const define Str btus_per_pound_dry_air calorie \u00b6 public static const define Str calorie calorie_per_gram \u00b6 public static const define Str calorie_per_gram candela \u00b6 public static const define Str candela candelas_per_square_meter \u00b6 public static const define Str candelas_per_square_meter celsius \u00b6 public static const define Str celsius celsius_degrees \u00b6 public static const define Str celsius_degrees centimeter \u00b6 public static const define Str centimeter centimeters_of_mercury \u00b6 public static const define Str centimeters_of_mercury centimeters_of_water \u00b6 public static const define Str centimeters_of_water coulomb \u00b6 public static const define Str coulomb cubic_centimeter \u00b6 public static const define Str cubic_centimeter cubic_feet_per_minute \u00b6 public static const define Str cubic_feet_per_minute cubic_feet_per_second \u00b6 public static const define Str cubic_feet_per_second cubic_foot \u00b6 public static const define Str cubic_foot cubic_inch \u00b6 public static const define Str cubic_inch cubic_meter \u00b6 public static const define Str cubic_meter cubic_meters_per_hour \u00b6 public static const define Str cubic_meters_per_hour cubic_meters_per_minute \u00b6 public static const define Str cubic_meters_per_minute cubic_meters_per_second \u00b6 public static const define Str cubic_meters_per_second cubic_millimeter \u00b6 public static const define Str cubic_millimeter cubic_yard \u00b6 public static const define Str cubic_yard cycles_per_hour \u00b6 public static const define Str cycles_per_hour cycles_per_minute \u00b6 public static const define Str cycles_per_minute day \u00b6 public static const define Str day db_microVolt \u00b6 public static const define Str db_microVolt db_milliVolt \u00b6 public static const define Str db_milliVolt decibel \u00b6 public static const define Str decibel degree_days_celsius \u00b6 public static const define Str degree_days_celsius degree_days_fahrenheit \u00b6 public static const define Str degree_days_fahrenheit degrees_angular \u00b6 public static const define Str degrees_angular degrees_celsius_per_hour \u00b6 public static const define Str degrees_celsius_per_hour degrees_celsius_per_minute \u00b6 public static const define Str degrees_celsius_per_minute degrees_fahrenheit_per_hour \u00b6 public static const define Str degrees_fahrenheit_per_hour degrees_fahrenheit_per_minute \u00b6 public static const define Str degrees_fahrenheit_per_minute degrees_kelvin_per_hour \u00b6 public static const define Str degrees_kelvin_per_hour degrees_kelvin_per_minute \u00b6 public static const define Str degrees_kelvin_per_minute degrees_kelvin_per_second \u00b6 public static const define Str degrees_kelvin_per_second degrees_phase \u00b6 public static const define Str degrees_phase delta_btus_per_pound \u00b6 public static const define Str delta_btus_per_pound delta_kilojoules_per_kilogram \u00b6 public static const define Str delta_kilojoules_per_kilogram dollar \u00b6 public static const define Str dollar euro \u00b6 public static const define Str euro fahrenheit \u00b6 public static const define Str fahrenheit fahrenheit_degrees \u00b6 public static const define Str fahrenheit_degrees farad \u00b6 public static const define Str farad feet_per_minute \u00b6 public static const define Str feet_per_minute feet_per_second \u00b6 public static const define Str feet_per_second fluid_ounce \u00b6 public static const define Str fluid_ounce foot \u00b6 public static const define Str foot foot_pounds_per_second \u00b6 public static const define Str foot_pounds_per_second footcandle \u00b6 public static const define Str footcandle footcandles \u00b6 public static const define Str footcandles formazin_nephelometric_unit \u00b6 public static const define Str formazin_nephelometric_unit franc \u00b6 public static const define Str franc gallon \u00b6 public static const define Str gallon gallons_per_minute \u00b6 public static const define Str gallons_per_minute gigajoule \u00b6 public static const define Str gigajoule gigawatt \u00b6 public static const define Str gigawatt gram \u00b6 public static const define Str gram grams_of_water_per_kilogram_dry_air \u00b6 public static const define Str grams_of_water_per_kilogram_dry_air grams_per_kilogram \u00b6 public static const define Str grams_per_kilogram grams_per_minute \u00b6 public static const define Str grams_per_minute grams_per_second \u00b6 public static const define Str grams_per_second grams_per_square_meter \u00b6 public static const define Str grams_per_square_meter hectopascal \u00b6 public static const define Str hectopascal henry \u00b6 public static const define Str henry hertz \u00b6 public static const define Str hertz horsepower \u00b6 public static const define Str horsepower horsepower_hour \u00b6 public static const define Str horsepower_hour hour \u00b6 public static const define Str hour hundredths_second \u00b6 public static const define Str hundredths_second imperial_gallon \u00b6 public static const define Str imperial_gallon imperial_gallons_per_minute \u00b6 public static const define Str imperial_gallons_per_minute inch \u00b6 public static const define Str inch inches_of_mercury \u00b6 public static const define Str inches_of_mercury inches_of_water \u00b6 public static const define Str inches_of_water joule \u00b6 public static const define Str joule joule_second \u00b6 public static const define Str joule_second joules_per_degree_kelvin \u00b6 public static const define Str joules_per_degree_kelvin joules_per_gram \u00b6 public static const define Str joules_per_gram joules_per_kilogram \u00b6 public static const define Str joules_per_kilogram joules_per_kilogram_degree_kelvin \u00b6 public static const define Str joules_per_kilogram_degree_kelvin joules_per_kilogram_dry_air \u00b6 public static const define Str joules_per_kilogram_dry_air joules_per_kilogram_se \u00b6 public static const define Str joules_per_kilogram_se joules_per_square_meter \u00b6 public static const define Str joules_per_square_meter julian_month \u00b6 public static const define Str julian_month kelvin \u00b6 public static const define Str kelvin kelvin_degrees \u00b6 public static const define Str kelvin_degrees kilobtu \u00b6 public static const define Str kilobtu kilobtus_per_hour \u00b6 public static const define Str kilobtus_per_hour kilogram \u00b6 public static const define Str kilogram kilograms_per_cubic_meter \u00b6 public static const define Str kilograms_per_cubic_meter kilograms_per_hour \u00b6 public static const define Str kilograms_per_hour kilograms_per_minute \u00b6 public static const define Str kilograms_per_minute kilograms_per_second \u00b6 public static const define Str kilograms_per_second kilograms_per_square_meter \u00b6 public static const define Str kilograms_per_square_meter kilohertz \u00b6 public static const define Str kilohertz kilohm \u00b6 public static const define Str kilohm kilojoule \u00b6 public static const define Str kilojoule kilojoule_per_kilogram \u00b6 public static const define Str kilojoule_per_kilogram kilojoules_per_degree_kelvin \u00b6 public static const define Str kilojoules_per_degree_kelvin kilojoules_per_kilogram \u00b6 public static const define Str kilojoules_per_kilogram kilojoules_per_kilogram_dry_air \u00b6 public static const define Str kilojoules_per_kilogram_dry_air kiloliter \u00b6 public static const define Str kiloliter kilometer \u00b6 public static const define Str kilometer kilometers_per_hour \u00b6 public static const define Str kilometers_per_hour kilometers_per_second \u00b6 public static const define Str kilometers_per_second kilopascal \u00b6 public static const define Str kilopascal kilovolt \u00b6 public static const define Str kilovolt kilovolt_ampere \u00b6 public static const define Str kilovolt_ampere kilovolt_ampere_hour \u00b6 public static const define Str kilovolt_ampere_hour kilovolt_ampere_reactive \u00b6 public static const define Str kilovolt_ampere_reactive kilovolt_ampere_reactive_hour \u00b6 public static const define Str kilovolt_ampere_reactive_hour kilowatt \u00b6 public static const define Str kilowatt kilowatt_hour \u00b6 public static const define Str kilowatt_hour kilowatt_hours_per_square_foot \u00b6 public static const define Str kilowatt_hours_per_square_foot kilowatt_hours_per_square_meter \u00b6 public static const define Str kilowatt_hours_per_square_meter lira \u00b6 public static const define Str lira liter \u00b6 public static const define Str liter liters_per_hour \u00b6 public static const define Str liters_per_hour liters_per_minute \u00b6 public static const define Str liters_per_minute liters_per_second \u00b6 public static const define Str liters_per_second lumen \u00b6 public static const define Str lumen lux \u00b6 public static const define Str lux megabtu \u00b6 public static const define Str megabtu megahertz \u00b6 public static const define Str megahertz megajoule \u00b6 public static const define Str megajoule megajoules_per_degree_kelvin \u00b6 public static const define Str megajoules_per_degree_kelvin megajoules_per_kilogram_dry_air \u00b6 public static const define Str megajoules_per_kilogram_dry_air megajoules_per_square_foot \u00b6 public static const define Str megajoules_per_square_foot megajoules_per_square_meter \u00b6 public static const define Str megajoules_per_square_meter megavolt \u00b6 public static const define Str megavolt megavolt_ampere \u00b6 public static const define Str megavolt_ampere megavolt_ampere_hour \u00b6 public static const define Str megavolt_ampere_hour megavolt_ampere_reactive \u00b6 public static const define Str megavolt_ampere_reactive megavolt_ampere_reactive_hour \u00b6 public static const define Str megavolt_ampere_reactive_hour megawatt \u00b6 public static const define Str megawatt megawatt_hour \u00b6 public static const define Str megawatt_hour megohm \u00b6 public static const define Str megohm meter \u00b6 public static const define Str meter meters_per_hour \u00b6 public static const define Str meters_per_hour meters_per_minute \u00b6 public static const define Str meters_per_minute meters_per_second \u00b6 public static const define Str meters_per_second meters_per_second_squared \u00b6 public static const define Str meters_per_second_squared metric_ton \u00b6 public static const define Str metric_ton metric_tons_per_hour \u00b6 public static const define Str metric_tons_per_hour micrometer \u00b6 public static const define Str micrometer microsecond \u00b6 public static const define Str microsecond mile \u00b6 public static const define Str mile miles_per_hour \u00b6 public static const define Str miles_per_hour milliampere \u00b6 public static const define Str milliampere millibar \u00b6 public static const define Str millibar milligram \u00b6 public static const define Str milligram milliliter \u00b6 public static const define Str milliliter milliliters_per_minute \u00b6 public static const define Str milliliters_per_minute milliliters_per_second \u00b6 public static const define Str milliliters_per_second millimeter \u00b6 public static const define Str millimeter millimeters_of_mercury \u00b6 public static const define Str millimeters_of_mercury millimeters_per_minute \u00b6 public static const define Str millimeters_per_minute millimeters_per_second \u00b6 public static const define Str millimeters_per_second milliohm \u00b6 public static const define Str milliohm millisecond \u00b6 public static const define Str millisecond millivolt \u00b6 public static const define Str millivolt milliwatt \u00b6 public static const define Str milliwatt minute \u00b6 public static const define Str minute nanosecond \u00b6 public static const define Str nanosecond nephelometric_turbidity_units \u00b6 public static const define Str nephelometric_turbidity_units newton \u00b6 public static const define Str newton newton_meter \u00b6 public static const define Str newton_meter newton_second \u00b6 public static const define Str newton_second newtons_per_meter \u00b6 public static const define Str newtons_per_meter newtons_per_meter_st \u00b6 public static const define Str newtons_per_meter_st ohm \u00b6 public static const define Str ohm ohm_meter \u00b6 public static const define Str ohm_meter ounce \u00b6 public static const define Str ounce pH \u00b6 public static const define Str pH parts_per_billion \u00b6 public static const define Str parts_per_billion parts_per_million \u00b6 public static const define Str parts_per_million parts_per_unit \u00b6 public static const define Str parts_per_unit pascal \u00b6 public static const define Str pascal per_hour \u00b6 public static const define Str per_hour per_minute \u00b6 public static const define Str per_minute per_second \u00b6 public static const define Str per_second percent \u00b6 public static const define Str percent percent_obscuration_per_foot \u00b6 public static const define Str percent_obscuration_per_foot percent_obscuration_per_meter \u00b6 public static const define Str percent_obscuration_per_meter percent_per_second \u00b6 public static const define Str percent_per_second percent_relative_humidity \u00b6 public static const define Str percent_relative_humidity peseta \u00b6 public static const define Str peseta pint \u00b6 public static const define Str pint pound \u00b6 public static const define Str pound pound_force \u00b6 public static const define Str pound_force pounds \u00b6 public static const define Str pounds pounds_per_hour \u00b6 public static const define Str pounds_per_hour pounds_per_minute \u00b6 public static const define Str pounds_per_minute pounds_per_second \u00b6 public static const define Str pounds_per_second pounds_per_square_inch \u00b6 public static const define Str pounds_per_square_inch power_factor \u00b6 public static const define Str power_factor psi_per_degree_fahrenheit \u00b6 public static const define Str psi_per_degree_fahrenheit quart \u00b6 public static const define Str quart radian \u00b6 public static const define Str radian radians_per_second \u00b6 public static const define Str radians_per_second radians_per_second_squared \u00b6 public static const define Str radians_per_second_squared revolutions_per_minute \u00b6 public static const define Str revolutions_per_minute rupee \u00b6 public static const define Str rupee second \u00b6 public static const define Str second short_ton \u00b6 public static const define Str short_ton siemens \u00b6 public static const define Str siemens siemens_per_meter \u00b6 public static const define Str siemens_per_meter square_centimeter \u00b6 public static const define Str square_centimeter square_foot \u00b6 public static const define Str square_foot square_inch \u00b6 public static const define Str square_inch square_kilometer \u00b6 public static const define Str square_kilometer square_meter \u00b6 public static const define Str square_meter square_meters_per_newton \u00b6 public static const define Str square_meters_per_newton square_mile \u00b6 public static const define Str square_mile square_millimeter \u00b6 public static const define Str square_millimeter square_yard \u00b6 public static const define Str square_yard steradian \u00b6 public static const define Str steradian tenths_second \u00b6 public static const define Str tenths_second tesla \u00b6 public static const define Str tesla therm \u00b6 public static const define Str therm tons_refrigeration \u00b6 public static const define Str tons_refrigeration tons_refrigeration_hour \u00b6 public static const define Str tons_refrigeration_hour torr \u00b6 public static const define Str torr volt \u00b6 public static const define Str volt volt_ampere \u00b6 public static const define Str volt_ampere volt_ampere_hour \u00b6 public static const define Str volt_ampere_hour volt_ampere_reactive \u00b6 public static const define Str volt_ampere_reactive volt_ampere_reactive_hour \u00b6 public static const define Str volt_ampere_reactive_hour volts_per_degree_kelvin \u00b6 public static const define Str volts_per_degree_kelvin volts_per_meter \u00b6 public static const define Str volts_per_meter watt \u00b6 public static const define Str watt watt_hour \u00b6 public static const define Str watt_hour watts_per_meter_degree_kelvin \u00b6 public static const define Str watts_per_meter_degree_kelvin watts_per_square_foot \u00b6 public static const define Str watts_per_square_foot watts_per_square_meter \u00b6 public static const define Str watts_per_square_meter watts_per_square_meter_degree_kelvin \u00b6 public static const define Str watts_per_square_meter_degree_kelvin weber \u00b6 public static const define Str weber week \u00b6 public static const define Str week won \u00b6 public static const define Str won yard \u00b6 public static const define Str yard year \u00b6 public static const define Str year yen \u00b6 public static const define Str yen Doc Home > API Index > sys > Units","title":"Units"},{"location":"api/sys/Units/#units","text":"Doc Home > API Index > sys > Units","title":"Units"},{"location":"api/sys/Units/#inheritance","text":"sys::Obj sys::Units public class Units Standard database of unit names to be used with the unit facet. These names are standardized by the oBIX OASIS specification.","title":"Inheritance"},{"location":"api/sys/Units/#fields","text":"","title":"Fields"},{"location":"api/sys/Units/#acre","text":"public static const define Str acre","title":"acre"},{"location":"api/sys/Units/#ampere","text":"public static const define Str ampere","title":"ampere"},{"location":"api/sys/Units/#ampere_square_meter","text":"public static const define Str ampere_square_meter","title":"ampere_square_meter"},{"location":"api/sys/Units/#amperes_per_meter","text":"public static const define Str amperes_per_meter","title":"amperes_per_meter"},{"location":"api/sys/Units/#amperes_per_square_meter","text":"public static const define Str amperes_per_square_meter","title":"amperes_per_square_meter"},{"location":"api/sys/Units/#atmosphere","text":"public static const define Str atmosphere","title":"atmosphere"},{"location":"api/sys/Units/#bar","text":"public static const define Str bar","title":"bar"},{"location":"api/sys/Units/#btu","text":"public static const define Str btu","title":"btu"},{"location":"api/sys/Units/#btu_per_pound","text":"public static const define Str btu_per_pound","title":"btu_per_pound"},{"location":"api/sys/Units/#btus_per_hour","text":"public static const define Str btus_per_hour","title":"btus_per_hour"},{"location":"api/sys/Units/#btus_per_pound","text":"public static const define Str btus_per_pound","title":"btus_per_pound"},{"location":"api/sys/Units/#btus_per_pound_dry_air","text":"public static const define Str btus_per_pound_dry_air","title":"btus_per_pound_dry_air"},{"location":"api/sys/Units/#calorie","text":"public static const define Str calorie","title":"calorie"},{"location":"api/sys/Units/#calorie_per_gram","text":"public static const define Str calorie_per_gram","title":"calorie_per_gram"},{"location":"api/sys/Units/#candela","text":"public static const define Str candela","title":"candela"},{"location":"api/sys/Units/#candelas_per_square_meter","text":"public static const define Str candelas_per_square_meter","title":"candelas_per_square_meter"},{"location":"api/sys/Units/#celsius","text":"public static const define Str celsius","title":"celsius"},{"location":"api/sys/Units/#celsius_degrees","text":"public static const define Str celsius_degrees","title":"celsius_degrees"},{"location":"api/sys/Units/#centimeter","text":"public static const define Str centimeter","title":"centimeter"},{"location":"api/sys/Units/#centimeters_of_mercury","text":"public static const define Str centimeters_of_mercury","title":"centimeters_of_mercury"},{"location":"api/sys/Units/#centimeters_of_water","text":"public static const define Str centimeters_of_water","title":"centimeters_of_water"},{"location":"api/sys/Units/#coulomb","text":"public static const define Str coulomb","title":"coulomb"},{"location":"api/sys/Units/#cubic_centimeter","text":"public static const define Str cubic_centimeter","title":"cubic_centimeter"},{"location":"api/sys/Units/#cubic_feet_per_minute","text":"public static const define Str cubic_feet_per_minute","title":"cubic_feet_per_minute"},{"location":"api/sys/Units/#cubic_feet_per_second","text":"public static const define Str cubic_feet_per_second","title":"cubic_feet_per_second"},{"location":"api/sys/Units/#cubic_foot","text":"public static const define Str cubic_foot","title":"cubic_foot"},{"location":"api/sys/Units/#cubic_inch","text":"public static const define Str cubic_inch","title":"cubic_inch"},{"location":"api/sys/Units/#cubic_meter","text":"public static const define Str cubic_meter","title":"cubic_meter"},{"location":"api/sys/Units/#cubic_meters_per_hour","text":"public static const define Str cubic_meters_per_hour","title":"cubic_meters_per_hour"},{"location":"api/sys/Units/#cubic_meters_per_minute","text":"public static const define Str cubic_meters_per_minute","title":"cubic_meters_per_minute"},{"location":"api/sys/Units/#cubic_meters_per_second","text":"public static const define Str cubic_meters_per_second","title":"cubic_meters_per_second"},{"location":"api/sys/Units/#cubic_millimeter","text":"public static const define Str cubic_millimeter","title":"cubic_millimeter"},{"location":"api/sys/Units/#cubic_yard","text":"public static const define Str cubic_yard","title":"cubic_yard"},{"location":"api/sys/Units/#cycles_per_hour","text":"public static const define Str cycles_per_hour","title":"cycles_per_hour"},{"location":"api/sys/Units/#cycles_per_minute","text":"public static const define Str cycles_per_minute","title":"cycles_per_minute"},{"location":"api/sys/Units/#day","text":"public static const define Str day","title":"day"},{"location":"api/sys/Units/#db_microvolt","text":"public static const define Str db_microVolt","title":"db_microVolt"},{"location":"api/sys/Units/#db_millivolt","text":"public static const define Str db_milliVolt","title":"db_milliVolt"},{"location":"api/sys/Units/#decibel","text":"public static const define Str decibel","title":"decibel"},{"location":"api/sys/Units/#degree_days_celsius","text":"public static const define Str degree_days_celsius","title":"degree_days_celsius"},{"location":"api/sys/Units/#degree_days_fahrenheit","text":"public static const define Str degree_days_fahrenheit","title":"degree_days_fahrenheit"},{"location":"api/sys/Units/#degrees_angular","text":"public static const define Str degrees_angular","title":"degrees_angular"},{"location":"api/sys/Units/#degrees_celsius_per_hour","text":"public static const define Str degrees_celsius_per_hour","title":"degrees_celsius_per_hour"},{"location":"api/sys/Units/#degrees_celsius_per_minute","text":"public static const define Str degrees_celsius_per_minute","title":"degrees_celsius_per_minute"},{"location":"api/sys/Units/#degrees_fahrenheit_per_hour","text":"public static const define Str degrees_fahrenheit_per_hour","title":"degrees_fahrenheit_per_hour"},{"location":"api/sys/Units/#degrees_fahrenheit_per_minute","text":"public static const define Str degrees_fahrenheit_per_minute","title":"degrees_fahrenheit_per_minute"},{"location":"api/sys/Units/#degrees_kelvin_per_hour","text":"public static const define Str degrees_kelvin_per_hour","title":"degrees_kelvin_per_hour"},{"location":"api/sys/Units/#degrees_kelvin_per_minute","text":"public static const define Str degrees_kelvin_per_minute","title":"degrees_kelvin_per_minute"},{"location":"api/sys/Units/#degrees_kelvin_per_second","text":"public static const define Str degrees_kelvin_per_second","title":"degrees_kelvin_per_second"},{"location":"api/sys/Units/#degrees_phase","text":"public static const define Str degrees_phase","title":"degrees_phase"},{"location":"api/sys/Units/#delta_btus_per_pound","text":"public static const define Str delta_btus_per_pound","title":"delta_btus_per_pound"},{"location":"api/sys/Units/#delta_kilojoules_per_kilogram","text":"public static const define Str delta_kilojoules_per_kilogram","title":"delta_kilojoules_per_kilogram"},{"location":"api/sys/Units/#dollar","text":"public static const define Str dollar","title":"dollar"},{"location":"api/sys/Units/#euro","text":"public static const define Str euro","title":"euro"},{"location":"api/sys/Units/#fahrenheit","text":"public static const define Str fahrenheit","title":"fahrenheit"},{"location":"api/sys/Units/#fahrenheit_degrees","text":"public static const define Str fahrenheit_degrees","title":"fahrenheit_degrees"},{"location":"api/sys/Units/#farad","text":"public static const define Str farad","title":"farad"},{"location":"api/sys/Units/#feet_per_minute","text":"public static const define Str feet_per_minute","title":"feet_per_minute"},{"location":"api/sys/Units/#feet_per_second","text":"public static const define Str feet_per_second","title":"feet_per_second"},{"location":"api/sys/Units/#fluid_ounce","text":"public static const define Str fluid_ounce","title":"fluid_ounce"},{"location":"api/sys/Units/#foot","text":"public static const define Str foot","title":"foot"},{"location":"api/sys/Units/#foot_pounds_per_second","text":"public static const define Str foot_pounds_per_second","title":"foot_pounds_per_second"},{"location":"api/sys/Units/#footcandle","text":"public static const define Str footcandle","title":"footcandle"},{"location":"api/sys/Units/#footcandles","text":"public static const define Str footcandles","title":"footcandles"},{"location":"api/sys/Units/#formazin_nephelometric_unit","text":"public static const define Str formazin_nephelometric_unit","title":"formazin_nephelometric_unit"},{"location":"api/sys/Units/#franc","text":"public static const define Str franc","title":"franc"},{"location":"api/sys/Units/#gallon","text":"public static const define Str gallon","title":"gallon"},{"location":"api/sys/Units/#gallons_per_minute","text":"public static const define Str gallons_per_minute","title":"gallons_per_minute"},{"location":"api/sys/Units/#gigajoule","text":"public static const define Str gigajoule","title":"gigajoule"},{"location":"api/sys/Units/#gigawatt","text":"public static const define Str gigawatt","title":"gigawatt"},{"location":"api/sys/Units/#gram","text":"public static const define Str gram","title":"gram"},{"location":"api/sys/Units/#grams_of_water_per_kilogram_dry_air","text":"public static const define Str grams_of_water_per_kilogram_dry_air","title":"grams_of_water_per_kilogram_dry_air"},{"location":"api/sys/Units/#grams_per_kilogram","text":"public static const define Str grams_per_kilogram","title":"grams_per_kilogram"},{"location":"api/sys/Units/#grams_per_minute","text":"public static const define Str grams_per_minute","title":"grams_per_minute"},{"location":"api/sys/Units/#grams_per_second","text":"public static const define Str grams_per_second","title":"grams_per_second"},{"location":"api/sys/Units/#grams_per_square_meter","text":"public static const define Str grams_per_square_meter","title":"grams_per_square_meter"},{"location":"api/sys/Units/#hectopascal","text":"public static const define Str hectopascal","title":"hectopascal"},{"location":"api/sys/Units/#henry","text":"public static const define Str henry","title":"henry"},{"location":"api/sys/Units/#hertz","text":"public static const define Str hertz","title":"hertz"},{"location":"api/sys/Units/#horsepower","text":"public static const define Str horsepower","title":"horsepower"},{"location":"api/sys/Units/#horsepower_hour","text":"public static const define Str horsepower_hour","title":"horsepower_hour"},{"location":"api/sys/Units/#hour","text":"public static const define Str hour","title":"hour"},{"location":"api/sys/Units/#hundredths_second","text":"public static const define Str hundredths_second","title":"hundredths_second"},{"location":"api/sys/Units/#imperial_gallon","text":"public static const define Str imperial_gallon","title":"imperial_gallon"},{"location":"api/sys/Units/#imperial_gallons_per_minute","text":"public static const define Str imperial_gallons_per_minute","title":"imperial_gallons_per_minute"},{"location":"api/sys/Units/#inch","text":"public static const define Str inch","title":"inch"},{"location":"api/sys/Units/#inches_of_mercury","text":"public static const define Str inches_of_mercury","title":"inches_of_mercury"},{"location":"api/sys/Units/#inches_of_water","text":"public static const define Str inches_of_water","title":"inches_of_water"},{"location":"api/sys/Units/#joule","text":"public static const define Str joule","title":"joule"},{"location":"api/sys/Units/#joule_second","text":"public static const define Str joule_second","title":"joule_second"},{"location":"api/sys/Units/#joules_per_degree_kelvin","text":"public static const define Str joules_per_degree_kelvin","title":"joules_per_degree_kelvin"},{"location":"api/sys/Units/#joules_per_gram","text":"public static const define Str joules_per_gram","title":"joules_per_gram"},{"location":"api/sys/Units/#joules_per_kilogram","text":"public static const define Str joules_per_kilogram","title":"joules_per_kilogram"},{"location":"api/sys/Units/#joules_per_kilogram_degree_kelvin","text":"public static const define Str joules_per_kilogram_degree_kelvin","title":"joules_per_kilogram_degree_kelvin"},{"location":"api/sys/Units/#joules_per_kilogram_dry_air","text":"public static const define Str joules_per_kilogram_dry_air","title":"joules_per_kilogram_dry_air"},{"location":"api/sys/Units/#joules_per_kilogram_se","text":"public static const define Str joules_per_kilogram_se","title":"joules_per_kilogram_se"},{"location":"api/sys/Units/#joules_per_square_meter","text":"public static const define Str joules_per_square_meter","title":"joules_per_square_meter"},{"location":"api/sys/Units/#julian_month","text":"public static const define Str julian_month","title":"julian_month"},{"location":"api/sys/Units/#kelvin","text":"public static const define Str kelvin","title":"kelvin"},{"location":"api/sys/Units/#kelvin_degrees","text":"public static const define Str kelvin_degrees","title":"kelvin_degrees"},{"location":"api/sys/Units/#kilobtu","text":"public static const define Str kilobtu","title":"kilobtu"},{"location":"api/sys/Units/#kilobtus_per_hour","text":"public static const define Str kilobtus_per_hour","title":"kilobtus_per_hour"},{"location":"api/sys/Units/#kilogram","text":"public static const define Str kilogram","title":"kilogram"},{"location":"api/sys/Units/#kilograms_per_cubic_meter","text":"public static const define Str kilograms_per_cubic_meter","title":"kilograms_per_cubic_meter"},{"location":"api/sys/Units/#kilograms_per_hour","text":"public static const define Str kilograms_per_hour","title":"kilograms_per_hour"},{"location":"api/sys/Units/#kilograms_per_minute","text":"public static const define Str kilograms_per_minute","title":"kilograms_per_minute"},{"location":"api/sys/Units/#kilograms_per_second","text":"public static const define Str kilograms_per_second","title":"kilograms_per_second"},{"location":"api/sys/Units/#kilograms_per_square_meter","text":"public static const define Str kilograms_per_square_meter","title":"kilograms_per_square_meter"},{"location":"api/sys/Units/#kilohertz","text":"public static const define Str kilohertz","title":"kilohertz"},{"location":"api/sys/Units/#kilohm","text":"public static const define Str kilohm","title":"kilohm"},{"location":"api/sys/Units/#kilojoule","text":"public static const define Str kilojoule","title":"kilojoule"},{"location":"api/sys/Units/#kilojoule_per_kilogram","text":"public static const define Str kilojoule_per_kilogram","title":"kilojoule_per_kilogram"},{"location":"api/sys/Units/#kilojoules_per_degree_kelvin","text":"public static const define Str kilojoules_per_degree_kelvin","title":"kilojoules_per_degree_kelvin"},{"location":"api/sys/Units/#kilojoules_per_kilogram","text":"public static const define Str kilojoules_per_kilogram","title":"kilojoules_per_kilogram"},{"location":"api/sys/Units/#kilojoules_per_kilogram_dry_air","text":"public static const define Str kilojoules_per_kilogram_dry_air","title":"kilojoules_per_kilogram_dry_air"},{"location":"api/sys/Units/#kiloliter","text":"public static const define Str kiloliter","title":"kiloliter"},{"location":"api/sys/Units/#kilometer","text":"public static const define Str kilometer","title":"kilometer"},{"location":"api/sys/Units/#kilometers_per_hour","text":"public static const define Str kilometers_per_hour","title":"kilometers_per_hour"},{"location":"api/sys/Units/#kilometers_per_second","text":"public static const define Str kilometers_per_second","title":"kilometers_per_second"},{"location":"api/sys/Units/#kilopascal","text":"public static const define Str kilopascal","title":"kilopascal"},{"location":"api/sys/Units/#kilovolt","text":"public static const define Str kilovolt","title":"kilovolt"},{"location":"api/sys/Units/#kilovolt_ampere","text":"public static const define Str kilovolt_ampere","title":"kilovolt_ampere"},{"location":"api/sys/Units/#kilovolt_ampere_hour","text":"public static const define Str kilovolt_ampere_hour","title":"kilovolt_ampere_hour"},{"location":"api/sys/Units/#kilovolt_ampere_reactive","text":"public static const define Str kilovolt_ampere_reactive","title":"kilovolt_ampere_reactive"},{"location":"api/sys/Units/#kilovolt_ampere_reactive_hour","text":"public static const define Str kilovolt_ampere_reactive_hour","title":"kilovolt_ampere_reactive_hour"},{"location":"api/sys/Units/#kilowatt","text":"public static const define Str kilowatt","title":"kilowatt"},{"location":"api/sys/Units/#kilowatt_hour","text":"public static const define Str kilowatt_hour","title":"kilowatt_hour"},{"location":"api/sys/Units/#kilowatt_hours_per_square_foot","text":"public static const define Str kilowatt_hours_per_square_foot","title":"kilowatt_hours_per_square_foot"},{"location":"api/sys/Units/#kilowatt_hours_per_square_meter","text":"public static const define Str kilowatt_hours_per_square_meter","title":"kilowatt_hours_per_square_meter"},{"location":"api/sys/Units/#lira","text":"public static const define Str lira","title":"lira"},{"location":"api/sys/Units/#liter","text":"public static const define Str liter","title":"liter"},{"location":"api/sys/Units/#liters_per_hour","text":"public static const define Str liters_per_hour","title":"liters_per_hour"},{"location":"api/sys/Units/#liters_per_minute","text":"public static const define Str liters_per_minute","title":"liters_per_minute"},{"location":"api/sys/Units/#liters_per_second","text":"public static const define Str liters_per_second","title":"liters_per_second"},{"location":"api/sys/Units/#lumen","text":"public static const define Str lumen","title":"lumen"},{"location":"api/sys/Units/#lux","text":"public static const define Str lux","title":"lux"},{"location":"api/sys/Units/#megabtu","text":"public static const define Str megabtu","title":"megabtu"},{"location":"api/sys/Units/#megahertz","text":"public static const define Str megahertz","title":"megahertz"},{"location":"api/sys/Units/#megajoule","text":"public static const define Str megajoule","title":"megajoule"},{"location":"api/sys/Units/#megajoules_per_degree_kelvin","text":"public static const define Str megajoules_per_degree_kelvin","title":"megajoules_per_degree_kelvin"},{"location":"api/sys/Units/#megajoules_per_kilogram_dry_air","text":"public static const define Str megajoules_per_kilogram_dry_air","title":"megajoules_per_kilogram_dry_air"},{"location":"api/sys/Units/#megajoules_per_square_foot","text":"public static const define Str megajoules_per_square_foot","title":"megajoules_per_square_foot"},{"location":"api/sys/Units/#megajoules_per_square_meter","text":"public static const define Str megajoules_per_square_meter","title":"megajoules_per_square_meter"},{"location":"api/sys/Units/#megavolt","text":"public static const define Str megavolt","title":"megavolt"},{"location":"api/sys/Units/#megavolt_ampere","text":"public static const define Str megavolt_ampere","title":"megavolt_ampere"},{"location":"api/sys/Units/#megavolt_ampere_hour","text":"public static const define Str megavolt_ampere_hour","title":"megavolt_ampere_hour"},{"location":"api/sys/Units/#megavolt_ampere_reactive","text":"public static const define Str megavolt_ampere_reactive","title":"megavolt_ampere_reactive"},{"location":"api/sys/Units/#megavolt_ampere_reactive_hour","text":"public static const define Str megavolt_ampere_reactive_hour","title":"megavolt_ampere_reactive_hour"},{"location":"api/sys/Units/#megawatt","text":"public static const define Str megawatt","title":"megawatt"},{"location":"api/sys/Units/#megawatt_hour","text":"public static const define Str megawatt_hour","title":"megawatt_hour"},{"location":"api/sys/Units/#megohm","text":"public static const define Str megohm","title":"megohm"},{"location":"api/sys/Units/#meter","text":"public static const define Str meter","title":"meter"},{"location":"api/sys/Units/#meters_per_hour","text":"public static const define Str meters_per_hour","title":"meters_per_hour"},{"location":"api/sys/Units/#meters_per_minute","text":"public static const define Str meters_per_minute","title":"meters_per_minute"},{"location":"api/sys/Units/#meters_per_second","text":"public static const define Str meters_per_second","title":"meters_per_second"},{"location":"api/sys/Units/#meters_per_second_squared","text":"public static const define Str meters_per_second_squared","title":"meters_per_second_squared"},{"location":"api/sys/Units/#metric_ton","text":"public static const define Str metric_ton","title":"metric_ton"},{"location":"api/sys/Units/#metric_tons_per_hour","text":"public static const define Str metric_tons_per_hour","title":"metric_tons_per_hour"},{"location":"api/sys/Units/#micrometer","text":"public static const define Str micrometer","title":"micrometer"},{"location":"api/sys/Units/#microsecond","text":"public static const define Str microsecond","title":"microsecond"},{"location":"api/sys/Units/#mile","text":"public static const define Str mile","title":"mile"},{"location":"api/sys/Units/#miles_per_hour","text":"public static const define Str miles_per_hour","title":"miles_per_hour"},{"location":"api/sys/Units/#milliampere","text":"public static const define Str milliampere","title":"milliampere"},{"location":"api/sys/Units/#millibar","text":"public static const define Str millibar","title":"millibar"},{"location":"api/sys/Units/#milligram","text":"public static const define Str milligram","title":"milligram"},{"location":"api/sys/Units/#milliliter","text":"public static const define Str milliliter","title":"milliliter"},{"location":"api/sys/Units/#milliliters_per_minute","text":"public static const define Str milliliters_per_minute","title":"milliliters_per_minute"},{"location":"api/sys/Units/#milliliters_per_second","text":"public static const define Str milliliters_per_second","title":"milliliters_per_second"},{"location":"api/sys/Units/#millimeter","text":"public static const define Str millimeter","title":"millimeter"},{"location":"api/sys/Units/#millimeters_of_mercury","text":"public static const define Str millimeters_of_mercury","title":"millimeters_of_mercury"},{"location":"api/sys/Units/#millimeters_per_minute","text":"public static const define Str millimeters_per_minute","title":"millimeters_per_minute"},{"location":"api/sys/Units/#millimeters_per_second","text":"public static const define Str millimeters_per_second","title":"millimeters_per_second"},{"location":"api/sys/Units/#milliohm","text":"public static const define Str milliohm","title":"milliohm"},{"location":"api/sys/Units/#millisecond","text":"public static const define Str millisecond","title":"millisecond"},{"location":"api/sys/Units/#millivolt","text":"public static const define Str millivolt","title":"millivolt"},{"location":"api/sys/Units/#milliwatt","text":"public static const define Str milliwatt","title":"milliwatt"},{"location":"api/sys/Units/#minute","text":"public static const define Str minute","title":"minute"},{"location":"api/sys/Units/#nanosecond","text":"public static const define Str nanosecond","title":"nanosecond"},{"location":"api/sys/Units/#nephelometric_turbidity_units","text":"public static const define Str nephelometric_turbidity_units","title":"nephelometric_turbidity_units"},{"location":"api/sys/Units/#newton","text":"public static const define Str newton","title":"newton"},{"location":"api/sys/Units/#newton_meter","text":"public static const define Str newton_meter","title":"newton_meter"},{"location":"api/sys/Units/#newton_second","text":"public static const define Str newton_second","title":"newton_second"},{"location":"api/sys/Units/#newtons_per_meter","text":"public static const define Str newtons_per_meter","title":"newtons_per_meter"},{"location":"api/sys/Units/#newtons_per_meter_st","text":"public static const define Str newtons_per_meter_st","title":"newtons_per_meter_st"},{"location":"api/sys/Units/#ohm","text":"public static const define Str ohm","title":"ohm"},{"location":"api/sys/Units/#ohm_meter","text":"public static const define Str ohm_meter","title":"ohm_meter"},{"location":"api/sys/Units/#ounce","text":"public static const define Str ounce","title":"ounce"},{"location":"api/sys/Units/#ph","text":"public static const define Str pH","title":"pH"},{"location":"api/sys/Units/#parts_per_billion","text":"public static const define Str parts_per_billion","title":"parts_per_billion"},{"location":"api/sys/Units/#parts_per_million","text":"public static const define Str parts_per_million","title":"parts_per_million"},{"location":"api/sys/Units/#parts_per_unit","text":"public static const define Str parts_per_unit","title":"parts_per_unit"},{"location":"api/sys/Units/#pascal","text":"public static const define Str pascal","title":"pascal"},{"location":"api/sys/Units/#per_hour","text":"public static const define Str per_hour","title":"per_hour"},{"location":"api/sys/Units/#per_minute","text":"public static const define Str per_minute","title":"per_minute"},{"location":"api/sys/Units/#per_second","text":"public static const define Str per_second","title":"per_second"},{"location":"api/sys/Units/#percent","text":"public static const define Str percent","title":"percent"},{"location":"api/sys/Units/#percent_obscuration_per_foot","text":"public static const define Str percent_obscuration_per_foot","title":"percent_obscuration_per_foot"},{"location":"api/sys/Units/#percent_obscuration_per_meter","text":"public static const define Str percent_obscuration_per_meter","title":"percent_obscuration_per_meter"},{"location":"api/sys/Units/#percent_per_second","text":"public static const define Str percent_per_second","title":"percent_per_second"},{"location":"api/sys/Units/#percent_relative_humidity","text":"public static const define Str percent_relative_humidity","title":"percent_relative_humidity"},{"location":"api/sys/Units/#peseta","text":"public static const define Str peseta","title":"peseta"},{"location":"api/sys/Units/#pint","text":"public static const define Str pint","title":"pint"},{"location":"api/sys/Units/#pound","text":"public static const define Str pound","title":"pound"},{"location":"api/sys/Units/#pound_force","text":"public static const define Str pound_force","title":"pound_force"},{"location":"api/sys/Units/#pounds","text":"public static const define Str pounds","title":"pounds"},{"location":"api/sys/Units/#pounds_per_hour","text":"public static const define Str pounds_per_hour","title":"pounds_per_hour"},{"location":"api/sys/Units/#pounds_per_minute","text":"public static const define Str pounds_per_minute","title":"pounds_per_minute"},{"location":"api/sys/Units/#pounds_per_second","text":"public static const define Str pounds_per_second","title":"pounds_per_second"},{"location":"api/sys/Units/#pounds_per_square_inch","text":"public static const define Str pounds_per_square_inch","title":"pounds_per_square_inch"},{"location":"api/sys/Units/#power_factor","text":"public static const define Str power_factor","title":"power_factor"},{"location":"api/sys/Units/#psi_per_degree_fahrenheit","text":"public static const define Str psi_per_degree_fahrenheit","title":"psi_per_degree_fahrenheit"},{"location":"api/sys/Units/#quart","text":"public static const define Str quart","title":"quart"},{"location":"api/sys/Units/#radian","text":"public static const define Str radian","title":"radian"},{"location":"api/sys/Units/#radians_per_second","text":"public static const define Str radians_per_second","title":"radians_per_second"},{"location":"api/sys/Units/#radians_per_second_squared","text":"public static const define Str radians_per_second_squared","title":"radians_per_second_squared"},{"location":"api/sys/Units/#revolutions_per_minute","text":"public static const define Str revolutions_per_minute","title":"revolutions_per_minute"},{"location":"api/sys/Units/#rupee","text":"public static const define Str rupee","title":"rupee"},{"location":"api/sys/Units/#second","text":"public static const define Str second","title":"second"},{"location":"api/sys/Units/#short_ton","text":"public static const define Str short_ton","title":"short_ton"},{"location":"api/sys/Units/#siemens","text":"public static const define Str siemens","title":"siemens"},{"location":"api/sys/Units/#siemens_per_meter","text":"public static const define Str siemens_per_meter","title":"siemens_per_meter"},{"location":"api/sys/Units/#square_centimeter","text":"public static const define Str square_centimeter","title":"square_centimeter"},{"location":"api/sys/Units/#square_foot","text":"public static const define Str square_foot","title":"square_foot"},{"location":"api/sys/Units/#square_inch","text":"public static const define Str square_inch","title":"square_inch"},{"location":"api/sys/Units/#square_kilometer","text":"public static const define Str square_kilometer","title":"square_kilometer"},{"location":"api/sys/Units/#square_meter","text":"public static const define Str square_meter","title":"square_meter"},{"location":"api/sys/Units/#square_meters_per_newton","text":"public static const define Str square_meters_per_newton","title":"square_meters_per_newton"},{"location":"api/sys/Units/#square_mile","text":"public static const define Str square_mile","title":"square_mile"},{"location":"api/sys/Units/#square_millimeter","text":"public static const define Str square_millimeter","title":"square_millimeter"},{"location":"api/sys/Units/#square_yard","text":"public static const define Str square_yard","title":"square_yard"},{"location":"api/sys/Units/#steradian","text":"public static const define Str steradian","title":"steradian"},{"location":"api/sys/Units/#tenths_second","text":"public static const define Str tenths_second","title":"tenths_second"},{"location":"api/sys/Units/#tesla","text":"public static const define Str tesla","title":"tesla"},{"location":"api/sys/Units/#therm","text":"public static const define Str therm","title":"therm"},{"location":"api/sys/Units/#tons_refrigeration","text":"public static const define Str tons_refrigeration","title":"tons_refrigeration"},{"location":"api/sys/Units/#tons_refrigeration_hour","text":"public static const define Str tons_refrigeration_hour","title":"tons_refrigeration_hour"},{"location":"api/sys/Units/#torr","text":"public static const define Str torr","title":"torr"},{"location":"api/sys/Units/#volt","text":"public static const define Str volt","title":"volt"},{"location":"api/sys/Units/#volt_ampere","text":"public static const define Str volt_ampere","title":"volt_ampere"},{"location":"api/sys/Units/#volt_ampere_hour","text":"public static const define Str volt_ampere_hour","title":"volt_ampere_hour"},{"location":"api/sys/Units/#volt_ampere_reactive","text":"public static const define Str volt_ampere_reactive","title":"volt_ampere_reactive"},{"location":"api/sys/Units/#volt_ampere_reactive_hour","text":"public static const define Str volt_ampere_reactive_hour","title":"volt_ampere_reactive_hour"},{"location":"api/sys/Units/#volts_per_degree_kelvin","text":"public static const define Str volts_per_degree_kelvin","title":"volts_per_degree_kelvin"},{"location":"api/sys/Units/#volts_per_meter","text":"public static const define Str volts_per_meter","title":"volts_per_meter"},{"location":"api/sys/Units/#watt","text":"public static const define Str watt","title":"watt"},{"location":"api/sys/Units/#watt_hour","text":"public static const define Str watt_hour","title":"watt_hour"},{"location":"api/sys/Units/#watts_per_meter_degree_kelvin","text":"public static const define Str watts_per_meter_degree_kelvin","title":"watts_per_meter_degree_kelvin"},{"location":"api/sys/Units/#watts_per_square_foot","text":"public static const define Str watts_per_square_foot","title":"watts_per_square_foot"},{"location":"api/sys/Units/#watts_per_square_meter","text":"public static const define Str watts_per_square_meter","title":"watts_per_square_meter"},{"location":"api/sys/Units/#watts_per_square_meter_degree_kelvin","text":"public static const define Str watts_per_square_meter_degree_kelvin","title":"watts_per_square_meter_degree_kelvin"},{"location":"api/sys/Units/#weber","text":"public static const define Str weber","title":"weber"},{"location":"api/sys/Units/#week","text":"public static const define Str week","title":"week"},{"location":"api/sys/Units/#won","text":"public static const define Str won","title":"won"},{"location":"api/sys/Units/#yard","text":"public static const define Str yard","title":"yard"},{"location":"api/sys/Units/#year","text":"public static const define Str year","title":"year"},{"location":"api/sys/Units/#yen","text":"public static const define Str yen Doc Home > API Index > sys > Units","title":"yen"},{"location":"api/sys/User/","text":"User \u00b6 Doc Home > API Index > sys > User Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::User public class User [niagaraIcon=\"module://icons/x16/user.png\"] User models a user account used for network authentication and authorization. Users are stored as children of the UserService. The user name is the component's name (limited to 7 chars). Fields \u00b6 ai \u00b6 public static const define int ai ar \u00b6 public static const define int ar aw \u00b6 public static const define int aw cred \u00b6 public inline property Buf cred [config, max=20] This is the credentials 160 bit SHA-1 digest of the UTF-8 string \"username:password\". oi \u00b6 public static const define int oi or \u00b6 public static const define int or ow \u00b6 public static const define int ow perm \u00b6 public property int perm [config] Permissions mask which grant this user specific permissions in the four security groups. Each byte in the permission mask is a bitmask of the 7 permissions for groups 0 to 3. prov \u00b6 public property byte prov [config] Permissions mask for provisioning. provApp \u00b6 public static const define int provApp provKits \u00b6 public static const define int provKits provSvm \u00b6 public static const define int provSvm ua \u00b6 public static const define int ua Methods \u00b6 canProv \u00b6 public bool canProv( Str uri) Can this user provisiong (read/write) the specified file. has \u00b6 public bool has( Component c, int hasPerm) Return if this user has the specified permission on the given component. permFor \u00b6 public int permFor( Component c) Return the permissions available . Doc Home > API Index > sys > User","title":"User"},{"location":"api/sys/User/#user","text":"Doc Home > API Index > sys > User","title":"User"},{"location":"api/sys/User/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::User public class User [niagaraIcon=\"module://icons/x16/user.png\"] User models a user account used for network authentication and authorization. Users are stored as children of the UserService. The user name is the component's name (limited to 7 chars).","title":"Inheritance"},{"location":"api/sys/User/#fields","text":"","title":"Fields"},{"location":"api/sys/User/#ai","text":"public static const define int ai","title":"ai"},{"location":"api/sys/User/#ar","text":"public static const define int ar","title":"ar"},{"location":"api/sys/User/#aw","text":"public static const define int aw","title":"aw"},{"location":"api/sys/User/#cred","text":"public inline property Buf cred [config, max=20] This is the credentials 160 bit SHA-1 digest of the UTF-8 string \"username:password\".","title":"cred"},{"location":"api/sys/User/#oi","text":"public static const define int oi","title":"oi"},{"location":"api/sys/User/#or","text":"public static const define int or","title":"or"},{"location":"api/sys/User/#ow","text":"public static const define int ow","title":"ow"},{"location":"api/sys/User/#perm","text":"public property int perm [config] Permissions mask which grant this user specific permissions in the four security groups. Each byte in the permission mask is a bitmask of the 7 permissions for groups 0 to 3.","title":"perm"},{"location":"api/sys/User/#prov","text":"public property byte prov [config] Permissions mask for provisioning.","title":"prov"},{"location":"api/sys/User/#provapp","text":"public static const define int provApp","title":"provApp"},{"location":"api/sys/User/#provkits","text":"public static const define int provKits","title":"provKits"},{"location":"api/sys/User/#provsvm","text":"public static const define int provSvm","title":"provSvm"},{"location":"api/sys/User/#ua","text":"public static const define int ua","title":"ua"},{"location":"api/sys/User/#methods","text":"","title":"Methods"},{"location":"api/sys/User/#canprov","text":"public bool canProv( Str uri) Can this user provisiong (read/write) the specified file.","title":"canProv"},{"location":"api/sys/User/#has","text":"public bool has( Component c, int hasPerm) Return if this user has the specified permission on the given component.","title":"has"},{"location":"api/sys/User/#permfor","text":"public int permFor( Component c) Return the permissions available . Doc Home > API Index > sys > User","title":"permFor"},{"location":"api/sys/UserService/","text":"UserService \u00b6 Doc Home > API Index > sys > UserService Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::Service sys::UserService public class UserService [niagaraIcon=\"module://icons/x16/user.png\"] UserService stores the list of users as child components. Doc Home > API Index > sys > UserService","title":"UserService"},{"location":"api/sys/UserService/#userservice","text":"Doc Home > API Index > sys > UserService","title":"UserService"},{"location":"api/sys/UserService/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::Service sys::UserService public class UserService [niagaraIcon=\"module://icons/x16/user.png\"] UserService stores the list of users as child components. Doc Home > API Index > sys > UserService","title":"Inheritance"},{"location":"api/sys/Virtual/","text":"Virtual \u00b6 Doc Home > API Index > sys > Virtual Inheritance \u00b6 sys::Obj sys::Virtual public abstract class Virtual Virtual is the base class for all classes which support virtual methods. Doc Home > API Index > sys > Virtual","title":"Virtual"},{"location":"api/sys/Virtual/#virtual","text":"Doc Home > API Index > sys > Virtual","title":"Virtual"},{"location":"api/sys/Virtual/#inheritance","text":"sys::Obj sys::Virtual public abstract class Virtual Virtual is the base class for all classes which support virtual methods. Doc Home > API Index > sys > Virtual","title":"Inheritance"},{"location":"api/sys/Watch/","text":"Watch \u00b6 Doc Home > API Index > sys > Watch Inheritance \u00b6 sys::Obj sys::Virtual sys::Watch public abstract class Watch Watch is used to manage an event queue of component changes. Every component is allocated a byte per potential watch determined by the Watch.max define. To use the watch framework: - Create your own subclass of Watch - In your service create an array of your Watch subclass - Call App.initWatches() on service startup with your subclass array - To allocate a watch call App.openWatch() passing in the array of your subclasses - When you close a watch, make sure you call App.closeWatch() Fields \u00b6 closed \u00b6 public bool closed Is this watch open or closed eventAll \u00b6 public static const define int eventAll Watch bitmask for all change event bits eventConfig \u00b6 public static const define int eventConfig Watch bitmask indicating a pending config property change event eventLinks \u00b6 public static const define int eventLinks Watch bitmask indicating a pending link change event eventRuntime \u00b6 public static const define int eventRuntime Watch bitmask indicating a pending runtime property change event eventTree \u00b6 public static const define int eventTree Watch bitmask indicating a pending tree change event index \u00b6 public byte index Bottom byte of the id is the index into App.watches max \u00b6 public static const define int max Number of concurrent watches to support rand \u00b6 public byte rand The top byte of the id is randomized to prevent id collisions subAll \u00b6 public static const define int subAll Watch bitmask for all subscription bits subConfig \u00b6 public static const define int subConfig Watch bitmask indicating a subscription to config property changes subLinks \u00b6 public static const define int subLinks Watch bitmask indicating a subscription to link changes subRuntime \u00b6 public static const define int subRuntime Watch bitmask indicating a subscription to runtime property changes subTree \u00b6 public static const define int subTree Watch bitmask indicating a subscription to tree changes Methods \u00b6 fromSubBit \u00b6 public static int fromSubBit(int subBit) Map a subscription bit to its ASCII code. id \u00b6 public int id() The watch id is a combination of the count in the high byte and the index in the low byte. toEventBit \u00b6 public static int toEventBit(int what) Map ASCII codes to event bit: 't' = eventTree 'c' = eventConfig 'r' = eventRuntime 'l' = eventLink '*' = eventAll toSubBit \u00b6 public static int toSubBit(int what) Map ASCII codes to subscription bit: 't' = subTree 'c' = subConfig 'r' = subRuntime 'l' = subLink '*' = subAll Doc Home > API Index > sys > Watch","title":"Watch"},{"location":"api/sys/Watch/#watch","text":"Doc Home > API Index > sys > Watch","title":"Watch"},{"location":"api/sys/Watch/#inheritance","text":"sys::Obj sys::Virtual sys::Watch public abstract class Watch Watch is used to manage an event queue of component changes. Every component is allocated a byte per potential watch determined by the Watch.max define. To use the watch framework: - Create your own subclass of Watch - In your service create an array of your Watch subclass - Call App.initWatches() on service startup with your subclass array - To allocate a watch call App.openWatch() passing in the array of your subclasses - When you close a watch, make sure you call App.closeWatch()","title":"Inheritance"},{"location":"api/sys/Watch/#fields","text":"","title":"Fields"},{"location":"api/sys/Watch/#closed","text":"public bool closed Is this watch open or closed","title":"closed"},{"location":"api/sys/Watch/#eventall","text":"public static const define int eventAll Watch bitmask for all change event bits","title":"eventAll"},{"location":"api/sys/Watch/#eventconfig","text":"public static const define int eventConfig Watch bitmask indicating a pending config property change event","title":"eventConfig"},{"location":"api/sys/Watch/#eventlinks","text":"public static const define int eventLinks Watch bitmask indicating a pending link change event","title":"eventLinks"},{"location":"api/sys/Watch/#eventruntime","text":"public static const define int eventRuntime Watch bitmask indicating a pending runtime property change event","title":"eventRuntime"},{"location":"api/sys/Watch/#eventtree","text":"public static const define int eventTree Watch bitmask indicating a pending tree change event","title":"eventTree"},{"location":"api/sys/Watch/#index","text":"public byte index Bottom byte of the id is the index into App.watches","title":"index"},{"location":"api/sys/Watch/#max","text":"public static const define int max Number of concurrent watches to support","title":"max"},{"location":"api/sys/Watch/#rand","text":"public byte rand The top byte of the id is randomized to prevent id collisions","title":"rand"},{"location":"api/sys/Watch/#suball","text":"public static const define int subAll Watch bitmask for all subscription bits","title":"subAll"},{"location":"api/sys/Watch/#subconfig","text":"public static const define int subConfig Watch bitmask indicating a subscription to config property changes","title":"subConfig"},{"location":"api/sys/Watch/#sublinks","text":"public static const define int subLinks Watch bitmask indicating a subscription to link changes","title":"subLinks"},{"location":"api/sys/Watch/#subruntime","text":"public static const define int subRuntime Watch bitmask indicating a subscription to runtime property changes","title":"subRuntime"},{"location":"api/sys/Watch/#subtree","text":"public static const define int subTree Watch bitmask indicating a subscription to tree changes","title":"subTree"},{"location":"api/sys/Watch/#methods","text":"","title":"Methods"},{"location":"api/sys/Watch/#fromsubbit","text":"public static int fromSubBit(int subBit) Map a subscription bit to its ASCII code.","title":"fromSubBit"},{"location":"api/sys/Watch/#id","text":"public int id() The watch id is a combination of the count in the high byte and the index in the low byte.","title":"id"},{"location":"api/sys/Watch/#toeventbit","text":"public static int toEventBit(int what) Map ASCII codes to event bit: 't' = eventTree 'c' = eventConfig 'r' = eventRuntime 'l' = eventLink '*' = eventAll","title":"toEventBit"},{"location":"api/sys/Watch/#tosubbit","text":"public static int toSubBit(int what) Map ASCII codes to subscription bit: 't' = subTree 'c' = subConfig 'r' = subRuntime 'l' = subLink '*' = subAll Doc Home > API Index > sys > Watch","title":"toSubBit"},{"location":"api/timing/","text":"timing \u00b6 Doc Home > API Index > timing Timing function block library DlyOff \u00b6 DlyOn \u00b6 OneShot \u00b6 Timer \u00b6 Doc Home > API Index > timing","title":"Index"},{"location":"api/timing/#timing","text":"Doc Home > API Index > timing Timing function block library","title":"timing"},{"location":"api/timing/#dlyoff","text":"","title":"DlyOff"},{"location":"api/timing/#dlyon","text":"","title":"DlyOn"},{"location":"api/timing/#oneshot","text":"","title":"OneShot"},{"location":"api/timing/#timer","text":"Doc Home > API Index > timing","title":"Timer"},{"location":"api/timing/DlyOff/","text":"DlyOff \u00b6 Doc Home > API Index > timing > DlyOff Inheritance \u00b6 sys::Obj sys::Virtual sys::Component timing::DlyOff public class DlyOff [niagaraIcon=\"module://icons/x16/control/control.png\"] DlyOff Delay Off object Delays the on to off transition by a time delay Fields \u00b6 delayTime \u00b6 public property float delayTime [summary, unit=\"second\", config] Specified hold time in sec hold \u00b6 public property int hold [unit=\"millisecond\", readonly] Remaining hold time in msec in \u00b6 public property bool in Input signal out \u00b6 public property bool out [readonly] Output signal Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > timing > DlyOff","title":"DlyOff"},{"location":"api/timing/DlyOff/#dlyoff","text":"Doc Home > API Index > timing > DlyOff","title":"DlyOff"},{"location":"api/timing/DlyOff/#inheritance","text":"sys::Obj sys::Virtual sys::Component timing::DlyOff public class DlyOff [niagaraIcon=\"module://icons/x16/control/control.png\"] DlyOff Delay Off object Delays the on to off transition by a time delay","title":"Inheritance"},{"location":"api/timing/DlyOff/#fields","text":"","title":"Fields"},{"location":"api/timing/DlyOff/#delaytime","text":"public property float delayTime [summary, unit=\"second\", config] Specified hold time in sec","title":"delayTime"},{"location":"api/timing/DlyOff/#hold","text":"public property int hold [unit=\"millisecond\", readonly] Remaining hold time in msec","title":"hold"},{"location":"api/timing/DlyOff/#in","text":"public property bool in Input signal","title":"in"},{"location":"api/timing/DlyOff/#out","text":"public property bool out [readonly] Output signal","title":"out"},{"location":"api/timing/DlyOff/#methods","text":"","title":"Methods"},{"location":"api/timing/DlyOff/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/timing/DlyOff/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > timing > DlyOff","title":"start"},{"location":"api/timing/DlyOn/","text":"DlyOn \u00b6 Doc Home > API Index > timing > DlyOn Inheritance \u00b6 sys::Obj sys::Virtual sys::Component timing::DlyOn public class DlyOn [niagaraIcon=\"module://icons/x16/control/control.png\"] DlyOn Delay On object Delays the off to on transition by a time delay Fields \u00b6 delayTime \u00b6 public property float delayTime [summary, unit=\"second\", config] Specified hold time in sec hold \u00b6 public property int hold [unit=\"millisecond\", readonly] Remaining hold time in msec in \u00b6 public property bool in Input signal out \u00b6 public property bool out [readonly] Output signal Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > timing > DlyOn","title":"DlyOn"},{"location":"api/timing/DlyOn/#dlyon","text":"Doc Home > API Index > timing > DlyOn","title":"DlyOn"},{"location":"api/timing/DlyOn/#inheritance","text":"sys::Obj sys::Virtual sys::Component timing::DlyOn public class DlyOn [niagaraIcon=\"module://icons/x16/control/control.png\"] DlyOn Delay On object Delays the off to on transition by a time delay","title":"Inheritance"},{"location":"api/timing/DlyOn/#fields","text":"","title":"Fields"},{"location":"api/timing/DlyOn/#delaytime","text":"public property float delayTime [summary, unit=\"second\", config] Specified hold time in sec","title":"delayTime"},{"location":"api/timing/DlyOn/#hold","text":"public property int hold [unit=\"millisecond\", readonly] Remaining hold time in msec","title":"hold"},{"location":"api/timing/DlyOn/#in","text":"public property bool in Input signal","title":"in"},{"location":"api/timing/DlyOn/#out","text":"public property bool out [readonly] Output signal","title":"out"},{"location":"api/timing/DlyOn/#methods","text":"","title":"Methods"},{"location":"api/timing/DlyOn/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/timing/DlyOn/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > timing > DlyOn","title":"start"},{"location":"api/timing/OneShot/","text":"OneShot \u00b6 Doc Home > API Index > timing > OneShot Inheritance \u00b6 sys::Obj sys::Virtual sys::Component timing::OneShot public class OneShot [niagaraIcon=\"module://icons/x16/control/control.png\"] OneShot: Boolean one-shot pulse generator out = true for pulseWidth sec, beginning at rising edge of in pulse retriggers on each rising edge of in, if canRetrig = true Fields \u00b6 canRetrig \u00b6 public property bool canRetrig [config] If true, subsequent edges on input will restart pulse width measurement (resulting in wider overall output pulse) in \u00b6 public property bool in Input signal out \u00b6 public property bool out [readonly] Output signal pulseWidth \u00b6 public property float pulseWidth [unit=\"second\", min=0, config] Width of desired output pulse, in seconds Methods \u00b6 clear \u00b6 public action void clear() Clears the output immediately, cancelling any pulse in progress execute \u00b6 public virtual override void execute() Execute is called once every scan. start \u00b6 public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > timing > OneShot","title":"OneShot"},{"location":"api/timing/OneShot/#oneshot","text":"Doc Home > API Index > timing > OneShot","title":"OneShot"},{"location":"api/timing/OneShot/#inheritance","text":"sys::Obj sys::Virtual sys::Component timing::OneShot public class OneShot [niagaraIcon=\"module://icons/x16/control/control.png\"] OneShot: Boolean one-shot pulse generator out = true for pulseWidth sec, beginning at rising edge of in pulse retriggers on each rising edge of in, if canRetrig = true","title":"Inheritance"},{"location":"api/timing/OneShot/#fields","text":"","title":"Fields"},{"location":"api/timing/OneShot/#canretrig","text":"public property bool canRetrig [config] If true, subsequent edges on input will restart pulse width measurement (resulting in wider overall output pulse)","title":"canRetrig"},{"location":"api/timing/OneShot/#in","text":"public property bool in Input signal","title":"in"},{"location":"api/timing/OneShot/#out","text":"public property bool out [readonly] Output signal","title":"out"},{"location":"api/timing/OneShot/#pulsewidth","text":"public property float pulseWidth [unit=\"second\", min=0, config] Width of desired output pulse, in seconds","title":"pulseWidth"},{"location":"api/timing/OneShot/#methods","text":"","title":"Methods"},{"location":"api/timing/OneShot/#clear","text":"public action void clear() Clears the output immediately, cancelling any pulse in progress","title":"clear"},{"location":"api/timing/OneShot/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/timing/OneShot/#start","text":"public virtual override void start() Callback when component is first started in an app. Doc Home > API Index > timing > OneShot","title":"start"},{"location":"api/timing/Timer/","text":"Timer \u00b6 Doc Home > API Index > timing > Timer Inheritance \u00b6 sys::Obj sys::Virtual sys::Component timing::Timer public class Timer [niagaraIcon=\"module://icons/x16/clock.png\"] Timer outputs a pulse for the configured amount of time \"in\" is used to fire the timer: - if low, out is forced to false - if high, out = 1 until timer reaches \"time\" seconds Alternatively, the pulse can be fired from the \"Start Timer\" action if run is not linked. Fields \u00b6 left \u00b6 public property int left [summary, unit=\"second\", readonly] Time left on the timer if running, in seconds If not running, this value is 0 out \u00b6 public property bool out [readonly] The timed output pulse run \u00b6 public property bool run [falseText=\"stop\", trueText=\"run\"] Used to fire the timer on transition from false -> true time \u00b6 public property int time [summary, unit=\"second\", config] Desired duration of the output pulse, in seconds Methods \u00b6 changed \u00b6 public virtual override void changed( Slot slot) override changed to recompute ms length of the timer if the time changes execute \u00b6 public virtual override void execute() Execute is called once every scan. resetTimer \u00b6 public action void resetTimer() Action to reset the timer. Any time already in progress is immediately canceled, and the \"left\" is set to 0 sec start \u00b6 public virtual override void start() start computes the ms length of the timer startTimer \u00b6 public action void startTimer() Used to manually start the timer in cases where there is no link to \"in\" property Issuing this command while the timer is already active will reset/restart the timer Doc Home > API Index > timing > Timer","title":"Timer"},{"location":"api/timing/Timer/#timer","text":"Doc Home > API Index > timing > Timer","title":"Timer"},{"location":"api/timing/Timer/#inheritance","text":"sys::Obj sys::Virtual sys::Component timing::Timer public class Timer [niagaraIcon=\"module://icons/x16/clock.png\"] Timer outputs a pulse for the configured amount of time \"in\" is used to fire the timer: - if low, out is forced to false - if high, out = 1 until timer reaches \"time\" seconds Alternatively, the pulse can be fired from the \"Start Timer\" action if run is not linked.","title":"Inheritance"},{"location":"api/timing/Timer/#fields","text":"","title":"Fields"},{"location":"api/timing/Timer/#left","text":"public property int left [summary, unit=\"second\", readonly] Time left on the timer if running, in seconds If not running, this value is 0","title":"left"},{"location":"api/timing/Timer/#out","text":"public property bool out [readonly] The timed output pulse","title":"out"},{"location":"api/timing/Timer/#run","text":"public property bool run [falseText=\"stop\", trueText=\"run\"] Used to fire the timer on transition from false -> true","title":"run"},{"location":"api/timing/Timer/#time","text":"public property int time [summary, unit=\"second\", config] Desired duration of the output pulse, in seconds","title":"time"},{"location":"api/timing/Timer/#methods","text":"","title":"Methods"},{"location":"api/timing/Timer/#changed","text":"public virtual override void changed( Slot slot) override changed to recompute ms length of the timer if the time changes","title":"changed"},{"location":"api/timing/Timer/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/timing/Timer/#resettimer","text":"public action void resetTimer() Action to reset the timer. Any time already in progress is immediately canceled, and the \"left\" is set to 0 sec","title":"resetTimer"},{"location":"api/timing/Timer/#start","text":"public virtual override void start() start computes the ms length of the timer","title":"start"},{"location":"api/timing/Timer/#starttimer","text":"public action void startTimer() Used to manually start the timer in cases where there is no link to \"in\" property Issuing this command while the timer is already active will reset/restart the timer Doc Home > API Index > timing > Timer","title":"startTimer"},{"location":"api/types/","text":"types \u00b6 Doc Home > API Index > types Basic types and constants B2F \u00b6 ConstBool \u00b6 ConstFloat \u00b6 ConstInt \u00b6 F2B \u00b6 F2I \u00b6 I2F \u00b6 L2F \u00b6 WriteBool \u00b6 WriteFloat \u00b6 WriteInt \u00b6 Doc Home > API Index > types","title":"Index"},{"location":"api/types/#types","text":"Doc Home > API Index > types Basic types and constants","title":"types"},{"location":"api/types/#b2f","text":"","title":"B2F"},{"location":"api/types/#constbool","text":"","title":"ConstBool"},{"location":"api/types/#constfloat","text":"","title":"ConstFloat"},{"location":"api/types/#constint","text":"","title":"ConstInt"},{"location":"api/types/#f2b","text":"","title":"F2B"},{"location":"api/types/#f2i","text":"","title":"F2I"},{"location":"api/types/#i2f","text":"","title":"I2F"},{"location":"api/types/#l2f","text":"","title":"L2F"},{"location":"api/types/#writebool","text":"","title":"WriteBool"},{"location":"api/types/#writefloat","text":"","title":"WriteFloat"},{"location":"api/types/#writeint","text":"Doc Home > API Index > types","title":"WriteInt"},{"location":"api/types/B2F/","text":"B2F \u00b6 Doc Home > API Index > types > B2F Inheritance \u00b6 sys::Obj sys::Virtual sys::Component types::B2F public class B2F [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] B2F 16 bit binary to float encoder object out = encoded value of inputs, with in16 the MSB and in1 as the LSB. count = sum of the inputs that are active. Fields \u00b6 count \u00b6 public property float count [readonly] count = sum of the inputs that are active. in1 \u00b6 public property bool in1 in1 in10 \u00b6 public property bool in10 in10 in11 \u00b6 public property bool in11 in11 in12 \u00b6 public property bool in12 in12 in13 \u00b6 public property bool in13 in13 in14 \u00b6 public property bool in14 in14 in15 \u00b6 public property bool in15 in15 in16 \u00b6 public property bool in16 in16 in2 \u00b6 public property bool in2 in2 in3 \u00b6 public property bool in3 in3 in4 \u00b6 public property bool in4 in4 in5 \u00b6 public property bool in5 in5 in6 \u00b6 public property bool in6 in6 in7 \u00b6 public property bool in7 in7 in8 \u00b6 public property bool in8 in8 in9 \u00b6 public property bool in9 in9 out \u00b6 public property float out [readonly] out = encoded value of inputs, with in16 the MSB and in1 as the LSB. Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > types > B2F","title":"B2F"},{"location":"api/types/B2F/#b2f","text":"Doc Home > API Index > types > B2F","title":"B2F"},{"location":"api/types/B2F/#inheritance","text":"sys::Obj sys::Virtual sys::Component types::B2F public class B2F [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] B2F 16 bit binary to float encoder object out = encoded value of inputs, with in16 the MSB and in1 as the LSB. count = sum of the inputs that are active.","title":"Inheritance"},{"location":"api/types/B2F/#fields","text":"","title":"Fields"},{"location":"api/types/B2F/#count","text":"public property float count [readonly] count = sum of the inputs that are active.","title":"count"},{"location":"api/types/B2F/#in1","text":"public property bool in1 in1","title":"in1"},{"location":"api/types/B2F/#in10","text":"public property bool in10 in10","title":"in10"},{"location":"api/types/B2F/#in11","text":"public property bool in11 in11","title":"in11"},{"location":"api/types/B2F/#in12","text":"public property bool in12 in12","title":"in12"},{"location":"api/types/B2F/#in13","text":"public property bool in13 in13","title":"in13"},{"location":"api/types/B2F/#in14","text":"public property bool in14 in14","title":"in14"},{"location":"api/types/B2F/#in15","text":"public property bool in15 in15","title":"in15"},{"location":"api/types/B2F/#in16","text":"public property bool in16 in16","title":"in16"},{"location":"api/types/B2F/#in2","text":"public property bool in2 in2","title":"in2"},{"location":"api/types/B2F/#in3","text":"public property bool in3 in3","title":"in3"},{"location":"api/types/B2F/#in4","text":"public property bool in4 in4","title":"in4"},{"location":"api/types/B2F/#in5","text":"public property bool in5 in5","title":"in5"},{"location":"api/types/B2F/#in6","text":"public property bool in6 in6","title":"in6"},{"location":"api/types/B2F/#in7","text":"public property bool in7 in7","title":"in7"},{"location":"api/types/B2F/#in8","text":"public property bool in8 in8","title":"in8"},{"location":"api/types/B2F/#in9","text":"public property bool in9 in9","title":"in9"},{"location":"api/types/B2F/#out","text":"public property float out [readonly] out = encoded value of inputs, with in16 the MSB and in1 as the LSB.","title":"out"},{"location":"api/types/B2F/#methods","text":"","title":"Methods"},{"location":"api/types/B2F/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > types > B2F","title":"execute"},{"location":"api/types/ConstBool/","text":"ConstBool \u00b6 Doc Home > API Index > types > ConstBool Inheritance \u00b6 sys::Obj sys::Virtual sys::Component types::ConstBool public class ConstBool [niagaraIcon=\"module://icons/x16/control/booleanPoint.png\"] ConstBool: boolean constant out should never be a link destination. Fields \u00b6 out \u00b6 public property bool out [summary, config] out value is set by actions Methods \u00b6 setFalse \u00b6 public action void setFalse() action to set out to false setNull \u00b6 public action void setNull() action to set out to null setTrue \u00b6 public action void setTrue() action to set out to true Doc Home > API Index > types > ConstBool","title":"ConstBool"},{"location":"api/types/ConstBool/#constbool","text":"Doc Home > API Index > types > ConstBool","title":"ConstBool"},{"location":"api/types/ConstBool/#inheritance","text":"sys::Obj sys::Virtual sys::Component types::ConstBool public class ConstBool [niagaraIcon=\"module://icons/x16/control/booleanPoint.png\"] ConstBool: boolean constant out should never be a link destination.","title":"Inheritance"},{"location":"api/types/ConstBool/#fields","text":"","title":"Fields"},{"location":"api/types/ConstBool/#out","text":"public property bool out [summary, config] out value is set by actions","title":"out"},{"location":"api/types/ConstBool/#methods","text":"","title":"Methods"},{"location":"api/types/ConstBool/#setfalse","text":"public action void setFalse() action to set out to false","title":"setFalse"},{"location":"api/types/ConstBool/#setnull","text":"public action void setNull() action to set out to null","title":"setNull"},{"location":"api/types/ConstBool/#settrue","text":"public action void setTrue() action to set out to true Doc Home > API Index > types > ConstBool","title":"setTrue"},{"location":"api/types/ConstFloat/","text":"ConstFloat \u00b6 Doc Home > API Index > types > ConstFloat Inheritance \u00b6 sys::Obj sys::Virtual sys::Component types::ConstFloat public class ConstFloat [niagaraIcon=\"module://icons/x16/control/numericPoint.png\"] ConstFloat: float constant out should never be a link destination. Fields \u00b6 out \u00b6 public property float out [summary, config] out value is set by actions Methods \u00b6 set \u00b6 public action void set(float x) action to set out value setNull \u00b6 public action void setNull() action to set out to null Doc Home > API Index > types > ConstFloat","title":"ConstFloat"},{"location":"api/types/ConstFloat/#constfloat","text":"Doc Home > API Index > types > ConstFloat","title":"ConstFloat"},{"location":"api/types/ConstFloat/#inheritance","text":"sys::Obj sys::Virtual sys::Component types::ConstFloat public class ConstFloat [niagaraIcon=\"module://icons/x16/control/numericPoint.png\"] ConstFloat: float constant out should never be a link destination.","title":"Inheritance"},{"location":"api/types/ConstFloat/#fields","text":"","title":"Fields"},{"location":"api/types/ConstFloat/#out","text":"public property float out [summary, config] out value is set by actions","title":"out"},{"location":"api/types/ConstFloat/#methods","text":"","title":"Methods"},{"location":"api/types/ConstFloat/#set","text":"public action void set(float x) action to set out value","title":"set"},{"location":"api/types/ConstFloat/#setnull","text":"public action void setNull() action to set out to null Doc Home > API Index > types > ConstFloat","title":"setNull"},{"location":"api/types/ConstInt/","text":"ConstInt \u00b6 Doc Home > API Index > types > ConstInt Inheritance \u00b6 sys::Obj sys::Virtual sys::Component types::ConstInt public class ConstInt [niagaraIcon=\"module://icons/x16/control/enumPoint.png\"] ConstInt: int constant out should never be a link destination. Fields \u00b6 out \u00b6 public property int out [summary, config] out value is set by actions Methods \u00b6 set \u00b6 public action void set(int x) action to set out value Doc Home > API Index > types > ConstInt","title":"ConstInt"},{"location":"api/types/ConstInt/#constint","text":"Doc Home > API Index > types > ConstInt","title":"ConstInt"},{"location":"api/types/ConstInt/#inheritance","text":"sys::Obj sys::Virtual sys::Component types::ConstInt public class ConstInt [niagaraIcon=\"module://icons/x16/control/enumPoint.png\"] ConstInt: int constant out should never be a link destination.","title":"Inheritance"},{"location":"api/types/ConstInt/#fields","text":"","title":"Fields"},{"location":"api/types/ConstInt/#out","text":"public property int out [summary, config] out value is set by actions","title":"out"},{"location":"api/types/ConstInt/#methods","text":"","title":"Methods"},{"location":"api/types/ConstInt/#set","text":"public action void set(int x) action to set out value Doc Home > API Index > types > ConstInt","title":"set"},{"location":"api/types/F2B/","text":"F2B \u00b6 Doc Home > API Index > types > F2B Inheritance \u00b6 sys::Obj sys::Virtual sys::Component types::F2B public class F2B [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] F2b float 16 bit decoder object The input float is cast to an int, which is then decoded to 16 bools of output out1 to out16 = decode with out1 = LSB and out16 = MSB ovrf is set if in > 65535 Fields \u00b6 in \u00b6 public property float in input value to be decoded out1 \u00b6 public property bool out1 [readonly] out1 is set if bit 0 (LSB) is set out10 \u00b6 public property bool out10 [readonly] out2 is set if bit 9 is set out11 \u00b6 public property bool out11 [readonly] out2 is set if bit 10 is set out12 \u00b6 public property bool out12 [readonly] out2 is set if bit 11 is set out13 \u00b6 public property bool out13 [readonly] out2 is set if bit 12 is set out14 \u00b6 public property bool out14 [readonly] out2 is set if bit 13 is set out15 \u00b6 public property bool out15 [readonly] out2 is set if bit 14 is set out16 \u00b6 public property bool out16 [readonly] out2 is set if bit 15 (MSB) is set out2 \u00b6 public property bool out2 [readonly] out2 is set if bit 1 is set out3 \u00b6 public property bool out3 [readonly] out2 is set if bit 2 is set out4 \u00b6 public property bool out4 [readonly] out2 is set if bit 3 is set out5 \u00b6 public property bool out5 [readonly] out2 is set if bit 4 is set out6 \u00b6 public property bool out6 [readonly] out2 is set if bit 5 is set out7 \u00b6 public property bool out7 [readonly] out2 is set if bit 6 is set out8 \u00b6 public property bool out8 [readonly] out2 is set if bit 7 is set out9 \u00b6 public property bool out9 [readonly] out2 is set if bit 8 is set ovrf \u00b6 public property bool ovrf [readonly] ovrf is set if in > 65535 Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > types > F2B","title":"F2B"},{"location":"api/types/F2B/#f2b","text":"Doc Home > API Index > types > F2B","title":"F2B"},{"location":"api/types/F2B/#inheritance","text":"sys::Obj sys::Virtual sys::Component types::F2B public class F2B [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] F2b float 16 bit decoder object The input float is cast to an int, which is then decoded to 16 bools of output out1 to out16 = decode with out1 = LSB and out16 = MSB ovrf is set if in > 65535","title":"Inheritance"},{"location":"api/types/F2B/#fields","text":"","title":"Fields"},{"location":"api/types/F2B/#in","text":"public property float in input value to be decoded","title":"in"},{"location":"api/types/F2B/#out1","text":"public property bool out1 [readonly] out1 is set if bit 0 (LSB) is set","title":"out1"},{"location":"api/types/F2B/#out10","text":"public property bool out10 [readonly] out2 is set if bit 9 is set","title":"out10"},{"location":"api/types/F2B/#out11","text":"public property bool out11 [readonly] out2 is set if bit 10 is set","title":"out11"},{"location":"api/types/F2B/#out12","text":"public property bool out12 [readonly] out2 is set if bit 11 is set","title":"out12"},{"location":"api/types/F2B/#out13","text":"public property bool out13 [readonly] out2 is set if bit 12 is set","title":"out13"},{"location":"api/types/F2B/#out14","text":"public property bool out14 [readonly] out2 is set if bit 13 is set","title":"out14"},{"location":"api/types/F2B/#out15","text":"public property bool out15 [readonly] out2 is set if bit 14 is set","title":"out15"},{"location":"api/types/F2B/#out16","text":"public property bool out16 [readonly] out2 is set if bit 15 (MSB) is set","title":"out16"},{"location":"api/types/F2B/#out2","text":"public property bool out2 [readonly] out2 is set if bit 1 is set","title":"out2"},{"location":"api/types/F2B/#out3","text":"public property bool out3 [readonly] out2 is set if bit 2 is set","title":"out3"},{"location":"api/types/F2B/#out4","text":"public property bool out4 [readonly] out2 is set if bit 3 is set","title":"out4"},{"location":"api/types/F2B/#out5","text":"public property bool out5 [readonly] out2 is set if bit 4 is set","title":"out5"},{"location":"api/types/F2B/#out6","text":"public property bool out6 [readonly] out2 is set if bit 5 is set","title":"out6"},{"location":"api/types/F2B/#out7","text":"public property bool out7 [readonly] out2 is set if bit 6 is set","title":"out7"},{"location":"api/types/F2B/#out8","text":"public property bool out8 [readonly] out2 is set if bit 7 is set","title":"out8"},{"location":"api/types/F2B/#out9","text":"public property bool out9 [readonly] out2 is set if bit 8 is set","title":"out9"},{"location":"api/types/F2B/#ovrf","text":"public property bool ovrf [readonly] ovrf is set if in > 65535","title":"ovrf"},{"location":"api/types/F2B/#methods","text":"","title":"Methods"},{"location":"api/types/F2B/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > types > F2B","title":"execute"},{"location":"api/types/F2I/","text":"F2I \u00b6 Doc Home > API Index > types > F2I Inheritance \u00b6 sys::Obj sys::Virtual sys::Component types::F2I public class F2I [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] F2I float-to-integer converter Fields \u00b6 in \u00b6 public property float in input to convert to integer out \u00b6 public property int out [readonly] input converted to an integer Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > types > F2I","title":"F2I"},{"location":"api/types/F2I/#f2i","text":"Doc Home > API Index > types > F2I","title":"F2I"},{"location":"api/types/F2I/#inheritance","text":"sys::Obj sys::Virtual sys::Component types::F2I public class F2I [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] F2I float-to-integer converter","title":"Inheritance"},{"location":"api/types/F2I/#fields","text":"","title":"Fields"},{"location":"api/types/F2I/#in","text":"public property float in input to convert to integer","title":"in"},{"location":"api/types/F2I/#out","text":"public property int out [readonly] input converted to an integer","title":"out"},{"location":"api/types/F2I/#methods","text":"","title":"Methods"},{"location":"api/types/F2I/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > types > F2I","title":"execute"},{"location":"api/types/I2F/","text":"I2F \u00b6 Doc Home > API Index > types > I2F Inheritance \u00b6 sys::Obj sys::Virtual sys::Component types::I2F public class I2F [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] I2F integer-to-float converter Fields \u00b6 in \u00b6 public property int in input to convert to float out \u00b6 public property float out [readonly] input converted to an float Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > types > I2F","title":"I2F"},{"location":"api/types/I2F/#i2f","text":"Doc Home > API Index > types > I2F","title":"I2F"},{"location":"api/types/I2F/#inheritance","text":"sys::Obj sys::Virtual sys::Component types::I2F public class I2F [niagaraIcon=\"module://icons/x16/control/util/switch.png\"] I2F integer-to-float converter","title":"Inheritance"},{"location":"api/types/I2F/#fields","text":"","title":"Fields"},{"location":"api/types/I2F/#in","text":"public property int in input to convert to float","title":"in"},{"location":"api/types/I2F/#out","text":"public property float out [readonly] input converted to an float","title":"out"},{"location":"api/types/I2F/#methods","text":"","title":"Methods"},{"location":"api/types/I2F/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > types > I2F","title":"execute"},{"location":"api/types/L2F/","text":"L2F \u00b6 Doc Home > API Index > types > L2F Inheritance \u00b6 sys::Obj sys::Virtual sys::Component types::L2F public class L2F [niagaraIcon=\"module://icons/x16/doubleArrowRight.png\"] I2F integer-to-float converter Fields \u00b6 in \u00b6 public property long in input to convert to float out \u00b6 public property float out [readonly] input converted to an float Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. Doc Home > API Index > types > L2F","title":"L2F"},{"location":"api/types/L2F/#l2f","text":"Doc Home > API Index > types > L2F","title":"L2F"},{"location":"api/types/L2F/#inheritance","text":"sys::Obj sys::Virtual sys::Component types::L2F public class L2F [niagaraIcon=\"module://icons/x16/doubleArrowRight.png\"] I2F integer-to-float converter","title":"Inheritance"},{"location":"api/types/L2F/#fields","text":"","title":"Fields"},{"location":"api/types/L2F/#in","text":"public property long in input to convert to float","title":"in"},{"location":"api/types/L2F/#out","text":"public property float out [readonly] input converted to an float","title":"out"},{"location":"api/types/L2F/#methods","text":"","title":"Methods"},{"location":"api/types/L2F/#execute","text":"public virtual override void execute() Execute is called once every scan. Doc Home > API Index > types > L2F","title":"execute"},{"location":"api/types/WriteBool/","text":"WriteBool \u00b6 Doc Home > API Index > types > WriteBool Inheritance \u00b6 sys::Obj sys::Virtual sys::Component types::WriteBool public class WriteBool [niagaraIcon=\"module://icons/x16/control/booleanPointWr.png\"] WriteBool can be used to link or set a boolean. If in is unlinked, in values can be set by actions. Fields \u00b6 in \u00b6 public property bool in [summary, config] input property, persisted as config property out \u00b6 public property bool out [summary, readonly] output property = in, runtime property Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. setFalse \u00b6 public action void setFalse() action to set in to false setNull \u00b6 public action void setNull() action to set out to null setTrue \u00b6 public action void setTrue() action to set in to true Doc Home > API Index > types > WriteBool","title":"WriteBool"},{"location":"api/types/WriteBool/#writebool","text":"Doc Home > API Index > types > WriteBool","title":"WriteBool"},{"location":"api/types/WriteBool/#inheritance","text":"sys::Obj sys::Virtual sys::Component types::WriteBool public class WriteBool [niagaraIcon=\"module://icons/x16/control/booleanPointWr.png\"] WriteBool can be used to link or set a boolean. If in is unlinked, in values can be set by actions.","title":"Inheritance"},{"location":"api/types/WriteBool/#fields","text":"","title":"Fields"},{"location":"api/types/WriteBool/#in","text":"public property bool in [summary, config] input property, persisted as config property","title":"in"},{"location":"api/types/WriteBool/#out","text":"public property bool out [summary, readonly] output property = in, runtime property","title":"out"},{"location":"api/types/WriteBool/#methods","text":"","title":"Methods"},{"location":"api/types/WriteBool/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/types/WriteBool/#setfalse","text":"public action void setFalse() action to set in to false","title":"setFalse"},{"location":"api/types/WriteBool/#setnull","text":"public action void setNull() action to set out to null","title":"setNull"},{"location":"api/types/WriteBool/#settrue","text":"public action void setTrue() action to set in to true Doc Home > API Index > types > WriteBool","title":"setTrue"},{"location":"api/types/WriteFloat/","text":"WriteFloat \u00b6 Doc Home > API Index > types > WriteFloat Inheritance \u00b6 sys::Obj sys::Virtual sys::Component types::WriteFloat public class WriteFloat [niagaraIcon=\"module://icons/x16/control/numericPointWr.png\"] WriteFloat can be used to link or set a float. If in is unlinked, in values can be set by actions. Fields \u00b6 in \u00b6 public property float in [summary, config] input property, persisted as config property out \u00b6 public property float out [summary, readonly] output property = in, runtime property Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. set \u00b6 public action void set(float x) action sets in to a value setNull \u00b6 public action void setNull() action sets in to null Doc Home > API Index > types > WriteFloat","title":"WriteFloat"},{"location":"api/types/WriteFloat/#writefloat","text":"Doc Home > API Index > types > WriteFloat","title":"WriteFloat"},{"location":"api/types/WriteFloat/#inheritance","text":"sys::Obj sys::Virtual sys::Component types::WriteFloat public class WriteFloat [niagaraIcon=\"module://icons/x16/control/numericPointWr.png\"] WriteFloat can be used to link or set a float. If in is unlinked, in values can be set by actions.","title":"Inheritance"},{"location":"api/types/WriteFloat/#fields","text":"","title":"Fields"},{"location":"api/types/WriteFloat/#in","text":"public property float in [summary, config] input property, persisted as config property","title":"in"},{"location":"api/types/WriteFloat/#out","text":"public property float out [summary, readonly] output property = in, runtime property","title":"out"},{"location":"api/types/WriteFloat/#methods","text":"","title":"Methods"},{"location":"api/types/WriteFloat/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/types/WriteFloat/#set","text":"public action void set(float x) action sets in to a value","title":"set"},{"location":"api/types/WriteFloat/#setnull","text":"public action void setNull() action sets in to null Doc Home > API Index > types > WriteFloat","title":"setNull"},{"location":"api/types/WriteInt/","text":"WriteInt \u00b6 Doc Home > API Index > types > WriteInt Inheritance \u00b6 sys::Obj sys::Virtual sys::Component types::WriteInt public class WriteInt [niagaraIcon=\"module://icons/x16/control/enumPointWr.png\"] WriteInt can be used to link or set a integer value. If in is unlinked, in values can be set by actions. Fields \u00b6 in \u00b6 public property int in [summary, config] input property, persisted as config property out \u00b6 public property int out [summary, readonly] output property = in, runtime property Methods \u00b6 execute \u00b6 public virtual override void execute() Execute is called once every scan. set \u00b6 public action void set(int x) action to in to a value Doc Home > API Index > types > WriteInt","title":"WriteInt"},{"location":"api/types/WriteInt/#writeint","text":"Doc Home > API Index > types > WriteInt","title":"WriteInt"},{"location":"api/types/WriteInt/#inheritance","text":"sys::Obj sys::Virtual sys::Component types::WriteInt public class WriteInt [niagaraIcon=\"module://icons/x16/control/enumPointWr.png\"] WriteInt can be used to link or set a integer value. If in is unlinked, in values can be set by actions.","title":"Inheritance"},{"location":"api/types/WriteInt/#fields","text":"","title":"Fields"},{"location":"api/types/WriteInt/#in","text":"public property int in [summary, config] input property, persisted as config property","title":"in"},{"location":"api/types/WriteInt/#out","text":"public property int out [summary, readonly] output property = in, runtime property","title":"out"},{"location":"api/types/WriteInt/#methods","text":"","title":"Methods"},{"location":"api/types/WriteInt/#execute","text":"public virtual override void execute() Execute is called once every scan.","title":"execute"},{"location":"api/types/WriteInt/#set","text":"public action void set(int x) action to in to a value Doc Home > API Index > types > WriteInt","title":"set"},{"location":"api/web/","text":"web \u00b6 Doc Home > API Index > web Web service and servlet engine Base64 \u00b6 HttpCode \u00b6 Path \u00b6 SpyRESTWeblet \u00b6 SpyWeblet \u00b6 WebParams \u00b6 WebReq \u00b6 WebRes \u00b6 WebService \u00b6 Weblet \u00b6 Doc Home > API Index > web","title":"Index"},{"location":"api/web/#web","text":"Doc Home > API Index > web Web service and servlet engine","title":"web"},{"location":"api/web/#base64","text":"","title":"Base64"},{"location":"api/web/#httpcode","text":"","title":"HttpCode"},{"location":"api/web/#path","text":"","title":"Path"},{"location":"api/web/#spyrestweblet","text":"","title":"SpyRESTWeblet"},{"location":"api/web/#spyweblet","text":"","title":"SpyWeblet"},{"location":"api/web/#webparams","text":"","title":"WebParams"},{"location":"api/web/#webreq","text":"","title":"WebReq"},{"location":"api/web/#webres","text":"","title":"WebRes"},{"location":"api/web/#webservice","text":"","title":"WebService"},{"location":"api/web/#weblet","text":"Doc Home > API Index > web","title":"Weblet"},{"location":"api/web/Base64/","text":"Base64 \u00b6 Doc Home > API Index > web > Base64 Inheritance \u00b6 sys::Obj web::Base64 public class Base64 Base64 encoding. Base64 encoding replaces each set of 3 bytes from the input with 4 bytes of encoded data. This implementation prints base64 encoding of byte array to given output. Fields \u00b6 PAD \u00b6 public static const define int PAD encodeTable \u00b6 public static const define byte[] encodeTable remainder \u00b6 public static inline byte[] remainder Methods \u00b6 append \u00b6 public static int append( OutStream out, int ch, int linelen, int pos) encode \u00b6 public static void encode( OutStream out, byte[] buf, int buflen) encodeLen \u00b6 public static void encodeLen( OutStream out, byte[] buf, int buflen, int linelen) Doc Home > API Index > web > Base64","title":"Base64"},{"location":"api/web/Base64/#base64","text":"Doc Home > API Index > web > Base64","title":"Base64"},{"location":"api/web/Base64/#inheritance","text":"sys::Obj web::Base64 public class Base64 Base64 encoding. Base64 encoding replaces each set of 3 bytes from the input with 4 bytes of encoded data. This implementation prints base64 encoding of byte array to given output.","title":"Inheritance"},{"location":"api/web/Base64/#fields","text":"","title":"Fields"},{"location":"api/web/Base64/#pad","text":"public static const define int PAD","title":"PAD"},{"location":"api/web/Base64/#encodetable","text":"public static const define byte[] encodeTable","title":"encodeTable"},{"location":"api/web/Base64/#remainder","text":"public static inline byte[] remainder","title":"remainder"},{"location":"api/web/Base64/#methods","text":"","title":"Methods"},{"location":"api/web/Base64/#append","text":"public static int append( OutStream out, int ch, int linelen, int pos)","title":"append"},{"location":"api/web/Base64/#encode","text":"public static void encode( OutStream out, byte[] buf, int buflen)","title":"encode"},{"location":"api/web/Base64/#encodelen","text":"public static void encodeLen( OutStream out, byte[] buf, int buflen, int linelen) Doc Home > API Index > web > Base64","title":"encodeLen"},{"location":"api/web/HttpCode/","text":"HttpCode \u00b6 Doc Home > API Index > web > HttpCode Inheritance \u00b6 sys::Obj web::HttpCode public final class HttpCode Common HTTP Status Codes. Based on RFC 2616 (HTTP/1.1 protocol) http://www.ietf.org/rfc/rfc2616.txt?number=2616 Fields \u00b6 accepted \u00b6 public static const define int accepted 202: Accepted badGateway \u00b6 public static const define int badGateway 502: Bad Gateway badHttpVersion \u00b6 public static const define int badHttpVersion 505: HTTP Version Not Supported badRange \u00b6 public static const define int badRange 416: Requested Range Not Satisfiable badRequest \u00b6 public static const define int badRequest 400: Bad Request conflict \u00b6 public static const define int conflict 409: Conflict cont \u00b6 public static const define int cont 100: Continue created \u00b6 public static const define int created 201: Created expectationFailed \u00b6 public static const define int expectationFailed 417: Expectation Failed forbidden \u00b6 public static const define int forbidden 403: Forbidden found \u00b6 public static const define int found 302: Found (sometimes known as Moved Temporarily\") gatewayTimeout \u00b6 public static const define int gatewayTimeout 504: Gateway Timeout gone \u00b6 public static const define int gone 410: Gone internalError \u00b6 public static const define int internalError 500: Internal Server Error lengthRequired \u00b6 public static const define int lengthRequired 411: Length Required methodNotAllowed \u00b6 public static const define int methodNotAllowed 405: Method Not Allowed movedPermanently \u00b6 public static const define int movedPermanently 301: Moved Permanently multipleChoice \u00b6 public static const define int multipleChoice 300: Multiple Choices noContent \u00b6 public static const define int noContent 204: No Content notAcceptable \u00b6 public static const define int notAcceptable 406: Not Acceptable notAuthoritative \u00b6 public static const define int notAuthoritative 203: Non-Authoritative Information notFound \u00b6 public static const define int notFound 404: Not Found notModified \u00b6 public static const define int notModified 304: Not Modified ok \u00b6 public static const define int ok 200: OK partial \u00b6 public static const define int partial 206: Partial Content preconditionFailed \u00b6 public static const define int preconditionFailed 412: Precondition Failed proxyAuthRequired \u00b6 public static const define int proxyAuthRequired 407: Proxy Authentication Required reset \u00b6 public static const define int reset 205: Reset Content seeOther \u00b6 public static const define int seeOther 303: See Other serviceUnavailable \u00b6 public static const define int serviceUnavailable 503: Service Unavailable switchingProtocols \u00b6 public static const define int switchingProtocols 101: Switching Protocols temporaryRedirect \u00b6 public static const define int temporaryRedirect 307: Temporary Redirect timeout \u00b6 public static const define int timeout 408: Request Timeout tooLarge \u00b6 public static const define int tooLarge 413: Request Entity Too Large unauthorized \u00b6 public static const define int unauthorized 401: Unauthorized unsupportedMedia \u00b6 public static const define int unsupportedMedia 415: Unsupported Media Type uriTooLong \u00b6 public static const define int uriTooLong 414: Request-URI Too Long useProxy \u00b6 public static const define int useProxy 305: Use Proxy Doc Home > API Index > web > HttpCode","title":"HttpCode"},{"location":"api/web/HttpCode/#httpcode","text":"Doc Home > API Index > web > HttpCode","title":"HttpCode"},{"location":"api/web/HttpCode/#inheritance","text":"sys::Obj web::HttpCode public final class HttpCode Common HTTP Status Codes. Based on RFC 2616 (HTTP/1.1 protocol) http://www.ietf.org/rfc/rfc2616.txt?number=2616","title":"Inheritance"},{"location":"api/web/HttpCode/#fields","text":"","title":"Fields"},{"location":"api/web/HttpCode/#accepted","text":"public static const define int accepted 202: Accepted","title":"accepted"},{"location":"api/web/HttpCode/#badgateway","text":"public static const define int badGateway 502: Bad Gateway","title":"badGateway"},{"location":"api/web/HttpCode/#badhttpversion","text":"public static const define int badHttpVersion 505: HTTP Version Not Supported","title":"badHttpVersion"},{"location":"api/web/HttpCode/#badrange","text":"public static const define int badRange 416: Requested Range Not Satisfiable","title":"badRange"},{"location":"api/web/HttpCode/#badrequest","text":"public static const define int badRequest 400: Bad Request","title":"badRequest"},{"location":"api/web/HttpCode/#conflict","text":"public static const define int conflict 409: Conflict","title":"conflict"},{"location":"api/web/HttpCode/#cont","text":"public static const define int cont 100: Continue","title":"cont"},{"location":"api/web/HttpCode/#created","text":"public static const define int created 201: Created","title":"created"},{"location":"api/web/HttpCode/#expectationfailed","text":"public static const define int expectationFailed 417: Expectation Failed","title":"expectationFailed"},{"location":"api/web/HttpCode/#forbidden","text":"public static const define int forbidden 403: Forbidden","title":"forbidden"},{"location":"api/web/HttpCode/#found","text":"public static const define int found 302: Found (sometimes known as Moved Temporarily\")","title":"found"},{"location":"api/web/HttpCode/#gatewaytimeout","text":"public static const define int gatewayTimeout 504: Gateway Timeout","title":"gatewayTimeout"},{"location":"api/web/HttpCode/#gone","text":"public static const define int gone 410: Gone","title":"gone"},{"location":"api/web/HttpCode/#internalerror","text":"public static const define int internalError 500: Internal Server Error","title":"internalError"},{"location":"api/web/HttpCode/#lengthrequired","text":"public static const define int lengthRequired 411: Length Required","title":"lengthRequired"},{"location":"api/web/HttpCode/#methodnotallowed","text":"public static const define int methodNotAllowed 405: Method Not Allowed","title":"methodNotAllowed"},{"location":"api/web/HttpCode/#movedpermanently","text":"public static const define int movedPermanently 301: Moved Permanently","title":"movedPermanently"},{"location":"api/web/HttpCode/#multiplechoice","text":"public static const define int multipleChoice 300: Multiple Choices","title":"multipleChoice"},{"location":"api/web/HttpCode/#nocontent","text":"public static const define int noContent 204: No Content","title":"noContent"},{"location":"api/web/HttpCode/#notacceptable","text":"public static const define int notAcceptable 406: Not Acceptable","title":"notAcceptable"},{"location":"api/web/HttpCode/#notauthoritative","text":"public static const define int notAuthoritative 203: Non-Authoritative Information","title":"notAuthoritative"},{"location":"api/web/HttpCode/#notfound","text":"public static const define int notFound 404: Not Found","title":"notFound"},{"location":"api/web/HttpCode/#notmodified","text":"public static const define int notModified 304: Not Modified","title":"notModified"},{"location":"api/web/HttpCode/#ok","text":"public static const define int ok 200: OK","title":"ok"},{"location":"api/web/HttpCode/#partial","text":"public static const define int partial 206: Partial Content","title":"partial"},{"location":"api/web/HttpCode/#preconditionfailed","text":"public static const define int preconditionFailed 412: Precondition Failed","title":"preconditionFailed"},{"location":"api/web/HttpCode/#proxyauthrequired","text":"public static const define int proxyAuthRequired 407: Proxy Authentication Required","title":"proxyAuthRequired"},{"location":"api/web/HttpCode/#reset","text":"public static const define int reset 205: Reset Content","title":"reset"},{"location":"api/web/HttpCode/#seeother","text":"public static const define int seeOther 303: See Other","title":"seeOther"},{"location":"api/web/HttpCode/#serviceunavailable","text":"public static const define int serviceUnavailable 503: Service Unavailable","title":"serviceUnavailable"},{"location":"api/web/HttpCode/#switchingprotocols","text":"public static const define int switchingProtocols 101: Switching Protocols","title":"switchingProtocols"},{"location":"api/web/HttpCode/#temporaryredirect","text":"public static const define int temporaryRedirect 307: Temporary Redirect","title":"temporaryRedirect"},{"location":"api/web/HttpCode/#timeout","text":"public static const define int timeout 408: Request Timeout","title":"timeout"},{"location":"api/web/HttpCode/#toolarge","text":"public static const define int tooLarge 413: Request Entity Too Large","title":"tooLarge"},{"location":"api/web/HttpCode/#unauthorized","text":"public static const define int unauthorized 401: Unauthorized","title":"unauthorized"},{"location":"api/web/HttpCode/#unsupportedmedia","text":"public static const define int unsupportedMedia 415: Unsupported Media Type","title":"unsupportedMedia"},{"location":"api/web/HttpCode/#uritoolong","text":"public static const define int uriTooLong 414: Request-URI Too Long","title":"uriTooLong"},{"location":"api/web/HttpCode/#useproxy","text":"public static const define int useProxy 305: Use Proxy Doc Home > API Index > web > HttpCode","title":"useProxy"},{"location":"api/web/Path/","text":"Path \u00b6 Doc Home > API Index > web > Path Inheritance \u00b6 sys::Obj web::Path public class Path Path models the parsed segments of the URI path Fields \u00b6 max \u00b6 public static const define int max names \u00b6 public inline Str [] names size \u00b6 public int size Methods \u00b6 dump \u00b6 public void dump( OutStream out) Doc Home > API Index > web > Path","title":"Path"},{"location":"api/web/Path/#path","text":"Doc Home > API Index > web > Path","title":"Path"},{"location":"api/web/Path/#inheritance","text":"sys::Obj web::Path public class Path Path models the parsed segments of the URI path","title":"Inheritance"},{"location":"api/web/Path/#fields","text":"","title":"Fields"},{"location":"api/web/Path/#max","text":"public static const define int max","title":"max"},{"location":"api/web/Path/#names","text":"public inline Str [] names","title":"names"},{"location":"api/web/Path/#size","text":"public int size","title":"size"},{"location":"api/web/Path/#methods","text":"","title":"Methods"},{"location":"api/web/Path/#dump","text":"public void dump( OutStream out) Doc Home > API Index > web > Path","title":"dump"},{"location":"api/web/SpyRESTWeblet/","text":"SpyRESTWeblet \u00b6 Doc Home > API Index > web > SpyRESTWeblet Inheritance \u00b6 sys::Obj sys::Virtual sys::Component web::Weblet web::SpyRESTWeblet public class SpyRESTWeblet SpyRESTWeblet is a built-in weblet which provides diagnostics visibility to the Sedona runtime in a REST/json format. Fields \u00b6 Methods \u00b6 app \u00b6 public void app( WebReq req, WebRes res) appComponent \u00b6 public void appComponent( WebReq req, WebRes res, Component c) backupApp \u00b6 public void backupApp( WebReq req, WebRes res) description \u00b6 public override Str description() doDelete \u00b6 public override void doDelete( WebReq req, WebRes res) echo \u00b6 public void echo( WebReq req, WebRes res) get \u00b6 public override void get( WebReq req, WebRes res) head \u00b6 public override void head( WebReq req, WebRes res) index \u00b6 public void index( WebReq req, WebRes res) kits \u00b6 public void kits( WebReq req, WebRes res) kitsIndex \u00b6 public void kitsIndex( WebReq req, WebRes res) kitsKit \u00b6 public void kitsKit( WebReq req, WebRes res, Kit k) kitsType \u00b6 public void kitsType( WebReq req, WebRes res, Type t) logs \u00b6 public void logs( WebReq req, WebRes res) post \u00b6 public override void post( WebReq req, WebRes res) prefix \u00b6 public override Str prefix() put \u00b6 public override void put( WebReq req, WebRes res) sox \u00b6 public void sox( WebReq req, WebRes res) soxIndex \u00b6 public void soxIndex( WebReq req, WebRes res, SoxService sox) start \u00b6 public override void start() stop \u00b6 public override void stop() updateLogLevel \u00b6 public void updateLogLevel( WebReq req, WebRes res) Doc Home > API Index > web > SpyRESTWeblet","title":"SpyRESTWeblet"},{"location":"api/web/SpyRESTWeblet/#spyrestweblet","text":"Doc Home > API Index > web > SpyRESTWeblet","title":"SpyRESTWeblet"},{"location":"api/web/SpyRESTWeblet/#inheritance","text":"sys::Obj sys::Virtual sys::Component web::Weblet web::SpyRESTWeblet public class SpyRESTWeblet SpyRESTWeblet is a built-in weblet which provides diagnostics visibility to the Sedona runtime in a REST/json format.","title":"Inheritance"},{"location":"api/web/SpyRESTWeblet/#fields","text":"","title":"Fields"},{"location":"api/web/SpyRESTWeblet/#methods","text":"","title":"Methods"},{"location":"api/web/SpyRESTWeblet/#app","text":"public void app( WebReq req, WebRes res)","title":"app"},{"location":"api/web/SpyRESTWeblet/#appcomponent","text":"public void appComponent( WebReq req, WebRes res, Component c)","title":"appComponent"},{"location":"api/web/SpyRESTWeblet/#backupapp","text":"public void backupApp( WebReq req, WebRes res)","title":"backupApp"},{"location":"api/web/SpyRESTWeblet/#description","text":"public override Str description()","title":"description"},{"location":"api/web/SpyRESTWeblet/#dodelete","text":"public override void doDelete( WebReq req, WebRes res)","title":"doDelete"},{"location":"api/web/SpyRESTWeblet/#echo","text":"public void echo( WebReq req, WebRes res)","title":"echo"},{"location":"api/web/SpyRESTWeblet/#get","text":"public override void get( WebReq req, WebRes res)","title":"get"},{"location":"api/web/SpyRESTWeblet/#head","text":"public override void head( WebReq req, WebRes res)","title":"head"},{"location":"api/web/SpyRESTWeblet/#index","text":"public void index( WebReq req, WebRes res)","title":"index"},{"location":"api/web/SpyRESTWeblet/#kits","text":"public void kits( WebReq req, WebRes res)","title":"kits"},{"location":"api/web/SpyRESTWeblet/#kitsindex","text":"public void kitsIndex( WebReq req, WebRes res)","title":"kitsIndex"},{"location":"api/web/SpyRESTWeblet/#kitskit","text":"public void kitsKit( WebReq req, WebRes res, Kit k)","title":"kitsKit"},{"location":"api/web/SpyRESTWeblet/#kitstype","text":"public void kitsType( WebReq req, WebRes res, Type t)","title":"kitsType"},{"location":"api/web/SpyRESTWeblet/#logs","text":"public void logs( WebReq req, WebRes res)","title":"logs"},{"location":"api/web/SpyRESTWeblet/#post","text":"public override void post( WebReq req, WebRes res)","title":"post"},{"location":"api/web/SpyRESTWeblet/#prefix","text":"public override Str prefix()","title":"prefix"},{"location":"api/web/SpyRESTWeblet/#put","text":"public override void put( WebReq req, WebRes res)","title":"put"},{"location":"api/web/SpyRESTWeblet/#sox","text":"public void sox( WebReq req, WebRes res)","title":"sox"},{"location":"api/web/SpyRESTWeblet/#soxindex","text":"public void soxIndex( WebReq req, WebRes res, SoxService sox)","title":"soxIndex"},{"location":"api/web/SpyRESTWeblet/#start","text":"public override void start()","title":"start"},{"location":"api/web/SpyRESTWeblet/#stop","text":"public override void stop()","title":"stop"},{"location":"api/web/SpyRESTWeblet/#updateloglevel","text":"public void updateLogLevel( WebReq req, WebRes res) Doc Home > API Index > web > SpyRESTWeblet","title":"updateLogLevel"},{"location":"api/web/SpyWeblet/","text":"SpyWeblet \u00b6 Doc Home > API Index > web > SpyWeblet Inheritance \u00b6 sys::Obj sys::Virtual sys::Component web::Weblet web::SpyWeblet public class SpyWeblet SpyWeblet is a built-in weblet which provides diagnostics visibility to the Sedona runtime. Fields \u00b6 Methods \u00b6 app \u00b6 public void app( WebReq req, WebRes res) appComponent \u00b6 public void appComponent( WebReq req, WebRes res, Component c) backupApp \u00b6 public void backupApp( WebReq req, WebRes res) componentRow \u00b6 public void componentRow( WebReq req, WebRes res, Component c, bool tr) componentTitle \u00b6 public void componentTitle( WebReq req, WebRes res) description \u00b6 public override Str description() echo \u00b6 public void echo( WebReq req, WebRes res) get \u00b6 public override void get( WebReq req, WebRes res) href \u00b6 public WebRes href( WebRes res, Component c, Str caption) index \u00b6 public void index( WebReq req, WebRes res) kits \u00b6 public void kits( WebReq req, WebRes res) kitsIndex \u00b6 public void kitsIndex( WebReq req, WebRes res) kitsKit \u00b6 public void kitsKit( WebReq req, WebRes res, Kit k) kitsType \u00b6 public void kitsType( WebReq req, WebRes res, Type t) logs \u00b6 public void logs( WebReq req, WebRes res) prefix \u00b6 public override Str prefix() sox \u00b6 public void sox( WebReq req, WebRes res) soxIndex \u00b6 public void soxIndex( WebReq req, WebRes res, SoxService sox) start \u00b6 public override void start() stop \u00b6 public override void stop() Doc Home > API Index > web > SpyWeblet","title":"SpyWeblet"},{"location":"api/web/SpyWeblet/#spyweblet","text":"Doc Home > API Index > web > SpyWeblet","title":"SpyWeblet"},{"location":"api/web/SpyWeblet/#inheritance","text":"sys::Obj sys::Virtual sys::Component web::Weblet web::SpyWeblet public class SpyWeblet SpyWeblet is a built-in weblet which provides diagnostics visibility to the Sedona runtime.","title":"Inheritance"},{"location":"api/web/SpyWeblet/#fields","text":"","title":"Fields"},{"location":"api/web/SpyWeblet/#methods","text":"","title":"Methods"},{"location":"api/web/SpyWeblet/#app","text":"public void app( WebReq req, WebRes res)","title":"app"},{"location":"api/web/SpyWeblet/#appcomponent","text":"public void appComponent( WebReq req, WebRes res, Component c)","title":"appComponent"},{"location":"api/web/SpyWeblet/#backupapp","text":"public void backupApp( WebReq req, WebRes res)","title":"backupApp"},{"location":"api/web/SpyWeblet/#componentrow","text":"public void componentRow( WebReq req, WebRes res, Component c, bool tr)","title":"componentRow"},{"location":"api/web/SpyWeblet/#componenttitle","text":"public void componentTitle( WebReq req, WebRes res)","title":"componentTitle"},{"location":"api/web/SpyWeblet/#description","text":"public override Str description()","title":"description"},{"location":"api/web/SpyWeblet/#echo","text":"public void echo( WebReq req, WebRes res)","title":"echo"},{"location":"api/web/SpyWeblet/#get","text":"public override void get( WebReq req, WebRes res)","title":"get"},{"location":"api/web/SpyWeblet/#href","text":"public WebRes href( WebRes res, Component c, Str caption)","title":"href"},{"location":"api/web/SpyWeblet/#index","text":"public void index( WebReq req, WebRes res)","title":"index"},{"location":"api/web/SpyWeblet/#kits","text":"public void kits( WebReq req, WebRes res)","title":"kits"},{"location":"api/web/SpyWeblet/#kitsindex","text":"public void kitsIndex( WebReq req, WebRes res)","title":"kitsIndex"},{"location":"api/web/SpyWeblet/#kitskit","text":"public void kitsKit( WebReq req, WebRes res, Kit k)","title":"kitsKit"},{"location":"api/web/SpyWeblet/#kitstype","text":"public void kitsType( WebReq req, WebRes res, Type t)","title":"kitsType"},{"location":"api/web/SpyWeblet/#logs","text":"public void logs( WebReq req, WebRes res)","title":"logs"},{"location":"api/web/SpyWeblet/#prefix","text":"public override Str prefix()","title":"prefix"},{"location":"api/web/SpyWeblet/#sox","text":"public void sox( WebReq req, WebRes res)","title":"sox"},{"location":"api/web/SpyWeblet/#soxindex","text":"public void soxIndex( WebReq req, WebRes res, SoxService sox)","title":"soxIndex"},{"location":"api/web/SpyWeblet/#start","text":"public override void start()","title":"start"},{"location":"api/web/SpyWeblet/#stop","text":"public override void stop() Doc Home > API Index > web > SpyWeblet","title":"stop"},{"location":"api/web/WebParams/","text":"WebParams \u00b6 Doc Home > API Index > web > WebParams Inheritance \u00b6 sys::Obj web::WebParams public class WebParams WebParams models a list of HTTP name/value parameter. Fields \u00b6 max \u00b6 public static const define int max names \u00b6 public inline Str [] names size \u00b6 public int size values \u00b6 public inline Str [] values Methods \u00b6 dump \u00b6 public void dump( OutStream out) Doc Home > API Index > web > WebParams","title":"WebParams"},{"location":"api/web/WebParams/#webparams","text":"Doc Home > API Index > web > WebParams","title":"WebParams"},{"location":"api/web/WebParams/#inheritance","text":"sys::Obj web::WebParams public class WebParams WebParams models a list of HTTP name/value parameter.","title":"Inheritance"},{"location":"api/web/WebParams/#fields","text":"","title":"Fields"},{"location":"api/web/WebParams/#max","text":"public static const define int max","title":"max"},{"location":"api/web/WebParams/#names","text":"public inline Str [] names","title":"names"},{"location":"api/web/WebParams/#size","text":"public int size","title":"size"},{"location":"api/web/WebParams/#values","text":"public inline Str [] values","title":"values"},{"location":"api/web/WebParams/#methods","text":"","title":"Methods"},{"location":"api/web/WebParams/#dump","text":"public void dump( OutStream out) Doc Home > API Index > web > WebParams","title":"dump"},{"location":"api/web/WebReq/","text":"WebReq \u00b6 Doc Home > API Index > web > WebReq Inheritance \u00b6 sys::Obj web::WebReq public class WebReq WebReq models the request side of an HTTP transaction. Fields \u00b6 method \u00b6 public Str method HTTP method: \"GET\" params \u00b6 public inline WebParams params Request parameters path \u00b6 public inline Path path The parsed path segments: \"a\", \"b\", \"c\" query \u00b6 public Str query The query part of uri or empty string: \"query\" service \u00b6 public WebService service Parent web service component uri \u00b6 public Str uri The full request URI: \"/a/b/c?query\" version \u00b6 public Str version HTTP version: \"HTTP/1.1\" Methods \u00b6 dump \u00b6 public void dump( OutStream out) Doc Home > API Index > web > WebReq","title":"WebReq"},{"location":"api/web/WebReq/#webreq","text":"Doc Home > API Index > web > WebReq","title":"WebReq"},{"location":"api/web/WebReq/#inheritance","text":"sys::Obj web::WebReq public class WebReq WebReq models the request side of an HTTP transaction.","title":"Inheritance"},{"location":"api/web/WebReq/#fields","text":"","title":"Fields"},{"location":"api/web/WebReq/#method","text":"public Str method HTTP method: \"GET\"","title":"method"},{"location":"api/web/WebReq/#params","text":"public inline WebParams params Request parameters","title":"params"},{"location":"api/web/WebReq/#path","text":"public inline Path path The parsed path segments: \"a\", \"b\", \"c\"","title":"path"},{"location":"api/web/WebReq/#query","text":"public Str query The query part of uri or empty string: \"query\"","title":"query"},{"location":"api/web/WebReq/#service","text":"public WebService service Parent web service component","title":"service"},{"location":"api/web/WebReq/#uri","text":"public Str uri The full request URI: \"/a/b/c?query\"","title":"uri"},{"location":"api/web/WebReq/#version","text":"public Str version HTTP version: \"HTTP/1.1\"","title":"version"},{"location":"api/web/WebReq/#methods","text":"","title":"Methods"},{"location":"api/web/WebReq/#dump","text":"public void dump( OutStream out) Doc Home > API Index > web > WebReq","title":"dump"},{"location":"api/web/WebRes/","text":"WebRes \u00b6 Doc Home > API Index > web > WebRes Inheritance \u00b6 sys::Obj sys::Virtual sys::OutStream web::WebRes public class WebRes WebRes models the response side of an HTTP transaction. All responses should be ordered as: 1. res.writeStatus 2. zero or more calls to res.writeHeader 3. res.finishHeaders 4. write body Fields \u00b6 bufLen \u00b6 public static const define int bufLen service \u00b6 public WebService service Parent web service component Methods \u00b6 close \u00b6 public override void close() encode64 \u00b6 public WebRes encode64( Buf b) Print the buf contents using base64 encoding and return this. esc \u00b6 public WebRes esc( Str s) Print the specified string escaping <, >, and & into the <, >, and & finishHeaders \u00b6 public WebRes finishHeaders() This call closes the header section and readys the output stream for the response content. flush \u00b6 public override void flush() html \u00b6 public WebRes html() Write out 200 OK status, text/html content type, and opening HTML markup. htmlEnd \u00b6 public WebRes htmlEnd() Write closing HTML markup. json \u00b6 public WebRes json() Write out 200 OK status, application/json content type, and opening JSON markup. jsonEsc \u00b6 public WebRes jsonEsc( Str s) Print the specified JSON string escaping \", \\, \\n, \\r, \\t Others (\\f, \\b) are ignored jsonKV \u00b6 public WebRes jsonKV( Str key, Str val) Print the specified JSON key/ value pair on a new line without indent jsonKVI \u00b6 public WebRes jsonKVI(int indent, Str key, Str val) Print the specified JSON key/ value pair on a new line with a specified indent jsonObjEnd \u00b6 public WebRes jsonObjEnd(int indent) Write closing JSON markup. on a new line jsonObjStart \u00b6 public WebRes jsonObjStart(int indent) Write opening JSON markup. jsonStrN \u00b6 public WebRes jsonStrN( Str str) Print the specified string in JSON format on a new line without indent jsonStrNI \u00b6 public WebRes jsonStrNI(int indent, Str str) Print the specified string in JSON format on a new line with a specified indent printDuration \u00b6 public WebRes printDuration(long ticks) Print duration in human readable form. printElapsed \u00b6 public WebRes printElapsed(long ticks) Print elapsed duration from specified ticks to now. printProp \u00b6 public WebRes printProp( Component c, Slot prop) Print the component's current value of the specified property. spaces \u00b6 public WebRes spaces(int num) Print the specified number of spaces. td \u00b6 public WebRes td() Write td start tag with no-wrap and left align. th \u00b6 public WebRes th( Str title) Write th element with no-wrap and left align. trTitle \u00b6 public WebRes trTitle( Str title, int colspan) Write a tr element with the specified colspan that can be used as a title header to separate rows. w \u00b6 public WebRes w( Str s) Print the specified string and return this. wi \u00b6 public WebRes wi(int i) Print the specified integer and return this. write \u00b6 public override bool write(int b) writeBytes \u00b6 public override bool writeBytes(byte[] b, int off, int len) writeContentType \u00b6 public WebRes writeContentType( Str val) Convenience for writeHeader(\"Content-Type\", val) writeHeader \u00b6 public WebRes writeHeader( Str name, Str val) Write a header name/value pair. This call must be made between writeStatus() and finishHeaders(). writeStatus \u00b6 public WebRes writeStatus(int status) Write response status line with specified HTTP status code. This call must be the very first thing written. writeStatusOk \u00b6 public WebRes writeStatusOk() Convenience for writeStatus(200) Doc Home > API Index > web > WebRes","title":"WebRes"},{"location":"api/web/WebRes/#webres","text":"Doc Home > API Index > web > WebRes","title":"WebRes"},{"location":"api/web/WebRes/#inheritance","text":"sys::Obj sys::Virtual sys::OutStream web::WebRes public class WebRes WebRes models the response side of an HTTP transaction. All responses should be ordered as: 1. res.writeStatus 2. zero or more calls to res.writeHeader 3. res.finishHeaders 4. write body","title":"Inheritance"},{"location":"api/web/WebRes/#fields","text":"","title":"Fields"},{"location":"api/web/WebRes/#buflen","text":"public static const define int bufLen","title":"bufLen"},{"location":"api/web/WebRes/#service","text":"public WebService service Parent web service component","title":"service"},{"location":"api/web/WebRes/#methods","text":"","title":"Methods"},{"location":"api/web/WebRes/#close","text":"public override void close()","title":"close"},{"location":"api/web/WebRes/#encode64","text":"public WebRes encode64( Buf b) Print the buf contents using base64 encoding and return this.","title":"encode64"},{"location":"api/web/WebRes/#esc","text":"public WebRes esc( Str s) Print the specified string escaping <, >, and & into the <, >, and &","title":"esc"},{"location":"api/web/WebRes/#finishheaders","text":"public WebRes finishHeaders() This call closes the header section and readys the output stream for the response content.","title":"finishHeaders"},{"location":"api/web/WebRes/#flush","text":"public override void flush()","title":"flush"},{"location":"api/web/WebRes/#html","text":"public WebRes html() Write out 200 OK status, text/html content type, and opening HTML markup.","title":"html"},{"location":"api/web/WebRes/#htmlend","text":"public WebRes htmlEnd() Write closing HTML markup.","title":"htmlEnd"},{"location":"api/web/WebRes/#json","text":"public WebRes json() Write out 200 OK status, application/json content type, and opening JSON markup.","title":"json"},{"location":"api/web/WebRes/#jsonesc","text":"public WebRes jsonEsc( Str s) Print the specified JSON string escaping \", \\, \\n, \\r, \\t Others (\\f, \\b) are ignored","title":"jsonEsc"},{"location":"api/web/WebRes/#jsonkv","text":"public WebRes jsonKV( Str key, Str val) Print the specified JSON key/ value pair on a new line without indent","title":"jsonKV"},{"location":"api/web/WebRes/#jsonkvi","text":"public WebRes jsonKVI(int indent, Str key, Str val) Print the specified JSON key/ value pair on a new line with a specified indent","title":"jsonKVI"},{"location":"api/web/WebRes/#jsonobjend","text":"public WebRes jsonObjEnd(int indent) Write closing JSON markup. on a new line","title":"jsonObjEnd"},{"location":"api/web/WebRes/#jsonobjstart","text":"public WebRes jsonObjStart(int indent) Write opening JSON markup.","title":"jsonObjStart"},{"location":"api/web/WebRes/#jsonstrn","text":"public WebRes jsonStrN( Str str) Print the specified string in JSON format on a new line without indent","title":"jsonStrN"},{"location":"api/web/WebRes/#jsonstrni","text":"public WebRes jsonStrNI(int indent, Str str) Print the specified string in JSON format on a new line with a specified indent","title":"jsonStrNI"},{"location":"api/web/WebRes/#printduration","text":"public WebRes printDuration(long ticks) Print duration in human readable form.","title":"printDuration"},{"location":"api/web/WebRes/#printelapsed","text":"public WebRes printElapsed(long ticks) Print elapsed duration from specified ticks to now.","title":"printElapsed"},{"location":"api/web/WebRes/#printprop","text":"public WebRes printProp( Component c, Slot prop) Print the component's current value of the specified property.","title":"printProp"},{"location":"api/web/WebRes/#spaces","text":"public WebRes spaces(int num) Print the specified number of spaces.","title":"spaces"},{"location":"api/web/WebRes/#td","text":"public WebRes td() Write td start tag with no-wrap and left align.","title":"td"},{"location":"api/web/WebRes/#th","text":"public WebRes th( Str title) Write th element with no-wrap and left align.","title":"th"},{"location":"api/web/WebRes/#trtitle","text":"public WebRes trTitle( Str title, int colspan) Write a tr element with the specified colspan that can be used as a title header to separate rows.","title":"trTitle"},{"location":"api/web/WebRes/#w","text":"public WebRes w( Str s) Print the specified string and return this.","title":"w"},{"location":"api/web/WebRes/#wi","text":"public WebRes wi(int i) Print the specified integer and return this.","title":"wi"},{"location":"api/web/WebRes/#write","text":"public override bool write(int b)","title":"write"},{"location":"api/web/WebRes/#writebytes","text":"public override bool writeBytes(byte[] b, int off, int len)","title":"writeBytes"},{"location":"api/web/WebRes/#writecontenttype","text":"public WebRes writeContentType( Str val) Convenience for writeHeader(\"Content-Type\", val)","title":"writeContentType"},{"location":"api/web/WebRes/#writeheader","text":"public WebRes writeHeader( Str name, Str val) Write a header name/value pair. This call must be made between writeStatus() and finishHeaders().","title":"writeHeader"},{"location":"api/web/WebRes/#writestatus","text":"public WebRes writeStatus(int status) Write response status line with specified HTTP status code. This call must be the very first thing written.","title":"writeStatus"},{"location":"api/web/WebRes/#writestatusok","text":"public WebRes writeStatusOk() Convenience for writeStatus(200) Doc Home > API Index > web > WebRes","title":"writeStatusOk"},{"location":"api/web/WebService/","text":"WebService \u00b6 Doc Home > API Index > web > WebService Inheritance \u00b6 sys::Obj sys::Virtual sys::Component sys::Service web::WebService public class WebService [niagaraIcon=\"module://icons/x16/web.png\"] WebService Fields \u00b6 handlersLen \u00b6 public static const define int handlersLen log \u00b6 public static const define Log log port \u00b6 public property short port [config] weblets \u00b6 public static Weblet weblets Linked list of weblets Methods \u00b6 start \u00b6 public override void start() stop \u00b6 public override void stop() work \u00b6 public override bool work() Doc Home > API Index > web > WebService","title":"WebService"},{"location":"api/web/WebService/#webservice","text":"Doc Home > API Index > web > WebService","title":"WebService"},{"location":"api/web/WebService/#inheritance","text":"sys::Obj sys::Virtual sys::Component sys::Service web::WebService public class WebService [niagaraIcon=\"module://icons/x16/web.png\"] WebService","title":"Inheritance"},{"location":"api/web/WebService/#fields","text":"","title":"Fields"},{"location":"api/web/WebService/#handlerslen","text":"public static const define int handlersLen","title":"handlersLen"},{"location":"api/web/WebService/#log","text":"public static const define Log log","title":"log"},{"location":"api/web/WebService/#port","text":"public property short port [config]","title":"port"},{"location":"api/web/WebService/#weblets","text":"public static Weblet weblets Linked list of weblets","title":"weblets"},{"location":"api/web/WebService/#methods","text":"","title":"Methods"},{"location":"api/web/WebService/#start","text":"public override void start()","title":"start"},{"location":"api/web/WebService/#stop","text":"public override void stop()","title":"stop"},{"location":"api/web/WebService/#work","text":"public override bool work() Doc Home > API Index > web > WebService","title":"work"},{"location":"api/web/Weblet/","text":"Weblet \u00b6 Doc Home > API Index > web > Weblet Inheritance \u00b6 sys::Obj sys::Virtual sys::Component web::Weblet public abstract class Weblet Weblet is the base class for Objects which handle HTTP requests for a specified URI prefix. Weblets will not be registered with the WebService until the register() method is invoked. This could be done in _sInit(), or at some other time. Weblets can be removed from the WebService using unregister(). Fields \u00b6 nextWeblet \u00b6 public Weblet nextWeblet Used for WebService's linked list of weblets Methods \u00b6 description \u00b6 public virtual Str description() Get a brief description of the weblet. doDelete \u00b6 public virtual void doDelete( WebReq req, WebRes res) Service a DELETE request. get \u00b6 public virtual void get( WebReq req, WebRes res) Service a GET request. head \u00b6 public virtual void head( WebReq req, WebRes res) Service a HEAD request. post \u00b6 public virtual void post( WebReq req, WebRes res) Service a POST request. prefix \u00b6 public abstract Str prefix() Get the weblet's prefix which should be a simple name (no slash) used for routing URIs to this Weblet. put \u00b6 public virtual void put( WebReq req, WebRes res) Service a PUT request. register \u00b6 public void register() Register the weblet with the WebService. service \u00b6 public virtual void service( WebReq req, WebRes res) Service the specified request. Default implementation routes to get(), head(), post(), put(), or delete(). unregister \u00b6 public void unregister() Remove this weblet from the WebService. Doc Home > API Index > web > Weblet","title":"Weblet"},{"location":"api/web/Weblet/#weblet","text":"Doc Home > API Index > web > Weblet","title":"Weblet"},{"location":"api/web/Weblet/#inheritance","text":"sys::Obj sys::Virtual sys::Component web::Weblet public abstract class Weblet Weblet is the base class for Objects which handle HTTP requests for a specified URI prefix. Weblets will not be registered with the WebService until the register() method is invoked. This could be done in _sInit(), or at some other time. Weblets can be removed from the WebService using unregister().","title":"Inheritance"},{"location":"api/web/Weblet/#fields","text":"","title":"Fields"},{"location":"api/web/Weblet/#nextweblet","text":"public Weblet nextWeblet Used for WebService's linked list of weblets","title":"nextWeblet"},{"location":"api/web/Weblet/#methods","text":"","title":"Methods"},{"location":"api/web/Weblet/#description","text":"public virtual Str description() Get a brief description of the weblet.","title":"description"},{"location":"api/web/Weblet/#dodelete","text":"public virtual void doDelete( WebReq req, WebRes res) Service a DELETE request.","title":"doDelete"},{"location":"api/web/Weblet/#get","text":"public virtual void get( WebReq req, WebRes res) Service a GET request.","title":"get"},{"location":"api/web/Weblet/#head","text":"public virtual void head( WebReq req, WebRes res) Service a HEAD request.","title":"head"},{"location":"api/web/Weblet/#post","text":"public virtual void post( WebReq req, WebRes res) Service a POST request.","title":"post"},{"location":"api/web/Weblet/#prefix","text":"public abstract Str prefix() Get the weblet's prefix which should be a simple name (no slash) used for routing URIs to this Weblet.","title":"prefix"},{"location":"api/web/Weblet/#put","text":"public virtual void put( WebReq req, WebRes res) Service a PUT request.","title":"put"},{"location":"api/web/Weblet/#register","text":"public void register() Register the weblet with the WebService.","title":"register"},{"location":"api/web/Weblet/#service","text":"public virtual void service( WebReq req, WebRes res) Service the specified request. Default implementation routes to get(), head(), post(), put(), or delete().","title":"service"},{"location":"api/web/Weblet/#unregister","text":"public void unregister() Remove this weblet from the WebService. Doc Home > API Index > web > Weblet","title":"unregister"},{"location":"appendix/conventions/","text":"Conventions \u00b6 Overview \u00b6 This chapter documents the coding conventions we use for the core Sedona Framework code, as well as the supporting Java and C code. Source Files \u00b6 Use 7-bit safe ASCII (subset of UTF-8) Prefer \"\\n\" unix line endings Prefer to put class Foo in source file called \"Foo.sedona\" Indentation \u00b6 Absolutely no tab characters, spaces only Two space indentation Allman styling curly braces: if (flag) { something() } else { somethingElse() } Prefer single statement on each line with no semicolon Leave one space between keyword and opening paren for statements such as if and while . Naming \u00b6 Name classes with upper camel case such as \"Foo\" and \"FooBar\" Name everything else with lower camel case such as \"foo\" and \"fooBar\" including kit names, field names, method names, local variables, and facets Do not use screaming caps such as FOO_BAR (except for defined constants) Comments \u00b6 Prefer /* */ for commenting out sections of code Prefer leading and trailing ** in doc sections, especially for methods: ** ** This is a method that does something. ** Void something() Break logical sections up using line of 65 / chars: //////////////////////////////////////////////////////////////// // Methods //////////////////////////////////////////////////////////////// Use Javadoc-style /** */ comments on classes, methods, and fields so that sedonac can auto-generate documentation for them. Facets \u00b6 All facets should be on the line above the property definition. Exception: The @config facet should always be on the same line as the property definition. @min = 0 @max = minutesInADay @unit = Units . minute @config property short duration @min = 0 @max = 100 property int range @asStr property Buf ( 32 ) filename = \"foo.txt\"","title":"Coding Conventions"},{"location":"appendix/conventions/#conventions","text":"","title":"Conventions"},{"location":"appendix/conventions/#overview","text":"This chapter documents the coding conventions we use for the core Sedona Framework code, as well as the supporting Java and C code.","title":"Overview"},{"location":"appendix/conventions/#source-files","text":"Use 7-bit safe ASCII (subset of UTF-8) Prefer \"\\n\" unix line endings Prefer to put class Foo in source file called \"Foo.sedona\"","title":"Source Files"},{"location":"appendix/conventions/#indentation","text":"Absolutely no tab characters, spaces only Two space indentation Allman styling curly braces: if (flag) { something() } else { somethingElse() } Prefer single statement on each line with no semicolon Leave one space between keyword and opening paren for statements such as if and while .","title":"Indentation"},{"location":"appendix/conventions/#naming","text":"Name classes with upper camel case such as \"Foo\" and \"FooBar\" Name everything else with lower camel case such as \"foo\" and \"fooBar\" including kit names, field names, method names, local variables, and facets Do not use screaming caps such as FOO_BAR (except for defined constants)","title":"Naming"},{"location":"appendix/conventions/#comments","text":"Prefer /* */ for commenting out sections of code Prefer leading and trailing ** in doc sections, especially for methods: ** ** This is a method that does something. ** Void something() Break logical sections up using line of 65 / chars: //////////////////////////////////////////////////////////////// // Methods //////////////////////////////////////////////////////////////// Use Javadoc-style /** */ comments on classes, methods, and fields so that sedonac can auto-generate documentation for them.","title":"Comments"},{"location":"appendix/conventions/#facets","text":"All facets should be on the line above the property definition. Exception: The @config facet should always be on the same line as the property definition. @min = 0 @max = minutesInADay @unit = Units . minute @config property short duration @min = 0 @max = 100 property int range @asStr property Buf ( 32 ) filename = \"foo.txt\"","title":"Facets"},{"location":"appendix/grammar/","text":"Grammar \u00b6 Sedona Grammar \u00b6 The Sedona grammar document formally describes the Sedona language.","title":"Grammar"},{"location":"appendix/grammar/#grammar","text":"","title":"Grammar"},{"location":"appendix/grammar/#sedona-grammar","text":"The Sedona grammar document formally describes the Sedona language.","title":"Sedona Grammar"},{"location":"appendix/license/","text":"The Sedona Framework Open Source License \u00b6 The License, granted by Tridium, Inc. (\"Licensor\"), as set forth below, applies only to the computer software and documentation (collectively, the \"Original Work\") available for download at http://sedonadev.org , which Original Work is copyright \u00a9 2006-2013 Licensor. \"Sedona Framework\" is a trademark of Licensor that our community of customers, partners and developers recognize as an indicator of quality and compatibility. For the avoidance of doubt, the License set forth below does not grant any right to use the \"Sedona Framework\" trademark in connection with the sale, offer for sale or distribution of any product or service. Licensor offers a program that allows you to apply for a permission or license to use the Sedona Framework trademark and related logo to indicate technological compatibility of products you develop with other products built on the Sedona Framework or Niagara Framework. The Powered by Sedona Framework logo is available for your use upon acceptance of your application by Tridium and your acceptance of the terms of the applicable agreement with Tridium. For more information on becoming authorized to use the \"Powered by Sedona Framework\" trademark, go to the certification program page. If you are not authorized by contract with Tridium to use the Sedona Framework logo, the correct way to state that you used the Sedona Framework to build a product is: \"The [insert name of your product] was built on the Sedona Framework\u0099.\" If you make this statement, you should also include in the text of the document or product packaging in which it is used the statement that \"Sedona Framework is a trademark of Tridium, Inc.\" or otherwise indicate that the trademark does not belong to you. Academic Free License (\"AFL\") v. 3.0 \u00b6 This Academic Free License (the \"License\") applies to any original work of authorship (the \"Original Work\") whose owner (the \"Licensor\") has placed the following licensing notice adjacent to the copyright notice for the Original Work: Licensed under the Academic Free License version 3.0 Grant of Copyright License. Licensor grants You a worldwide, royalty-free, non-exclusive, sublicensable license, for the duration of the copyright, to do the following: a. to reproduce the Original Work in copies, either alone or as part of a collective work; b. to translate, adapt, alter, transform, modify, or arrange the Original Work, thereby creating derivative works (\"Derivative Works\") based upon the Original Work; c. to distribute or communicate copies of the Original Work and Derivative Works to the public, under any license of your choice that does not contradict the terms and conditions, including Licensor's reserved rights and remedies, in this Academic Free License; d. to perform the Original Work publicly; and e. to display the Original Work publicly. Grant of Patent License. Licensor grants You a worldwide, royalty-free, non-exclusive, sublicensable license, under patent claims owned or controlled by the Licensor that are embodied in the Original Work as furnished by the Licensor, for the duration of the patents, to make, use, sell, offer for sale, have made, and import the Original Work and Derivative Works. Grant of Source Code License. The term \"Source Code\" means the preferred form of the Original Work for making modifications to it and all available documentation describing how to modify the Original Work. Licensor agrees to provide a machine-readable copy of the Source Code of the Original Work along with each copy of the Original Work that Licensor distributes. Licensor reserves the right to satisfy this obligation by placing a machine-readable copy of the Source Code in an information repository reasonably calculated to permit inexpensive and convenient access by You for as long as Licensor continues to distribute the Original Work. Exclusions From License Grant. Neither the names of Licensor, nor the names of any contributors to the Original Work, nor any of their trademarks or service marks, may be used to endorse or promote products derived from this Original Work without express prior permission of the Licensor. Except as expressly stated herein, nothing in this License grants any license to Licensor's trademarks, copyrights, patents, trade secrets or any other intellectual property. No patent license is granted to make, use, sell, offer for sale, have made, or import embodiments of any patent claims other than the licensed claims defined in Section 2. No license is granted to the trademarks of Licensor even if such marks are included in the Original Work. Nothing in this License shall be interpreted to prohibit Licensor from licensing under terms different from this License any Original Work that Licensor otherwise would have a right to license. External Deployment. The term \"External Deployment\" means the use, distribution, or communication of the Original Work or Derivative Works in any way such that the Original Work or Derivative Works may be used by anyone other than You, whether those works are distributed or communicated to those persons or made available as an application intended for use over a network. As an express condition for the grants of license hereunder, You must treat any External Deployment by You of the Original Work or a Derivative Work as a distribution under section 1\u00a9. Attribution Rights. You must retain, in the Source Code of any Derivative Works that You create, all copyright, patent, or trademark notices from the Source Code of the Original Work, as well as any notices of licensing and any descriptive text identified therein as an \"Attribution Notice.\" You must cause the Source Code for any Derivative Works that You create to carry a prominent Attribution Notice reasonably calculated to inform recipients that You have modified the Original Work. Warranty of Provenance and Disclaimer of Warranty. Licensor warrants that the copyright in and to the Original Work and the patent rights granted herein by Licensor are owned by the Licensor or are sublicensed to You under the terms of this License with the permission of the contributor(s) of those copyrights and patent rights. Except as expressly stated in the immediately preceding sentence, the Original Work is provided under this License on an \"AS IS\" BASIS and WITHOUT WARRANTY, either express or implied, including, without limitation, the warranties of non-infringement, merchantability or fitness for a particular purpose. THE ENTIRE RISK AS TO THE QUALITY OF THE ORIGINAL WORK IS WITH YOU. This DISCLAIMER OF WARRANTY constitutes an essential part of this License. No license to the Original Work is granted by this License except under this disclaimer. Limitation of Liability. Under no circumstances and under no legal theory, whether in tort (including negligence), contract, or otherwise, shall the Licensor be liable to anyone for any indirect, special, incidental, or consequential damages of any character arising as a result of this License or the use of the Original Work including, without limitation, damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses. This limitation of liability shall not apply to the extent applicable law prohibits such limitation. Acceptance and Termination. If, at any time, You expressly assented to this License, that assent indicates your clear and irrevocable acceptance of this License and all of its terms and conditions. If You distribute or communicate copies of the Original Work or a Derivative Work, You must make a reasonable effort under the circumstances to obtain the express assent of recipients to the terms of this License. This License conditions your rights to undertake the activities listed in Section 1, including your right to create Derivative Works based upon the Original Work, and doing so without honoring these terms and conditions is prohibited by copyright law and international treaty. Nothing in this License is intended to affect copyright exceptions and limitations (including \"fair use\" or \"fair dealing\"). This License shall terminate immediately and You may no longer exercise any of the rights granted to You by this License upon your failure to honor the conditions in Section 1\u00a9. Termination for Patent Action. This License shall terminate automatically and You may no longer exercise any of the rights granted to You by this License as of the date You commence an action, including a cross-claim or counterclaim, against Licensor or any licensee alleging that the Original Work infringes a patent. This termination provision shall not apply for an action alleging patent infringement by combinations of the Original Work with other software or hardware. Jurisdiction, Venue and Governing Law. Any action or suit relating to this License may be brought only in the courts of a jurisdiction wherein the Licensor resides or in which Licensor conducts its primary business, and under the laws of that jurisdiction excluding its conflict-of-law provisions. The application of the United Nations Convention on Contracts for the International Sale of Goods is expressly excluded. Any use of the Original Work outside the scope of this License or after its termination shall be subject to the requirements and penalties of copyright or patent law in the appropriate jurisdiction. This section shall survive the termination of this License. Attorneys' Fees. In any action to enforce the terms of this License or seeking damages relating thereto, the prevailing party shall be entitled to recover its costs and expenses, including, without limitation, reasonable attorneys' fees and costs incurred in connection with such action, including any appeal of such action. This section shall survive the termination of this License. Miscellaneous. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Definition of \"You\" in This License. \"You\" throughout this License, whether in upper or lower case, means an individual or a legal entity exercising rights under, and complying with all of the terms of, this License. For legal entities, \"You\" includes any entity that controls, is controlled by, or is under common control with you. For purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. Right to Use. You may use the Original Work in all ways not otherwise restricted or conditioned by this License or by law, and Licensor promises not to interfere with or be responsible for such uses by You. Modification of This License. This License is Copyright \u00a9 2005 Lawrence Rosen. Permission is granted to copy, distribute, or communicate this License without modification. Nothing in this License permits You to modify this License as applied to the Original Work or to Derivative Works. However, You may modify the text of this License and copy, distribute or communicate your modified version (the \"Modified License\") and apply it to other original works of authorship subject to the following conditions: (i) You may not indicate in any way that your Modified License is the \"Academic Free License\" or \"AFL\" and you may not use those names in the name of your Modified License; (ii) You must replace the notice specified in the first paragraph above with the notice \"Licensed under <insert your license name here>\" or with a notice of your own that is not confusingly similar to the notice in this License; and (iii) You may not claim that your original works are open source software unless your Modified License has been approved by Open Source Initiative (OSI) and You comply with its license review and certification process.","title":"License"},{"location":"appendix/license/#the-sedona-framework-open-source-license","text":"The License, granted by Tridium, Inc. (\"Licensor\"), as set forth below, applies only to the computer software and documentation (collectively, the \"Original Work\") available for download at http://sedonadev.org , which Original Work is copyright \u00a9 2006-2013 Licensor. \"Sedona Framework\" is a trademark of Licensor that our community of customers, partners and developers recognize as an indicator of quality and compatibility. For the avoidance of doubt, the License set forth below does not grant any right to use the \"Sedona Framework\" trademark in connection with the sale, offer for sale or distribution of any product or service. Licensor offers a program that allows you to apply for a permission or license to use the Sedona Framework trademark and related logo to indicate technological compatibility of products you develop with other products built on the Sedona Framework or Niagara Framework. The Powered by Sedona Framework logo is available for your use upon acceptance of your application by Tridium and your acceptance of the terms of the applicable agreement with Tridium. For more information on becoming authorized to use the \"Powered by Sedona Framework\" trademark, go to the certification program page. If you are not authorized by contract with Tridium to use the Sedona Framework logo, the correct way to state that you used the Sedona Framework to build a product is: \"The [insert name of your product] was built on the Sedona Framework\u0099.\" If you make this statement, you should also include in the text of the document or product packaging in which it is used the statement that \"Sedona Framework is a trademark of Tridium, Inc.\" or otherwise indicate that the trademark does not belong to you.","title":"The Sedona Framework Open Source License"},{"location":"appendix/license/#academic-free-license-afl-v-30","text":"This Academic Free License (the \"License\") applies to any original work of authorship (the \"Original Work\") whose owner (the \"Licensor\") has placed the following licensing notice adjacent to the copyright notice for the Original Work: Licensed under the Academic Free License version 3.0 Grant of Copyright License. Licensor grants You a worldwide, royalty-free, non-exclusive, sublicensable license, for the duration of the copyright, to do the following: a. to reproduce the Original Work in copies, either alone or as part of a collective work; b. to translate, adapt, alter, transform, modify, or arrange the Original Work, thereby creating derivative works (\"Derivative Works\") based upon the Original Work; c. to distribute or communicate copies of the Original Work and Derivative Works to the public, under any license of your choice that does not contradict the terms and conditions, including Licensor's reserved rights and remedies, in this Academic Free License; d. to perform the Original Work publicly; and e. to display the Original Work publicly. Grant of Patent License. Licensor grants You a worldwide, royalty-free, non-exclusive, sublicensable license, under patent claims owned or controlled by the Licensor that are embodied in the Original Work as furnished by the Licensor, for the duration of the patents, to make, use, sell, offer for sale, have made, and import the Original Work and Derivative Works. Grant of Source Code License. The term \"Source Code\" means the preferred form of the Original Work for making modifications to it and all available documentation describing how to modify the Original Work. Licensor agrees to provide a machine-readable copy of the Source Code of the Original Work along with each copy of the Original Work that Licensor distributes. Licensor reserves the right to satisfy this obligation by placing a machine-readable copy of the Source Code in an information repository reasonably calculated to permit inexpensive and convenient access by You for as long as Licensor continues to distribute the Original Work. Exclusions From License Grant. Neither the names of Licensor, nor the names of any contributors to the Original Work, nor any of their trademarks or service marks, may be used to endorse or promote products derived from this Original Work without express prior permission of the Licensor. Except as expressly stated herein, nothing in this License grants any license to Licensor's trademarks, copyrights, patents, trade secrets or any other intellectual property. No patent license is granted to make, use, sell, offer for sale, have made, or import embodiments of any patent claims other than the licensed claims defined in Section 2. No license is granted to the trademarks of Licensor even if such marks are included in the Original Work. Nothing in this License shall be interpreted to prohibit Licensor from licensing under terms different from this License any Original Work that Licensor otherwise would have a right to license. External Deployment. The term \"External Deployment\" means the use, distribution, or communication of the Original Work or Derivative Works in any way such that the Original Work or Derivative Works may be used by anyone other than You, whether those works are distributed or communicated to those persons or made available as an application intended for use over a network. As an express condition for the grants of license hereunder, You must treat any External Deployment by You of the Original Work or a Derivative Work as a distribution under section 1\u00a9. Attribution Rights. You must retain, in the Source Code of any Derivative Works that You create, all copyright, patent, or trademark notices from the Source Code of the Original Work, as well as any notices of licensing and any descriptive text identified therein as an \"Attribution Notice.\" You must cause the Source Code for any Derivative Works that You create to carry a prominent Attribution Notice reasonably calculated to inform recipients that You have modified the Original Work. Warranty of Provenance and Disclaimer of Warranty. Licensor warrants that the copyright in and to the Original Work and the patent rights granted herein by Licensor are owned by the Licensor or are sublicensed to You under the terms of this License with the permission of the contributor(s) of those copyrights and patent rights. Except as expressly stated in the immediately preceding sentence, the Original Work is provided under this License on an \"AS IS\" BASIS and WITHOUT WARRANTY, either express or implied, including, without limitation, the warranties of non-infringement, merchantability or fitness for a particular purpose. THE ENTIRE RISK AS TO THE QUALITY OF THE ORIGINAL WORK IS WITH YOU. This DISCLAIMER OF WARRANTY constitutes an essential part of this License. No license to the Original Work is granted by this License except under this disclaimer. Limitation of Liability. Under no circumstances and under no legal theory, whether in tort (including negligence), contract, or otherwise, shall the Licensor be liable to anyone for any indirect, special, incidental, or consequential damages of any character arising as a result of this License or the use of the Original Work including, without limitation, damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses. This limitation of liability shall not apply to the extent applicable law prohibits such limitation. Acceptance and Termination. If, at any time, You expressly assented to this License, that assent indicates your clear and irrevocable acceptance of this License and all of its terms and conditions. If You distribute or communicate copies of the Original Work or a Derivative Work, You must make a reasonable effort under the circumstances to obtain the express assent of recipients to the terms of this License. This License conditions your rights to undertake the activities listed in Section 1, including your right to create Derivative Works based upon the Original Work, and doing so without honoring these terms and conditions is prohibited by copyright law and international treaty. Nothing in this License is intended to affect copyright exceptions and limitations (including \"fair use\" or \"fair dealing\"). This License shall terminate immediately and You may no longer exercise any of the rights granted to You by this License upon your failure to honor the conditions in Section 1\u00a9. Termination for Patent Action. This License shall terminate automatically and You may no longer exercise any of the rights granted to You by this License as of the date You commence an action, including a cross-claim or counterclaim, against Licensor or any licensee alleging that the Original Work infringes a patent. This termination provision shall not apply for an action alleging patent infringement by combinations of the Original Work with other software or hardware. Jurisdiction, Venue and Governing Law. Any action or suit relating to this License may be brought only in the courts of a jurisdiction wherein the Licensor resides or in which Licensor conducts its primary business, and under the laws of that jurisdiction excluding its conflict-of-law provisions. The application of the United Nations Convention on Contracts for the International Sale of Goods is expressly excluded. Any use of the Original Work outside the scope of this License or after its termination shall be subject to the requirements and penalties of copyright or patent law in the appropriate jurisdiction. This section shall survive the termination of this License. Attorneys' Fees. In any action to enforce the terms of this License or seeking damages relating thereto, the prevailing party shall be entitled to recover its costs and expenses, including, without limitation, reasonable attorneys' fees and costs incurred in connection with such action, including any appeal of such action. This section shall survive the termination of this License. Miscellaneous. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Definition of \"You\" in This License. \"You\" throughout this License, whether in upper or lower case, means an individual or a legal entity exercising rights under, and complying with all of the terms of, this License. For legal entities, \"You\" includes any entity that controls, is controlled by, or is under common control with you. For purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. Right to Use. You may use the Original Work in all ways not otherwise restricted or conditioned by this License or by law, and Licensor promises not to interfere with or be responsible for such uses by You. Modification of This License. This License is Copyright \u00a9 2005 Lawrence Rosen. Permission is granted to copy, distribute, or communicate this License without modification. Nothing in this License permits You to modify this License as applied to the Original Work or to Derivative Works. However, You may modify the text of this License and copy, distribute or communicate your modified version (the \"Modified License\") and apply it to other original works of authorship subject to the following conditions: (i) You may not indicate in any way that your Modified License is the \"Academic Free License\" or \"AFL\" and you may not use those names in the name of your Modified License; (ii) You must replace the notice specified in the first paragraph above with the notice \"Licensed under <insert your license name here>\" or with a notice of your own that is not confusingly similar to the notice in this License; and (iii) You may not claim that your original works are open source software unless your Modified License has been approved by Open Source Initiative (OSI) and You comply with its license review and certification process.","title":"Academic Free License (\"AFL\") v. 3.0"},{"location":"appendix/scodeFormat/","text":"SCode Format \u00b6 Image Format \u00b6 image { header header item[] items // each item aligned by swSize } header { 0: u4 magic: 0x5ED0BA07 for big endian, 0x07BAD05E for little endian 4: u1 majorVer: 1 5: u1 minorVer: 0 6: u1 blockSize: addr = blockIndex*blockSize + codeBaseAddr 7: u1 refSize: num bytes in address pointers 8: u4 imageSize: num bytes of whole image including full header 12: u4 dataSize: num bytes for static field data 16: bix main method block index 18: bix test table 20: bix kits array block index 22: u1 number of kits in kits array } item { vtable | kit | type | int | float | long | double | str | slot | log | method | tests | qnameType | qnameSlot } vtable { u2[] block indexes to each virtual method } kit { // see sys::Kit field memory layout } type { // see sys::Type field memory layout } slot { // see sys::Slot field memory layout } log { // see sys::Log field memory layout } int { 0: s4 32-bit integer constants } long { 0: s8 64-bit integer constants } float { 0: f4 32-bit float constants } double { 0: f8 64-bit double constants } str { 0: u1[] ASCII char string terminated by 0 (C string literal) } method { 0: u1 numParams (including implicit this) 1: u1 numLocals 2: u1[] opcodes } tests { u2 count test[] table } test { u2: qnameSlot u2: test method } qnameType { u2: kit name str index u2: type name str index } qnameSlot { u2: qnameType index u2: slot name str index }","title":"SCode Format"},{"location":"appendix/scodeFormat/#scode-format","text":"","title":"SCode Format"},{"location":"appendix/scodeFormat/#image-format","text":"image { header header item[] items // each item aligned by swSize } header { 0: u4 magic: 0x5ED0BA07 for big endian, 0x07BAD05E for little endian 4: u1 majorVer: 1 5: u1 minorVer: 0 6: u1 blockSize: addr = blockIndex*blockSize + codeBaseAddr 7: u1 refSize: num bytes in address pointers 8: u4 imageSize: num bytes of whole image including full header 12: u4 dataSize: num bytes for static field data 16: bix main method block index 18: bix test table 20: bix kits array block index 22: u1 number of kits in kits array } item { vtable | kit | type | int | float | long | double | str | slot | log | method | tests | qnameType | qnameSlot } vtable { u2[] block indexes to each virtual method } kit { // see sys::Kit field memory layout } type { // see sys::Type field memory layout } slot { // see sys::Slot field memory layout } log { // see sys::Log field memory layout } int { 0: s4 32-bit integer constants } long { 0: s8 64-bit integer constants } float { 0: f4 32-bit float constants } double { 0: f8 64-bit double constants } str { 0: u1[] ASCII char string terminated by 0 (C string literal) } method { 0: u1 numParams (including implicit this) 1: u1 numLocals 2: u1[] opcodes } tests { u2 count test[] table } test { u2: qnameSlot u2: test method } qnameType { u2: kit name str index u2: type name str index } qnameSlot { u2: qnameType index u2: slot name str index }","title":"Image Format"},{"location":"apps/apps/","text":"Apps \u00b6 Overview \u00b6 Applications for the Sedona Framework are designed and deployed according to the component model, which separates the code from the application. In this architecture you have a clean boundary between the code packaged into kits and the application defined as a tree of components defined in those kits. This model allows you to build applications simply by assembling components, configuring their properties, and linking slots together to define control flow. This style of programming is especially amenable to graphical programming. So when we refer to a Sedona Framework application, we are really talking about a tree of components assembled together. An application is purely declarative, all the code is encapsulated in the kits. The application itself is stored as a file using one of two file formats: SAX : a simple XML representation of the application that is easily generated and consumed by software tools SAB : a compact binary representation of the application, suitable for storage and execution on a Sedona Framework-enabled device You can convert between the two file formats using sedonac . Boot Strap \u00b6 Applications are boot-strapped in the following phases: Loaded : Each component is loaded from the SAB file into memory and its Component.loaded() callback is invoked. Start : Once all the components are loaded, each component has its Component.start() callback invoked. Running : The application enters the main execution loop (described next). Execution \u00b6 The Sedona Framework's execution model is based a single-threaded main loop with a fixed scan rate: Recursively execute components. For each component: a. Step through the component's list of children and execute them first b. Propagate incoming links to this component c. Call this component's execute() virtual method 2. Give any remaining time in the scan cycle to services via Service.work() 3. If no services have remaining work, then relinquish CPU (via yield or sleep) until next cycle Controlling child execution rate \u00b6 For Sedona 1.2 a new virtual method was added to the Component class. If a component's allowChildExecute() returns false , then the app will skip (1a), the recursive step through the component's child components. It will simply call execute() on the current component and then go on to the next one at the same hierarchy level. (The base class version of the method always returns true , which preserves pre-1.2 behavior.) This method can be overridden to force child components to be executed at a slower rate than the main loop. As an example, there is a new component sys::RateFolder that uses this strategy to provide multi-rate app functionality. Yield vs Sleep \u00b6 Depending on the underlying execution environment, the App can either return control to the OS (exit the SVM) or sleep until it's time to run again. Preemptive multithreaded OS \u00b6 These include Windows, Linux or QNX. When a thread calls the OS sleep primitive, other threads are given a chance to run. The SVM thread may be swapped in and out several times during an execute cycle. Main Loop \u00b6 In this environment, the Sedona VM executes as the main loop and all other work is done at ISR level. Once the App completes an execute cycle, it can delay by entering a busy-wait loop. Cooperative tasking OS \u00b6 In this environment, a task must return control to the scheduler to allow other tasks a chance to run. The sleep and busy-wait approaches won't work here since the SVM will never exit, so the SVM must support a clean exit and re-entry. This is accomplished by the yield mechanism described below. Yield \u00b6 The Sedona Framework supports yielding to provide a graceful exit (and subsequent reentry) of the SVM, allowing the platform CPU to perform other operations. Systems that require yield functionality must override the following methods of PlatformService : yieldRequired() - returns true if the SVM should exit after each App execute cycle yield(long yieldTime) - indicates the SVM will be exiting and requests to be resumed in yieldTime nanoseconds If a PlatformService subclass returns true to yieldRequired(), then the App will exit with the error code ERR_YIELD after each execution loop. On exiting, the App will call yield(yieldTime) to determine how soon it needs to be resumed. Native code should resume the SVM via vmResume(SedonaVM*) as soon as possible, but before the requested time. If vmResume is not called before yieldTime expires, App cycle overruns could occur. Hibernation \u00b6 When entering hibernation, the App exits and returns control to the bootstrap code. It is similar to yield but it is expected that the hibernation time will be much longer than a typical yield time. Hibernation is driven by application logic and most likely will not occur each App execute cycle, whereas yield must occur each cycle. To enter the hibernation state, an application calls App.hibernate() . This will set a flag on App and when the current execution cycle is complete, it will cause the App to exit with error code ERR_HIBERNATE . This will gracefully unwind the call stack, returning control to the boot code. The device's boot code should then put the device to sleep. It is a device dependent issue to decide how it will wake up from hibernation. When the device does wake, it should restart the SVM with a call to vmResume(SedonaVM*) . If your device doesn't support hibernation, then you will need to simulate it using code such as the following: result = vmRun ( & vm ); while ( result == ERR_HIBERNATE ) { //printf(\"-- Simulated hibernate --\\n\"); result = vmResume ( & vm ); } If you are developing Sedona Framework components, applications, or drivers you should keep hibernation in mind. Any software that might run on a battery powered device needs to support hibernation cleanly. This means that function blocks should assume the scan rate might have hibernation pauses. If you have services that need to do something special when hibernating or waking, then you will need to override the functions Service.onHibernate() and Service.onUnhibernate() . Service.onHibernate() will be called prior to SVM exit. Service.onUnhibernate() will be called after the SVM is resumed and prior to the App execution loop starting back up. Steady State \u00b6 Most apps will be fully operational by the end of the first cycle. When hardware I/O is involved, however, an app may need to allow additional time for the hardware to warm up, or for complex logic results to propagate fully to all components. For this purpose, the Sedona Framework provides a \"steady state\" timing feature that should be used to protect the hardware from reading or writing transient values while the app is starting up. The steady state feature consists of two pieces: timeToSteadyState : This integer specifies the time delay between the start of app execution and the time at which the app is assumed to be in \"steady state\". It is a config property of the App class, so it can be set in the app definition (.sax file) or at runtime from a remote access tool (e.g. the App property sheet in Sedona Framework Workbench). The default value is 0, meaning that the delay ends when the app enters the \"Running\" phase described above. The correct value for a given App will vary depending on the application logic and the specific hardware involved. - isSteadyState() : This is a method that returns true if the app has entered \"steady state\" mode, i.e. if the time delay defined by timeToSteadyState has elapsed, and false otherwise. Once steady state mode is reached, this method will continue to return true until the app is restarted. Code that affects hardware on the native level should use this method to avoid reading or writing hardware values until steady state is reached. Note : This feature is not used internally within the App. It only affects behavior of components that use the isSteadyState() method. It is the responsibility of each kit developer to call this method as needed to protect the hardware. By default, App.timeToSteadyState applies only to the first time the SVM is started. Once steady time has elapsed, hibernate/yield will not affect it. If App.hibernationResetsSteadyState is set to true, then the steady state flag will be cleared each time device exits hibernation. Links \u00b6 Links are the mechanism used to define control flow in an app. Links are said to be from a given component's slot to another component's slot. Currently links are supported only between properties; you cannot link to an action slot. During link propagation, the from-property value is copied into the to-property . This mechanism could be used, for example, to link sensor inputs through control logic to control actuator outputs. Services \u00b6 Services are special components that subclass from sys::Service . Services have three primary characteristics that set them apart from other types of components: Type Lookup : Services are easy to lookup by type via the App.lookupService method. This allows other components in the App to find a given service at runtime simply by knowing its type. Background work : Other components get a single callback, execute() , to do work during a scan cycle. Service components, on the other hand, have an additional callback, work() to handle background work during any time available at the end of a given scan cycle. Hibernation control : Each time the App finishes an execute cycle, it calls Service.canHibernate() on all services. If a service is not in a state where it can hibernate, it should return false. (For example, if a service is waiting for a network reply, it would return false.) Platform services for devices that never need to hibernate should always return false. Services are often used to provide functionality to other components. For example the UserService is used to lookup and authenticate user accounts. Many services such as protocol drivers also perform background work to service network messages. SAX File Format \u00b6 A SAX file is structured as follows: <sedonaApp> <schema> <kit name= 'sys' /> ... </schema> <app> <comp name= \"play\" id= \"1\" type= \"sys::Folder\" > <comp name= \"rampA\" id= \"7\" type= \"control::Ramp\" > <prop name= \"min\" val= \"20.00000\" /> <prop name= \"max\" val= \"80.00000\" /> </comp> ... </comp> ... </app> <links> <link from= \"/play/rampA.out\" to= \"/play/something.else\" /> ... </links> </sedonaApp> <sedonaApp> root element that contains: <schema> : contains <kit> elements <app> : contains <comp> elements <links> : contains <link> elements <kit> defines the kits used by the application: name : required kit name checksum : optional kit checksum; if omitted the latest version of the kit is assumed <comp> defines each component in the application: <comp> : nested elements map to nested components <prop> : property configuration for the component name : required name of component (limited in length) type : required qname of the component's type id : optional two byte identifier; if omitted an id is auto-generated <prop> defines the property value of a component within a <comp> element. Supported attributes: name : required name of property val : required value. Buf properties should be a base64 encoded value (unless asStr in which case just use string value). <link> element defines a link between two slots using the format of /path/comp.slot : from : the from component and slot name to : the to component and slot name SAB Files \u00b6 While XML is a nice representation for tools to work with app files, XML is too big and difficult to work with in an embedded device. So we use the SAB format when we need a compact binary representation. Sedona Framework devices typically store their application as an SAB file (although often it might just be a location in flash memory versus a real file system). Schemas \u00b6 Sedona Framework application files, whether stored as SAX or SAB format, always contain a schema . This is simply a list of the kits (with matching kit checksums) that the app requires in order to run. The Sedona VM cannot start the app if its current scode image does not contain all the kits in the app's schema. APIs \u00b6 If you want to develop tools for managing Sedona apps, check out the sedona.offline Java APIs for working with both SAX and SAB files: OfflineApp.encodeAppXml OfflineApp.decodeAppXml OfflineApp.encodeAppBinary OfflineApp.decodeAppBinary","title":"Application Model"},{"location":"apps/apps/#apps","text":"","title":"Apps"},{"location":"apps/apps/#overview","text":"Applications for the Sedona Framework are designed and deployed according to the component model, which separates the code from the application. In this architecture you have a clean boundary between the code packaged into kits and the application defined as a tree of components defined in those kits. This model allows you to build applications simply by assembling components, configuring their properties, and linking slots together to define control flow. This style of programming is especially amenable to graphical programming. So when we refer to a Sedona Framework application, we are really talking about a tree of components assembled together. An application is purely declarative, all the code is encapsulated in the kits. The application itself is stored as a file using one of two file formats: SAX : a simple XML representation of the application that is easily generated and consumed by software tools SAB : a compact binary representation of the application, suitable for storage and execution on a Sedona Framework-enabled device You can convert between the two file formats using sedonac .","title":"Overview"},{"location":"apps/apps/#boot-strap","text":"Applications are boot-strapped in the following phases: Loaded : Each component is loaded from the SAB file into memory and its Component.loaded() callback is invoked. Start : Once all the components are loaded, each component has its Component.start() callback invoked. Running : The application enters the main execution loop (described next).","title":"Boot Strap"},{"location":"apps/apps/#execution","text":"The Sedona Framework's execution model is based a single-threaded main loop with a fixed scan rate: Recursively execute components. For each component: a. Step through the component's list of children and execute them first b. Propagate incoming links to this component c. Call this component's execute() virtual method 2. Give any remaining time in the scan cycle to services via Service.work() 3. If no services have remaining work, then relinquish CPU (via yield or sleep) until next cycle","title":"Execution"},{"location":"apps/apps/#controlling-child-execution-rate","text":"For Sedona 1.2 a new virtual method was added to the Component class. If a component's allowChildExecute() returns false , then the app will skip (1a), the recursive step through the component's child components. It will simply call execute() on the current component and then go on to the next one at the same hierarchy level. (The base class version of the method always returns true , which preserves pre-1.2 behavior.) This method can be overridden to force child components to be executed at a slower rate than the main loop. As an example, there is a new component sys::RateFolder that uses this strategy to provide multi-rate app functionality.","title":"Controlling child execution rate"},{"location":"apps/apps/#yield-vs-sleep","text":"Depending on the underlying execution environment, the App can either return control to the OS (exit the SVM) or sleep until it's time to run again.","title":"Yield vs Sleep"},{"location":"apps/apps/#preemptive-multithreaded-os","text":"These include Windows, Linux or QNX. When a thread calls the OS sleep primitive, other threads are given a chance to run. The SVM thread may be swapped in and out several times during an execute cycle.","title":"Preemptive multithreaded OS"},{"location":"apps/apps/#main-loop","text":"In this environment, the Sedona VM executes as the main loop and all other work is done at ISR level. Once the App completes an execute cycle, it can delay by entering a busy-wait loop.","title":"Main Loop"},{"location":"apps/apps/#cooperative-tasking-os","text":"In this environment, a task must return control to the scheduler to allow other tasks a chance to run. The sleep and busy-wait approaches won't work here since the SVM will never exit, so the SVM must support a clean exit and re-entry. This is accomplished by the yield mechanism described below.","title":"Cooperative tasking OS"},{"location":"apps/apps/#yield","text":"The Sedona Framework supports yielding to provide a graceful exit (and subsequent reentry) of the SVM, allowing the platform CPU to perform other operations. Systems that require yield functionality must override the following methods of PlatformService : yieldRequired() - returns true if the SVM should exit after each App execute cycle yield(long yieldTime) - indicates the SVM will be exiting and requests to be resumed in yieldTime nanoseconds If a PlatformService subclass returns true to yieldRequired(), then the App will exit with the error code ERR_YIELD after each execution loop. On exiting, the App will call yield(yieldTime) to determine how soon it needs to be resumed. Native code should resume the SVM via vmResume(SedonaVM*) as soon as possible, but before the requested time. If vmResume is not called before yieldTime expires, App cycle overruns could occur.","title":"Yield"},{"location":"apps/apps/#hibernation","text":"When entering hibernation, the App exits and returns control to the bootstrap code. It is similar to yield but it is expected that the hibernation time will be much longer than a typical yield time. Hibernation is driven by application logic and most likely will not occur each App execute cycle, whereas yield must occur each cycle. To enter the hibernation state, an application calls App.hibernate() . This will set a flag on App and when the current execution cycle is complete, it will cause the App to exit with error code ERR_HIBERNATE . This will gracefully unwind the call stack, returning control to the boot code. The device's boot code should then put the device to sleep. It is a device dependent issue to decide how it will wake up from hibernation. When the device does wake, it should restart the SVM with a call to vmResume(SedonaVM*) . If your device doesn't support hibernation, then you will need to simulate it using code such as the following: result = vmRun ( & vm ); while ( result == ERR_HIBERNATE ) { //printf(\"-- Simulated hibernate --\\n\"); result = vmResume ( & vm ); } If you are developing Sedona Framework components, applications, or drivers you should keep hibernation in mind. Any software that might run on a battery powered device needs to support hibernation cleanly. This means that function blocks should assume the scan rate might have hibernation pauses. If you have services that need to do something special when hibernating or waking, then you will need to override the functions Service.onHibernate() and Service.onUnhibernate() . Service.onHibernate() will be called prior to SVM exit. Service.onUnhibernate() will be called after the SVM is resumed and prior to the App execution loop starting back up.","title":"Hibernation"},{"location":"apps/apps/#steady-state","text":"Most apps will be fully operational by the end of the first cycle. When hardware I/O is involved, however, an app may need to allow additional time for the hardware to warm up, or for complex logic results to propagate fully to all components. For this purpose, the Sedona Framework provides a \"steady state\" timing feature that should be used to protect the hardware from reading or writing transient values while the app is starting up. The steady state feature consists of two pieces: timeToSteadyState : This integer specifies the time delay between the start of app execution and the time at which the app is assumed to be in \"steady state\". It is a config property of the App class, so it can be set in the app definition (.sax file) or at runtime from a remote access tool (e.g. the App property sheet in Sedona Framework Workbench). The default value is 0, meaning that the delay ends when the app enters the \"Running\" phase described above. The correct value for a given App will vary depending on the application logic and the specific hardware involved. - isSteadyState() : This is a method that returns true if the app has entered \"steady state\" mode, i.e. if the time delay defined by timeToSteadyState has elapsed, and false otherwise. Once steady state mode is reached, this method will continue to return true until the app is restarted. Code that affects hardware on the native level should use this method to avoid reading or writing hardware values until steady state is reached. Note : This feature is not used internally within the App. It only affects behavior of components that use the isSteadyState() method. It is the responsibility of each kit developer to call this method as needed to protect the hardware. By default, App.timeToSteadyState applies only to the first time the SVM is started. Once steady time has elapsed, hibernate/yield will not affect it. If App.hibernationResetsSteadyState is set to true, then the steady state flag will be cleared each time device exits hibernation.","title":"Steady State"},{"location":"apps/apps/#links","text":"Links are the mechanism used to define control flow in an app. Links are said to be from a given component's slot to another component's slot. Currently links are supported only between properties; you cannot link to an action slot. During link propagation, the from-property value is copied into the to-property . This mechanism could be used, for example, to link sensor inputs through control logic to control actuator outputs.","title":"Links"},{"location":"apps/apps/#services","text":"Services are special components that subclass from sys::Service . Services have three primary characteristics that set them apart from other types of components: Type Lookup : Services are easy to lookup by type via the App.lookupService method. This allows other components in the App to find a given service at runtime simply by knowing its type. Background work : Other components get a single callback, execute() , to do work during a scan cycle. Service components, on the other hand, have an additional callback, work() to handle background work during any time available at the end of a given scan cycle. Hibernation control : Each time the App finishes an execute cycle, it calls Service.canHibernate() on all services. If a service is not in a state where it can hibernate, it should return false. (For example, if a service is waiting for a network reply, it would return false.) Platform services for devices that never need to hibernate should always return false. Services are often used to provide functionality to other components. For example the UserService is used to lookup and authenticate user accounts. Many services such as protocol drivers also perform background work to service network messages.","title":"Services"},{"location":"apps/apps/#sax-file-format","text":"A SAX file is structured as follows: <sedonaApp> <schema> <kit name= 'sys' /> ... </schema> <app> <comp name= \"play\" id= \"1\" type= \"sys::Folder\" > <comp name= \"rampA\" id= \"7\" type= \"control::Ramp\" > <prop name= \"min\" val= \"20.00000\" /> <prop name= \"max\" val= \"80.00000\" /> </comp> ... </comp> ... </app> <links> <link from= \"/play/rampA.out\" to= \"/play/something.else\" /> ... </links> </sedonaApp> <sedonaApp> root element that contains: <schema> : contains <kit> elements <app> : contains <comp> elements <links> : contains <link> elements <kit> defines the kits used by the application: name : required kit name checksum : optional kit checksum; if omitted the latest version of the kit is assumed <comp> defines each component in the application: <comp> : nested elements map to nested components <prop> : property configuration for the component name : required name of component (limited in length) type : required qname of the component's type id : optional two byte identifier; if omitted an id is auto-generated <prop> defines the property value of a component within a <comp> element. Supported attributes: name : required name of property val : required value. Buf properties should be a base64 encoded value (unless asStr in which case just use string value). <link> element defines a link between two slots using the format of /path/comp.slot : from : the from component and slot name to : the to component and slot name","title":"SAX File Format"},{"location":"apps/apps/#sab-files","text":"While XML is a nice representation for tools to work with app files, XML is too big and difficult to work with in an embedded device. So we use the SAB format when we need a compact binary representation. Sedona Framework devices typically store their application as an SAB file (although often it might just be a location in flash memory versus a real file system).","title":"SAB Files"},{"location":"apps/apps/#schemas","text":"Sedona Framework application files, whether stored as SAX or SAB format, always contain a schema . This is simply a list of the kits (with matching kit checksums) that the app requires in order to run. The Sedona VM cannot start the app if its current scode image does not contain all the kits in the app's schema.","title":"Schemas"},{"location":"apps/apps/#apis","text":"If you want to develop tools for managing Sedona apps, check out the sedona.offline Java APIs for working with both SAX and SAB files: OfflineApp.encodeAppXml OfflineApp.decodeAppXml OfflineApp.encodeAppBinary OfflineApp.decodeAppBinary","title":"APIs"},{"location":"apps/security/","text":"Security \u00b6 Overview \u00b6 The Sedona Framework's security model is based upon the following principles: Users represent an authenticated user account (human or machine) Components are assigned to one or more of four security groups Slots are designated as operator level or admin level Users are assigned permission levels for the four groups Any network access such as Sox checks permissions before any operation Users \u00b6 Any Sedona Framework application that wishes to utilize security must include an instance of the sys::UserService containing at least one sys::User component. Each sys::User component represents a user account. User components must be direct children of the UserService. The Component.name of the User component is the username. Authentication \u00b6 Each User component stores a 20 byte cred property, which is the credentials hash of the user's password. Because credentials are a one-way hash, the password is never readable. Credentials are computed as follows: text = username + \":\" + password bytes = text from step 1 encoded as UTF-8 cred = SHA-1 hash of bytes in step 2 You can use the sedona.util.UserUtil to programmatically compute credentials. Or you can use the command line: D: \\s edona>sedonac sedona.util.UserUtil brian secret User: brian:secret Digest: 0x [ 74091bc2a1f43108df56281b6a74975bab86236f ] Base64: dAkbwqH0MQjfVigbanSXW6uGI28 = Network protocols that support authentication should work as follows: Generate a random nonce to be used only one time Send the nonce to the client Client should generate its credentials from username and password Client creates digest by hashing the credentials from step 3 with the nonce Client sends digest from step 4 to server Server computes expected digest from nonce and known credentials If client's digest from step 5 matches server's digest from step 6 then client is authenticated If a protocol doesn't support authentication, then it should define a configuration property that references a user account to use for security checking. Groups \u00b6 Components are assigned into one or more security groups. There are four security groups indicated by the least significant nibble in the Component.meta property: Group Value Group 1 0x01 Group 2 0x02 Group 3 0x04 Group 4 0x08 Components can be in multiple groups. For example: to assign a component to groups 2 and 3, set the bottom nibble of Component.meta to 0x06 . If a component is not included in any groups, then that component is not network accessible. Slots \u00b6 Every slot in a component is defined as operator level or admin level for security purposes. By default a slot is admin level. You can mark a slot operator level with the @operator facet. Use Slot.isOperator() to check a slot's level. Permissions \u00b6 There are seven security permissions defined as a bitmask: User Permission Bitmask User.or operator read 0x01 User.ow operator write 0x02 User.oi operator invoke 0x04 User.ar admin read 0x08 User.aw admin write 0x10 User.ai admin invoke 0x20 User.ua user admin 0x40 Users are granted zero or more of each of these seven permissions for each user group via the User.perm property. Each group's permissions is stored in a byte: Group Byte Group 1 byte 0 Group 2 byte 1 Group 3 byte 2 Group 4 byte 3 For example to grant a user operator read and write in group 1 and full permissions in group 3: perm = (( or | ow | oi | ar | aw | ai | ua ) << 16 ) | (( or | ow ) << 0 ) Permission Grants \u00b6 To compute the permissions a user has on a given component, we combine the user's configured permissions for each group the given component is a member of. Consider this example of a User's configured permissions: Groups or ow oi ar aw ai ua Group 1 x x - x - - - Group 2 x - x - - - - Group 3 x x x x x x x Group 4 - - - - - - - Some examples of what permissions this user would be granted: Permissions for component in group 1: or, ow, ar Permissions for component in group 2: or, oi Permissions for component in group 3: all Permissions for component in group 4: none Permissions for component in group 1 and 2: or, ow, oi, ar (union of 1 and 2) Access Control \u00b6 The previous sections explain how we compute the permissions granted to a user for a specific component. The following table defines what permissions are required for operations: Perm Operation or to read or subscribe to a component (1) or to read the current value of an operator property ow to modify the current value of an operator property oi to invoke an operator action ar to read the current value of an admin property (2) aw to modify the current value of an admin property ai to invoke an admin action aw on parent to add a child component aw on parent to reorder children components aw on component to rename aw on component to delete ar to read or subscribe to a components links ar/aw ar on \"from\" component and aw on \"to\" component to create link aw on \"to\" component to delete a link ua on User component to read, write, modify, delete Sox Implementation Notes: When reading a component's children via a tree update, unreadable children components are automatically omitted in the result When performing a property update or subscribe, admin properties are not serialized when not available Provisioning \u00b6 Each user is explicitly granted permissions to read and write the files associated with provisioning: Method Permission for file Byte User.provApp read/write \"app.sab\" 0x01 User.provKits read/write \"kits.scode\" 0x02 User.provSvm read/write \"svm.*\" 0x04","title":"Security"},{"location":"apps/security/#security","text":"","title":"Security"},{"location":"apps/security/#overview","text":"The Sedona Framework's security model is based upon the following principles: Users represent an authenticated user account (human or machine) Components are assigned to one or more of four security groups Slots are designated as operator level or admin level Users are assigned permission levels for the four groups Any network access such as Sox checks permissions before any operation","title":"Overview"},{"location":"apps/security/#users","text":"Any Sedona Framework application that wishes to utilize security must include an instance of the sys::UserService containing at least one sys::User component. Each sys::User component represents a user account. User components must be direct children of the UserService. The Component.name of the User component is the username.","title":"Users"},{"location":"apps/security/#authentication","text":"Each User component stores a 20 byte cred property, which is the credentials hash of the user's password. Because credentials are a one-way hash, the password is never readable. Credentials are computed as follows: text = username + \":\" + password bytes = text from step 1 encoded as UTF-8 cred = SHA-1 hash of bytes in step 2 You can use the sedona.util.UserUtil to programmatically compute credentials. Or you can use the command line: D: \\s edona>sedonac sedona.util.UserUtil brian secret User: brian:secret Digest: 0x [ 74091bc2a1f43108df56281b6a74975bab86236f ] Base64: dAkbwqH0MQjfVigbanSXW6uGI28 = Network protocols that support authentication should work as follows: Generate a random nonce to be used only one time Send the nonce to the client Client should generate its credentials from username and password Client creates digest by hashing the credentials from step 3 with the nonce Client sends digest from step 4 to server Server computes expected digest from nonce and known credentials If client's digest from step 5 matches server's digest from step 6 then client is authenticated If a protocol doesn't support authentication, then it should define a configuration property that references a user account to use for security checking.","title":"Authentication"},{"location":"apps/security/#groups","text":"Components are assigned into one or more security groups. There are four security groups indicated by the least significant nibble in the Component.meta property: Group Value Group 1 0x01 Group 2 0x02 Group 3 0x04 Group 4 0x08 Components can be in multiple groups. For example: to assign a component to groups 2 and 3, set the bottom nibble of Component.meta to 0x06 . If a component is not included in any groups, then that component is not network accessible.","title":"Groups"},{"location":"apps/security/#slots","text":"Every slot in a component is defined as operator level or admin level for security purposes. By default a slot is admin level. You can mark a slot operator level with the @operator facet. Use Slot.isOperator() to check a slot's level.","title":"Slots"},{"location":"apps/security/#permissions","text":"There are seven security permissions defined as a bitmask: User Permission Bitmask User.or operator read 0x01 User.ow operator write 0x02 User.oi operator invoke 0x04 User.ar admin read 0x08 User.aw admin write 0x10 User.ai admin invoke 0x20 User.ua user admin 0x40 Users are granted zero or more of each of these seven permissions for each user group via the User.perm property. Each group's permissions is stored in a byte: Group Byte Group 1 byte 0 Group 2 byte 1 Group 3 byte 2 Group 4 byte 3 For example to grant a user operator read and write in group 1 and full permissions in group 3: perm = (( or | ow | oi | ar | aw | ai | ua ) << 16 ) | (( or | ow ) << 0 )","title":"Permissions"},{"location":"apps/security/#permission-grants","text":"To compute the permissions a user has on a given component, we combine the user's configured permissions for each group the given component is a member of. Consider this example of a User's configured permissions: Groups or ow oi ar aw ai ua Group 1 x x - x - - - Group 2 x - x - - - - Group 3 x x x x x x x Group 4 - - - - - - - Some examples of what permissions this user would be granted: Permissions for component in group 1: or, ow, ar Permissions for component in group 2: or, oi Permissions for component in group 3: all Permissions for component in group 4: none Permissions for component in group 1 and 2: or, ow, oi, ar (union of 1 and 2)","title":"Permission Grants"},{"location":"apps/security/#access-control","text":"The previous sections explain how we compute the permissions granted to a user for a specific component. The following table defines what permissions are required for operations: Perm Operation or to read or subscribe to a component (1) or to read the current value of an operator property ow to modify the current value of an operator property oi to invoke an operator action ar to read the current value of an admin property (2) aw to modify the current value of an admin property ai to invoke an admin action aw on parent to add a child component aw on parent to reorder children components aw on component to rename aw on component to delete ar to read or subscribe to a components links ar/aw ar on \"from\" component and aw on \"to\" component to create link aw on \"to\" component to delete a link ua on User component to read, write, modify, delete Sox Implementation Notes: When reading a component's children via a tree update, unreadable children components are automatically omitted in the result When performing a property update or subscribe, admin properties are not serialized when not available","title":"Access Control"},{"location":"apps/security/#provisioning","text":"Each user is explicitly granted permissions to read and write the files associated with provisioning: Method Permission for file Byte User.provApp read/write \"app.sab\" 0x01 User.provKits read/write \"kits.scode\" 0x02 User.provSvm read/write \"svm.*\" 0x04","title":"Provisioning"},{"location":"deployment/kits/","text":"Kits \u00b6 Overview \u00b6 A kit is the basic unit of modularity in the Sedona Framework: Kits define a global name for identifying modules Kits define a global namespace for types and schemas Kits define code versioning Kits define the dependency graphs Kits encapsulate code, types, and meta-data Because kits define the top of the global namespace, each must have a globally unique name. The Sedona Framework requires kits to be prefixed with the vendor's name. See Vendors for the rules regarding vendor and kit naming. Versioning \u00b6 Version numbers are specified as a sequence of decimal numbers separated by the dot character. Convention is to use a four part version of major.minor.build[.patch] . The sedona.util.Version class provides a Java API for working with versions and doing comparisons. When a kit is compiled, sedonac uses the following rules to determine the version of the kit (from highest priority to lowest): If the -kitVersion switch appears on the command line, then that version is used If the version attribute in \"kit.xml\" explicitly defines a version, then that version is used Fallback is to use the \"buildVersion\" definition in \"lib/sedona.properties\" If the version is not specified in any of the above ways, a compile error occurs. Dependencies \u00b6 Dependencies identify a kit by name with a set of version constraints. Dependencies are used whenever the Sedona Framework tools need to resolve a specific kit version: Kits declare dependencies to use another kit's APIs ( kits.xml ). SCode images declare dependencies for the kits to link together ( scode ). Platform manifests declare dependencies on kits with native methods ( platform ). The sedona.Depend class provides a Java API for parsing and comparing dependencies: depend := name space* constraints constraints := constraint [space* \",\" space* constraint]* constraint := versionSimple | versionPlus | versionExact | versionRange | checksum versionSimple := version versionPlus := version space* \"+\" versionExact := version space* \"=\" versionRange := version space* \"-\" space* version version := digit [\".\" digit]* checksum := \"0x\" 8 hex digits digit := \"0\" - \"9\" Note that a simple version constraint such as foo 1.2 really means 1.2.* - it will match all build numbers and patch numbers within 1.2 . Likewise foo 1.2.64 will match all patch numbers within the 1.2.64 build. The + plus sign is used to specify a given version and anything greater. The = equals sign is used to specify an exact version match. Hence, foo 1.2.64= would match 1.2.64 but not 1.2 , or 1.2.64.1 . The - dash is used to specify an inclusive range. When using a range, then end version is matched using the same rules as a simple version. For example, not only 1.8 , 2.0.4 , and 3.1.1.1 , but also 4 , 4.2 , and 4.0.99 are all matches for foo 1.2-4 . You may also specify a list of constraints separated by commas. Multiple version dependencies are evaluated using a logical OR, i.e. any match is considered an overall match. A version constraint and a checksum constraint are evaluated using a logical AND, i.e. both must match. Examples: \"foo 1.2\" Any version of foo 1.2 with any build or patch number \"foo 1.2.64\" Any version of foo 1.2.64 with any patch number \"foo 0+\" Any version of foo - version wildcard \"foo 1.2+\" Any version of foo 1.2 or greater \"foo 1.2.64=\" Only foo version 1.2.64 \"foo 1.2.64=,0xaabbccdd\" Only foo version 1.2.64 with checksum 0xaabbccdd \"foo 1.2-1.4\" Any version between 1.2 and 1.4 inclusive \"foo 1.2,1.4\" Any version of 1.2 or 1.4 \"foo 0x1b02d4fc\" Any version of foo with a checksum of 0x1b02d4fc \"foo 1.0, 0x1b02d4fc\" Any version of foo 1.0 and a checksum of 0x1b02d4fc Vendors \u00b6 To avoid naming collisions, kits must be prepended by a vendor name. The vendor name is an alphanumeric text string and must be less than 32 characters. It is normally capitalized. Examples of valid vendor names: Acme Acme12 AcmeCompany Your kit names must be prepended with your vendor name. Kit names are alphanumeric and may contain the underscore ('_') character after the vendor prefix. The vendor name is treated as case-insensitive when it is verified, so a kit prefix need not have the same capitalization as the vendor name. All these are valid kit names for a kit owned by the Acme vendor: acme_control acmeControl Acmecontrol The prefix will also be checked against the vendor name specified in the kit manifest (again ignoring case); this will be handled at compile time by sedonac when it generates your kit manifest. <kitManifest name= \"acme_control\" vendor= \"Acme\" checksum= \"40464bf3\" hasNatives= \"false\" doc= \"false\" version= \"1.0.5\" description= \"Basic function block library\" > Visit http://sedonadev.org to register your vendor name.","title":"Kits"},{"location":"deployment/kits/#kits","text":"","title":"Kits"},{"location":"deployment/kits/#overview","text":"A kit is the basic unit of modularity in the Sedona Framework: Kits define a global name for identifying modules Kits define a global namespace for types and schemas Kits define code versioning Kits define the dependency graphs Kits encapsulate code, types, and meta-data Because kits define the top of the global namespace, each must have a globally unique name. The Sedona Framework requires kits to be prefixed with the vendor's name. See Vendors for the rules regarding vendor and kit naming.","title":"Overview"},{"location":"deployment/kits/#versioning","text":"Version numbers are specified as a sequence of decimal numbers separated by the dot character. Convention is to use a four part version of major.minor.build[.patch] . The sedona.util.Version class provides a Java API for working with versions and doing comparisons. When a kit is compiled, sedonac uses the following rules to determine the version of the kit (from highest priority to lowest): If the -kitVersion switch appears on the command line, then that version is used If the version attribute in \"kit.xml\" explicitly defines a version, then that version is used Fallback is to use the \"buildVersion\" definition in \"lib/sedona.properties\" If the version is not specified in any of the above ways, a compile error occurs.","title":"Versioning"},{"location":"deployment/kits/#dependencies","text":"Dependencies identify a kit by name with a set of version constraints. Dependencies are used whenever the Sedona Framework tools need to resolve a specific kit version: Kits declare dependencies to use another kit's APIs ( kits.xml ). SCode images declare dependencies for the kits to link together ( scode ). Platform manifests declare dependencies on kits with native methods ( platform ). The sedona.Depend class provides a Java API for parsing and comparing dependencies: depend := name space* constraints constraints := constraint [space* \",\" space* constraint]* constraint := versionSimple | versionPlus | versionExact | versionRange | checksum versionSimple := version versionPlus := version space* \"+\" versionExact := version space* \"=\" versionRange := version space* \"-\" space* version version := digit [\".\" digit]* checksum := \"0x\" 8 hex digits digit := \"0\" - \"9\" Note that a simple version constraint such as foo 1.2 really means 1.2.* - it will match all build numbers and patch numbers within 1.2 . Likewise foo 1.2.64 will match all patch numbers within the 1.2.64 build. The + plus sign is used to specify a given version and anything greater. The = equals sign is used to specify an exact version match. Hence, foo 1.2.64= would match 1.2.64 but not 1.2 , or 1.2.64.1 . The - dash is used to specify an inclusive range. When using a range, then end version is matched using the same rules as a simple version. For example, not only 1.8 , 2.0.4 , and 3.1.1.1 , but also 4 , 4.2 , and 4.0.99 are all matches for foo 1.2-4 . You may also specify a list of constraints separated by commas. Multiple version dependencies are evaluated using a logical OR, i.e. any match is considered an overall match. A version constraint and a checksum constraint are evaluated using a logical AND, i.e. both must match. Examples: \"foo 1.2\" Any version of foo 1.2 with any build or patch number \"foo 1.2.64\" Any version of foo 1.2.64 with any patch number \"foo 0+\" Any version of foo - version wildcard \"foo 1.2+\" Any version of foo 1.2 or greater \"foo 1.2.64=\" Only foo version 1.2.64 \"foo 1.2.64=,0xaabbccdd\" Only foo version 1.2.64 with checksum 0xaabbccdd \"foo 1.2-1.4\" Any version between 1.2 and 1.4 inclusive \"foo 1.2,1.4\" Any version of 1.2 or 1.4 \"foo 0x1b02d4fc\" Any version of foo with a checksum of 0x1b02d4fc \"foo 1.0, 0x1b02d4fc\" Any version of foo 1.0 and a checksum of 0x1b02d4fc","title":"Dependencies"},{"location":"deployment/kits/#vendors","text":"To avoid naming collisions, kits must be prepended by a vendor name. The vendor name is an alphanumeric text string and must be less than 32 characters. It is normally capitalized. Examples of valid vendor names: Acme Acme12 AcmeCompany Your kit names must be prepended with your vendor name. Kit names are alphanumeric and may contain the underscore ('_') character after the vendor prefix. The vendor name is treated as case-insensitive when it is verified, so a kit prefix need not have the same capitalization as the vendor name. All these are valid kit names for a kit owned by the Acme vendor: acme_control acmeControl Acmecontrol The prefix will also be checked against the vendor name specified in the kit manifest (again ignoring case); this will be handled at compile time by sedonac when it generates your kit manifest. <kitManifest name= \"acme_control\" vendor= \"Acme\" checksum= \"40464bf3\" hasNatives= \"false\" doc= \"false\" version= \"1.0.5\" description= \"Basic function block library\" > Visit http://sedonadev.org to register your vendor name.","title":"Vendors"},{"location":"deployment/schema/","text":"Schema \u00b6 Overview \u00b6 Because the Sedona Framework is designed to work in very constrained embedded environments, we have to make design tradeoffs. One of the biggest tradeoffs is using a low level binary format for Sedona Framework application files and the Sox protocol. This compact form requires out-of-band information for encoding and decoding. For example the binary format does not contain kit, type, or slot definitions, only their numeric ids. So in order to reconstruct the original app from its binary SAB file, we must have some external way to map those ids to the right definitions. Correct versioning is also important, since kits may evolve over time to include new types and new slots which could change their ids. The schema tells us how to create the right mapping for the app, by specifying the kit versions and checksums that were used to create the app. Kit Parts \u00b6 Every kit contains zero or more named types. Each type declares zero or more slots. For a given version of a kit, there is a fixed list of types and their declared slots. Each slot has a fixed name, flags, and type. When a kit is compiled from source into a kit zip file, the compiler generates a checksum for this fixed list of types and slots. The combination of a kit name and checksum is called a kit part . The kit meta-data, checksum, and list of types and slots is included in the kit file as an XML file called \"manifest.xml\". Here is an example manifest file: <?xml version='1.0'?> <kitManifest name= \"sysTest\" checksum= \"da52f78f\" version= \"1.0\" vendor= \"Tridium\" description= \"Test suite for core language and sys APIs\" buildHost= \"BLAZE\" buildTime= \"2007-05-17T16:21:08.030-04:00\" > <type id= \"0\" name= \"AbstractTestComp\" base= \"sys::Component\" > <slot id= \"0\" name= \"az\" type= \"bool\" /> <slot id= \"1\" name= \"ai\" type= \"int\" /> </type> <type id= \"1\" name= \"TestComp\" base= \"sysTest::AbstractTestComp\" > <slot id= \"0\" name= \"z1\" type= \"bool\" /> <slot id= \"1\" name= \"b1\" type= \"byte\" /> <slot id= \"2\" name= \"addF1\" type= \"float\" flags= \"a\" /> </type> <type id= \"2\" name= \"SubTestComp\" base= \"sysTest::TestComp\" > <slot id= \"0\" name= \"sb\" type= \"byte\" /> <slot id= \"1\" name= \"si\" type= \"int\" /> </type> </kitManifest> The checksum is based only on the kit's component types (those that subclass sys::Component ) and slots. The checksum is not based on variable meta-data such as the kit's version number, or on non-component types which could never appear in an app definition. This means that multiple versions of the same kit might share the same checksum if no component types or slots have been modified between versions. Don't confuse version with checksum . Version represents a revision of the whole kit including its code, algorithms, and when it was built; the version only changes when the developer chooses to specify a different version number. Checksum represents a revision of the declared types and slots, and it changes automatically whenever the type or slot definitions change. Kit Database \u00b6 Within a Sedona Framework installation we store all the local copies of kits with the file pattern: {Sedona home}/kits/{kit}/{kit}-{checksum}-{version}.kit For example: {Sedona home}/ kits/ control/ control-cdf5f0f0-1.0.28.kit control-cdf5f0f0-1.0.29.kit control-1239c0de-1.0.29.kit sys/ sys-ef94b11d-1.0.28.kit . . . We call this directory the kit database . It can store multiple versions of each kit with different checksums. The sedona.kit.* Java APIs can be used to work with the kit database. Manifest Database \u00b6 Kit files contain all the information we need when working with schema. However, to interface with a device that is using a kit we don't need the full kit file, only the XML manifest file that represents it. So in addition to the kit database, we also create a manifest database with the file pattern: {Sedona home}/manifests/{kit}/{kit}-{checksum}.xml For example: {Sedona home}/ manifests/ control/ control-cdf5f0f0.xml control-1239c0de.xml sys/ sys-ef94b11d.xml . . . By storing the manifests in a separate database, we don't need to use the kit files themselves to work with the kits' types. This is typically more efficient, and in addition it allows a vendor to publish just the manifests for their kits as opposed to entire kit files. Note, however, that manifests cannot be used to create an SCode image. Building an SCode image requires access to the actual kit files. The sedona.manifest.* APIs are used to work with manifests and the manifest database via the Java toolkit. The KitManifest class represents the information stored a kit manifest file and provides methods for encoding and decoding from XML. The ManifestDb class is used to load and save KitManifest s to the file system. Schemas \u00b6 A Sedona Framework application is composed of multiple kits. A specific list of kit parts (kits at a specific checksum revision) is called a schema . Matching schemas guarantee compatibility between the app running on the device and the app's representation elsewhere, such as in a PC-based tool. Only when a kit manifest is accessed for a specific schema can we correctly interpret binary information such as kit id and slot id. For example the kit id for the \"control\" kit might be 3 in one schema, but 5 in another schema that has a different list of kit parts. Slot ids for a given kit part can also change across schemas, if there are changes to slots inherited from base types. The Java API for working with schemas is in sedona.* . Schemas are built with the sedona.Schema class from a list of KitParts which are resolved against the manifest database. Assuming all the kit parts can be resolved to kit manifests, we can build a complete representation of the schema including the full list of kits, types, and slots along with their respective ids. The Schema is then used to work with binary formats such as \".sab\" files and Sox messages. Kits versus Manifests \u00b6 So when do you need a kit and when do you only need a manifest? This table helps summarize the differences: What Encapsulates Versioned By Uses Manifest type and slot schema checksum sax, sab, and sox Kit code version number compiling dependencies and scode images For example when working with an application file or Sox, only the type schemas are needed. No knowledge of the internal code is required. However when compiling, you need the full kit that contains the actual code. So a manifest is somewhat analogous to a C header file, which declares function prototypes but does not contain any code for the functions. Manifests are versioned with a checksum each time a type or slot definition is modified. Kits are versioned with a version number typically whenever code is modified. Resolving Manifests \u00b6 To fully connect to a remote Sedona device, there must be local copies of the kit manifests corresponding to the device's current schema. The recommended rules for locating each kit manifest are: Check the local manifest database first; if the manifest is found then use it Check the local kit database for the given kit, if found then extract the manifest file and store it in the local manifest database Download the manifest from sedonadev.org to the local manifest database These steps are automatically implemented by the Sedona ManifestDb API. If any manifests required by the schema are not found a MissingKitManifestException is thrown, which contains information about the specific manifests that are missing. This information can be used to compose a friendly error message to the user about why the connection failed, or to request the missing file(s) from the device itself (see next section). Kit Manifest Server \u00b6 Beginning with Sedona 1.2, the Sedona Sox Client supports retrieving missing manifest files from the remote Sedona device itself. If it detects the MissingKitManifestException when resolving the device's schema locally, it requests the missing manifests from the device. If the device is set up to serve the requested manifests it will send them. This feature can make it easier to deploy new devices, as they can be shipped with the necessary manifests installed on the device rather than requiring them to be installed separately in advance on the Sox Client host. Serving kit manifests is accomplished very simply, using a special filename prefix called a scheme to indicate to the device where to look for the file in its local file system. This allows the manifest retrieval to be accomplished using the regular Sox file transfer protocol. When the Sox Client detects that a manifest is not found by the usual rules described above, it sends a Sox \"get file\" request to the device using the filename of the missing manifest adding the appropriate scheme prefix. When the device receives the request, it recognizes by the prefix that this is a manifest file, and looks in its local database for the one requested. If the file is found, it sends it via Sox back to the requesting client. Implementation Details \u00b6 To make this feature work on a given Sedona platform, the following things must be true: The required manifest file(s) must be stored on the device The \" m: \" scheme must be implemented on the remote Sedona device (see below) The sedonadev.autodownload property in sedona.properties must be set to false, or omitted entirely A scheme is simply a prefix to the filename, such as \"m:\", which is translated on the remote device into a local path where the file should be located. There are two ways to implement a scheme: It can be implemented entirely at the native level, encapsulated in the appropriate sys::FileStore natives It can be implemented at the Sedona level using a platform-specific FileStore subclass. If it is implemented at the native level, then at the Sedona level the device treats the prefix as part of the actual filename. The native implementation of FileStore.doOpen() must then strip off the prefix and substitute the path to the local manifest database. The resulting full path to the file is then passed to the local file system and handled just like any other file transfer request. If it is implemented using a FileStore subclass, then the FileStore subclass should override the accept() method such that it returns true if the filename begins with the desired prefix. Then the open() method can be overridden to strip off the scheme prefix and substitute the desired path, or the FileStore subclass may have an additional native method that provides the appropriate path for all files in that scheme. The Sedona 1.2 open source includes a class in the 'win32' platform kit, called Win32ProvDbFileStore . This class demonstrates the second (Sedona-level) implementation strategy described above. N.B. An ambitious Sedona developer could use this same strategy to provide kit files and/or platform manifests as well as kit manifests. Review \u00b6 To summarize the schema pipeline: Checksum : Generated by the compiler when compiling a kit file from source, the checksum is based on the declared types and slots in the kit. Kit Part : The combination of kit name and kit checksum that uniquely identifies a kit for a specific schema revision. Kit Manifest : A file containing a kit's checksum and type definitions, stored as a zip archive entry named \"manifest.xml\". Kit Database : A local database of kit versions, created and maintained by the Sedona Framework Java toolkit. Manifest Database : A local database of all the kit manifests that have been accumulated, created, and maintained by the Sedona Framework Java toolkit. These manifests are XML files keyed by kit name and checksum. Schema : A list of kit parts aggregated by the Sedona Framework Java toolkit. A schema defines the full meta-data required to work with binary format entities with matching schemas. Each Sedona Framework runtime and application file has a single, fixed schema. The Java toolkit models schemas via the sedona.Schema API.","title":"Schema"},{"location":"deployment/schema/#schema","text":"","title":"Schema"},{"location":"deployment/schema/#overview","text":"Because the Sedona Framework is designed to work in very constrained embedded environments, we have to make design tradeoffs. One of the biggest tradeoffs is using a low level binary format for Sedona Framework application files and the Sox protocol. This compact form requires out-of-band information for encoding and decoding. For example the binary format does not contain kit, type, or slot definitions, only their numeric ids. So in order to reconstruct the original app from its binary SAB file, we must have some external way to map those ids to the right definitions. Correct versioning is also important, since kits may evolve over time to include new types and new slots which could change their ids. The schema tells us how to create the right mapping for the app, by specifying the kit versions and checksums that were used to create the app.","title":"Overview"},{"location":"deployment/schema/#kit-parts","text":"Every kit contains zero or more named types. Each type declares zero or more slots. For a given version of a kit, there is a fixed list of types and their declared slots. Each slot has a fixed name, flags, and type. When a kit is compiled from source into a kit zip file, the compiler generates a checksum for this fixed list of types and slots. The combination of a kit name and checksum is called a kit part . The kit meta-data, checksum, and list of types and slots is included in the kit file as an XML file called \"manifest.xml\". Here is an example manifest file: <?xml version='1.0'?> <kitManifest name= \"sysTest\" checksum= \"da52f78f\" version= \"1.0\" vendor= \"Tridium\" description= \"Test suite for core language and sys APIs\" buildHost= \"BLAZE\" buildTime= \"2007-05-17T16:21:08.030-04:00\" > <type id= \"0\" name= \"AbstractTestComp\" base= \"sys::Component\" > <slot id= \"0\" name= \"az\" type= \"bool\" /> <slot id= \"1\" name= \"ai\" type= \"int\" /> </type> <type id= \"1\" name= \"TestComp\" base= \"sysTest::AbstractTestComp\" > <slot id= \"0\" name= \"z1\" type= \"bool\" /> <slot id= \"1\" name= \"b1\" type= \"byte\" /> <slot id= \"2\" name= \"addF1\" type= \"float\" flags= \"a\" /> </type> <type id= \"2\" name= \"SubTestComp\" base= \"sysTest::TestComp\" > <slot id= \"0\" name= \"sb\" type= \"byte\" /> <slot id= \"1\" name= \"si\" type= \"int\" /> </type> </kitManifest> The checksum is based only on the kit's component types (those that subclass sys::Component ) and slots. The checksum is not based on variable meta-data such as the kit's version number, or on non-component types which could never appear in an app definition. This means that multiple versions of the same kit might share the same checksum if no component types or slots have been modified between versions. Don't confuse version with checksum . Version represents a revision of the whole kit including its code, algorithms, and when it was built; the version only changes when the developer chooses to specify a different version number. Checksum represents a revision of the declared types and slots, and it changes automatically whenever the type or slot definitions change.","title":"Kit Parts"},{"location":"deployment/schema/#kit-database","text":"Within a Sedona Framework installation we store all the local copies of kits with the file pattern: {Sedona home}/kits/{kit}/{kit}-{checksum}-{version}.kit For example: {Sedona home}/ kits/ control/ control-cdf5f0f0-1.0.28.kit control-cdf5f0f0-1.0.29.kit control-1239c0de-1.0.29.kit sys/ sys-ef94b11d-1.0.28.kit . . . We call this directory the kit database . It can store multiple versions of each kit with different checksums. The sedona.kit.* Java APIs can be used to work with the kit database.","title":"Kit Database"},{"location":"deployment/schema/#manifest-database","text":"Kit files contain all the information we need when working with schema. However, to interface with a device that is using a kit we don't need the full kit file, only the XML manifest file that represents it. So in addition to the kit database, we also create a manifest database with the file pattern: {Sedona home}/manifests/{kit}/{kit}-{checksum}.xml For example: {Sedona home}/ manifests/ control/ control-cdf5f0f0.xml control-1239c0de.xml sys/ sys-ef94b11d.xml . . . By storing the manifests in a separate database, we don't need to use the kit files themselves to work with the kits' types. This is typically more efficient, and in addition it allows a vendor to publish just the manifests for their kits as opposed to entire kit files. Note, however, that manifests cannot be used to create an SCode image. Building an SCode image requires access to the actual kit files. The sedona.manifest.* APIs are used to work with manifests and the manifest database via the Java toolkit. The KitManifest class represents the information stored a kit manifest file and provides methods for encoding and decoding from XML. The ManifestDb class is used to load and save KitManifest s to the file system.","title":"Manifest Database"},{"location":"deployment/schema/#schemas","text":"A Sedona Framework application is composed of multiple kits. A specific list of kit parts (kits at a specific checksum revision) is called a schema . Matching schemas guarantee compatibility between the app running on the device and the app's representation elsewhere, such as in a PC-based tool. Only when a kit manifest is accessed for a specific schema can we correctly interpret binary information such as kit id and slot id. For example the kit id for the \"control\" kit might be 3 in one schema, but 5 in another schema that has a different list of kit parts. Slot ids for a given kit part can also change across schemas, if there are changes to slots inherited from base types. The Java API for working with schemas is in sedona.* . Schemas are built with the sedona.Schema class from a list of KitParts which are resolved against the manifest database. Assuming all the kit parts can be resolved to kit manifests, we can build a complete representation of the schema including the full list of kits, types, and slots along with their respective ids. The Schema is then used to work with binary formats such as \".sab\" files and Sox messages.","title":"Schemas"},{"location":"deployment/schema/#kits-versus-manifests","text":"So when do you need a kit and when do you only need a manifest? This table helps summarize the differences: What Encapsulates Versioned By Uses Manifest type and slot schema checksum sax, sab, and sox Kit code version number compiling dependencies and scode images For example when working with an application file or Sox, only the type schemas are needed. No knowledge of the internal code is required. However when compiling, you need the full kit that contains the actual code. So a manifest is somewhat analogous to a C header file, which declares function prototypes but does not contain any code for the functions. Manifests are versioned with a checksum each time a type or slot definition is modified. Kits are versioned with a version number typically whenever code is modified.","title":"Kits versus Manifests"},{"location":"deployment/schema/#resolving-manifests","text":"To fully connect to a remote Sedona device, there must be local copies of the kit manifests corresponding to the device's current schema. The recommended rules for locating each kit manifest are: Check the local manifest database first; if the manifest is found then use it Check the local kit database for the given kit, if found then extract the manifest file and store it in the local manifest database Download the manifest from sedonadev.org to the local manifest database These steps are automatically implemented by the Sedona ManifestDb API. If any manifests required by the schema are not found a MissingKitManifestException is thrown, which contains information about the specific manifests that are missing. This information can be used to compose a friendly error message to the user about why the connection failed, or to request the missing file(s) from the device itself (see next section).","title":"Resolving Manifests"},{"location":"deployment/schema/#kit-manifest-server","text":"Beginning with Sedona 1.2, the Sedona Sox Client supports retrieving missing manifest files from the remote Sedona device itself. If it detects the MissingKitManifestException when resolving the device's schema locally, it requests the missing manifests from the device. If the device is set up to serve the requested manifests it will send them. This feature can make it easier to deploy new devices, as they can be shipped with the necessary manifests installed on the device rather than requiring them to be installed separately in advance on the Sox Client host. Serving kit manifests is accomplished very simply, using a special filename prefix called a scheme to indicate to the device where to look for the file in its local file system. This allows the manifest retrieval to be accomplished using the regular Sox file transfer protocol. When the Sox Client detects that a manifest is not found by the usual rules described above, it sends a Sox \"get file\" request to the device using the filename of the missing manifest adding the appropriate scheme prefix. When the device receives the request, it recognizes by the prefix that this is a manifest file, and looks in its local database for the one requested. If the file is found, it sends it via Sox back to the requesting client.","title":"Kit Manifest Server"},{"location":"deployment/schema/#implementation-details","text":"To make this feature work on a given Sedona platform, the following things must be true: The required manifest file(s) must be stored on the device The \" m: \" scheme must be implemented on the remote Sedona device (see below) The sedonadev.autodownload property in sedona.properties must be set to false, or omitted entirely A scheme is simply a prefix to the filename, such as \"m:\", which is translated on the remote device into a local path where the file should be located. There are two ways to implement a scheme: It can be implemented entirely at the native level, encapsulated in the appropriate sys::FileStore natives It can be implemented at the Sedona level using a platform-specific FileStore subclass. If it is implemented at the native level, then at the Sedona level the device treats the prefix as part of the actual filename. The native implementation of FileStore.doOpen() must then strip off the prefix and substitute the path to the local manifest database. The resulting full path to the file is then passed to the local file system and handled just like any other file transfer request. If it is implemented using a FileStore subclass, then the FileStore subclass should override the accept() method such that it returns true if the filename begins with the desired prefix. Then the open() method can be overridden to strip off the scheme prefix and substitute the desired path, or the FileStore subclass may have an additional native method that provides the appropriate path for all files in that scheme. The Sedona 1.2 open source includes a class in the 'win32' platform kit, called Win32ProvDbFileStore . This class demonstrates the second (Sedona-level) implementation strategy described above. N.B. An ambitious Sedona developer could use this same strategy to provide kit files and/or platform manifests as well as kit manifests.","title":"Implementation Details"},{"location":"deployment/schema/#review","text":"To summarize the schema pipeline: Checksum : Generated by the compiler when compiling a kit file from source, the checksum is based on the declared types and slots in the kit. Kit Part : The combination of kit name and kit checksum that uniquely identifies a kit for a specific schema revision. Kit Manifest : A file containing a kit's checksum and type definitions, stored as a zip archive entry named \"manifest.xml\". Kit Database : A local database of kit versions, created and maintained by the Sedona Framework Java toolkit. Manifest Database : A local database of all the kit manifests that have been accumulated, created, and maintained by the Sedona Framework Java toolkit. These manifests are XML files keyed by kit name and checksum. Schema : A list of kit parts aggregated by the Sedona Framework Java toolkit. A schema defines the full meta-data required to work with binary format entities with matching schemas. Each Sedona Framework runtime and application file has a single, fixed schema. The Java toolkit models schemas via the sedona.Schema API.","title":"Review"},{"location":"development/niagara/","text":"Niagara \u00b6 Overview \u00b6 This section covers integration of the Sedona Framework with the Niagara AX Framework. Sedona Framework components in Niagara Provisioning Sedona Framework-enabled devices from Niagara Sedona in Niagara \u00b6 This section details how to write Sedona Framework components in such a way that they can be easily integrated with the Niagara AX component architecture. This section will help developers familiar with the Niagara AX Framework to understand how Sedona idioms translate to Niagara idioms. In particular, this section will detail various aspects of programming Sedona Framework components so that the user experience inside Workbench is very similar to that of using standard BComponents in Niagara. How Niagara uses sys::Facets when modeling Sedona Framework Components Niagara Views on Sedona Framework Components In Niagara, all Sedona Framework components are modeled as a special kind of BComponent called BSedonaComponent. Regardless of your Sedona Framework component type, it will be modeled as a BSedonaComponent, which essentially wraps your sys::Component type. The primary means of communicating information about a Sedona Framework component type and its slots to Niagara is by using sys::Facets . The following tables detail which facets are recognized by Niagara, and how they are used when Niagara constructs a BSedonaComponent to model your sys::Component . Component Facets \u00b6 The following table lists the facets for a sys::Component type that Niagara will recognize. Facet Type Description niagaraIcon Str The Ord to the location of the icon to use for this component palette bool If set to false, then the type will not be displayed in the Sedona Palette. Otherwise, it will be shown in the palette Examples @niagaraIcon = \"module://icons/x16/control/math/add.png\" public class Add2 extends Component { ... } @palette = false public class CommonBase extends Component { ... } Slot Facets \u00b6 BComponent slot flags \u00b6 If you define a facet on your Sedona component slot that has the same name as a Niagara flag, and its value is true or false , then the corresponding slot in the BSedonaComponent will be likewise set; otherwise, the facet will simply be treated like all other facets (see BComponent facet list ). The most common slot flags to set are listed in the table below. Facet Description readonly The readonly flag is used to indicate slots that cannot be changed by the user. hidden Hidden slots are designed to be invisible to the user, and exist only for Java developers. User interfaces should rarely display hidden slots. summary Summary properties are the focal points of any given BComponent. This flag is used by user interface tools to indicate primary properties for display. This might be as a column in a table, or as a glyph in a graphical programming tool. confirmRequired When the action is invoked by a user, a confirmation dialog must be acknowledged before proceeding. operator This gives a slot an operator security level. By default when this flag is clear, the slot has an admin security level. noAudit Setting this flag prevents property changes and action invocations from being audited. Note All Sedona runtime slots are treated as summary unless the summary facet is explicitly set to false: @summary=false . Examples: public class Foo extends Component { ... // Require the user to confirm that they actually // want to reboot the system before executing the action. @confirmRequired action void reboot() { ... } // Don't want UI to allow user to edit password property @config @readonly @asStr property Buf(17) password // This slot we don't want displayed to users, but we // want operators to be allowed to change it. @hidden @operator property int debugLevel = 0 } Note See Component Properties for a discussion of @config and other Sedona-only facets. BComponent slot facets \u00b6 If a slot facet does not match a Niagara flag name, then it will stored as a a BFacet for the slot. Some BFacets have a special meaning in Niagara. This table lists some of the more common BFacets: Facet Type Description min number Used to specify the minimum value for a number, or the minimum number of characters in a Str. max number Used to specify the maximum value for a number, or the maximum number of characters in a Str. unit Str Display text that describes the property's units. precision int Used with floating point numbers to define the number of digits after the decimal point. radix int Used with integers to qualify base radix. showSeparators bool Used with numerics to enable/disable displaying of separators between every 3 digits (e.g. 10,000 vs. 10000). multiLine bool Used with Str to support a multiline editor. fieldWidth int Used with Str to specify the number of columns in a text field. allowNull bool Tells the field editor allow the value to be set to null. fieldEditor Str Indicates the BTypeSpec of the field editor to use for editing a property value. It overrides the default field editor registered for the property's value. trueText Str Display text to be used for a boolean property when true. falseText Str Display text to be used for a boolean property when false. nullText Str Display text to be used for a boolean property when null. Examples: public class Foo extends Component { ... // Property for password - must be at least 8 chars long // and no more than 16. @min=8 @max=16 @config @asStr property Buf(17) pwd // The debug level should be specified in base 16. @radix=16 @min=0 @config property int dbgLevel = 0x1234 } Niagara Views \u00b6 Normally in Niagara, views are registered on a BTypeSpec by using the <agent/> specification in the module-include.xml file of your module. However, since all Sedona Framework components are modeled as BSedonaComponents in Niagara, a different mechanism is used to register views on your Sedona Framework component. Namely, <def/> blocks are used to define agents on specific Sedona Framework component types. An example follows. Suppose you have developed a Service called MyService in kit foo . The qname for this type is foo::MyService . Suppose, further, that you have written a Niagara view BMyServiceView to manage this service and that it resides in module bar . The BTypeSpec for this service is bar:MyServiceView . To register your view on the MyService service, you would add the following lines to the module-include.xml for your module: <defs> <!-- This declares the agent on the foo::MyService service --> <def name= \"sedona.foo::MyService#agent\" value= \"bar:MyServiceView\" /> </def> <types> ... <!-- Declare the Niagara type as usual, but no agent block is required --> <type name= \"MyServiceView\" class= \"com.bar.BMyServiceView\" /> ... </types> When your view loads, a BISedonaComponent will be passed to the doLoadValue method of your view. protected void doLoadValue ( BObject value , Context cx ) throws Exception { BISedonaComponent myService = ( BISedonaComponent ) value ; // See the javax.baja.sedona.sys.BISedonaComponent interface // for more details. } Note The concrete class BSedonaComponent is deprecated as of the TXS 1.1 release. You should migrate your views to use the new BISedonaComponent interface instead. If you have questions about writing views for Sedona Framework components, ask them on one of the Sedona Framework forums on Niagara Central . Provisioning from Niagara \u00b6 When using Niagara tools to provision a Sedona Framework-enabled device, there are a few things to be aware of: File names : Niagara makes assumptions about the file names used to launch the remote platform. In particular, it assumes: the SVM is named \"svm.bin\" (or \"svm.exe\"), the kit bundle file is named \"kits.scode\", and the app binary is named \"app.sab\". File PUT : To be Sox compliant, Sedona Framework platforms must use app.sab as the file name of the app to run, and kits.scode as the file name of the scode image to run. Further, to be Sox compliant, a platform must look for an app.sab.stage and a kits.scode.stage file when starting and rename them to app.sab and kits.scode respectively before the SVM attempts to load the app and scode. Hence, when Niagara writes new app and scode files to the device, it does so in three stages: 1. Writes the app as `app.sab.writing` and the scode as `kits.scode.writing`. 2. Renames those files to `app.sab.stage` and `kits.scode.stage` respectively. 3. Restarts the device. File GET : A file GET operation from Sedona to Niagara should prompt the user for the path and filename to be used on the local host for the received file. The name of the file as it is being transferred is normally not visible (or relevant) to the user.","title":"Niagara"},{"location":"development/niagara/#niagara","text":"","title":"Niagara"},{"location":"development/niagara/#overview","text":"This section covers integration of the Sedona Framework with the Niagara AX Framework. Sedona Framework components in Niagara Provisioning Sedona Framework-enabled devices from Niagara","title":"Overview"},{"location":"development/niagara/#sedona-in-niagara","text":"This section details how to write Sedona Framework components in such a way that they can be easily integrated with the Niagara AX component architecture. This section will help developers familiar with the Niagara AX Framework to understand how Sedona idioms translate to Niagara idioms. In particular, this section will detail various aspects of programming Sedona Framework components so that the user experience inside Workbench is very similar to that of using standard BComponents in Niagara. How Niagara uses sys::Facets when modeling Sedona Framework Components Niagara Views on Sedona Framework Components In Niagara, all Sedona Framework components are modeled as a special kind of BComponent called BSedonaComponent. Regardless of your Sedona Framework component type, it will be modeled as a BSedonaComponent, which essentially wraps your sys::Component type. The primary means of communicating information about a Sedona Framework component type and its slots to Niagara is by using sys::Facets . The following tables detail which facets are recognized by Niagara, and how they are used when Niagara constructs a BSedonaComponent to model your sys::Component .","title":"Sedona in Niagara"},{"location":"development/niagara/#component-facets","text":"The following table lists the facets for a sys::Component type that Niagara will recognize. Facet Type Description niagaraIcon Str The Ord to the location of the icon to use for this component palette bool If set to false, then the type will not be displayed in the Sedona Palette. Otherwise, it will be shown in the palette Examples @niagaraIcon = \"module://icons/x16/control/math/add.png\" public class Add2 extends Component { ... } @palette = false public class CommonBase extends Component { ... }","title":"Component Facets"},{"location":"development/niagara/#slot-facets","text":"","title":"Slot Facets"},{"location":"development/niagara/#bcomponent-slot-flags","text":"If you define a facet on your Sedona component slot that has the same name as a Niagara flag, and its value is true or false , then the corresponding slot in the BSedonaComponent will be likewise set; otherwise, the facet will simply be treated like all other facets (see BComponent facet list ). The most common slot flags to set are listed in the table below. Facet Description readonly The readonly flag is used to indicate slots that cannot be changed by the user. hidden Hidden slots are designed to be invisible to the user, and exist only for Java developers. User interfaces should rarely display hidden slots. summary Summary properties are the focal points of any given BComponent. This flag is used by user interface tools to indicate primary properties for display. This might be as a column in a table, or as a glyph in a graphical programming tool. confirmRequired When the action is invoked by a user, a confirmation dialog must be acknowledged before proceeding. operator This gives a slot an operator security level. By default when this flag is clear, the slot has an admin security level. noAudit Setting this flag prevents property changes and action invocations from being audited. Note All Sedona runtime slots are treated as summary unless the summary facet is explicitly set to false: @summary=false . Examples: public class Foo extends Component { ... // Require the user to confirm that they actually // want to reboot the system before executing the action. @confirmRequired action void reboot() { ... } // Don't want UI to allow user to edit password property @config @readonly @asStr property Buf(17) password // This slot we don't want displayed to users, but we // want operators to be allowed to change it. @hidden @operator property int debugLevel = 0 } Note See Component Properties for a discussion of @config and other Sedona-only facets.","title":"BComponent slot flags"},{"location":"development/niagara/#bcomponent-slot-facets","text":"If a slot facet does not match a Niagara flag name, then it will stored as a a BFacet for the slot. Some BFacets have a special meaning in Niagara. This table lists some of the more common BFacets: Facet Type Description min number Used to specify the minimum value for a number, or the minimum number of characters in a Str. max number Used to specify the maximum value for a number, or the maximum number of characters in a Str. unit Str Display text that describes the property's units. precision int Used with floating point numbers to define the number of digits after the decimal point. radix int Used with integers to qualify base radix. showSeparators bool Used with numerics to enable/disable displaying of separators between every 3 digits (e.g. 10,000 vs. 10000). multiLine bool Used with Str to support a multiline editor. fieldWidth int Used with Str to specify the number of columns in a text field. allowNull bool Tells the field editor allow the value to be set to null. fieldEditor Str Indicates the BTypeSpec of the field editor to use for editing a property value. It overrides the default field editor registered for the property's value. trueText Str Display text to be used for a boolean property when true. falseText Str Display text to be used for a boolean property when false. nullText Str Display text to be used for a boolean property when null. Examples: public class Foo extends Component { ... // Property for password - must be at least 8 chars long // and no more than 16. @min=8 @max=16 @config @asStr property Buf(17) pwd // The debug level should be specified in base 16. @radix=16 @min=0 @config property int dbgLevel = 0x1234 }","title":"BComponent slot facets"},{"location":"development/niagara/#niagara-views","text":"Normally in Niagara, views are registered on a BTypeSpec by using the <agent/> specification in the module-include.xml file of your module. However, since all Sedona Framework components are modeled as BSedonaComponents in Niagara, a different mechanism is used to register views on your Sedona Framework component. Namely, <def/> blocks are used to define agents on specific Sedona Framework component types. An example follows. Suppose you have developed a Service called MyService in kit foo . The qname for this type is foo::MyService . Suppose, further, that you have written a Niagara view BMyServiceView to manage this service and that it resides in module bar . The BTypeSpec for this service is bar:MyServiceView . To register your view on the MyService service, you would add the following lines to the module-include.xml for your module: <defs> <!-- This declares the agent on the foo::MyService service --> <def name= \"sedona.foo::MyService#agent\" value= \"bar:MyServiceView\" /> </def> <types> ... <!-- Declare the Niagara type as usual, but no agent block is required --> <type name= \"MyServiceView\" class= \"com.bar.BMyServiceView\" /> ... </types> When your view loads, a BISedonaComponent will be passed to the doLoadValue method of your view. protected void doLoadValue ( BObject value , Context cx ) throws Exception { BISedonaComponent myService = ( BISedonaComponent ) value ; // See the javax.baja.sedona.sys.BISedonaComponent interface // for more details. } Note The concrete class BSedonaComponent is deprecated as of the TXS 1.1 release. You should migrate your views to use the new BISedonaComponent interface instead. If you have questions about writing views for Sedona Framework components, ask them on one of the Sedona Framework forums on Niagara Central .","title":"Niagara Views"},{"location":"development/niagara/#provisioning-from-niagara","text":"When using Niagara tools to provision a Sedona Framework-enabled device, there are a few things to be aware of: File names : Niagara makes assumptions about the file names used to launch the remote platform. In particular, it assumes: the SVM is named \"svm.bin\" (or \"svm.exe\"), the kit bundle file is named \"kits.scode\", and the app binary is named \"app.sab\". File PUT : To be Sox compliant, Sedona Framework platforms must use app.sab as the file name of the app to run, and kits.scode as the file name of the scode image to run. Further, to be Sox compliant, a platform must look for an app.sab.stage and a kits.scode.stage file when starting and rename them to app.sab and kits.scode respectively before the SVM attempts to load the app and scode. Hence, when Niagara writes new app and scode files to the device, it does so in three stages: 1. Writes the app as `app.sab.writing` and the scode as `kits.scode.writing`. 2. Renames those files to `app.sab.stage` and `kits.scode.stage` respectively. 3. Restarts the device. File GET : A file GET operation from Sedona to Niagara should prompt the user for the path and filename to be used on the local host for the received file. The name of the file as it is being transferred is normally not visible (or relevant) to the user.","title":"Provisioning from Niagara"},{"location":"development/porting/","text":"Porting \u00b6 Overview \u00b6 The SVM is designed to be easily ported to new hardware and OS platforms using the following steps: Add platform specific declarations to sedona.h Select the kits with native methods that you plan to support Write custom implementations for native methods where needed Write bootstrap code to start the SVM Stage the VM code and platform manifest using an XML build script Compile the C code using your platform's C compiler Run the test suite to verify a successful port sedona.h \u00b6 Porting to a new target platform begins with sedona.h which is located in the src/vm directory. This file is included by every native source file, and contains essential definitions required for building the native layer. It contains sections for major target platforms such as Win32, QNX, and UNIX. Each platform's section is wrapped by an #if defined() directive for the given target compiler/platform. If none of the existing sections is matched, the preprocessor will look for a file named sedona-local.h in the include path, and include its contents in place of the other target sections. Definitions for a new platform can be added in a new #elif defined() section in sedona.h , but the modified sedona.h will then need to be updated manually if any changes are made to the public version of the file. A simpler solution is to create a local sedona-local.h file to hold the definitions for the new platform. This file will then automatically be included in the build and can be maintained separately from the core Sedona Framework distribution. There are instructions at the top of sedona.h that describe the types and macros that must be defined for each platform, such as the ANSI C 99 integer types and macros for endianness and block sizes. Definitions for key types like Cell and SedonaVM are defined at the bottom of the file, as well as the function declarations for working with the VM. Natives \u00b6 Kits without native methods require no changes to run on a new target platform. For each kit with native methods, the existing code must first be examined to see what additional work needs to be done. As described in the Native Methods chapter, every native method must have an appropriately-named C function that implements that method for the target platform. However some C functions are more portable across platforms than others. For example a native method like sys::Sys.copy may be written in ANSI C and shared by many or perhaps all platforms. Other methods, such as sys::Sys.ticks , almost always require a custom implementation for each hardware or OS platform. All the native source code is organized under a directory called native in the kit directory. Native functions that are portable across all platforms should be contained in C files located directly in the native directory, one file per class using the naming convention \" {kit}_{class}.c \". Any native functions that are implemented separately for each platform should be located in sub-directories under native , one per platform. Code files under these directories are named using the convention \" {kit}_{type}_{platform}.c \". This helps avoid file name collisions. For example, given a kit myKit with one class MyClass that has native functions, some portable and some platform-specific, the code would be organized as follows: myKit/ +- kit.xml +- MyClass.sedona +- native/ | +- myKit_MyClass.c | +- qnx/ | | +- myKit_MyClass_qnx.c | +- win32/ | | +- myKit_MyClass_win32.c +- test/ | +- MyClassTest.sedona All the source code files for the native methods are stored under the folder myKit/native . Functions that can be shared across all platforms are in the file named myKit_MyClass.c , located in the native folder. These functions should not need to be implemented again when porting to a new platform. Source files for platform-specific implementations are located in a separate subfolder for each platform, and the platform name is appended to the source file name. When porting the kit to a new platform newPlat , simply create a new folder native/newPlat and put the native method implementations into a source file myKit_MyClass_newPlat.c under the new folder. Bootstrap \u00b6 In addition to the native methods for each kit, the new platform port will need some native bootstrapping code to start the SVM. For sophisticated devices with an OS and a file system (such as a PC), it may be sufficient to build and run the code provided in main.c , which is located in the src/vm directory. This function can be executed from the OS command line, providing on the command line the filenames for the scode image and the app to be run. (Even with platforms that cannot support main.c , it may still be useful as a guide for writing the new bootstrap code.) On smaller, simpler platforms, new bootstrap code will need to be written. Every platform will have a unique implementation, but at some point the SVM will need to be started by calling vmRun(SedonaVM*) . (Both vmRun() and the SedonaVM struct are defined in sedona.h .) Before calling vmRun() , a SedonaVM struct must be created and then initialized as follows: Configure codeBaseAddr and codeSize to point to the scode image. Typically the scode is stored in a disk file or in flash memory, and loaded into RAM at this point. If so then codeBaseAddr is simply a pointer to the scode image in RAM. Configure stackBaseAddr and stackMaxSize to point to an area of RAM that can be used for the stack. Most commonly this is a static or dynamically-allocated array of the desired size. Configure args and argsLen to pass in the arguments to the Sedona Framework main method. The args pointer should reference a normal array of C null terminated strings (just like a standard C main signature). Configure a callback function for onAssertFailure . This function is generally used in test code, and is called whenever an assert condition fails. More details on using the Sedona Framework test facility may be found in the Test chapter. Configure the call function pointer to point to vmCall . This indirection provides a hook for patching a ROM based VM. Configure a pointer to the nativeTable array generated automatically during the VM code generation stage. See the Native Methods chapter for more information. When the SedonaVM struct has been initialized, start the SVM by calling vmRun() and passing a pointer to the struct. Sedona VM Exit Values \u00b6 When the Sedona VM exits, the calling function must decide what to do next based on the return code. If the VM exits normally with a return code of 0 , it generally means the VM is not expecting to restart. The most common use of this is when running the test harness. If so, then the global variables assertSuccesses and assertFailures will contain the number of calls to assert that passed and failed, respectively. When the action App.restart() is invoked, the app stops running and sets the return code to Err.restart . On most platforms this leads to the SVM exiting with the value ERR_RESTART . If this value is received then the calling function should repeat the above steps to restart the SVM (possibly using different app.sab or kits.scode files if the device is restarting after being provisioned ). Note however that App.restart() also calls the platform service's restart() method, which could produce different behavior depending on how that method is implemented. For example, on a device with no OS it might issue a soft restart to the CPU, in which case there would be no return code to process. Some platforms may require the Sedona VM to yield execution control to allow other tasks to run. When vmRun() returns ERR_YIELD , the application is yielding CPU control. See the Yield section for more details. Each platform requires the implementation of an appropriate hibernation strategy. When vmRun() returns ERR_HIBERNATE then the application has requested that the platform go into a low-power or sleep state. Awakening from this state is under the control of the device, not the Sedona Framework application. Upon awaking, call the vmResume() function to start the SVM again from where it left off. See the Hibernation section for more details. If vmRun() returns a non-zero value other than ERR_RESTART , ERR_HIBERNATE , or ERR_YIELD , then there is a problem. Error codes generated in the scode image or the app are defined in src/sys/Err.sedona ; errors from the VM itself are usually indicated by an error code in src/vm/errorcodes.h . Staging \u00b6 Once the native code has been implemented, the next step is to stage the VM and native code. This copies the relevant native source files into a single directory in order to compile them using the appropriate native toolchain. Staging is accomplished by running sedonac with a platform definition file and specifying the output directory for the staged files. The platform definition lists all the directories containing C source files required to build the SVM for a target platform. (The platform toolchain may add additional non-Sedona files when it builds the final executable). See the platform definition section for more details and an example platform definition file. The platform definition file supplies some basic information about the platform, then lists the kits with native code that will be supported by the VM. Kits without native methods do not need to be mentioned in the platform XML. Finally it identifies the path to each directory containing native code that will be required by the VM at runtime. This includes not only the relevant Sedona native methods implementations, but also the source for the SVM itself. (On platforms where some portion of the VM is in ROM, only the RAM-based code may need to be included here.) Staging is performed by calling sedonac with the platform definition file, specifying the target directory via the -outDir option. For example, $ sedonac platforms/src/acme/basicPlatform-win32.xml -outDir tempStageDir This results in the following: All existing files are removed from the folder tempStageDir All source files are copied from the listed paths into tempStageDir The file nativetable.c is generated, which defines the native function lookup table If the platform id is known at staging time, a sedonaPlatform.h file is created, which contains the PLATFORM_ID macro. The platform manifest is staged in tempStageDir/.par/platformManifest.xml . The toolchain can later add the SVM binary to into the .par/svm/ directory (if desired) and then generate a PAR file . The PAR file could be uploaded to sedonadev.org or installed in the local platform database . Note Given that Tridium no longer supports Sedona, the par file can no longer be uploaded to sedonadev.org . Wrap Up \u00b6 Note that sedonac does not build the C code, it simply assembles the files together into a single directory. The C code must then be built with the appropriate toolchain for the target platform. Neither does sedonac generate an actual PAR file for you. It will help by staging a basic .par/ directory containing the platform manifest. However, the toolchain build process will need to include steps/scripts to generate the PAR file for local and/or public use. Once the VM executable has been built, a good next step is to run the test harness and verify the port was successful.","title":"Porting"},{"location":"development/porting/#porting","text":"","title":"Porting"},{"location":"development/porting/#overview","text":"The SVM is designed to be easily ported to new hardware and OS platforms using the following steps: Add platform specific declarations to sedona.h Select the kits with native methods that you plan to support Write custom implementations for native methods where needed Write bootstrap code to start the SVM Stage the VM code and platform manifest using an XML build script Compile the C code using your platform's C compiler Run the test suite to verify a successful port","title":"Overview"},{"location":"development/porting/#sedonah","text":"Porting to a new target platform begins with sedona.h which is located in the src/vm directory. This file is included by every native source file, and contains essential definitions required for building the native layer. It contains sections for major target platforms such as Win32, QNX, and UNIX. Each platform's section is wrapped by an #if defined() directive for the given target compiler/platform. If none of the existing sections is matched, the preprocessor will look for a file named sedona-local.h in the include path, and include its contents in place of the other target sections. Definitions for a new platform can be added in a new #elif defined() section in sedona.h , but the modified sedona.h will then need to be updated manually if any changes are made to the public version of the file. A simpler solution is to create a local sedona-local.h file to hold the definitions for the new platform. This file will then automatically be included in the build and can be maintained separately from the core Sedona Framework distribution. There are instructions at the top of sedona.h that describe the types and macros that must be defined for each platform, such as the ANSI C 99 integer types and macros for endianness and block sizes. Definitions for key types like Cell and SedonaVM are defined at the bottom of the file, as well as the function declarations for working with the VM.","title":"sedona.h"},{"location":"development/porting/#natives","text":"Kits without native methods require no changes to run on a new target platform. For each kit with native methods, the existing code must first be examined to see what additional work needs to be done. As described in the Native Methods chapter, every native method must have an appropriately-named C function that implements that method for the target platform. However some C functions are more portable across platforms than others. For example a native method like sys::Sys.copy may be written in ANSI C and shared by many or perhaps all platforms. Other methods, such as sys::Sys.ticks , almost always require a custom implementation for each hardware or OS platform. All the native source code is organized under a directory called native in the kit directory. Native functions that are portable across all platforms should be contained in C files located directly in the native directory, one file per class using the naming convention \" {kit}_{class}.c \". Any native functions that are implemented separately for each platform should be located in sub-directories under native , one per platform. Code files under these directories are named using the convention \" {kit}_{type}_{platform}.c \". This helps avoid file name collisions. For example, given a kit myKit with one class MyClass that has native functions, some portable and some platform-specific, the code would be organized as follows: myKit/ +- kit.xml +- MyClass.sedona +- native/ | +- myKit_MyClass.c | +- qnx/ | | +- myKit_MyClass_qnx.c | +- win32/ | | +- myKit_MyClass_win32.c +- test/ | +- MyClassTest.sedona All the source code files for the native methods are stored under the folder myKit/native . Functions that can be shared across all platforms are in the file named myKit_MyClass.c , located in the native folder. These functions should not need to be implemented again when porting to a new platform. Source files for platform-specific implementations are located in a separate subfolder for each platform, and the platform name is appended to the source file name. When porting the kit to a new platform newPlat , simply create a new folder native/newPlat and put the native method implementations into a source file myKit_MyClass_newPlat.c under the new folder.","title":"Natives"},{"location":"development/porting/#bootstrap","text":"In addition to the native methods for each kit, the new platform port will need some native bootstrapping code to start the SVM. For sophisticated devices with an OS and a file system (such as a PC), it may be sufficient to build and run the code provided in main.c , which is located in the src/vm directory. This function can be executed from the OS command line, providing on the command line the filenames for the scode image and the app to be run. (Even with platforms that cannot support main.c , it may still be useful as a guide for writing the new bootstrap code.) On smaller, simpler platforms, new bootstrap code will need to be written. Every platform will have a unique implementation, but at some point the SVM will need to be started by calling vmRun(SedonaVM*) . (Both vmRun() and the SedonaVM struct are defined in sedona.h .) Before calling vmRun() , a SedonaVM struct must be created and then initialized as follows: Configure codeBaseAddr and codeSize to point to the scode image. Typically the scode is stored in a disk file or in flash memory, and loaded into RAM at this point. If so then codeBaseAddr is simply a pointer to the scode image in RAM. Configure stackBaseAddr and stackMaxSize to point to an area of RAM that can be used for the stack. Most commonly this is a static or dynamically-allocated array of the desired size. Configure args and argsLen to pass in the arguments to the Sedona Framework main method. The args pointer should reference a normal array of C null terminated strings (just like a standard C main signature). Configure a callback function for onAssertFailure . This function is generally used in test code, and is called whenever an assert condition fails. More details on using the Sedona Framework test facility may be found in the Test chapter. Configure the call function pointer to point to vmCall . This indirection provides a hook for patching a ROM based VM. Configure a pointer to the nativeTable array generated automatically during the VM code generation stage. See the Native Methods chapter for more information. When the SedonaVM struct has been initialized, start the SVM by calling vmRun() and passing a pointer to the struct.","title":"Bootstrap"},{"location":"development/porting/#sedona-vm-exit-values","text":"When the Sedona VM exits, the calling function must decide what to do next based on the return code. If the VM exits normally with a return code of 0 , it generally means the VM is not expecting to restart. The most common use of this is when running the test harness. If so, then the global variables assertSuccesses and assertFailures will contain the number of calls to assert that passed and failed, respectively. When the action App.restart() is invoked, the app stops running and sets the return code to Err.restart . On most platforms this leads to the SVM exiting with the value ERR_RESTART . If this value is received then the calling function should repeat the above steps to restart the SVM (possibly using different app.sab or kits.scode files if the device is restarting after being provisioned ). Note however that App.restart() also calls the platform service's restart() method, which could produce different behavior depending on how that method is implemented. For example, on a device with no OS it might issue a soft restart to the CPU, in which case there would be no return code to process. Some platforms may require the Sedona VM to yield execution control to allow other tasks to run. When vmRun() returns ERR_YIELD , the application is yielding CPU control. See the Yield section for more details. Each platform requires the implementation of an appropriate hibernation strategy. When vmRun() returns ERR_HIBERNATE then the application has requested that the platform go into a low-power or sleep state. Awakening from this state is under the control of the device, not the Sedona Framework application. Upon awaking, call the vmResume() function to start the SVM again from where it left off. See the Hibernation section for more details. If vmRun() returns a non-zero value other than ERR_RESTART , ERR_HIBERNATE , or ERR_YIELD , then there is a problem. Error codes generated in the scode image or the app are defined in src/sys/Err.sedona ; errors from the VM itself are usually indicated by an error code in src/vm/errorcodes.h .","title":"Sedona VM Exit Values"},{"location":"development/porting/#staging","text":"Once the native code has been implemented, the next step is to stage the VM and native code. This copies the relevant native source files into a single directory in order to compile them using the appropriate native toolchain. Staging is accomplished by running sedonac with a platform definition file and specifying the output directory for the staged files. The platform definition lists all the directories containing C source files required to build the SVM for a target platform. (The platform toolchain may add additional non-Sedona files when it builds the final executable). See the platform definition section for more details and an example platform definition file. The platform definition file supplies some basic information about the platform, then lists the kits with native code that will be supported by the VM. Kits without native methods do not need to be mentioned in the platform XML. Finally it identifies the path to each directory containing native code that will be required by the VM at runtime. This includes not only the relevant Sedona native methods implementations, but also the source for the SVM itself. (On platforms where some portion of the VM is in ROM, only the RAM-based code may need to be included here.) Staging is performed by calling sedonac with the platform definition file, specifying the target directory via the -outDir option. For example, $ sedonac platforms/src/acme/basicPlatform-win32.xml -outDir tempStageDir This results in the following: All existing files are removed from the folder tempStageDir All source files are copied from the listed paths into tempStageDir The file nativetable.c is generated, which defines the native function lookup table If the platform id is known at staging time, a sedonaPlatform.h file is created, which contains the PLATFORM_ID macro. The platform manifest is staged in tempStageDir/.par/platformManifest.xml . The toolchain can later add the SVM binary to into the .par/svm/ directory (if desired) and then generate a PAR file . The PAR file could be uploaded to sedonadev.org or installed in the local platform database . Note Given that Tridium no longer supports Sedona, the par file can no longer be uploaded to sedonadev.org .","title":"Staging"},{"location":"development/porting/#wrap-up","text":"Note that sedonac does not build the C code, it simply assembles the files together into a single directory. The C code must then be built with the appropriate toolchain for the target platform. Neither does sedonac generate an actual PAR file for you. It will help by staging a basic .par/ directory containing the platform manifest. However, the toolchain build process will need to include steps/scripts to generate the PAR file for local and/or public use. Once the VM executable has been built, a good next step is to run the test harness and verify the port was successful.","title":"Wrap Up"},{"location":"development/sedonac/","text":"Sedonac \u00b6 Overview \u00b6 The sedonac tool is like a swiss army knife, it is used for the following tasks: Compile Kit : compile Sedona source code into a kit file. Compile Dir : compile a group of kits Compile Code : compile a set of kits into an scode file Compile Platform : stage the native code for a specific platform binary Compile App : convert between sax and sab formats Run : run an arbitrary class within \"sedona.jar\" or \"sedoanc.jar\". Build Docs : auto-generate HTML documentation Compile Kit \u00b6 Sedonac compiles Sedona source files into a kit file when run on a \"kit.xml\" file (or a directory that contains a \"kit.xml\" file). <sedonaKit name = \"serial\" vendor = \"Tridium\" description = \"Serial I/O support\" includeSource = \"true\" doc = \"true\" > <!-- Dependencies --> <depend on= \"sys 1.0\" /> <!-- Source Directories --> <source dir= \".\" /> <source dir= \"test\" testonly= \"true\" /> <!-- Natives --> <native qname= \"serial::SerialPort.doInit\" id= \"4::0\" /> <native qname= \"serial::SerialPort.doClose\" id= \"4::1\" /> <native qname= \"serial::SerialPort.doRead\" id= \"4::2\" /> <native qname= \"serial::SerialPort.doWrite\" id= \"4::3\" /> </sedonaKit> Specification of elements and attributes: <sedonaKit> top level element: name : (required) name of kit. See Vendors for rules on kit names. vendor : (required) name of vendor for kit description : (required) short description for kit includeSource : (optional) boolean indicates whether to include source in kit zip. Defaults to false. doc : (optional) boolean indicates whether to include this kit in API documentation. Defaults to false. version : (optional) version string. Supports variable substitution . See versioning <depend> specifies the dependencies of the kits on : (required) dependency as a kit name and version constraint. <source> specifies a directory of source code: dir : (required) directory path where \"kit.xml\" is located, relative to top directory testonly : (optional) boolean indicating whether the classes in the kit should be used in the test harness. If true, it infers the @testonly facet on all the classes in that directory. Default is false. <native> specifies a native method identifier: qname : qualified name of the native method id : qualified id of the native method Compile Dir \u00b6 If sedonac is run on a file containing a sedonaDir element (usually named \"dir.xml\"), it compiles all the kits named in the list: <sedonaDir> <target name= \"sys\" /> <target name= \"inet\" /> <target name= \"sox\" /> </sedonaDir> <target> specifies a child target: name : (required) name of child directory. The kits will be compiled separately; to assemble them into an scode image, see Compile Code below. Compile Code \u00b6 If sedonac is run on a file containing a sedonaCode element, it compiles the given set of kits into an scode image. The filename of the input XML file is used for the output scode file, e.g. if the input file is \"foo.xml\" sedonac will create a file called \"foo.scode\" in the same directory. <sedonaCode endian= \"little\" blockSize= \"4\" refSize= \"4\" main= \"sys::Sys.main\" debug= \"true\" test= \"true\" > <depend on= \"sys 1.0\" /> <depend on= \"sox 1.0\" /> <depend on= \"inet 1.0\" /> </sedonaCode> <sedonaCode> top level element for scode compile: endian : either \"little\" or \"big\" based on target processor. blockSize : size of a scode block in bytes (see \"sedona.h\") refSize : size of a memory pointer in bytes for target processor (4 for 32-bit processor). main : qualified method name of main method (typically sys::Sys.main ). debug : (optional) boolean to include debug meta-data in image. Defaults to false test : (optional) boolean to include test code in image. Defaults to false armDouble : (optional) set to true if using an ARM microprocessor where 64-bit doubles are stored using byte level little endian, word level big endian. <depend> specifies the kits to compile into the image: on : (required) dependency as a kit name and version constraint. test : (optional) boolean to include tests for this key. Defaults to value of sedonaCode.test if unspecified. Note that the test and debug flags may have a significant impact on scode size. Compile Platform \u00b6 Sedonac is used to stage the native code when compiling a binary image for a given platform. This happens when sedonac is run against an XML file with a sedonaPlatform root element. See Staging and Platform Definition for more details. Compile App \u00b6 If you run sedonac against a file with a \".sax\" extension it converts the application to a \".sab\" file, and vice versa. The output file is placed in the same directory as the input file: D: \\s edona \\p ub \\a pps>sedonac test.sax ConvertAppFile [ D: \\s edona \\p ub \\a pps \\t est.sax -> D: \\s edona \\p ub \\a pps \\t est.sab ] +---------------------------------- | RAM: 14 .2kb ( 14588 bytes ) | FLASH: 0 .4kb ( 382 bytes ) +---------------------------------- Running sedonac on an application file also prints a memory impact report. The RAM value is an estimate of how much memory the application consumes in RAM during runtime. FLASH is the size required to persist the application to durable storage like flash memory (always exactly the same as the size of the sab file). Also see the Apps and Memory chapters. Run \u00b6 If you pass a qualified Java classname to sedonac it will attempt to run that class's main() method: D: \\s edona>sedonac sedona.util.UserUtil brian pass User: brian:pass Digest: 0x [ ca4d1fd9a089ff9d50ab1f1dc4e4772a6b24c6bb ] Base64: yk0f2aCJ/51Qqx8dxOR3Kmskxrs = The class must be defined in \"sedona.jar\" or \"sedonac.jar\": Build Docs \u00b6 The -doc switch builds HTML documentation along with the scode. For example: D: \\s edona>sedonac -doc pub/src/sys Parse [ 44 files ] WriteKit [ D: \\s edona \\p ub \\k its \\s ys \\s ys-b0ce639-1.0.36.kit ] WriteDoc [ D: \\s edona \\p ub \\d oc \\s ys ] *** Success! *** D: \\s edona \\s edonac -doc pub/doc/toc.xml TableOfContents [ D: \\s edona \\p ub \\d oc -> D: \\s edona \\p ub \\d oc ] CheckHtmlLinks [ D: \\s edona \\p ub \\d oc ] *** Success! *** D: \\s edona \\s edonac If the input file is a directory of kit source folders, then it will build the kits and automatically generate HTML documentation for each class, as well as a summary page for each kit. All fields and methods for each class will be included in the documentation, and any ** style comments above a given field or method will be included with the entry for that field or method. If instead the input file to sedonac -doc is an XML file, it will be processed for information on generating a table of contents. See the file doc/toc.xml for an example. Variable Substitution \u00b6 Some attributes in the various input XML files allow for variable substitution. Such attributes will be read by sedonac, and any variables present in the attribute text will be replaced by the variable value. A variable is specified as ${variableName} . For example: <sedonaPlatform vendor=\"Tridium\" id=\"tridium-foo-${sedona.env.version}\" /> The id attribute above might end up being resolved as tridium-foo-1.0.38 . Sedonac will resolve variables according to the following rules: If the variable starts with os.env. then sedonac will attempt to resolve an environment variable. For example, ${os.env.USER} will cause sedonac to look in the environment for a variable called USER . If the variable starts with sedona.env. then sedonac will attempt to resolve a variable in the Sedona Framework environment (see sedona.Env.java). For example, ${sedona.env.buildVersion} will cause sedonac to try and resolve property buildVersion in the sedona environment. Note: as a convenience ${sedona.env.version} resolves to sedona.Env.version Otherwise, attempt to resolve the variable name against any variables that the compiler might set. For example, when compiling a platform definition file the compiler will set a variable called ${stage.nativeChecksum} . It is always a compiler error if a variable cannot be resolved. The most common place that variable substitution is used is in the platform definition file. The documentation for each XML file will explicitly indicate which elements and attributes support variable substitution (if any).","title":"Sedonac"},{"location":"development/sedonac/#sedonac","text":"","title":"Sedonac"},{"location":"development/sedonac/#overview","text":"The sedonac tool is like a swiss army knife, it is used for the following tasks: Compile Kit : compile Sedona source code into a kit file. Compile Dir : compile a group of kits Compile Code : compile a set of kits into an scode file Compile Platform : stage the native code for a specific platform binary Compile App : convert between sax and sab formats Run : run an arbitrary class within \"sedona.jar\" or \"sedoanc.jar\". Build Docs : auto-generate HTML documentation","title":"Overview"},{"location":"development/sedonac/#compile-kit","text":"Sedonac compiles Sedona source files into a kit file when run on a \"kit.xml\" file (or a directory that contains a \"kit.xml\" file). <sedonaKit name = \"serial\" vendor = \"Tridium\" description = \"Serial I/O support\" includeSource = \"true\" doc = \"true\" > <!-- Dependencies --> <depend on= \"sys 1.0\" /> <!-- Source Directories --> <source dir= \".\" /> <source dir= \"test\" testonly= \"true\" /> <!-- Natives --> <native qname= \"serial::SerialPort.doInit\" id= \"4::0\" /> <native qname= \"serial::SerialPort.doClose\" id= \"4::1\" /> <native qname= \"serial::SerialPort.doRead\" id= \"4::2\" /> <native qname= \"serial::SerialPort.doWrite\" id= \"4::3\" /> </sedonaKit> Specification of elements and attributes: <sedonaKit> top level element: name : (required) name of kit. See Vendors for rules on kit names. vendor : (required) name of vendor for kit description : (required) short description for kit includeSource : (optional) boolean indicates whether to include source in kit zip. Defaults to false. doc : (optional) boolean indicates whether to include this kit in API documentation. Defaults to false. version : (optional) version string. Supports variable substitution . See versioning <depend> specifies the dependencies of the kits on : (required) dependency as a kit name and version constraint. <source> specifies a directory of source code: dir : (required) directory path where \"kit.xml\" is located, relative to top directory testonly : (optional) boolean indicating whether the classes in the kit should be used in the test harness. If true, it infers the @testonly facet on all the classes in that directory. Default is false. <native> specifies a native method identifier: qname : qualified name of the native method id : qualified id of the native method","title":"Compile Kit"},{"location":"development/sedonac/#compile-dir","text":"If sedonac is run on a file containing a sedonaDir element (usually named \"dir.xml\"), it compiles all the kits named in the list: <sedonaDir> <target name= \"sys\" /> <target name= \"inet\" /> <target name= \"sox\" /> </sedonaDir> <target> specifies a child target: name : (required) name of child directory. The kits will be compiled separately; to assemble them into an scode image, see Compile Code below.","title":"Compile Dir"},{"location":"development/sedonac/#compile-code","text":"If sedonac is run on a file containing a sedonaCode element, it compiles the given set of kits into an scode image. The filename of the input XML file is used for the output scode file, e.g. if the input file is \"foo.xml\" sedonac will create a file called \"foo.scode\" in the same directory. <sedonaCode endian= \"little\" blockSize= \"4\" refSize= \"4\" main= \"sys::Sys.main\" debug= \"true\" test= \"true\" > <depend on= \"sys 1.0\" /> <depend on= \"sox 1.0\" /> <depend on= \"inet 1.0\" /> </sedonaCode> <sedonaCode> top level element for scode compile: endian : either \"little\" or \"big\" based on target processor. blockSize : size of a scode block in bytes (see \"sedona.h\") refSize : size of a memory pointer in bytes for target processor (4 for 32-bit processor). main : qualified method name of main method (typically sys::Sys.main ). debug : (optional) boolean to include debug meta-data in image. Defaults to false test : (optional) boolean to include test code in image. Defaults to false armDouble : (optional) set to true if using an ARM microprocessor where 64-bit doubles are stored using byte level little endian, word level big endian. <depend> specifies the kits to compile into the image: on : (required) dependency as a kit name and version constraint. test : (optional) boolean to include tests for this key. Defaults to value of sedonaCode.test if unspecified. Note that the test and debug flags may have a significant impact on scode size.","title":"Compile Code"},{"location":"development/sedonac/#compile-platform","text":"Sedonac is used to stage the native code when compiling a binary image for a given platform. This happens when sedonac is run against an XML file with a sedonaPlatform root element. See Staging and Platform Definition for more details.","title":"Compile Platform"},{"location":"development/sedonac/#compile-app","text":"If you run sedonac against a file with a \".sax\" extension it converts the application to a \".sab\" file, and vice versa. The output file is placed in the same directory as the input file: D: \\s edona \\p ub \\a pps>sedonac test.sax ConvertAppFile [ D: \\s edona \\p ub \\a pps \\t est.sax -> D: \\s edona \\p ub \\a pps \\t est.sab ] +---------------------------------- | RAM: 14 .2kb ( 14588 bytes ) | FLASH: 0 .4kb ( 382 bytes ) +---------------------------------- Running sedonac on an application file also prints a memory impact report. The RAM value is an estimate of how much memory the application consumes in RAM during runtime. FLASH is the size required to persist the application to durable storage like flash memory (always exactly the same as the size of the sab file). Also see the Apps and Memory chapters.","title":"Compile App"},{"location":"development/sedonac/#run","text":"If you pass a qualified Java classname to sedonac it will attempt to run that class's main() method: D: \\s edona>sedonac sedona.util.UserUtil brian pass User: brian:pass Digest: 0x [ ca4d1fd9a089ff9d50ab1f1dc4e4772a6b24c6bb ] Base64: yk0f2aCJ/51Qqx8dxOR3Kmskxrs = The class must be defined in \"sedona.jar\" or \"sedonac.jar\":","title":"Run"},{"location":"development/sedonac/#build-docs","text":"The -doc switch builds HTML documentation along with the scode. For example: D: \\s edona>sedonac -doc pub/src/sys Parse [ 44 files ] WriteKit [ D: \\s edona \\p ub \\k its \\s ys \\s ys-b0ce639-1.0.36.kit ] WriteDoc [ D: \\s edona \\p ub \\d oc \\s ys ] *** Success! *** D: \\s edona \\s edonac -doc pub/doc/toc.xml TableOfContents [ D: \\s edona \\p ub \\d oc -> D: \\s edona \\p ub \\d oc ] CheckHtmlLinks [ D: \\s edona \\p ub \\d oc ] *** Success! *** D: \\s edona \\s edonac If the input file is a directory of kit source folders, then it will build the kits and automatically generate HTML documentation for each class, as well as a summary page for each kit. All fields and methods for each class will be included in the documentation, and any ** style comments above a given field or method will be included with the entry for that field or method. If instead the input file to sedonac -doc is an XML file, it will be processed for information on generating a table of contents. See the file doc/toc.xml for an example.","title":"Build Docs"},{"location":"development/sedonac/#variable-substitution","text":"Some attributes in the various input XML files allow for variable substitution. Such attributes will be read by sedonac, and any variables present in the attribute text will be replaced by the variable value. A variable is specified as ${variableName} . For example: <sedonaPlatform vendor=\"Tridium\" id=\"tridium-foo-${sedona.env.version}\" /> The id attribute above might end up being resolved as tridium-foo-1.0.38 . Sedonac will resolve variables according to the following rules: If the variable starts with os.env. then sedonac will attempt to resolve an environment variable. For example, ${os.env.USER} will cause sedonac to look in the environment for a variable called USER . If the variable starts with sedona.env. then sedonac will attempt to resolve a variable in the Sedona Framework environment (see sedona.Env.java). For example, ${sedona.env.buildVersion} will cause sedonac to try and resolve property buildVersion in the sedona environment. Note: as a convenience ${sedona.env.version} resolves to sedona.Env.version Otherwise, attempt to resolve the variable name against any variables that the compiler might set. For example, when compiling a platform definition file the compiler will set a variable called ${stage.nativeChecksum} . It is always a compiler error if a variable cannot be resolved. The most common place that variable substitution is used is in the platform definition file. The documentation for each XML file will explicitly indicate which elements and attributes support variable substitution (if any).","title":"Variable Substitution"},{"location":"development/testing/","text":"Testing \u00b6 Overview \u00b6 We all love test driven development! The Sedona Framework comes with built-in support for writing and running unit tests. You won't have any excuses to skip unit testing. The test framework is based upon the following principles: Bundled with Kits : the goal of the test framework is to enable you to bundle unit tests for each kit with the kit itself Test Only Code : a set of classes within a kit is marked test only so that we can include or exclude test code easily Test Methods : classes that extend sys::Test are automatically scanned for test methods and added to the test harness Test Harness : the Sedona Framework runtime includes a harness to automatically run all the tests for a given scode image Test Only \u00b6 Because the Sedona Framework targets very resource constrained devices, we need to maximize every byte available. So the compiler lets you mark which classes are test code versus normal runtime code. The standard mechanism to do this is via the test attribute in your \"kit.xml\" build file: <source dir= \".\" /> <source dir= \"test\" testonly= \"true\" /> The XML above illustrates a kit build file that contains two source directories. The \".\" directory contains the normal runtime classes. On the other hand, all the classes defined in the \"test\" directory are automatically marked test only . If you look at the IR for these classes you will see each test class annotated with the @testonly facet. Convention is to place all test code in a subdirectory called \"test\" inside your source folder. Test Methods \u00b6 Tests are organized into test classes , which are classes that extend sys::Test . Every method inside a test class whose name starts with \"test\" is a test method . Test methods are the primary unit of test execution. Test methods must be public, static, non-native methods that return void and declare no parameters. Each test method should be designed to test a single feature or function of your kit's code. The test is implemented using one or more assert statements. This is an example test class for testing sys::Str : class StrTest extends Test { static void testEquals() { assert(\"a\".equals(\"a\")) assert(!\"a\".equals(\"x\")) } } Test Harness \u00b6 Follow these steps to run the test harness: Ensure that your scode image includes test code by setting the sedonaCode.test attribute to true in your scode XML build file. If you need to free up extra memory, or wish to narrow the tests to run, you can set the depend.test attribute on each kit element in your scode XML build file. This allows you to include or exclude test code on a kit by kit basis (if sedonaCode.test is false then these attributes are ignored). Ensure the main attribute is set to sys::Sys.main in your scode XML build file Build the test version of your scode Run the VM using the -test argument, which will execute all the test methods and report assert successes and failures: svm kits.scode -test","title":"Testing"},{"location":"development/testing/#testing","text":"","title":"Testing"},{"location":"development/testing/#overview","text":"We all love test driven development! The Sedona Framework comes with built-in support for writing and running unit tests. You won't have any excuses to skip unit testing. The test framework is based upon the following principles: Bundled with Kits : the goal of the test framework is to enable you to bundle unit tests for each kit with the kit itself Test Only Code : a set of classes within a kit is marked test only so that we can include or exclude test code easily Test Methods : classes that extend sys::Test are automatically scanned for test methods and added to the test harness Test Harness : the Sedona Framework runtime includes a harness to automatically run all the tests for a given scode image","title":"Overview"},{"location":"development/testing/#test-only","text":"Because the Sedona Framework targets very resource constrained devices, we need to maximize every byte available. So the compiler lets you mark which classes are test code versus normal runtime code. The standard mechanism to do this is via the test attribute in your \"kit.xml\" build file: <source dir= \".\" /> <source dir= \"test\" testonly= \"true\" /> The XML above illustrates a kit build file that contains two source directories. The \".\" directory contains the normal runtime classes. On the other hand, all the classes defined in the \"test\" directory are automatically marked test only . If you look at the IR for these classes you will see each test class annotated with the @testonly facet. Convention is to place all test code in a subdirectory called \"test\" inside your source folder.","title":"Test Only"},{"location":"development/testing/#test-methods","text":"Tests are organized into test classes , which are classes that extend sys::Test . Every method inside a test class whose name starts with \"test\" is a test method . Test methods are the primary unit of test execution. Test methods must be public, static, non-native methods that return void and declare no parameters. Each test method should be designed to test a single feature or function of your kit's code. The test is implemented using one or more assert statements. This is an example test class for testing sys::Str : class StrTest extends Test { static void testEquals() { assert(\"a\".equals(\"a\")) assert(!\"a\".equals(\"x\")) } }","title":"Test Methods"},{"location":"development/testing/#test-harness","text":"Follow these steps to run the test harness: Ensure that your scode image includes test code by setting the sedonaCode.test attribute to true in your scode XML build file. If you need to free up extra memory, or wish to narrow the tests to run, you can set the depend.test attribute on each kit element in your scode XML build file. This allows you to include or exclude test code on a kit by kit basis (if sedonaCode.test is false then these attributes are ignored). Ensure the main attribute is set to sys::Sys.main in your scode XML build file Build the test version of your scode Run the VM using the -test argument, which will execute all the test methods and report assert successes and failures: svm kits.scode -test","title":"Test Harness"},{"location":"language/arrays/","text":"Arrays \u00b6 Overview \u00b6 The Sedona Framework model for arrays is very similar to the C language. An array is just a block of memory large enough hold a declared number of items. Arrays do not store their own length, so bounds checking is up to the developer. The format of an array type declaration is: <Type>[<size>] // size is optional byte[10] buf // example of sized array type declaration Person[] people // example of unsized array type declaration If the size of the array is specified between the brackets we call it a sized array , otherwise we call it a unsized array . The Sedona Framework does not support multi-dimensional arrays. Memory Management \u00b6 Arrays are always passed by reference - the reference is just a pointer to the base address of the array. To actually allocate memory for an array, it must be declared as an inline field. For example: class Foo { static int[5] x static inline int[5] y } In the class above we declare two static fields. The field x is a reference to an array of five ints - so it allocates enough memory to store a pointer (typically 4 bytes on a 32-bit machine). The field y on the other hand is storage for five ints, so it allocates 20 bytes. In the example above Foo.x is just a pointer, so you can set x to any value that points to 5 ints. For example the assignment x=y updates x to point to the block of memory allocated by y . On the other hand, y actually allocates a block of memory to store 5 ints. You can pass y around as a pointer and index its values, but you cannot change what it points to. Like all inline fields, y can never be used as the left hand side of an assignment statement. Arrays of References \u00b6 An array of objects is stored as an array of references to those objects. On a machine with 32-bit pointers, this means that an array of 3 objects will always be 12 bytes no matter how big the objects themselves are. However, there is a special syntax for allocating enough memory to hold the objects too: class Point { int x int y } class Shape { static Point [] a static inline Point [ 3 ] b static inline Point [ 3 ] c = {...} } The Point class stores two ints, which means a single instance of Point is 8 bytes. Note the three different field declarations in Shape : Shape.a : The first field a declares a pointer to an array of Point s, so a is allocated enough memory to store a single pointer (most likely 4 bytes). Shape.b : The field Point.b allocates enough memory to store 3 references to Points , but doesn't allocate any memory for actual Point instances - so b would allocate 12 bytes on a 32-bit machine. The references don't point to anything yet; they must be initialized elsewhere to point to actual objects. Shape.c : The Point.c field uses the special syntax = {...} to allocate enough memory for an array of 3 references to Points and 3 instances of Points . So c will allocate 36 bytes of memory on a 32-bit machine: 12 for the array itself, plus 3*8 for the instances. The compiler auto-generates initialization code to assign the references to the instances. Unsized Classes \u00b6 Under most circumstances you must specify a size to declare an inline array. However a class may declare one instance field as an unsized inline array. We call these classes unsized classes because their size isn't fixed. To make this work, unsized classes have a few special rules: The class can have no more than one unsized inline array The unsized inline array must be an instance field (not static) The array length must be assigned in the constructor The length must be assigned directly from a constructor parameter The class must be declared final (true of all classes with constructor arguments) The sys::Buf class is a good example of an unsized class: final class Buf { Buf ( int maxBufLen ) { this . bytesLen = maxBufLen this . bytes . length = maxBufLen } inline byte [] bytes // raw byte array short bytesLen // length of bytes array } The code snippet above illustrates how to declare an unsized inline array. The constructor must have a statement that assigns the \"length field\" of the array. The right hand side of the assignment must be a parameter of the constructor (it can't be a calculated value). To declare an instance of a Buf we pass the length to the inline constructor: inline Buf(3) buf1st inline Buf(10) buf2nd In the example above we declared two instances of Buf . The first buffer allocates enough memory to store Buf 's fixed slots (such as bytesLen ) plus enough memory for 3 bytes. The second buffer allocates enough memory for Buf 's fixed slots plus 10 bytes. This feature is used extensively when working with the sys::Str class. Array Literals \u00b6 Some array types may be declared as literals in code: define Str[] colors = {\"red\", \"green\", \"blue\"} See Array Literals for more details.","title":"Arrays"},{"location":"language/arrays/#arrays","text":"","title":"Arrays"},{"location":"language/arrays/#overview","text":"The Sedona Framework model for arrays is very similar to the C language. An array is just a block of memory large enough hold a declared number of items. Arrays do not store their own length, so bounds checking is up to the developer. The format of an array type declaration is: <Type>[<size>] // size is optional byte[10] buf // example of sized array type declaration Person[] people // example of unsized array type declaration If the size of the array is specified between the brackets we call it a sized array , otherwise we call it a unsized array . The Sedona Framework does not support multi-dimensional arrays.","title":"Overview"},{"location":"language/arrays/#memory-management","text":"Arrays are always passed by reference - the reference is just a pointer to the base address of the array. To actually allocate memory for an array, it must be declared as an inline field. For example: class Foo { static int[5] x static inline int[5] y } In the class above we declare two static fields. The field x is a reference to an array of five ints - so it allocates enough memory to store a pointer (typically 4 bytes on a 32-bit machine). The field y on the other hand is storage for five ints, so it allocates 20 bytes. In the example above Foo.x is just a pointer, so you can set x to any value that points to 5 ints. For example the assignment x=y updates x to point to the block of memory allocated by y . On the other hand, y actually allocates a block of memory to store 5 ints. You can pass y around as a pointer and index its values, but you cannot change what it points to. Like all inline fields, y can never be used as the left hand side of an assignment statement.","title":"Memory Management"},{"location":"language/arrays/#arrays-of-references","text":"An array of objects is stored as an array of references to those objects. On a machine with 32-bit pointers, this means that an array of 3 objects will always be 12 bytes no matter how big the objects themselves are. However, there is a special syntax for allocating enough memory to hold the objects too: class Point { int x int y } class Shape { static Point [] a static inline Point [ 3 ] b static inline Point [ 3 ] c = {...} } The Point class stores two ints, which means a single instance of Point is 8 bytes. Note the three different field declarations in Shape : Shape.a : The first field a declares a pointer to an array of Point s, so a is allocated enough memory to store a single pointer (most likely 4 bytes). Shape.b : The field Point.b allocates enough memory to store 3 references to Points , but doesn't allocate any memory for actual Point instances - so b would allocate 12 bytes on a 32-bit machine. The references don't point to anything yet; they must be initialized elsewhere to point to actual objects. Shape.c : The Point.c field uses the special syntax = {...} to allocate enough memory for an array of 3 references to Points and 3 instances of Points . So c will allocate 36 bytes of memory on a 32-bit machine: 12 for the array itself, plus 3*8 for the instances. The compiler auto-generates initialization code to assign the references to the instances.","title":"Arrays of References"},{"location":"language/arrays/#unsized-classes","text":"Under most circumstances you must specify a size to declare an inline array. However a class may declare one instance field as an unsized inline array. We call these classes unsized classes because their size isn't fixed. To make this work, unsized classes have a few special rules: The class can have no more than one unsized inline array The unsized inline array must be an instance field (not static) The array length must be assigned in the constructor The length must be assigned directly from a constructor parameter The class must be declared final (true of all classes with constructor arguments) The sys::Buf class is a good example of an unsized class: final class Buf { Buf ( int maxBufLen ) { this . bytesLen = maxBufLen this . bytes . length = maxBufLen } inline byte [] bytes // raw byte array short bytesLen // length of bytes array } The code snippet above illustrates how to declare an unsized inline array. The constructor must have a statement that assigns the \"length field\" of the array. The right hand side of the assignment must be a parameter of the constructor (it can't be a calculated value). To declare an instance of a Buf we pass the length to the inline constructor: inline Buf(3) buf1st inline Buf(10) buf2nd In the example above we declared two instances of Buf . The first buffer allocates enough memory to store Buf 's fixed slots (such as bytesLen ) plus enough memory for 3 bytes. The second buffer allocates enough memory for Buf 's fixed slots plus 10 bytes. This feature is used extensively when working with the sys::Str class.","title":"Unsized Classes"},{"location":"language/arrays/#array-literals","text":"Some array types may be declared as literals in code: define Str[] colors = {\"red\", \"green\", \"blue\"} See Array Literals for more details.","title":"Array Literals"},{"location":"language/classes/","text":"Classes \u00b6 Overview \u00b6 Classes are the primary way you organize your code within kits. Classes are named containers for fields and methods. A field or method definition is called a slot and identified by a unique name within a given class. Slots may not be overloaded by name, which means you cannot declare a field and method to have the same name (allowed in Java). Nor can you declare multiple methods with the same name overloaded by parameters (allowed in both Java and C#). You can declare multiple classes in a single source file, although by convention each class is placed in its own source file with the same name. For example the class \"Thing\" would be declared in the file \"Thing.sedona\". Modifiers \u00b6 By default a class is public , or you can explicitly use the public keyword. Alternatively use the internal keyword to declare a class that only has visibility within its kit. The abstract keyword is used with classes that can never be instantiated directly. Any class that declares abstract methods must be marked abstract. Use the final class modifier to prevent a class from being subclassed. Inheritance \u00b6 The Sedona Framework supports inheritance much like Java or C#. However, there is no support for interfaces or any type of multiple inheritance. Similar to Java, all Sedona classes implicitly extend sys::Obj , a class with no fields or methods of its own. To support polymorphism and virtual methods, however, a Sedona class (or some class in its hierarchy) must explicitly extend sys::Virtual , which allocates space for the virtual table. The syntax for inheritance looks just like Java with the extends keyword: abstract class Shape extends Virtual { abstract int area () } class Square extends Shape { override int area () { return width * width } int width } Note that extending Virtual has some memory impact: In addition to the space required for the type's virtual table, it imposes a two byte overhead per class instance.","title":"Classes"},{"location":"language/classes/#classes","text":"","title":"Classes"},{"location":"language/classes/#overview","text":"Classes are the primary way you organize your code within kits. Classes are named containers for fields and methods. A field or method definition is called a slot and identified by a unique name within a given class. Slots may not be overloaded by name, which means you cannot declare a field and method to have the same name (allowed in Java). Nor can you declare multiple methods with the same name overloaded by parameters (allowed in both Java and C#). You can declare multiple classes in a single source file, although by convention each class is placed in its own source file with the same name. For example the class \"Thing\" would be declared in the file \"Thing.sedona\".","title":"Overview"},{"location":"language/classes/#modifiers","text":"By default a class is public , or you can explicitly use the public keyword. Alternatively use the internal keyword to declare a class that only has visibility within its kit. The abstract keyword is used with classes that can never be instantiated directly. Any class that declares abstract methods must be marked abstract. Use the final class modifier to prevent a class from being subclassed.","title":"Modifiers"},{"location":"language/classes/#inheritance","text":"The Sedona Framework supports inheritance much like Java or C#. However, there is no support for interfaces or any type of multiple inheritance. Similar to Java, all Sedona classes implicitly extend sys::Obj , a class with no fields or methods of its own. To support polymorphism and virtual methods, however, a Sedona class (or some class in its hierarchy) must explicitly extend sys::Virtual , which allocates space for the virtual table. The syntax for inheritance looks just like Java with the extends keyword: abstract class Shape extends Virtual { abstract int area () } class Square extends Shape { override int area () { return width * width } int width } Note that extending Virtual has some memory impact: In addition to the space required for the type's virtual table, it imposes a two byte overhead per class instance.","title":"Inheritance"},{"location":"language/components/","text":"Components \u00b6 Overview \u00b6 Sedona is a component oriented language, which means that programs are developed as reusable chunks of code designed to be snapped together much like Lego building blocks. This chapter discusses components themselves; the Apps chapter discusses how components are assembled into applications. A component is any class that extends sys::Component . Components include several features: Can define property fields Can define action methods Can be organized into a tree structure Can be given a human friendly name (up to 7 ASCII characters) Have a two byte identifier within an application Can be linked within an application Provides callback methods that can be overridden Component types have reflection capability Properties \u00b6 Properties are normal instance fields that are annotated with the property keyword. Properties are how components expose configuration and runtime state. Properties are restricted to the following types: bool byte short int long float double sys::Buf Note that you must use the := operator when assigning values to properties. See Assigning to Properties for details. Config vs Runtime \u00b6 Properties are either config or runtime . Config properties are persistent and typically are changed by the user. Runtime properties are transient and are changed by the component itself during runtime. Properties are runtime by default unless marked with the \"config\" facet. A simple example: class FooServer extends Component { @config property bool enabled @config property int port = 80 property int count // runtime prop } Buf Properties \u00b6 Properties typed as Buf are a bit special from the primitive property types. The biggest difference is that primitives are by-value and can't be changed without setting the field itself. However, buffer properties are always inlined and accessed by reference. When declaring a buffer property, the inline modifier is implied. The following example illustrates a buffer property with a total capacity of 8 bytes: class Foo extends Component { property Buf(8) blob } Because buffer properties are accessed by reference, the framework has no knowledge when the buffer is modified. So it is the developer's responsibility to notify the framework of a buffer change via the Component.changed method (typically using a slot literal): void updateBlob() { blob.copyFromStr(\"wow!\") changed(Foo.blob) } Note that changed is called automatically when setting primitive property types. You should only manually call changed for Buf properties. AsStr Properties \u00b6 Buf is the only non-primitive property type available. However, it is a common case to store a Str value in a Buf property. If you know that a buffer property will always store a null-terminated string, then you should mark the property with the \"asStr\" facet: class Foo extends Component { @config @asStr property Buf(8) descr } The Buf size is the total capacity including the null terminator - so in the example above we can store a string with a max of seven characters. The Buf class has convenience methods when storing a string such as toStr and copyFromStr . Marking a buffer property asStr has a couple of benefits: Buffer overruns are handled to ensure that there is always a null terminator during deserialization. It lets higher levels of the framework treat the buffer as more than raw binary data. For example, asStr properties are serialized as text rather than base64 in XML files. Actions \u00b6 Actions are normal instance methods that are annotated with the action keyword. Every action is implicitly defined to be virtual , so they can be overridden. Actions are typically used as commands on a component. As methods, actions \"do something\" rather than store or display a value. Actions methods must be declared to return void and must have zero or one parameter. If a parameter is specified then it must be one of the following types: bool int long float double sys::Buf Examples of \"actions in action\": class Foo extends Component { action void actionNoArg() { Sys.out.print(\"actionNoArg\").nl() } @asStr action void actionStr(Buf x) { Sys.out.print(x.toStr()).nl() } } class FooOverride extends Foo { override action void actionNoArg() { Sys.out.print(\"Override actionNoArg\").nl() } } Note that you can use the \"asStr\" facet to annotate an action that takes a Buf, if the argument should be a null-terminated string. Callbacks \u00b6 Any class that extends sys::Component includes the following virtual methods. Each is called automatically by the system at the appropriate time. These callback methods may be overridden by Component subclasses to change the behavior of the component. virtual void loaded() virtual void start() virtual void execute() virtual void changed(Slot slot) virtual void setToDefault(Slot slot) virtual int childEvent(int eType, Component child) virtual int parentEvent(int eType, Component parent) virtual int linkEvent(int eType, Link link) See the API documentation at sys::Component for details on how these methods are used.","title":"Components"},{"location":"language/components/#components","text":"","title":"Components"},{"location":"language/components/#overview","text":"Sedona is a component oriented language, which means that programs are developed as reusable chunks of code designed to be snapped together much like Lego building blocks. This chapter discusses components themselves; the Apps chapter discusses how components are assembled into applications. A component is any class that extends sys::Component . Components include several features: Can define property fields Can define action methods Can be organized into a tree structure Can be given a human friendly name (up to 7 ASCII characters) Have a two byte identifier within an application Can be linked within an application Provides callback methods that can be overridden Component types have reflection capability","title":"Overview"},{"location":"language/components/#properties","text":"Properties are normal instance fields that are annotated with the property keyword. Properties are how components expose configuration and runtime state. Properties are restricted to the following types: bool byte short int long float double sys::Buf Note that you must use the := operator when assigning values to properties. See Assigning to Properties for details.","title":"Properties"},{"location":"language/components/#config-vs-runtime","text":"Properties are either config or runtime . Config properties are persistent and typically are changed by the user. Runtime properties are transient and are changed by the component itself during runtime. Properties are runtime by default unless marked with the \"config\" facet. A simple example: class FooServer extends Component { @config property bool enabled @config property int port = 80 property int count // runtime prop }","title":"Config vs Runtime"},{"location":"language/components/#buf-properties","text":"Properties typed as Buf are a bit special from the primitive property types. The biggest difference is that primitives are by-value and can't be changed without setting the field itself. However, buffer properties are always inlined and accessed by reference. When declaring a buffer property, the inline modifier is implied. The following example illustrates a buffer property with a total capacity of 8 bytes: class Foo extends Component { property Buf(8) blob } Because buffer properties are accessed by reference, the framework has no knowledge when the buffer is modified. So it is the developer's responsibility to notify the framework of a buffer change via the Component.changed method (typically using a slot literal): void updateBlob() { blob.copyFromStr(\"wow!\") changed(Foo.blob) } Note that changed is called automatically when setting primitive property types. You should only manually call changed for Buf properties.","title":"Buf Properties"},{"location":"language/components/#asstr-properties","text":"Buf is the only non-primitive property type available. However, it is a common case to store a Str value in a Buf property. If you know that a buffer property will always store a null-terminated string, then you should mark the property with the \"asStr\" facet: class Foo extends Component { @config @asStr property Buf(8) descr } The Buf size is the total capacity including the null terminator - so in the example above we can store a string with a max of seven characters. The Buf class has convenience methods when storing a string such as toStr and copyFromStr . Marking a buffer property asStr has a couple of benefits: Buffer overruns are handled to ensure that there is always a null terminator during deserialization. It lets higher levels of the framework treat the buffer as more than raw binary data. For example, asStr properties are serialized as text rather than base64 in XML files.","title":"AsStr Properties"},{"location":"language/components/#actions","text":"Actions are normal instance methods that are annotated with the action keyword. Every action is implicitly defined to be virtual , so they can be overridden. Actions are typically used as commands on a component. As methods, actions \"do something\" rather than store or display a value. Actions methods must be declared to return void and must have zero or one parameter. If a parameter is specified then it must be one of the following types: bool int long float double sys::Buf Examples of \"actions in action\": class Foo extends Component { action void actionNoArg() { Sys.out.print(\"actionNoArg\").nl() } @asStr action void actionStr(Buf x) { Sys.out.print(x.toStr()).nl() } } class FooOverride extends Foo { override action void actionNoArg() { Sys.out.print(\"Override actionNoArg\").nl() } } Note that you can use the \"asStr\" facet to annotate an action that takes a Buf, if the argument should be a null-terminated string.","title":"Actions"},{"location":"language/components/#callbacks","text":"Any class that extends sys::Component includes the following virtual methods. Each is called automatically by the system at the appropriate time. These callback methods may be overridden by Component subclasses to change the behavior of the component. virtual void loaded() virtual void start() virtual void execute() virtual void changed(Slot slot) virtual void setToDefault(Slot slot) virtual int childEvent(int eType, Component child) virtual int parentEvent(int eType, Component parent) virtual int linkEvent(int eType, Link link) See the API documentation at sys::Component for details on how these methods are used.","title":"Callbacks"},{"location":"language/expr/","text":"Expressions \u00b6 Overview \u00b6 Expressions are almost identical to those found in C or Java. The same operator precedence rules apply: Expression(s) Operator(s) Accessors . ?. () [] Unary - ! ~ ++ -- (cast) Multiplicative * / % Additive + - Bitwise Shift >> << Elvis ?: Relational < <= > >= Equality == != Bitwise AND & Bitwise XOR ^ Bitwise OR | Logical AND && Logical OR || Ternary ? : Assignment = += -= *= /= |= ^= &= >>= <<= Arithmetic Operators \u00b6 The following arithmetic operators may be used with numeric primitives: Name Operator Multiplication x * y Division x / y Modulus (remainder) x % y Addition x + y Subtraction x - y Negation -x Prefix Increment ++x Prefix Decrement --x Postfix Increment x++ Postfix Decrement x-- The Modulus operator is only available for integer types, it may not be used with floats or doubles. The prefix/postfix operators work just like C and Java. If using the prefix operator the result of the expression is the new value. If using the postfix operator the result is the old value: int x = 4 // x == 4 int y = ++x // x == 5, y == 5 int z = x++ // x == 6, z == 5 Bitwise Operators \u00b6 The following bitwise operators may be used with integer primitives (byte, short, int, long): Name Operator Or x | y Xor x ^ y And x & y Left Shift x << y Right Shift x >> y Not ~x Logical Operators \u00b6 The following logical operators may be used with booleans: Name Operator Or x || y And x && y Not !x Both the Or and And operators are short circuiting. If the first term of Or evaluates to true, then the second term is not evaluated. If the first term of And evaluates to false, then the second term is not evaluated. Comparison \u00b6 The following operators are used for comparison: Name Operator Equal x == y Not Equal x != y Greater Than x > y Greater Than or Equal x >= y Less Than x < y Less Than or Equal x <= y Non-numeric types may only use the equality ( == and != ) operators. Reference types compare identity (pointer address). Assignment \u00b6 The = operator is used to assign the right hand side expression to the left hand side. The left hand side must be assignable . Assignable expressions are local variables, fields, and array indices. The compound assignment operators += -= *= /= |= ^= &= >>= <<= can be used to combine an arithmetic or bitwise operator with assignment: int x = 5 // x == 5 x += 3 // x == 8 Assigning to Properties \u00b6 If the left hand side of an assignment expression is a component property then you must use the := assignment operator instead of = . This highlights the fact that assigning a new value to a property results in more than just the storage of the new value; it also has potential side effects that may not always be visible to the user. Note that there are no compound property assignment operators; increment, decrement, etc must be spelled out explicitly in the expression. // Property px property int px // Non-property field ix int ix void myfunc () { // Use := when lhs is a property px : = 3 // Use = when lhs is a non-property ix = px // No compound assignment operators px : = px + 1 } Casting \u00b6 Sedona uses a syntax just like C or Java to perform a cast. Casts are required when the compiler cannot perform a static type check. For example, if you need to assign an Obj to a Component, then you must use a cast: c = (Component)obj . This type of cast is for compile time checking only, at runtime it is basically a no-op like C. Casts are also used with numeric types to perform a type conversion. For example to convert an int into a float: f = (float)i . Note that unlike C and Java, upcasts such as from an int to a long are not implicit - you must be explicitly use a cast. Safe Navigation \u00b6 Sedona supports Groovy's safe navigation operator: x?.slot . You can use the safe nav operator to access fields or call methods. If the target expression of a slot access is null, then the whole expression short circuits to evaluate to null. If the field or method returns a primitive then it short circuits to false/zero. Using the safe nav operator is a convenient and more efficient way than manually checking for null: // hard way DeviceNetwork net = null if (point != null) { Device dev = point.getDevice() if (dev != null) net = dev.getNetwork() } // easy way DeviceNetwork net = point?.getDevice()?.getNetwork() Elvis \u00b6 Sedona supports Groovy's elvis operator: lhs ?: rhs . If lhs evaluates to null, then the whole expression evaluates to rhs. If lhs is non-null, then the rhs is short circuited and the whole expression evaluates to lhs. The elvis operator is a convenient and more efficient way to write code where you might use the ternary operator: // hard way name != null ? name : \"unknown\" // easy way name ?: \"unknown\" Ternary \u00b6 Sedona supports the C/Java ternary operator: c ? t : f . The boolean expression c is evaluated. If true then the ternary expression evaluates to t , otherwise it evaluates to f : bool x = true Str msg = x ? \"On\" : \"Off\" // msg == \"On\" x = false msg = x ? \"On\" : \"Off\" // msg == \"Off\" String Interpolation \u00b6 Sedona supports string interpolation, which allows for concise string formatting. String interpolation can be used with any method that has one Str parameter and returns an OutStream . You may use the \"+\" operator to concatenate multiple expressions to a string literal: // using the + operator int x = 77 Sys.out.print(\"x=\" + x) // is equivalent to this statement Sys.out.print(\"x=\").printInt(x) The example above illustrates why interpolation is only used with methods that take a Str and return an OutStream . The compiler doesn't actually create a new string, rather it chains multiple print calls. Use of the \"+\" operator is allowed, but the preferred mechanism for string formatting is to embed the expressions directly into the string literal itself using the '$' character. You can embed any arbitrary expression into a string literal using the syntax \"${expr}\" . If the expression is a simple variable name or a variable name followed by a dot field access, then you can omit the curly braces. Use the '\\$' escape sequence to print the dollar sign itself. Some examples: // example from above Sys . out . print ( \"x=${x}\" ) // same but omitting the braces Sys . out . print ( \"x=$x\" ) // embedded expressions Sys . out . print ( \"x=0x${Sys.hexStr(x)}\" ) The following types are supported with string interpolation: Type Print Method Str OutStream.print bool OutStream.printBool int OutStream.printInt long OutStream.printLong float OutStream.printFloat double OutStream.printDouble","title":"Expressions"},{"location":"language/expr/#expressions","text":"","title":"Expressions"},{"location":"language/expr/#overview","text":"Expressions are almost identical to those found in C or Java. The same operator precedence rules apply: Expression(s) Operator(s) Accessors . ?. () [] Unary - ! ~ ++ -- (cast) Multiplicative * / % Additive + - Bitwise Shift >> << Elvis ?: Relational < <= > >= Equality == != Bitwise AND & Bitwise XOR ^ Bitwise OR | Logical AND && Logical OR || Ternary ? : Assignment = += -= *= /= |= ^= &= >>= <<=","title":"Overview"},{"location":"language/expr/#arithmetic-operators","text":"The following arithmetic operators may be used with numeric primitives: Name Operator Multiplication x * y Division x / y Modulus (remainder) x % y Addition x + y Subtraction x - y Negation -x Prefix Increment ++x Prefix Decrement --x Postfix Increment x++ Postfix Decrement x-- The Modulus operator is only available for integer types, it may not be used with floats or doubles. The prefix/postfix operators work just like C and Java. If using the prefix operator the result of the expression is the new value. If using the postfix operator the result is the old value: int x = 4 // x == 4 int y = ++x // x == 5, y == 5 int z = x++ // x == 6, z == 5","title":"Arithmetic Operators"},{"location":"language/expr/#bitwise-operators","text":"The following bitwise operators may be used with integer primitives (byte, short, int, long): Name Operator Or x | y Xor x ^ y And x & y Left Shift x << y Right Shift x >> y Not ~x","title":"Bitwise Operators"},{"location":"language/expr/#logical-operators","text":"The following logical operators may be used with booleans: Name Operator Or x || y And x && y Not !x Both the Or and And operators are short circuiting. If the first term of Or evaluates to true, then the second term is not evaluated. If the first term of And evaluates to false, then the second term is not evaluated.","title":"Logical Operators"},{"location":"language/expr/#comparison","text":"The following operators are used for comparison: Name Operator Equal x == y Not Equal x != y Greater Than x > y Greater Than or Equal x >= y Less Than x < y Less Than or Equal x <= y Non-numeric types may only use the equality ( == and != ) operators. Reference types compare identity (pointer address).","title":"Comparison"},{"location":"language/expr/#assignment","text":"The = operator is used to assign the right hand side expression to the left hand side. The left hand side must be assignable . Assignable expressions are local variables, fields, and array indices. The compound assignment operators += -= *= /= |= ^= &= >>= <<= can be used to combine an arithmetic or bitwise operator with assignment: int x = 5 // x == 5 x += 3 // x == 8","title":"Assignment"},{"location":"language/expr/#assigning-to-properties","text":"If the left hand side of an assignment expression is a component property then you must use the := assignment operator instead of = . This highlights the fact that assigning a new value to a property results in more than just the storage of the new value; it also has potential side effects that may not always be visible to the user. Note that there are no compound property assignment operators; increment, decrement, etc must be spelled out explicitly in the expression. // Property px property int px // Non-property field ix int ix void myfunc () { // Use := when lhs is a property px : = 3 // Use = when lhs is a non-property ix = px // No compound assignment operators px : = px + 1 }","title":"Assigning to Properties"},{"location":"language/expr/#casting","text":"Sedona uses a syntax just like C or Java to perform a cast. Casts are required when the compiler cannot perform a static type check. For example, if you need to assign an Obj to a Component, then you must use a cast: c = (Component)obj . This type of cast is for compile time checking only, at runtime it is basically a no-op like C. Casts are also used with numeric types to perform a type conversion. For example to convert an int into a float: f = (float)i . Note that unlike C and Java, upcasts such as from an int to a long are not implicit - you must be explicitly use a cast.","title":"Casting"},{"location":"language/expr/#safe-navigation","text":"Sedona supports Groovy's safe navigation operator: x?.slot . You can use the safe nav operator to access fields or call methods. If the target expression of a slot access is null, then the whole expression short circuits to evaluate to null. If the field or method returns a primitive then it short circuits to false/zero. Using the safe nav operator is a convenient and more efficient way than manually checking for null: // hard way DeviceNetwork net = null if (point != null) { Device dev = point.getDevice() if (dev != null) net = dev.getNetwork() } // easy way DeviceNetwork net = point?.getDevice()?.getNetwork()","title":"Safe Navigation"},{"location":"language/expr/#elvis","text":"Sedona supports Groovy's elvis operator: lhs ?: rhs . If lhs evaluates to null, then the whole expression evaluates to rhs. If lhs is non-null, then the rhs is short circuited and the whole expression evaluates to lhs. The elvis operator is a convenient and more efficient way to write code where you might use the ternary operator: // hard way name != null ? name : \"unknown\" // easy way name ?: \"unknown\"","title":"Elvis"},{"location":"language/expr/#ternary","text":"Sedona supports the C/Java ternary operator: c ? t : f . The boolean expression c is evaluated. If true then the ternary expression evaluates to t , otherwise it evaluates to f : bool x = true Str msg = x ? \"On\" : \"Off\" // msg == \"On\" x = false msg = x ? \"On\" : \"Off\" // msg == \"Off\"","title":"Ternary"},{"location":"language/expr/#string-interpolation","text":"Sedona supports string interpolation, which allows for concise string formatting. String interpolation can be used with any method that has one Str parameter and returns an OutStream . You may use the \"+\" operator to concatenate multiple expressions to a string literal: // using the + operator int x = 77 Sys.out.print(\"x=\" + x) // is equivalent to this statement Sys.out.print(\"x=\").printInt(x) The example above illustrates why interpolation is only used with methods that take a Str and return an OutStream . The compiler doesn't actually create a new string, rather it chains multiple print calls. Use of the \"+\" operator is allowed, but the preferred mechanism for string formatting is to embed the expressions directly into the string literal itself using the '$' character. You can embed any arbitrary expression into a string literal using the syntax \"${expr}\" . If the expression is a simple variable name or a variable name followed by a dot field access, then you can omit the curly braces. Use the '\\$' escape sequence to print the dollar sign itself. Some examples: // example from above Sys . out . print ( \"x=${x}\" ) // same but omitting the braces Sys . out . print ( \"x=$x\" ) // embedded expressions Sys . out . print ( \"x=0x${Sys.hexStr(x)}\" ) The following types are supported with string interpolation: Type Print Method Str OutStream.print bool OutStream.printBool int OutStream.printInt long OutStream.printLong float OutStream.printFloat double OutStream.printDouble","title":"String Interpolation"},{"location":"language/fields/","text":"Fields \u00b6 Overview \u00b6 Fields are storage locations used to store a class variable. The following keywords may be applied to a field declaration: static : class-based field (versus instance-based, see below) const : indicates a field is immutable inline : allocates memory for the variable instance define : used to declare a constant variable property : promotes a field to a component property In addition to the keywords above, a field may be annotated with a protection scope keyword . If no protection scope is specified, then public is assumed. Static versus Instance Fields \u00b6 If a field is marked with the static keyword, then the field is stored once for all instances of that class. Static fields are essentially global variables scoped within a class type. Instance fields on the other hand allocate storage for each instance of the declaring type: class Display { static int maxId = 5 int id = -1 int width int height } In the code above we declare a class called Display with three instance fields id , width , and height . Each instance of Display will store its own copies of these fields. The static field maxId has one fixed memory location for the whole Sedona VM. Field Access \u00b6 Access to instance fields is done through an implicit or explicit instance pointer. The keyword this may be used to reference the current instance inside an instance method. If no instance pointer is used, then this is implied (only available inside an instance method): int area () { return this . width * this . height // this keyword } int area () { return width * height // shortcut for above } static int area ( Display d ) { return d . width * d . height // explicit instance pointer } Access to static fields is done through an implicit or explicit type literal. Implicit static access (where the type name is not specified) is only available inside methods of the Display class: static bool isValidId ( int id ) { return id < maxId // implicit static field access } static bool isValidId ( int id ) { return id < Display . maxId // explicit static field access } Also see Safe Navigation for how to use the \"?.\" operator for field access. Field Defaults \u00b6 Fields of a primitive type can declare a default expression. For example in the Display class declared above, the maxId field defaults to 5 and the id field defaults to -1 . Static fields are initialized when the Sedona VM is booted. The compiler will automatically create a synthetic method called _sInit() , which executes the initialization code for static fields. Instance fields are initialized in the declaring class's constructor . Any field without a default value has its memory initialized to zero. In the case of bool fields it is false , for numeric fields it is 0, and for references it is null . Const Fields \u00b6 Some of the core types in the sys kit contain fields marked with the const keyword. This indicates that these fields are immutable, and are actually stored within the scode memory itself. On some platforms these fields may be stored in readonly memory such as ROM. Attempts to set a const field will result in a compiler error. You cannot create your own const fields directly - only the predefined sys types can use this keyword. However you can use the define keyword to declare user defined constants. Define Fields \u00b6 The define keyword is used to declare a named constant. Defines are like const fields - if you try to assign to a define field you will get a compiler error. Defines don't actually allocate memory, rather they are inlined at compile time. Because of this trait, the value of a define field must be expressed as a literal value: class Flags { define int tooBig = 0x01 define int tooSmall = 0x02 } Defines are accessed just like static fields: if (( f & tooBig ) != 0 ) return true // implicit access if (( f & Flags . tooBig ) != 0 ) return true // explicit access The following types are supported for defines: bool : true , false , or null int : 32-bit integer literal value long : 64-bit integer literal value (or time literal) float : 32-bit float literal value double : 64-bit float literal value sys::Str : null terminated string literal sys::Log : see Logging Array literals: see next section Array Literals \u00b6 The define keyword may be used to create constant array literals. This allows you to declare readonly data lookup tables that will be stored in scode. The following array literal types are supported: byte[] short[] int[] long[] float[] double[] Str[] Array literals are declared using curly braces with a comma separator. The values inside an array literal must be literals themselves (they cannot be expressions). Examples: define byte[] daysInMonths = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} define Str[] weekdays = {\"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\" } Array literals are treated like const structures and are read-only. It is a compile time error to assign to a array literal (or any define). Inline Fields \u00b6 A field with a non-primitive (i.e. object) type is normally a reference to a sys::Obj object. Inside the SVM, an object field is a pointer to an object. For example on a 32-bit machine, an object field would allocate 4 bytes for a pointer. The object itself resides elsewhere in memory. However, often we wish the field to contain an instance of the object. This is done with the inline keyword. Let's look at an example: class Point { int x ; int y } class Foo { Point a inline Point b } In this example Foo.a is a pointer field - it allocates just enough space to store a pointer to a Point instance (typically 4 bytes). However, Foo.b actually allocates memory to store the entire Point instance (8 bytes to store two 32-bit ints). Inline fields play an important role in the Sedona Framework's static memory management. They allow you to develop complex data structures where memory is laid out by the compiler. This makes it possible for tools to calculate ahead of time exactly how much memory a component requires, since they can assume the component will not be allocating any additional memory during runtime. Inline fields can be static or instance based. Inline fields use the same syntax as reference fields. However an inline field is not assignable. You cannot point the reference to another instance since the entire instance is already embedded (you will get a compiler error if you try). Property Fields \u00b6 Fields may be annotated with the property keyword to promote the field into a Component property. Properties must be instance fields on a subclass of sys::Component . See Component Properties for more details.","title":"Fields"},{"location":"language/fields/#fields","text":"","title":"Fields"},{"location":"language/fields/#overview","text":"Fields are storage locations used to store a class variable. The following keywords may be applied to a field declaration: static : class-based field (versus instance-based, see below) const : indicates a field is immutable inline : allocates memory for the variable instance define : used to declare a constant variable property : promotes a field to a component property In addition to the keywords above, a field may be annotated with a protection scope keyword . If no protection scope is specified, then public is assumed.","title":"Overview"},{"location":"language/fields/#static-versus-instance-fields","text":"If a field is marked with the static keyword, then the field is stored once for all instances of that class. Static fields are essentially global variables scoped within a class type. Instance fields on the other hand allocate storage for each instance of the declaring type: class Display { static int maxId = 5 int id = -1 int width int height } In the code above we declare a class called Display with three instance fields id , width , and height . Each instance of Display will store its own copies of these fields. The static field maxId has one fixed memory location for the whole Sedona VM.","title":"Static versus Instance Fields"},{"location":"language/fields/#field-access","text":"Access to instance fields is done through an implicit or explicit instance pointer. The keyword this may be used to reference the current instance inside an instance method. If no instance pointer is used, then this is implied (only available inside an instance method): int area () { return this . width * this . height // this keyword } int area () { return width * height // shortcut for above } static int area ( Display d ) { return d . width * d . height // explicit instance pointer } Access to static fields is done through an implicit or explicit type literal. Implicit static access (where the type name is not specified) is only available inside methods of the Display class: static bool isValidId ( int id ) { return id < maxId // implicit static field access } static bool isValidId ( int id ) { return id < Display . maxId // explicit static field access } Also see Safe Navigation for how to use the \"?.\" operator for field access.","title":"Field Access"},{"location":"language/fields/#field-defaults","text":"Fields of a primitive type can declare a default expression. For example in the Display class declared above, the maxId field defaults to 5 and the id field defaults to -1 . Static fields are initialized when the Sedona VM is booted. The compiler will automatically create a synthetic method called _sInit() , which executes the initialization code for static fields. Instance fields are initialized in the declaring class's constructor . Any field without a default value has its memory initialized to zero. In the case of bool fields it is false , for numeric fields it is 0, and for references it is null .","title":"Field Defaults"},{"location":"language/fields/#const-fields","text":"Some of the core types in the sys kit contain fields marked with the const keyword. This indicates that these fields are immutable, and are actually stored within the scode memory itself. On some platforms these fields may be stored in readonly memory such as ROM. Attempts to set a const field will result in a compiler error. You cannot create your own const fields directly - only the predefined sys types can use this keyword. However you can use the define keyword to declare user defined constants.","title":"Const Fields"},{"location":"language/fields/#define-fields","text":"The define keyword is used to declare a named constant. Defines are like const fields - if you try to assign to a define field you will get a compiler error. Defines don't actually allocate memory, rather they are inlined at compile time. Because of this trait, the value of a define field must be expressed as a literal value: class Flags { define int tooBig = 0x01 define int tooSmall = 0x02 } Defines are accessed just like static fields: if (( f & tooBig ) != 0 ) return true // implicit access if (( f & Flags . tooBig ) != 0 ) return true // explicit access The following types are supported for defines: bool : true , false , or null int : 32-bit integer literal value long : 64-bit integer literal value (or time literal) float : 32-bit float literal value double : 64-bit float literal value sys::Str : null terminated string literal sys::Log : see Logging Array literals: see next section","title":"Define Fields"},{"location":"language/fields/#array-literals","text":"The define keyword may be used to create constant array literals. This allows you to declare readonly data lookup tables that will be stored in scode. The following array literal types are supported: byte[] short[] int[] long[] float[] double[] Str[] Array literals are declared using curly braces with a comma separator. The values inside an array literal must be literals themselves (they cannot be expressions). Examples: define byte[] daysInMonths = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} define Str[] weekdays = {\"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\" } Array literals are treated like const structures and are read-only. It is a compile time error to assign to a array literal (or any define).","title":"Array Literals"},{"location":"language/fields/#inline-fields","text":"A field with a non-primitive (i.e. object) type is normally a reference to a sys::Obj object. Inside the SVM, an object field is a pointer to an object. For example on a 32-bit machine, an object field would allocate 4 bytes for a pointer. The object itself resides elsewhere in memory. However, often we wish the field to contain an instance of the object. This is done with the inline keyword. Let's look at an example: class Point { int x ; int y } class Foo { Point a inline Point b } In this example Foo.a is a pointer field - it allocates just enough space to store a pointer to a Point instance (typically 4 bytes). However, Foo.b actually allocates memory to store the entire Point instance (8 bytes to store two 32-bit ints). Inline fields play an important role in the Sedona Framework's static memory management. They allow you to develop complex data structures where memory is laid out by the compiler. This makes it possible for tools to calculate ahead of time exactly how much memory a component requires, since they can assume the component will not be allocating any additional memory during runtime. Inline fields can be static or instance based. Inline fields use the same syntax as reference fields. However an inline field is not assignable. You cannot point the reference to another instance since the entire instance is already embedded (you will get a compiler error if you try).","title":"Inline Fields"},{"location":"language/fields/#property-fields","text":"Fields may be annotated with the property keyword to promote the field into a Component property. Properties must be instance fields on a subclass of sys::Component . See Component Properties for more details.","title":"Property Fields"},{"location":"language/lang/","text":"Language \u00b6 Overview \u00b6 Sedona is a programming language based upon the following principles: Familiar Syntax : Reuses C, Java, and C# syntax where possible. Object Oriented : Includes the three pillars of OO: encapsulated classes, inheritance, and polymorphism. Component Oriented : Based on a development paradigm of reusable software components. Applications are assembled by wiring together pre-built components. Static Typing : Uses a static type system much like Java and C# with explicit typing of fields, methods, and local variables. This allows the compiler to perform type checking. Static Memory : Manages memory statically at compile time, making it ideal for embedded platforms with limited resources. Namespaces \u00b6 Sedona Framework code is organized into a three unit hierarchy: Kit : A module of deployment and versioning. Kits form the top of the namespace and must be globally unique. Kit names are required to be prefixed with the vendor's name. Class : An object oriented unit of organization. Classes are always scoped within a kit. Slot : Special fields and methods defined within a class are called slots . Slots are the externally visible \"wiring points\" on a component that can be linked to other components in a Sedona application. Kits are globally unique and used to scope classes which in turn scope slots. We use this structure to define globally unique qualified names or qnames for classes and slots. A Class qname consists of the kit name and class name joined by the \"::\" separator. A slot qname is the class's qname joined to the slot's simple name by the \".\" separator: control::Ramp // class qname control::Ramp.out // slot qname Structure \u00b6 Sedona Framework software is packaged up into modules called kits . The source code for a kit is managed as a set of text files with the \".sedona\" extension. A \"kit.xml\" file instructs the compiler how to compile the kit and what directories contain the source code. A typical source directory is structured as follows: myCoolKit/ // directory for myCoolKit +- kit.xml // kit build manifest +- CoolComp.sedona // source file +- AnotherCoolComp.sedona // source file +- test/ +- CoolCompTest.sedona // source file for tests You can then compile the kit using either the directory or \"kit.xml\" file. Assuming your current directory is the parent of \"myCoolKit\" you could use either of the following commands to compile: sedonac myCoolKit sedonac myCoolKit/kit.xml Each source file is called a compilation unit . Source text files must use UTF-8 encoding (7-bit ASCII is a clean subset of UTF-8). Each compilation unit can contain one or more classes . Sedona does not require any correlation between your source file names and class names. However, by convention each class is sourced in a file with the same name. For example CoolComp is stored in a text file called \"CoolComp.sedona\". Classes \u00b6 A kit contains one or more classes . A class is very similar to a Java or C# class. However, Sedona doesn't have the concept of interfaces - so everything is strictly based on single inheritance. A class is composed of zero or more named slots . There are two kinds of slots: Field : a memory location for storing a variable to manage state ; Method : an executable function to manage behavior ; All slots must be uniquely named. Sedona doesn't support method overloading by parameter types as you might find in Java or C#. Protection Scope \u00b6 The following keywords are used to annotate the protection scope of classes and slots: public : visible to everyone; this is the default scope if no keyword is specified [applies to classes and slots] internal : visible to classes in the same kit only [applies to classes and slots] protected : visible to subclasses only [applies to slots only] private : visible to declaring class only [applies to slots only]","title":"Language"},{"location":"language/lang/#language","text":"","title":"Language"},{"location":"language/lang/#overview","text":"Sedona is a programming language based upon the following principles: Familiar Syntax : Reuses C, Java, and C# syntax where possible. Object Oriented : Includes the three pillars of OO: encapsulated classes, inheritance, and polymorphism. Component Oriented : Based on a development paradigm of reusable software components. Applications are assembled by wiring together pre-built components. Static Typing : Uses a static type system much like Java and C# with explicit typing of fields, methods, and local variables. This allows the compiler to perform type checking. Static Memory : Manages memory statically at compile time, making it ideal for embedded platforms with limited resources.","title":"Overview"},{"location":"language/lang/#namespaces","text":"Sedona Framework code is organized into a three unit hierarchy: Kit : A module of deployment and versioning. Kits form the top of the namespace and must be globally unique. Kit names are required to be prefixed with the vendor's name. Class : An object oriented unit of organization. Classes are always scoped within a kit. Slot : Special fields and methods defined within a class are called slots . Slots are the externally visible \"wiring points\" on a component that can be linked to other components in a Sedona application. Kits are globally unique and used to scope classes which in turn scope slots. We use this structure to define globally unique qualified names or qnames for classes and slots. A Class qname consists of the kit name and class name joined by the \"::\" separator. A slot qname is the class's qname joined to the slot's simple name by the \".\" separator: control::Ramp // class qname control::Ramp.out // slot qname","title":"Namespaces"},{"location":"language/lang/#structure","text":"Sedona Framework software is packaged up into modules called kits . The source code for a kit is managed as a set of text files with the \".sedona\" extension. A \"kit.xml\" file instructs the compiler how to compile the kit and what directories contain the source code. A typical source directory is structured as follows: myCoolKit/ // directory for myCoolKit +- kit.xml // kit build manifest +- CoolComp.sedona // source file +- AnotherCoolComp.sedona // source file +- test/ +- CoolCompTest.sedona // source file for tests You can then compile the kit using either the directory or \"kit.xml\" file. Assuming your current directory is the parent of \"myCoolKit\" you could use either of the following commands to compile: sedonac myCoolKit sedonac myCoolKit/kit.xml Each source file is called a compilation unit . Source text files must use UTF-8 encoding (7-bit ASCII is a clean subset of UTF-8). Each compilation unit can contain one or more classes . Sedona does not require any correlation between your source file names and class names. However, by convention each class is sourced in a file with the same name. For example CoolComp is stored in a text file called \"CoolComp.sedona\".","title":"Structure"},{"location":"language/lang/#classes","text":"A kit contains one or more classes . A class is very similar to a Java or C# class. However, Sedona doesn't have the concept of interfaces - so everything is strictly based on single inheritance. A class is composed of zero or more named slots . There are two kinds of slots: Field : a memory location for storing a variable to manage state ; Method : an executable function to manage behavior ; All slots must be uniquely named. Sedona doesn't support method overloading by parameter types as you might find in Java or C#.","title":"Classes"},{"location":"language/lang/#protection-scope","text":"The following keywords are used to annotate the protection scope of classes and slots: public : visible to everyone; this is the default scope if no keyword is specified [applies to classes and slots] internal : visible to classes in the same kit only [applies to classes and slots] protected : visible to subclasses only [applies to slots only] private : visible to declaring class only [applies to slots only]","title":"Protection Scope"},{"location":"language/logging/","text":"Logging \u00b6 Overview \u00b6 The Sedona Framework includes a built-in logging facility with the following features: Simple syntax to embed logging in your source code Ability to selectively enable/disable logging at runtime Ability to selectively compile logging in or out of an scode image Log Levels \u00b6 There are five logging severity levels: Log.NONE : all logging is disabled Log.ERROR : indicates a failure condition Log.WARNING : indicates an unexpected condition Log.MESSAGE : indicates something of interest Log.TRACE : used to embed debug tracing Log Definition \u00b6 The sys::Log class is the primary API used for logging. The Log class is a const class like Type or Slot . This means you can't directly allocate instances yourself. Instead we use the define keyword to define a Log instance: class MyService { define Log log } Like other defines, the log is treated much like a static field. During compilation all the log instances are compiled into the scode as const data much like Kit instances. The APIs for log reflection follow a similar pattern to kit reflection: class Sys { define int logsLen const static Log[logsLen] logs static inline byte[logsLen] logLevels static Log log(int id) static Log findLog(Str qname) } const class Log { define int NONE = 0 define int ERROR = 1 define int WARNING = 2 define int MESSAGE = 3 define int TRACE = 4 int level() bool isError() bool isWarning() bool isMessage() bool isTrace() OutStream error(Str msg) OutStream warning(Str msg) OutStream message(Str msg) OutStream trace(Str msg) const short id const Str qname } Note that the logging levels are stored separately from the Log instances themselves. This is because the log objects are readonly and stored in the code section. The log levels must be in dynamic memory to allow runtime modification. Log Naming \u00b6 All logs are identified by a qname (qualified name), which is based on the define field's qname: If the define field is named \"log\", then the log qname is the qname of the declaring type If the define field ends in \"Log\", then the log qname is the field's qname minus the \"Log\" suffix If none of the above applies, then log's qname is the field's qname For example this class in a kit named \"acme\": class MyService { define Log log // log qname is \"acme::MyService\" define Log reqLog // log qname is \"acme::MyService.req\" define Log stuff // log qname is \"acme::MyService.stuff\" } By convention, your primary Log definition should be named \"log\" to match rule 1. Sub-logging for extra tracing should use names with a \"Log\" suffix. Logging \u00b6 To embed logging into your code, call one of following the logging methods : sys::Log.error sys::Log.warning sys::Log.message sys::Log.trace All of the logging methods take a Str and return an OutStream , which permits string interpolation : // these lines of code log.message(\"Started!\") log.error(\"Cannot open port=$port\") log.trace(\"Received $numBytes bytes from $addr\") // would print something like -- MESSAGE [acme::MyServer] Started! -- ERROR [acme::MyServer] Cannot open port 8080 -- TRACE [acme::MyServer] Received 5 bytes from 32 A few points to note: Don't add a trailing newline to your message, one will be added automatically Don't include any severity or log identity in your message string, this information is automatically included (the actual format is implementation specific) You are required to call the logging methods on the field define itself. For example you can't assign the log reference to a local variable, then use the local variable to call one of the logging methods - this will result in a compile time error. The reason for this restriction is that it enables the compiler to generate level checking and conditional compilation checking. Runtime Configuration \u00b6 Log levels are stored in the Sys.logLevels field. This array is indexed by Log.id and stores the current level as a number between 0 and 4 (Log.NONE to Log.TRACE): // change my logging level to trace Sys.logLevels[log.id] = Log.TRACE The current level defines the maximum severity that is logged. For example a level or WARNING will log calls to error and warning , but not calls to message and trace . All log levels default to MESSAGE on startup. The compiler automatically inserts code that jumps over a logging statement if the current log level is set lower. This means the method call and any embedded expressions are efficiently skipped: // this code log.trace(\"This is the ${count++} time\") // is semantically equivalent to if (log.isTrace()) log.trace(\"This is the ${count++} time\") WebService Spy Page \u00b6 If a Sedona device is running the web::WebService , then you can use the spy page at \"<device IP>/spy/logs\" to change the log levels for a SVM at runtime. Compile-time Configuration \u00b6 Note This feature is not implemented yet","title":"Logging"},{"location":"language/logging/#logging","text":"","title":"Logging"},{"location":"language/logging/#overview","text":"The Sedona Framework includes a built-in logging facility with the following features: Simple syntax to embed logging in your source code Ability to selectively enable/disable logging at runtime Ability to selectively compile logging in or out of an scode image","title":"Overview"},{"location":"language/logging/#log-levels","text":"There are five logging severity levels: Log.NONE : all logging is disabled Log.ERROR : indicates a failure condition Log.WARNING : indicates an unexpected condition Log.MESSAGE : indicates something of interest Log.TRACE : used to embed debug tracing","title":"Log Levels"},{"location":"language/logging/#log-definition","text":"The sys::Log class is the primary API used for logging. The Log class is a const class like Type or Slot . This means you can't directly allocate instances yourself. Instead we use the define keyword to define a Log instance: class MyService { define Log log } Like other defines, the log is treated much like a static field. During compilation all the log instances are compiled into the scode as const data much like Kit instances. The APIs for log reflection follow a similar pattern to kit reflection: class Sys { define int logsLen const static Log[logsLen] logs static inline byte[logsLen] logLevels static Log log(int id) static Log findLog(Str qname) } const class Log { define int NONE = 0 define int ERROR = 1 define int WARNING = 2 define int MESSAGE = 3 define int TRACE = 4 int level() bool isError() bool isWarning() bool isMessage() bool isTrace() OutStream error(Str msg) OutStream warning(Str msg) OutStream message(Str msg) OutStream trace(Str msg) const short id const Str qname } Note that the logging levels are stored separately from the Log instances themselves. This is because the log objects are readonly and stored in the code section. The log levels must be in dynamic memory to allow runtime modification.","title":"Log Definition"},{"location":"language/logging/#log-naming","text":"All logs are identified by a qname (qualified name), which is based on the define field's qname: If the define field is named \"log\", then the log qname is the qname of the declaring type If the define field ends in \"Log\", then the log qname is the field's qname minus the \"Log\" suffix If none of the above applies, then log's qname is the field's qname For example this class in a kit named \"acme\": class MyService { define Log log // log qname is \"acme::MyService\" define Log reqLog // log qname is \"acme::MyService.req\" define Log stuff // log qname is \"acme::MyService.stuff\" } By convention, your primary Log definition should be named \"log\" to match rule 1. Sub-logging for extra tracing should use names with a \"Log\" suffix.","title":"Log Naming"},{"location":"language/logging/#logging_1","text":"To embed logging into your code, call one of following the logging methods : sys::Log.error sys::Log.warning sys::Log.message sys::Log.trace All of the logging methods take a Str and return an OutStream , which permits string interpolation : // these lines of code log.message(\"Started!\") log.error(\"Cannot open port=$port\") log.trace(\"Received $numBytes bytes from $addr\") // would print something like -- MESSAGE [acme::MyServer] Started! -- ERROR [acme::MyServer] Cannot open port 8080 -- TRACE [acme::MyServer] Received 5 bytes from 32 A few points to note: Don't add a trailing newline to your message, one will be added automatically Don't include any severity or log identity in your message string, this information is automatically included (the actual format is implementation specific) You are required to call the logging methods on the field define itself. For example you can't assign the log reference to a local variable, then use the local variable to call one of the logging methods - this will result in a compile time error. The reason for this restriction is that it enables the compiler to generate level checking and conditional compilation checking.","title":"Logging"},{"location":"language/logging/#runtime-configuration","text":"Log levels are stored in the Sys.logLevels field. This array is indexed by Log.id and stores the current level as a number between 0 and 4 (Log.NONE to Log.TRACE): // change my logging level to trace Sys.logLevels[log.id] = Log.TRACE The current level defines the maximum severity that is logged. For example a level or WARNING will log calls to error and warning , but not calls to message and trace . All log levels default to MESSAGE on startup. The compiler automatically inserts code that jumps over a logging statement if the current log level is set lower. This means the method call and any embedded expressions are efficiently skipped: // this code log.trace(\"This is the ${count++} time\") // is semantically equivalent to if (log.isTrace()) log.trace(\"This is the ${count++} time\")","title":"Runtime Configuration"},{"location":"language/logging/#webservice-spy-page","text":"If a Sedona device is running the web::WebService , then you can use the spy page at \"<device IP>/spy/logs\" to change the log levels for a SVM at runtime.","title":"WebService Spy Page"},{"location":"language/logging/#compile-time-configuration","text":"Note This feature is not implemented yet","title":"Compile-time Configuration"},{"location":"language/memory/","text":"Memory \u00b6 Overview \u00b6 Utilizing memory as efficiently as possible is a core requirement for making the Sedona Framework run on small, embedded devices. We divide memory into the following sections: Stack : the call stack (RAM) Data : all the memory declared as static fields in the current scode (RAM) Sedona Framework App : the components that define the current application (RAM) Sedona Framework Code : the scode image for the installed kits (RAM, or possibly flash memory) SAB File : the compact binary representation of the application (usually stored in flash) C Code : native code and SVM executable (RAM, or possibly flash) C Data : native code data segment (RAM) C Stack : the C native call stack (RAM) We use the terms RAM and flash a bit loosely here: RAM must be high speed read/write memory, and flash is persistent memory (on a large device this could be a disk drive). If flash is high speed you might be able to run code directly out of flash, but normally those code segments will be loaded into RAM. While reading this topic you may find it useful to refer to the Sedona VM source code, located in the src/vm folder. Computing Memory Requirements \u00b6 So how do you figure out how much memory each of the sections declared above requires? Let's look at each section: C Code, C Data, and C Stack \u00b6 The C code, data, and stack segments will be determined by your development tools and C compiler. We use the term \"C Code\" to denote any non-Sedona code such as C, C++, or assembly. This code typically includes boot code, OS code (if your device has one), all your native method implementations, comm stacks, and the SVM itself. All this is normally lumped into a single binary executable file called \"svm\". The C Data segment includes all the memory buffers used by this code. Note: On some platforms, part of the SVM may already be in ROM or other permanent storage. In that case the \"svm\" executable created during compilation will contain only the portion of the SVM that is not in ROM, and its RAM footprint will be reduced. Stack \u00b6 The Sedona stack is defined by the stackBaseAddr and stackMaxSize fields of the SedonaVM struct when the VM is launched. Typically the size is one or two KB - you may wish to test your application to find the maximum call stack. Heavy use of recursion and methods with a large number of locals will affect your call stack size. Code and Data \u00b6 The sizes of the Sedona Code and Data segments are calculated when the scode image is compiled: D: \\s edona>sedonac scode \\x 86 -test.xml ReadKits [ 5 kits ] WriteImage [ D: \\s edona \\s code \\x 86 -test.scode ] ( 29632 bytes ) +---------------------------------- | Data: 0 .4kb ( 360 bytes ) | Code: 28 .9kb ( 29632 bytes ) | Total: 29 .3kb ( 29992 bytes ) +---------------------------------- These numbers are directly related to how many kits you include and the code size of those kits. Declaring static fields will consume memory in your Data segment; instance fields only affect the application size. If you are running your code out of RAM, then the Total size is what matters. If you can run your code out of flash, then the Code will not use any RAM but the Data segment must still be stored in RAM. Note that the scode flags test and debug can have a huge impact on scode size. The location of the Code is passed to the VM in the SedonaVM struct via the codeBaseAddr field. The Data section is allocated by the malloc macro - see \"sedona.h\" for details. Sedona Framework Application \u00b6 The Sedona Framework application itself is always run out of RAM. This is where we instantiate the components and links. Memory for components and links is allocated by the malloc macro. If components or links are removed during runtime, then the memory is freed by the free macro (if the platform supports it). The Sedona Framework application runs out of RAM, but has configuration data that must be persistent between power cycles. So we also store the application to flash as a SAB file . How this file is loaded on startup and stored back to flash on save is handled by the platform's implementation of the sys::FileStore native methods. Sedonac will report how much RAM and flash a given application consumes when you do a conversion between SAX or SAB: D: \\s edona>sedonac apps \\t est.sax ConvertAppFile [ D: \\s edona \\a pps \\t est.sax -> D: \\s edona \\a pps \\t est.sab ] +---------------------------------- | RAM: 14 .2kb ( 14588 bytes ) | FLASH: 0 .4kb ( 382 bytes ) +---------------------------------- See the Field Layout section to evaluate how much memory each component type consumes. Heap \u00b6 The memory for the Data section and for the components and links in the App is allocated using the malloc macro as defined in \"sedona.h\". If components or links are removed during runtime, then this memory is freed by the free macro. You can implement your \"heap management\" using three strategies: Stdlib : if you have the resources, you can just use C's built-in malloc and free. However if using a compiler like GCC this might require importing a huge chunk of library code into your native image. Custom Heap : if the stdlib implementation of malloc and free is too big, you might consider writing your own simple heap manager. Malloc Only : many devices might require only a static application in which case there is no requirement for freeing memory. In resource limited devices, the ability to free memory might be outweighed by the risk of heap fragmentation. In this case your heap management might be nothing more than a pointer to the next chunk of memory to allocate. A call to free would be a no-op. If objects are removed from the application the memory would not be recovered until the system is reset. Field Layout \u00b6 You can pass the -layout flag to sedonac when compiling your scode image to dump the memory layout of each type. This gives you exact details for how memory is being consumed: How many bytes each component type consumes in RAM Memory offset of every instance field against the object's base address Memory address of every static field against the Data base address A good rule of thumb is that each component averages between 50 and 100 bytes and each link consumes 16 bytes. A network protocol service will typically consume several KB since it must allocate buffers and internal data structures. However, you really must use the -layout flag to see exactly how many bytes each component will consume. Note that sedonac has no visibility into the behavior of native methods. Any dynamic memory allocation that occurs at the native level must be calculated separately and added manually to the totals provided by the -layout flag. Hibernation \u00b6 The Sedona Framework supports hibernation , which allows a device to enter a low power state. The Sedona Framework assumes that during hibernation its data section in RAM (managed by the heap malloc and free calls) will not be affected. The device can either maintain RAM during hibernation or save and restore to the same memory addresses. See Hibernation .","title":"Memory"},{"location":"language/memory/#memory","text":"","title":"Memory"},{"location":"language/memory/#overview","text":"Utilizing memory as efficiently as possible is a core requirement for making the Sedona Framework run on small, embedded devices. We divide memory into the following sections: Stack : the call stack (RAM) Data : all the memory declared as static fields in the current scode (RAM) Sedona Framework App : the components that define the current application (RAM) Sedona Framework Code : the scode image for the installed kits (RAM, or possibly flash memory) SAB File : the compact binary representation of the application (usually stored in flash) C Code : native code and SVM executable (RAM, or possibly flash) C Data : native code data segment (RAM) C Stack : the C native call stack (RAM) We use the terms RAM and flash a bit loosely here: RAM must be high speed read/write memory, and flash is persistent memory (on a large device this could be a disk drive). If flash is high speed you might be able to run code directly out of flash, but normally those code segments will be loaded into RAM. While reading this topic you may find it useful to refer to the Sedona VM source code, located in the src/vm folder.","title":"Overview"},{"location":"language/memory/#computing-memory-requirements","text":"So how do you figure out how much memory each of the sections declared above requires? Let's look at each section:","title":"Computing Memory Requirements"},{"location":"language/memory/#c-code-c-data-and-c-stack","text":"The C code, data, and stack segments will be determined by your development tools and C compiler. We use the term \"C Code\" to denote any non-Sedona code such as C, C++, or assembly. This code typically includes boot code, OS code (if your device has one), all your native method implementations, comm stacks, and the SVM itself. All this is normally lumped into a single binary executable file called \"svm\". The C Data segment includes all the memory buffers used by this code. Note: On some platforms, part of the SVM may already be in ROM or other permanent storage. In that case the \"svm\" executable created during compilation will contain only the portion of the SVM that is not in ROM, and its RAM footprint will be reduced.","title":"C Code, C Data, and C Stack"},{"location":"language/memory/#stack","text":"The Sedona stack is defined by the stackBaseAddr and stackMaxSize fields of the SedonaVM struct when the VM is launched. Typically the size is one or two KB - you may wish to test your application to find the maximum call stack. Heavy use of recursion and methods with a large number of locals will affect your call stack size.","title":"Stack"},{"location":"language/memory/#code-and-data","text":"The sizes of the Sedona Code and Data segments are calculated when the scode image is compiled: D: \\s edona>sedonac scode \\x 86 -test.xml ReadKits [ 5 kits ] WriteImage [ D: \\s edona \\s code \\x 86 -test.scode ] ( 29632 bytes ) +---------------------------------- | Data: 0 .4kb ( 360 bytes ) | Code: 28 .9kb ( 29632 bytes ) | Total: 29 .3kb ( 29992 bytes ) +---------------------------------- These numbers are directly related to how many kits you include and the code size of those kits. Declaring static fields will consume memory in your Data segment; instance fields only affect the application size. If you are running your code out of RAM, then the Total size is what matters. If you can run your code out of flash, then the Code will not use any RAM but the Data segment must still be stored in RAM. Note that the scode flags test and debug can have a huge impact on scode size. The location of the Code is passed to the VM in the SedonaVM struct via the codeBaseAddr field. The Data section is allocated by the malloc macro - see \"sedona.h\" for details.","title":"Code and Data"},{"location":"language/memory/#sedona-framework-application","text":"The Sedona Framework application itself is always run out of RAM. This is where we instantiate the components and links. Memory for components and links is allocated by the malloc macro. If components or links are removed during runtime, then the memory is freed by the free macro (if the platform supports it). The Sedona Framework application runs out of RAM, but has configuration data that must be persistent between power cycles. So we also store the application to flash as a SAB file . How this file is loaded on startup and stored back to flash on save is handled by the platform's implementation of the sys::FileStore native methods. Sedonac will report how much RAM and flash a given application consumes when you do a conversion between SAX or SAB: D: \\s edona>sedonac apps \\t est.sax ConvertAppFile [ D: \\s edona \\a pps \\t est.sax -> D: \\s edona \\a pps \\t est.sab ] +---------------------------------- | RAM: 14 .2kb ( 14588 bytes ) | FLASH: 0 .4kb ( 382 bytes ) +---------------------------------- See the Field Layout section to evaluate how much memory each component type consumes.","title":"Sedona Framework Application"},{"location":"language/memory/#heap","text":"The memory for the Data section and for the components and links in the App is allocated using the malloc macro as defined in \"sedona.h\". If components or links are removed during runtime, then this memory is freed by the free macro. You can implement your \"heap management\" using three strategies: Stdlib : if you have the resources, you can just use C's built-in malloc and free. However if using a compiler like GCC this might require importing a huge chunk of library code into your native image. Custom Heap : if the stdlib implementation of malloc and free is too big, you might consider writing your own simple heap manager. Malloc Only : many devices might require only a static application in which case there is no requirement for freeing memory. In resource limited devices, the ability to free memory might be outweighed by the risk of heap fragmentation. In this case your heap management might be nothing more than a pointer to the next chunk of memory to allocate. A call to free would be a no-op. If objects are removed from the application the memory would not be recovered until the system is reset.","title":"Heap"},{"location":"language/memory/#field-layout","text":"You can pass the -layout flag to sedonac when compiling your scode image to dump the memory layout of each type. This gives you exact details for how memory is being consumed: How many bytes each component type consumes in RAM Memory offset of every instance field against the object's base address Memory address of every static field against the Data base address A good rule of thumb is that each component averages between 50 and 100 bytes and each link consumes 16 bytes. A network protocol service will typically consume several KB since it must allocate buffers and internal data structures. However, you really must use the -layout flag to see exactly how many bytes each component will consume. Note that sedonac has no visibility into the behavior of native methods. Any dynamic memory allocation that occurs at the native level must be calculated separately and added manually to the totals provided by the -layout flag.","title":"Field Layout"},{"location":"language/memory/#hibernation","text":"The Sedona Framework supports hibernation , which allows a device to enter a low power state. The Sedona Framework assumes that during hibernation its data section in RAM (managed by the heap malloc and free calls) will not be affected. The device can either maintain RAM during hibernation or save and restore to the same memory addresses. See Hibernation .","title":"Hibernation"},{"location":"language/methods/","text":"Overview \u00b6 Methods are functions used to implement executable behavior. The following keywords may be applied to a method declaration: static : class based method versus instance based virtual : indicates method that may be polymorphically overridden abstract : indicates a pure virtual method override : required to indicate an override of an inherited method native : indicates a method implemented in native C code action : promotes a method to a component action In addition to the keywords above, a method may be annotated with a protection scope keyword. If no protection scope is specified, then public is assumed. Return Values \u00b6 If the method returns a value to the calling function, the return value type is included in the function definition. If the method does not return anything, the keyword void is used instead of a return type. class Example { void echo() { Sys.out.print(\"echo\").nl() } // returns nothing int add(int x, int y) { return x + y } // returns an int value } In Sedona, a method may return any primitive type, or a reference to any built-in or user-defined class type; the only exception is an action method, which always returns void . Static Methods \u00b6 Static methods are prefixed with the static keyword. Static methods are essentially global functions scoped within a class name. They are declared just like Java methods: class Example { static void echo() { Sys.out.print(\"echo\").nl() } static int add(int x, int y) { return x + y } } Static methods are called with an implict or explicit type literal: Example.echo() // explicit int five = add(2, 3) // implicit (only inside Example or subclasses) Instance Methods \u00b6 Instance methods are declared whenever the static keyword is omitted. Instance methods contain an implicit this parameter, which is the instance the method is called on: class Example { int add() { return x + y } int sub() { return this.x - this.y } int x int y } Note in the example, that every instance method has an implicit parameter accessed via the this keyword. Instance methods are called with an implict or explicit instance: add() // implicit against this this.sub() // explicit against this x.sub() // explicit against x x?.sub() // null safe call See Safe Navigation for how to use the \"?.\" operator. Virtual Methods \u00b6 Virtual methods are designed to be overridden by a subclass to enable polymorphism. Methods must be marked using the virtual keyword before they can be overridden by subclasses. Subclasses must declare they are overriding a method using the override keyword: class Animal extends Virtual { virtual void talk() { Sys.out.print(\"generic\\n\") } } class Cat extends Animal { override void talk() { Sys.out.print(\"meow\\n\") } } animal.talk() // prints generic cat.talk() // prints meow By default an overridden method cannot itself be overridden by a subsequent subclass. In order for Cat.talk() to be overridden by the subclass Kitten , it must include again the keyword virtual : class Cat extends Animal { override virtual void talk() { Sys.out.print(\"meow\\n\") } // override AND virtual } class Kitten extends Cat { override void talk() { Sys.out.print(\"mew!\\n\") } // this now compiles } kitten.talk() // prints mew! Classes that declare virtual methods must derive from sys::Virtual . Be aware that virtual classes have the overhead of an extra pointer for their vtable (typically 4 extra bytes). Abstract Methods \u00b6 Abstract methods are virtual methods without an implementation. They are declared using the abstract keyword. Abstract methods are implied to be virtual - it is an error to use both the abstract and virtual keyword. Abstract methods must not provide a method body. The containing class must also be declared abstract . Super \u00b6 By default any virtual method call with an implicit or explicit target of this invokes the most specific version of that method. You can use the super keyword to invoke the super class version of a method: class Kitten extends Cat { override void talk() { super.talk() } } kitten.talk() // now prints meow Constructors \u00b6 A class may have one constructor, which is compiled into a method called _iInit . Whenever a class declares instance fields with a default value , the compiler auto-generates a constructor for you. A class may declare an explicit constructor using a syntax similiar to Java: final class BufInStream extends InStream { BufInStream(Buf abuf) { this.buf = abuf } Buf buf } To keep Sedona lightweight and simple, the following rules apply to constructor methods: A class may only declare one explicit constructor (parameter overloading is not supported). A class with an explicit constructor must be marked final . Subclasses of sys::Component cannot declare a constructor with parameters. Declared constructors are used with unsized classes to specify an array length. The constructor method for a class is called whenever an object of that type is instantiated. For static inline fields, this happens as soon as the scode is loaded when the Sedona VM boots up. For instance inline fields, this happens when the Sedona VM loads the Sedona application and calls the constructors for the application's components as well as each component's inline object fields. If the running app is modified remotely, however, any new components will be instantiated immediately by App.add() , which will call the component's constructor (and all its non-static inline object fields) at that time. For example: class Foo { // static constructor calls static inline Buf(100) buf static inline BufInStream(buf) in static inline BufOutStream(buf) out static inline Foo inst // instance constructor calls inline Buf(20) ibuf } Inline static fields are initialized in declaration order on VM startup, which calls the appropriate constructors. These constructor calls often result in instance constructor calls, which in turn recursively chain for nested inline fields. For the example above, the compiler will create the following code; Foo._sInit is then automatically called when the VM boots: static void Foo . _sInit () { Foo . buf . _iInit ( 100 ) Foo . in . _iInit ( Foo . buf ) Foo . out . _iInit ( Foo . buf ) Foo . inst . _iInit () } void Foo . _iInit () { this . ibuf . _iInit ( 20 ) } Native Methods \u00b6 The native keyword is used on methods that are implemented in C code. Like abstract methods, native methods must not define a body. See Native Methods for more details. Action Methods \u00b6 Methods may be annotated with the action keyword to promote the method into a Component action. Actions must be instance methods on a subclass of sys::Component . See Component Actions for more details.","title":"Methods"},{"location":"language/methods/#overview","text":"Methods are functions used to implement executable behavior. The following keywords may be applied to a method declaration: static : class based method versus instance based virtual : indicates method that may be polymorphically overridden abstract : indicates a pure virtual method override : required to indicate an override of an inherited method native : indicates a method implemented in native C code action : promotes a method to a component action In addition to the keywords above, a method may be annotated with a protection scope keyword. If no protection scope is specified, then public is assumed.","title":"Overview"},{"location":"language/methods/#return-values","text":"If the method returns a value to the calling function, the return value type is included in the function definition. If the method does not return anything, the keyword void is used instead of a return type. class Example { void echo() { Sys.out.print(\"echo\").nl() } // returns nothing int add(int x, int y) { return x + y } // returns an int value } In Sedona, a method may return any primitive type, or a reference to any built-in or user-defined class type; the only exception is an action method, which always returns void .","title":"Return Values"},{"location":"language/methods/#static-methods","text":"Static methods are prefixed with the static keyword. Static methods are essentially global functions scoped within a class name. They are declared just like Java methods: class Example { static void echo() { Sys.out.print(\"echo\").nl() } static int add(int x, int y) { return x + y } } Static methods are called with an implict or explicit type literal: Example.echo() // explicit int five = add(2, 3) // implicit (only inside Example or subclasses)","title":"Static Methods"},{"location":"language/methods/#instance-methods","text":"Instance methods are declared whenever the static keyword is omitted. Instance methods contain an implicit this parameter, which is the instance the method is called on: class Example { int add() { return x + y } int sub() { return this.x - this.y } int x int y } Note in the example, that every instance method has an implicit parameter accessed via the this keyword. Instance methods are called with an implict or explicit instance: add() // implicit against this this.sub() // explicit against this x.sub() // explicit against x x?.sub() // null safe call See Safe Navigation for how to use the \"?.\" operator.","title":"Instance Methods"},{"location":"language/methods/#virtual-methods","text":"Virtual methods are designed to be overridden by a subclass to enable polymorphism. Methods must be marked using the virtual keyword before they can be overridden by subclasses. Subclasses must declare they are overriding a method using the override keyword: class Animal extends Virtual { virtual void talk() { Sys.out.print(\"generic\\n\") } } class Cat extends Animal { override void talk() { Sys.out.print(\"meow\\n\") } } animal.talk() // prints generic cat.talk() // prints meow By default an overridden method cannot itself be overridden by a subsequent subclass. In order for Cat.talk() to be overridden by the subclass Kitten , it must include again the keyword virtual : class Cat extends Animal { override virtual void talk() { Sys.out.print(\"meow\\n\") } // override AND virtual } class Kitten extends Cat { override void talk() { Sys.out.print(\"mew!\\n\") } // this now compiles } kitten.talk() // prints mew! Classes that declare virtual methods must derive from sys::Virtual . Be aware that virtual classes have the overhead of an extra pointer for their vtable (typically 4 extra bytes).","title":"Virtual Methods"},{"location":"language/methods/#abstract-methods","text":"Abstract methods are virtual methods without an implementation. They are declared using the abstract keyword. Abstract methods are implied to be virtual - it is an error to use both the abstract and virtual keyword. Abstract methods must not provide a method body. The containing class must also be declared abstract .","title":"Abstract Methods"},{"location":"language/methods/#super","text":"By default any virtual method call with an implicit or explicit target of this invokes the most specific version of that method. You can use the super keyword to invoke the super class version of a method: class Kitten extends Cat { override void talk() { super.talk() } } kitten.talk() // now prints meow","title":"Super"},{"location":"language/methods/#constructors","text":"A class may have one constructor, which is compiled into a method called _iInit . Whenever a class declares instance fields with a default value , the compiler auto-generates a constructor for you. A class may declare an explicit constructor using a syntax similiar to Java: final class BufInStream extends InStream { BufInStream(Buf abuf) { this.buf = abuf } Buf buf } To keep Sedona lightweight and simple, the following rules apply to constructor methods: A class may only declare one explicit constructor (parameter overloading is not supported). A class with an explicit constructor must be marked final . Subclasses of sys::Component cannot declare a constructor with parameters. Declared constructors are used with unsized classes to specify an array length. The constructor method for a class is called whenever an object of that type is instantiated. For static inline fields, this happens as soon as the scode is loaded when the Sedona VM boots up. For instance inline fields, this happens when the Sedona VM loads the Sedona application and calls the constructors for the application's components as well as each component's inline object fields. If the running app is modified remotely, however, any new components will be instantiated immediately by App.add() , which will call the component's constructor (and all its non-static inline object fields) at that time. For example: class Foo { // static constructor calls static inline Buf(100) buf static inline BufInStream(buf) in static inline BufOutStream(buf) out static inline Foo inst // instance constructor calls inline Buf(20) ibuf } Inline static fields are initialized in declaration order on VM startup, which calls the appropriate constructors. These constructor calls often result in instance constructor calls, which in turn recursively chain for nested inline fields. For the example above, the compiler will create the following code; Foo._sInit is then automatically called when the VM boots: static void Foo . _sInit () { Foo . buf . _iInit ( 100 ) Foo . in . _iInit ( Foo . buf ) Foo . out . _iInit ( Foo . buf ) Foo . inst . _iInit () } void Foo . _iInit () { this . ibuf . _iInit ( 20 ) }","title":"Constructors"},{"location":"language/methods/#native-methods","text":"The native keyword is used on methods that are implemented in C code. Like abstract methods, native methods must not define a body. See Native Methods for more details.","title":"Native Methods"},{"location":"language/methods/#action-methods","text":"Methods may be annotated with the action keyword to promote the method into a Component action. Actions must be instance methods on a subclass of sys::Component . See Component Actions for more details.","title":"Action Methods"},{"location":"language/nativeMethods/","text":"Native Methods \u00b6 Overview \u00b6 Native methods are used to create Sedona APIs that bind to native code written in the C programming language. The following steps are used to create a native method: Native Id : Every native method is assigned a unique two byte identifier in the kit's kit.xml file Stub : Every native method is declared in the Sedona code using the native modifier Native Implementation : Native methods are implemented as functions in the C programming language Native Tables : At staging, function pointers to the native implementations are mapped into tables for dispatch by the SVM at runtime Native Id \u00b6 Every native method is assigned a two byte identifier used to dispatch a call to the proper C function. The first byte is the kitId and the second byte is the methodId . Native ids are expressed as \"kitId::methodId\". Each kit that contains native methods should be assigned a unique kitId. Technically kitIds don't need to be globally unique, but they must be unique across all the kits that might be used together for a given platform. The range of kitIds from 0 to 99 is reserved for core Sedona Framework kits. Third parties should use kitIds from 100 to 255 (or contact the Sedona Framework development team). The sys kit itself is assigned the kitId of zero. Any platform service kit (i.e. a platform-specific kit containing a PlatformService subclass) can be given a kitId of 1, since there will never be more than one such kit loaded on a Sedona device at any given time. Within a kit, every native method is assigned a unique methodId. Because the methodId is only a byte, there can be at most 255 native methods in a single kit. The list of native ids for a kit is defined in the kit.xml file using the following XML format: <natives> <native qname= \"foo::Type1.method1\" id= \"6::0\" /> <native qname= \"foo::Type1.method2\" id= \"6::1\" /> <native qname= \"foo::Type2.method1\" id= \"6::2\" /> </natives> The natives element contains one or more native elements for each native method in the kit. The native element contains two required attributes: qname specifies the qualified name of the native method and id specifies the native id formatted as \"kitId::methodId\". In this example, the kitId for kit foo is 6, and the native method methodIds are 0, 1, and 2. Stubs \u00b6 Native methods are declared like normal methods but without a method body (just like abstract methods). Native methods must be flagged with the native keyword. Native methods cannot be abstract or virtual . For example: class Type2 { static native int add(int a, int b) static native void test(bool z, int i, float f) native float testf(int i, float f) } The compiler will perform a series of checks upon the native ids and native stubs when compiling source code into a kit file (in the ResolveNatives step). Unless errors are detected, the native ids are written into the appropriate IR files of the kit. If any native ids are modified, you must recompile from source. Native Implementation \u00b6 The SVM is stack based. Each item on the stack is called a Cell , which is a union of int32_t , float , and void* . Unless you are running on a 64-bit processor, a Cell is 32-bits wide. The definition of Cell in sedona.h is: typedef union { int32_t ival; // 32-bit signed int float fval; // 32-bit float void* aval; // address pointer } Cell; Every native method must be implemented in C as a function that takes two arguments: a SedonaVM_s pointer and a Cell pointer into the stack, and returns a Cell . (Native methods that return a long or a double require special handling, described in more detail below). The definition for SedonaVM_s is in sedona.h . The typedef for a native method pointer is: typedef Cell (*NativeMethod)(struct SedonaVM_s* vm, Cell* params); The method parameters are accessed from the stack via the Cell pointer params . You can manually extract the individual parameters using array indexing. If the native method is not static, then parameter 0 is always the implicit this pointer. It is important to note that all native method implementations return a Cell value even when the Sedona signature for the method returns void . You can use the constant nullCell to return from a method that returns void . Other predefined Cell constants are trueCell , falseCell , zeroCell , oneCell , and negOneCell . An example implementation of the foo::Type2.add method: Cell foo_Type2_add ( SedonaVM * vm , Cell * params ) { int32_t a = params [ 0 ]. ival ; int32_t b = params [ 1 ]. ival ; Cell result ; result . ival = a + b ; return result } An example implementation of the foo::Type2.test method: Cell foo_Type2_test ( SedonaVM * vm , Cell * params ) { int32_t z = params [ 0 ]. ival ; int32_t b = params [ 1 ]. ival ; float f = params [ 2 ]. fval ; printf ( \"test %d %d %f \\n \" , z , b , f ); return nullCell ; } An example implementation of the (non-static) foo::Type2.testf method: Cell foo_Type2_testf ( SedonaVM * vm , Cell * params ) { void * this = params [ 0 ]. aval ; /* 'this' pointer is implicit first element of params[] */ int32_t b = params [ 1 ]. ival ; float f = params [ 2 ]. fval ; Cell result ; result . fval = b * f ; printf ( \"test %d*%f=%f \\n \" , b , f , result . fval ); return result ; } Note in the examples above how each parameter is extracted using array indexing and the union member name. Pointers (including strings) should use the aval member, floats the fval member, and all other primitives are accessed using the ival member. Note that a Sedona bool maps into zero and non-zero for false and true respectively. Arrays of primitives are accessed like their C counterparts. Native methods that pass or return long or double are a bit trickier. A single long or double value requires two Cells to store the full 64-bits. To access a long or double function argument requires the use of pointer casting to access two consecutive elements of the parameter array. A native method that returns a long or double should declare the return type to be int64_t instead of Cell . The following is an example - note how each long parameter actually consumes two cells of the parameter list: native static long addTwoLongs ( long a , long b ) int64_t foo_Type3_addTwoLongs ( SedonaVM * vm , Cell * params ) { int64_t a = * ( int64_t * )( params + 0 ); // param 0+1 int64_t b = * ( int64_t * )( params + 2 ); // param 2+3 return a + b ; } A summary of common mappings from Sedona to their C equivalents: Sedona C Sedona C bool int32_t bool[] uint8_t* byte int32_t byte[] uint8_t* short int32_t short[] uint16_t* int int32_t int[] int32_t* long int64_t long[] int64_t* float float float[] float* double double double[] double* Obj void* Obj[] void** Str uint8_t* Str[] uint8_t** Note that strings can be used as a normal null terminated C string. Refer to the Porting chapter for how to structure your native C code. Native Tables \u00b6 When the SVM is compiled, the SVM is bound to a lookup table for all the native methods available. This lookup table is a two level array of function pointers. The first level of the array maps to the kitIds and the second level maps to the methodIds. For example the function pointer for the native id of \"2::7\" would be nativeTable[2][7] . The native lookup table is automatically generated as \"nativetable.c\" when sedonac is used to stage a VM . Additional Issues \u00b6 The existing native method facility provides low level hooks to bind Sedona Framework APIs into the native platform. However due to its low level nature it maps fairly closely to the stack architecture of the VM. This design has the major limitation that it only works well when accessing primitives off the stack. There is currently no safe mechanism to access individual fields of an Object within a native method, as you would need to know exactly how the compiler will layout the memory (even then it would be quite brittle). In the meantime the best practice is to pass only primitives (or arrays of primitives) as parameters. Predefined Kit Ids \u00b6 The following table shows some of the currently predefined native kit ids. All PlatformService kits use a native kit id of 1. Kit Id sys 0 platform svcs 1 inet 2 serial 3 basicio 4 bacnet 5 smbus 6 spibus 7 nrio 8 datetimeStd 9","title":"Native Methods"},{"location":"language/nativeMethods/#native-methods","text":"","title":"Native Methods"},{"location":"language/nativeMethods/#overview","text":"Native methods are used to create Sedona APIs that bind to native code written in the C programming language. The following steps are used to create a native method: Native Id : Every native method is assigned a unique two byte identifier in the kit's kit.xml file Stub : Every native method is declared in the Sedona code using the native modifier Native Implementation : Native methods are implemented as functions in the C programming language Native Tables : At staging, function pointers to the native implementations are mapped into tables for dispatch by the SVM at runtime","title":"Overview"},{"location":"language/nativeMethods/#native-id","text":"Every native method is assigned a two byte identifier used to dispatch a call to the proper C function. The first byte is the kitId and the second byte is the methodId . Native ids are expressed as \"kitId::methodId\". Each kit that contains native methods should be assigned a unique kitId. Technically kitIds don't need to be globally unique, but they must be unique across all the kits that might be used together for a given platform. The range of kitIds from 0 to 99 is reserved for core Sedona Framework kits. Third parties should use kitIds from 100 to 255 (or contact the Sedona Framework development team). The sys kit itself is assigned the kitId of zero. Any platform service kit (i.e. a platform-specific kit containing a PlatformService subclass) can be given a kitId of 1, since there will never be more than one such kit loaded on a Sedona device at any given time. Within a kit, every native method is assigned a unique methodId. Because the methodId is only a byte, there can be at most 255 native methods in a single kit. The list of native ids for a kit is defined in the kit.xml file using the following XML format: <natives> <native qname= \"foo::Type1.method1\" id= \"6::0\" /> <native qname= \"foo::Type1.method2\" id= \"6::1\" /> <native qname= \"foo::Type2.method1\" id= \"6::2\" /> </natives> The natives element contains one or more native elements for each native method in the kit. The native element contains two required attributes: qname specifies the qualified name of the native method and id specifies the native id formatted as \"kitId::methodId\". In this example, the kitId for kit foo is 6, and the native method methodIds are 0, 1, and 2.","title":"Native Id"},{"location":"language/nativeMethods/#stubs","text":"Native methods are declared like normal methods but without a method body (just like abstract methods). Native methods must be flagged with the native keyword. Native methods cannot be abstract or virtual . For example: class Type2 { static native int add(int a, int b) static native void test(bool z, int i, float f) native float testf(int i, float f) } The compiler will perform a series of checks upon the native ids and native stubs when compiling source code into a kit file (in the ResolveNatives step). Unless errors are detected, the native ids are written into the appropriate IR files of the kit. If any native ids are modified, you must recompile from source.","title":"Stubs"},{"location":"language/nativeMethods/#native-implementation","text":"The SVM is stack based. Each item on the stack is called a Cell , which is a union of int32_t , float , and void* . Unless you are running on a 64-bit processor, a Cell is 32-bits wide. The definition of Cell in sedona.h is: typedef union { int32_t ival; // 32-bit signed int float fval; // 32-bit float void* aval; // address pointer } Cell; Every native method must be implemented in C as a function that takes two arguments: a SedonaVM_s pointer and a Cell pointer into the stack, and returns a Cell . (Native methods that return a long or a double require special handling, described in more detail below). The definition for SedonaVM_s is in sedona.h . The typedef for a native method pointer is: typedef Cell (*NativeMethod)(struct SedonaVM_s* vm, Cell* params); The method parameters are accessed from the stack via the Cell pointer params . You can manually extract the individual parameters using array indexing. If the native method is not static, then parameter 0 is always the implicit this pointer. It is important to note that all native method implementations return a Cell value even when the Sedona signature for the method returns void . You can use the constant nullCell to return from a method that returns void . Other predefined Cell constants are trueCell , falseCell , zeroCell , oneCell , and negOneCell . An example implementation of the foo::Type2.add method: Cell foo_Type2_add ( SedonaVM * vm , Cell * params ) { int32_t a = params [ 0 ]. ival ; int32_t b = params [ 1 ]. ival ; Cell result ; result . ival = a + b ; return result } An example implementation of the foo::Type2.test method: Cell foo_Type2_test ( SedonaVM * vm , Cell * params ) { int32_t z = params [ 0 ]. ival ; int32_t b = params [ 1 ]. ival ; float f = params [ 2 ]. fval ; printf ( \"test %d %d %f \\n \" , z , b , f ); return nullCell ; } An example implementation of the (non-static) foo::Type2.testf method: Cell foo_Type2_testf ( SedonaVM * vm , Cell * params ) { void * this = params [ 0 ]. aval ; /* 'this' pointer is implicit first element of params[] */ int32_t b = params [ 1 ]. ival ; float f = params [ 2 ]. fval ; Cell result ; result . fval = b * f ; printf ( \"test %d*%f=%f \\n \" , b , f , result . fval ); return result ; } Note in the examples above how each parameter is extracted using array indexing and the union member name. Pointers (including strings) should use the aval member, floats the fval member, and all other primitives are accessed using the ival member. Note that a Sedona bool maps into zero and non-zero for false and true respectively. Arrays of primitives are accessed like their C counterparts. Native methods that pass or return long or double are a bit trickier. A single long or double value requires two Cells to store the full 64-bits. To access a long or double function argument requires the use of pointer casting to access two consecutive elements of the parameter array. A native method that returns a long or double should declare the return type to be int64_t instead of Cell . The following is an example - note how each long parameter actually consumes two cells of the parameter list: native static long addTwoLongs ( long a , long b ) int64_t foo_Type3_addTwoLongs ( SedonaVM * vm , Cell * params ) { int64_t a = * ( int64_t * )( params + 0 ); // param 0+1 int64_t b = * ( int64_t * )( params + 2 ); // param 2+3 return a + b ; } A summary of common mappings from Sedona to their C equivalents: Sedona C Sedona C bool int32_t bool[] uint8_t* byte int32_t byte[] uint8_t* short int32_t short[] uint16_t* int int32_t int[] int32_t* long int64_t long[] int64_t* float float float[] float* double double double[] double* Obj void* Obj[] void** Str uint8_t* Str[] uint8_t** Note that strings can be used as a normal null terminated C string. Refer to the Porting chapter for how to structure your native C code.","title":"Native Implementation"},{"location":"language/nativeMethods/#native-tables","text":"When the SVM is compiled, the SVM is bound to a lookup table for all the native methods available. This lookup table is a two level array of function pointers. The first level of the array maps to the kitIds and the second level maps to the methodIds. For example the function pointer for the native id of \"2::7\" would be nativeTable[2][7] . The native lookup table is automatically generated as \"nativetable.c\" when sedonac is used to stage a VM .","title":"Native Tables"},{"location":"language/nativeMethods/#additional-issues","text":"The existing native method facility provides low level hooks to bind Sedona Framework APIs into the native platform. However due to its low level nature it maps fairly closely to the stack architecture of the VM. This design has the major limitation that it only works well when accessing primitives off the stack. There is currently no safe mechanism to access individual fields of an Object within a native method, as you would need to know exactly how the compiler will layout the memory (even then it would be quite brittle). In the meantime the best practice is to pass only primitives (or arrays of primitives) as parameters.","title":"Additional Issues"},{"location":"language/nativeMethods/#predefined-kit-ids","text":"The following table shows some of the currently predefined native kit ids. All PlatformService kits use a native kit id of 1. Kit Id sys 0 platform svcs 1 inet 2 serial 3 basicio 4 bacnet 5 smbus 6 spibus 7 nrio 8 datetimeStd 9","title":"Predefined Kit Ids"},{"location":"language/primitives/","text":"Primitives \u00b6 Overview \u00b6 The Sedona programming language contains the following built-in primitive types: bool : boolean value byte : unsigned 8-bit integer (as field or array only) short : unsigned 16-bit integer (as field or array only) int : signed 32-bit integer long : signed 64-bit integer float : 32-bit floating point double : 64-bit floating point In addition to the primitive types, the following class types have special language support for literal representation: Str : string of ASCII characters terminated by 0 (like C string) Buf : chunk of bytes in memory These types are described in more detail below. Bool \u00b6 The bool type stores a boolean variable. Boolean literals are expressed using the true , false , and null keywords. Use null to indicate an invalid boolean value. If used in a boolean expression, null will evaluate to true (it is represented as 2 in memory). A bool is stored in fields and arrays as an unsigned 8-bit integer. During stack manipulation bool s are stored on the stack as signed 32-bit integers. The representation for booleans: Value Binary String false 0 \"false\" true 1 \"true\" null 2 \"null\" Integers \u00b6 There are four integer types of varying widths: byte : unsigned 8-bit integer (as field or array only) short : unsigned 16-bit integer (as field or array only) int : signed 32-bit integer long : signed 64-bit integer Both byte and short are special types that may only be used as fields or in arrays. Attempting to use byte or short as a return type, parameter type, or local variable type is a compiler error. Note that unlike Java both byte and short are unsigned . Currently there is no signed 8-bit or 16-bit integer type. All integer operations on the SVM stack are performed using signed 32-bit integers. When a byte or short is loaded from a field or array it is automatically expanded into a 32-bit signed value. Likewise when it is stored back into a field or array it is narrowed from a 32-bit signed value. Integer literals are decimal by default. If prefixed with \"0x\" they are hexadecimal. You may use the underbar \"_\" as separator in both decimal and hexadecimal formats. To specify a 64-bit long value, you must append an \"L\" to the number. Char escapes \u00b6 You may also use single quotes to specify a character as an integer literal. The following character escape sequences are supported: \\0 zero/null terminator \\n newline \\r carriage return \\t horizontal tab \\\" double quote \\' single quote \\\\ backslash \\$ dollar sign ($ is used for str interpolation) Examples of integer literals: 8 -78 0xABCD 10_000 0xffff_ffff 'x' '\\n' 0L 0x1234_5678_aabb_ccddL Floating Point \u00b6 The float type maps to a 32-bit floating point value and double to 64-bit floating point. Floating point literals are expressed in decimal format using a '.' dot as the decimal point. The 'F' or 'f' character may be used as a suffix (required if not using a decimal point). The 'D' or 'd' character is required as a suffix for a 64-bit double. You may use the '_' underbar as a separator. You can also specify floating point literals in scientific notation. All numbers given in scientific notation are of type float unless explicitly marked as a double using 'D' or 'd'. A floating-point literal has the following format: The keyword null is used to represent not-a-number for situations requiring indication of an invalid float or double. The string representation for null floats and doubles is always 'null'. The '==' operator will return true when comparing two null floating point values (this is different from Java and IEEE). The evaluation of arithmetic and comparison operations with null operands, however, is unspecified for the Sedona VM. 3f 3.0 40_000F -2.00D 0d 1e+5 5.86e12d 314159E-5 null Time \u00b6 The Sedona Framework represents time in nanosecond ticks, stored as a 64-bit long. When working with time, you can use a special literal representation for longs using the following suffixes on a decimal number: Suffix Unit Nanosecond Multiplier ns nanoseconds 1 ms milliseconds 1,000,000 sec seconds 1,000,000,000 min minutes 60,000,000,000 hr hours 3,600,000,000,000 days days 86,400,000,000,000 Examples of long time literals and what they represent: 5ns // 5L 1ms // 1_000_000L 10sec // 10_000_000_000L 3min // 180_000_000_000L 12hr // 43_200_000_000_000L 0.5ms // 500_000L 0.001sec // 1_000_000L 0.25min // 15_000_000_000L 0.5days // 43_200_000_000_000L 1days // 86_400_000_000_000L 36500days // 31_53_600_000_000_000_000L Str \u00b6 The sys::Str class models a string of ASCII characters. Strings are stored in memory like C strings using a null terminator (a byte with a value of zero). You should use only 7-bit ASCII characters (clear high bit) to allow future UTF-8 and Unicode support. In the SVM, the Str class makes use of the unsized class feature to create a byte[] of the correct length when the Str object is instantiated. No other fields are declared, so an instance of Str is stored in memory just like a byte[] . You can also treat a Str reference as a normal C string ( char* ) when writing native methods . Because Str is an unsized class, you must specify the length of the string when declaring a Str field. For example to declare a Str that can hold a max of 8 characters (including the null terminator): Str someStr // reference to Str stored elsewhere inline Str ( 8 ) myStr // storage allocated here for 8 byte Str Sedona also supports string interpolation when writing to an output stream. Str literals are written using double quotes. You may use supported escape sequences for special characters inside the quotes. All Str literals are interned when compiling a scode image - this means that all Str literals with the same sequence of characters will share the same reference. Str literals should be considered read-only memory - never try to change the contents of a Str literal. Examples of Str literals: \"hello\" \"Hi there.\\nHow are you?\" The compiler automatically adds the null terminator byte when interning the literal. For example a pointer to the literal \"abc\" is really a pointer to four bytes of memory containing \"abc\\0\" . Buf \u00b6 The sys::Buf class models a contiguous chunk of bytes in memory. Like sys::Str , it is an unsized class containing a byte[] that is allocated to the specified size when the Buf object is created. Unlike Str , however, Buf does not treat its contents as a string, so no null terminator is added. It also has fields that store the size of the buffer and the number of bytes used. The syntax for a Buf literal is 0x[hexDigits] . You can use whitespace (including newlines) between bytes. For example: static Buf literalA = 0x[cafe babe 03 dead beef] Just like Str literals, Buf literals are interned and stored in scode memory space. So you should never attempt to write into a Buf literal\\'s memory space - for example never try to set the bytesLen field or change the contents of the bytes field. Array Literals \u00b6 Although they are not free-form expressions, you can also declare array literals in code: define Str[] colors = {\"red\", \"green\", \"blue\"} See Array Literals for more details.","title":"Primitives"},{"location":"language/primitives/#primitives","text":"","title":"Primitives"},{"location":"language/primitives/#overview","text":"The Sedona programming language contains the following built-in primitive types: bool : boolean value byte : unsigned 8-bit integer (as field or array only) short : unsigned 16-bit integer (as field or array only) int : signed 32-bit integer long : signed 64-bit integer float : 32-bit floating point double : 64-bit floating point In addition to the primitive types, the following class types have special language support for literal representation: Str : string of ASCII characters terminated by 0 (like C string) Buf : chunk of bytes in memory These types are described in more detail below.","title":"Overview"},{"location":"language/primitives/#bool","text":"The bool type stores a boolean variable. Boolean literals are expressed using the true , false , and null keywords. Use null to indicate an invalid boolean value. If used in a boolean expression, null will evaluate to true (it is represented as 2 in memory). A bool is stored in fields and arrays as an unsigned 8-bit integer. During stack manipulation bool s are stored on the stack as signed 32-bit integers. The representation for booleans: Value Binary String false 0 \"false\" true 1 \"true\" null 2 \"null\"","title":"Bool"},{"location":"language/primitives/#integers","text":"There are four integer types of varying widths: byte : unsigned 8-bit integer (as field or array only) short : unsigned 16-bit integer (as field or array only) int : signed 32-bit integer long : signed 64-bit integer Both byte and short are special types that may only be used as fields or in arrays. Attempting to use byte or short as a return type, parameter type, or local variable type is a compiler error. Note that unlike Java both byte and short are unsigned . Currently there is no signed 8-bit or 16-bit integer type. All integer operations on the SVM stack are performed using signed 32-bit integers. When a byte or short is loaded from a field or array it is automatically expanded into a 32-bit signed value. Likewise when it is stored back into a field or array it is narrowed from a 32-bit signed value. Integer literals are decimal by default. If prefixed with \"0x\" they are hexadecimal. You may use the underbar \"_\" as separator in both decimal and hexadecimal formats. To specify a 64-bit long value, you must append an \"L\" to the number.","title":"Integers"},{"location":"language/primitives/#char-escapes","text":"You may also use single quotes to specify a character as an integer literal. The following character escape sequences are supported: \\0 zero/null terminator \\n newline \\r carriage return \\t horizontal tab \\\" double quote \\' single quote \\\\ backslash \\$ dollar sign ($ is used for str interpolation) Examples of integer literals: 8 -78 0xABCD 10_000 0xffff_ffff 'x' '\\n' 0L 0x1234_5678_aabb_ccddL","title":"Char escapes"},{"location":"language/primitives/#floating-point","text":"The float type maps to a 32-bit floating point value and double to 64-bit floating point. Floating point literals are expressed in decimal format using a '.' dot as the decimal point. The 'F' or 'f' character may be used as a suffix (required if not using a decimal point). The 'D' or 'd' character is required as a suffix for a 64-bit double. You may use the '_' underbar as a separator. You can also specify floating point literals in scientific notation. All numbers given in scientific notation are of type float unless explicitly marked as a double using 'D' or 'd'. A floating-point literal has the following format: The keyword null is used to represent not-a-number for situations requiring indication of an invalid float or double. The string representation for null floats and doubles is always 'null'. The '==' operator will return true when comparing two null floating point values (this is different from Java and IEEE). The evaluation of arithmetic and comparison operations with null operands, however, is unspecified for the Sedona VM. 3f 3.0 40_000F -2.00D 0d 1e+5 5.86e12d 314159E-5 null","title":"Floating Point"},{"location":"language/primitives/#time","text":"The Sedona Framework represents time in nanosecond ticks, stored as a 64-bit long. When working with time, you can use a special literal representation for longs using the following suffixes on a decimal number: Suffix Unit Nanosecond Multiplier ns nanoseconds 1 ms milliseconds 1,000,000 sec seconds 1,000,000,000 min minutes 60,000,000,000 hr hours 3,600,000,000,000 days days 86,400,000,000,000 Examples of long time literals and what they represent: 5ns // 5L 1ms // 1_000_000L 10sec // 10_000_000_000L 3min // 180_000_000_000L 12hr // 43_200_000_000_000L 0.5ms // 500_000L 0.001sec // 1_000_000L 0.25min // 15_000_000_000L 0.5days // 43_200_000_000_000L 1days // 86_400_000_000_000L 36500days // 31_53_600_000_000_000_000L","title":"Time"},{"location":"language/primitives/#str","text":"The sys::Str class models a string of ASCII characters. Strings are stored in memory like C strings using a null terminator (a byte with a value of zero). You should use only 7-bit ASCII characters (clear high bit) to allow future UTF-8 and Unicode support. In the SVM, the Str class makes use of the unsized class feature to create a byte[] of the correct length when the Str object is instantiated. No other fields are declared, so an instance of Str is stored in memory just like a byte[] . You can also treat a Str reference as a normal C string ( char* ) when writing native methods . Because Str is an unsized class, you must specify the length of the string when declaring a Str field. For example to declare a Str that can hold a max of 8 characters (including the null terminator): Str someStr // reference to Str stored elsewhere inline Str ( 8 ) myStr // storage allocated here for 8 byte Str Sedona also supports string interpolation when writing to an output stream. Str literals are written using double quotes. You may use supported escape sequences for special characters inside the quotes. All Str literals are interned when compiling a scode image - this means that all Str literals with the same sequence of characters will share the same reference. Str literals should be considered read-only memory - never try to change the contents of a Str literal. Examples of Str literals: \"hello\" \"Hi there.\\nHow are you?\" The compiler automatically adds the null terminator byte when interning the literal. For example a pointer to the literal \"abc\" is really a pointer to four bytes of memory containing \"abc\\0\" .","title":"Str"},{"location":"language/primitives/#buf","text":"The sys::Buf class models a contiguous chunk of bytes in memory. Like sys::Str , it is an unsized class containing a byte[] that is allocated to the specified size when the Buf object is created. Unlike Str , however, Buf does not treat its contents as a string, so no null terminator is added. It also has fields that store the size of the buffer and the number of bytes used. The syntax for a Buf literal is 0x[hexDigits] . You can use whitespace (including newlines) between bytes. For example: static Buf literalA = 0x[cafe babe 03 dead beef] Just like Str literals, Buf literals are interned and stored in scode memory space. So you should never attempt to write into a Buf literal\\'s memory space - for example never try to set the bytesLen field or change the contents of the bytes field.","title":"Buf"},{"location":"language/primitives/#array-literals","text":"Although they are not free-form expressions, you can also declare array literals in code: define Str[] colors = {\"red\", \"green\", \"blue\"} See Array Literals for more details.","title":"Array Literals"},{"location":"language/reflection/","text":"Reflection \u00b6 Overview \u00b6 Despite its tiny runtime footprint, the Sedona Framework has powerful reflection support for accessing kit, type, and slot meta-data at runtime. However unlike the general purpose reflection found in Java, Sedona reflection is only supported for Component types and Property/Action slots. Kits \u00b6 You can access the installed kits with the sys::Kit class: // iterate over the installed kits foreach (Kit kit : Sys.kits, Sys.kitsLen) Sys.out.print(\"$kit.name $kit.version ${Sys.hexStr(kit.checksum)}\").nl() // look up a kit by name Kit kit = Sys.findKit(\"sys\") Types \u00b6 The sys::Type API is used to reflectively work with types at runtime. Only types that extend from Component are available for reflection: // walk the types installed in a given kit Kit kit = Sys.findKit(\"control\") foreach (Type t : kit.types, kit.typesLen) Sys.out.print(\" ${kit.name}::${t.name}\").nl() // lookup a type by qname Type t = Sys.findType(\"control::Ramp\") // type literal for class User Type t = User.type If you know the type you need at compile time, you should use type literals since they are most efficient: UserService s = (UserService)Sys.app.lookupService(UserService.type) Slots \u00b6 The sys::Slot API is used to reflectively work with slots at runtime. Only the property and action slots of component types are available for reflection: // walk a type's slots Type t = App.type foreach (Slot slot : t.slots, t.slotsLen) Sys.out.print(\" ${slot.name}: $slot.type.name\").nl() // lookup a slot by name Slot restart = t.findSlot(\"restart\") // slot literal for the App action \"restart\" Slot restart = App.restart If you know the slot you need at compile time, you should use slot literals since they are most efficient. Ids \u00b6 Note that Kit , Type , and Slot each have an id field, which is a direct index into the corresponding array: Id Field Index Into Kit.id Sys.kits Type.id Kit.types Slot.id Type.slots This is an extremely efficient way to lookup kits, types, and slots. However, be aware that the id lookup only works within a specific schema. As soon you change the installed kits or the version of those kits, then all of the reflection ids will likely change. This trade-off between the efficiency of id based lookup versus the ability to version kits is the basis of Schemas .","title":"Reflection"},{"location":"language/reflection/#reflection","text":"","title":"Reflection"},{"location":"language/reflection/#overview","text":"Despite its tiny runtime footprint, the Sedona Framework has powerful reflection support for accessing kit, type, and slot meta-data at runtime. However unlike the general purpose reflection found in Java, Sedona reflection is only supported for Component types and Property/Action slots.","title":"Overview"},{"location":"language/reflection/#kits","text":"You can access the installed kits with the sys::Kit class: // iterate over the installed kits foreach (Kit kit : Sys.kits, Sys.kitsLen) Sys.out.print(\"$kit.name $kit.version ${Sys.hexStr(kit.checksum)}\").nl() // look up a kit by name Kit kit = Sys.findKit(\"sys\")","title":"Kits"},{"location":"language/reflection/#types","text":"The sys::Type API is used to reflectively work with types at runtime. Only types that extend from Component are available for reflection: // walk the types installed in a given kit Kit kit = Sys.findKit(\"control\") foreach (Type t : kit.types, kit.typesLen) Sys.out.print(\" ${kit.name}::${t.name}\").nl() // lookup a type by qname Type t = Sys.findType(\"control::Ramp\") // type literal for class User Type t = User.type If you know the type you need at compile time, you should use type literals since they are most efficient: UserService s = (UserService)Sys.app.lookupService(UserService.type)","title":"Types"},{"location":"language/reflection/#slots","text":"The sys::Slot API is used to reflectively work with slots at runtime. Only the property and action slots of component types are available for reflection: // walk a type's slots Type t = App.type foreach (Slot slot : t.slots, t.slotsLen) Sys.out.print(\" ${slot.name}: $slot.type.name\").nl() // lookup a slot by name Slot restart = t.findSlot(\"restart\") // slot literal for the App action \"restart\" Slot restart = App.restart If you know the slot you need at compile time, you should use slot literals since they are most efficient.","title":"Slots"},{"location":"language/reflection/#ids","text":"Note that Kit , Type , and Slot each have an id field, which is a direct index into the corresponding array: Id Field Index Into Kit.id Sys.kits Type.id Kit.types Slot.id Type.slots This is an extremely efficient way to lookup kits, types, and slots. However, be aware that the id lookup only works within a specific schema. As soon you change the installed kits or the version of those kits, then all of the reflection ids will likely change. This trade-off between the efficiency of id based lookup versus the ability to version kits is the basis of Schemas .","title":"Ids"},{"location":"language/stmt/","text":"Statements \u00b6 Overview \u00b6 Statements are very close to those found in C or Java: Expression : expression statement Locals : declare a local variable Return : exit from a method If/Else : conditional branching While : conditional looping For : just like C for statement Foreach : array iteration Goto : unconditional branching Switch : jump tables Assert : used for unit testing Unlike C or Java, statements are not required to be terminated with a semicolon. By convention they are terminated with a newline, although they can also be terminated with a semicolon or \"}\". All of these are valid statements: if ( c ) { doSomething () orAnother () } if ( c ) { doSomething (); orAnother (); } if ( c ) { doSomething (); orAnother () } Note that Sedona's grammar is not always unambiguous when terminating a statement with a newline. So on occasion you might be required to use a semicolon. If you get a weird compiler error you don't understand try sticking in a semicolon. This might happen if you have a statement that starts with a parenthesis such as ((Type)x).something() . Expression \u00b6 The most common type of statements are stand alone expressions. The following expressions can be used as a statement: Assignment: x = y, x++, x[i] = y, x.f += y Method calls: x() Local Variables \u00b6 Local variables are declared as follows: float f int i = 5 Component c = doSomething() Local variables are scoped within their block - they are not visible to parent blocks. A local variable must be definitely assigned before it is used or the compiler will generate an error. Sedona doesn't currently support declaring multiple local variables in one statement like C or Java. Return \u00b6 The return statement is used to exit a method. If a return is used in a non-void method, then it must specify the expression to return: // void return return // non-void return return expr If Else \u00b6 Sedona supports C style if/else statements: // if, no else if (cond) block // if-else if (cond) block else block // if, if-else, else if (cond) block else if (cond) block else block Like C/Java, each block may be a single statement, or a block of statements wrapped in \"{ }\" curly braces. Looping \u00b6 Sedona supports the traditional while, do-while, and for loops of C like languages. Sedona also has a foreach statement for iterating arrays. In each case, the repeated code can be a single statement or a sequence of statements wrapped in \"{ }\" curly braces. While \u00b6 The while statement is used to loop while a boolean expression evaluates to true: while (cond) block Do While \u00b6 The do-while statement works just like the while loop, except the condition is evaluated at the end of the block. It is typically used when you wish to guarantee the loops executes at least once: do block while (cond) For \u00b6 The for statement works like a while loop except it allows an initialization expression and an update expression that executes after each loop iteration: for (init; cond; update) block // example - prints 0 to 4 for (int i=0; i<5; ++i) Sys.out.print(\"i = $i\\n\") Any of the init, cond, or update expressions may be omitted. If the cond is omitted, then it defaults to true and the loop must be terminated with a break or return statement inside the block. Foreach \u00b6 Sedona provides the foreach statement to iterate through an array. Using the foreach statement is more efficient than using a for loop because is compiles into a specialized instruction. The foreach statement takes a local variable declaration, an array to iterate, and an optional array length: foreach (type var : array) block foreach (type var : array, length) block // example - prints each kit name and version foreach (Kit kit : Sys.kits, Sys.kitsLen) Sys.out.print(\"$kit.name $kit.version\").nl() The length may be omitted only if the compiler can infer the length of the array from its declaration. Break \u00b6 The break statement is used to exit a loop. It may be used with any looping statement (while, do-while, for, and foreach): // prints 0 to 3, then breaks for (int i=0; i<10; ++i) { if (i == 4) break Sys.out.print(\"i=$i\\n\") } If a break is used inside nested loops, it breaks from the inner-most loop. Labeled breaks are not supported. Continue \u00b6 The continue statement causes the next iteration of the containing loop to begin. For a while and do-while, the loop condition is executed immediately. For a for or foreach loop, control is passed to the increment step. // prints 0, 1, 3 (skips 2) for (int i=0; i<4; ++i) { if (i == 2) continue Sys.out.print(\"i=$i\\n\") } If a continue is used inside nested loops, it continues the inner-most loop. Labeled continues are not supported. Goto \u00b6 The goto statement performs an unconditional jump to a labeled statement within the same method: // this method always returns \"y\" static Str f() { goto foo return \"x\" foo: return \"y\" } Switch \u00b6 The switch statement works just like C and Java. It evaluates an integer expression and jumps to a cast label: Str s = null switch (i) { case 0: case 1: s = \"0 or 1\" break case 2: s = \"2\" break default: s = \"not 0, 1, or 2\" } Like C, case blocks fall through to the next case block - use a break statement to break out of the switch statement. The default block handles any value without an matching case label. The default block is optional; if omitted then unmatched values fall through to the next statement after the switch. However, if the default block exists, it must be the last label in the switch statement. If the last case statement does not break and there is a default block, the last case statement will fall through into the default block. switch(i) { case 0: reset() break case 1: init() // fall through to default block default: work() // whenever i is not zero } Limits on Case Values \u00b6 To reduce code size, case values must not be too widely spaced. For a difference delta between the minimum and maximum case values, and total number of case values num , at least one of the following must be true: delta <= 30 num*3 >= delta It is a compile time error if both conditions are false. If you get this compiler error, you should change your code to use the if/else if/.../else idiom. Assert \u00b6 The assert statement is used for unit testing . assert(cond) The condition must be a boolean expression. Failed assertions result in a call to the Sedona VM's onAssertFailure callback. On most platforms, this will print a message to stdout. See Porting for more details.","title":"Statements"},{"location":"language/stmt/#statements","text":"","title":"Statements"},{"location":"language/stmt/#overview","text":"Statements are very close to those found in C or Java: Expression : expression statement Locals : declare a local variable Return : exit from a method If/Else : conditional branching While : conditional looping For : just like C for statement Foreach : array iteration Goto : unconditional branching Switch : jump tables Assert : used for unit testing Unlike C or Java, statements are not required to be terminated with a semicolon. By convention they are terminated with a newline, although they can also be terminated with a semicolon or \"}\". All of these are valid statements: if ( c ) { doSomething () orAnother () } if ( c ) { doSomething (); orAnother (); } if ( c ) { doSomething (); orAnother () } Note that Sedona's grammar is not always unambiguous when terminating a statement with a newline. So on occasion you might be required to use a semicolon. If you get a weird compiler error you don't understand try sticking in a semicolon. This might happen if you have a statement that starts with a parenthesis such as ((Type)x).something() .","title":"Overview"},{"location":"language/stmt/#expression","text":"The most common type of statements are stand alone expressions. The following expressions can be used as a statement: Assignment: x = y, x++, x[i] = y, x.f += y Method calls: x()","title":"Expression"},{"location":"language/stmt/#local-variables","text":"Local variables are declared as follows: float f int i = 5 Component c = doSomething() Local variables are scoped within their block - they are not visible to parent blocks. A local variable must be definitely assigned before it is used or the compiler will generate an error. Sedona doesn't currently support declaring multiple local variables in one statement like C or Java.","title":"Local Variables"},{"location":"language/stmt/#return","text":"The return statement is used to exit a method. If a return is used in a non-void method, then it must specify the expression to return: // void return return // non-void return return expr","title":"Return"},{"location":"language/stmt/#if-else","text":"Sedona supports C style if/else statements: // if, no else if (cond) block // if-else if (cond) block else block // if, if-else, else if (cond) block else if (cond) block else block Like C/Java, each block may be a single statement, or a block of statements wrapped in \"{ }\" curly braces.","title":"If Else"},{"location":"language/stmt/#looping","text":"Sedona supports the traditional while, do-while, and for loops of C like languages. Sedona also has a foreach statement for iterating arrays. In each case, the repeated code can be a single statement or a sequence of statements wrapped in \"{ }\" curly braces.","title":"Looping"},{"location":"language/stmt/#while","text":"The while statement is used to loop while a boolean expression evaluates to true: while (cond) block","title":"While"},{"location":"language/stmt/#do-while","text":"The do-while statement works just like the while loop, except the condition is evaluated at the end of the block. It is typically used when you wish to guarantee the loops executes at least once: do block while (cond)","title":"Do While"},{"location":"language/stmt/#for","text":"The for statement works like a while loop except it allows an initialization expression and an update expression that executes after each loop iteration: for (init; cond; update) block // example - prints 0 to 4 for (int i=0; i<5; ++i) Sys.out.print(\"i = $i\\n\") Any of the init, cond, or update expressions may be omitted. If the cond is omitted, then it defaults to true and the loop must be terminated with a break or return statement inside the block.","title":"For"},{"location":"language/stmt/#foreach","text":"Sedona provides the foreach statement to iterate through an array. Using the foreach statement is more efficient than using a for loop because is compiles into a specialized instruction. The foreach statement takes a local variable declaration, an array to iterate, and an optional array length: foreach (type var : array) block foreach (type var : array, length) block // example - prints each kit name and version foreach (Kit kit : Sys.kits, Sys.kitsLen) Sys.out.print(\"$kit.name $kit.version\").nl() The length may be omitted only if the compiler can infer the length of the array from its declaration.","title":"Foreach"},{"location":"language/stmt/#break","text":"The break statement is used to exit a loop. It may be used with any looping statement (while, do-while, for, and foreach): // prints 0 to 3, then breaks for (int i=0; i<10; ++i) { if (i == 4) break Sys.out.print(\"i=$i\\n\") } If a break is used inside nested loops, it breaks from the inner-most loop. Labeled breaks are not supported.","title":"Break"},{"location":"language/stmt/#continue","text":"The continue statement causes the next iteration of the containing loop to begin. For a while and do-while, the loop condition is executed immediately. For a for or foreach loop, control is passed to the increment step. // prints 0, 1, 3 (skips 2) for (int i=0; i<4; ++i) { if (i == 2) continue Sys.out.print(\"i=$i\\n\") } If a continue is used inside nested loops, it continues the inner-most loop. Labeled continues are not supported.","title":"Continue"},{"location":"language/stmt/#goto","text":"The goto statement performs an unconditional jump to a labeled statement within the same method: // this method always returns \"y\" static Str f() { goto foo return \"x\" foo: return \"y\" }","title":"Goto"},{"location":"language/stmt/#switch","text":"The switch statement works just like C and Java. It evaluates an integer expression and jumps to a cast label: Str s = null switch (i) { case 0: case 1: s = \"0 or 1\" break case 2: s = \"2\" break default: s = \"not 0, 1, or 2\" } Like C, case blocks fall through to the next case block - use a break statement to break out of the switch statement. The default block handles any value without an matching case label. The default block is optional; if omitted then unmatched values fall through to the next statement after the switch. However, if the default block exists, it must be the last label in the switch statement. If the last case statement does not break and there is a default block, the last case statement will fall through into the default block. switch(i) { case 0: reset() break case 1: init() // fall through to default block default: work() // whenever i is not zero }","title":"Switch"},{"location":"language/stmt/#limits-on-case-values","text":"To reduce code size, case values must not be too widely spaced. For a difference delta between the minimum and maximum case values, and total number of case values num , at least one of the following must be true: delta <= 30 num*3 >= delta It is a compile time error if both conditions are false. If you get this compiler error, you should change your code to use the if/else if/.../else idiom.","title":"Limits on Case Values"},{"location":"language/stmt/#assert","text":"The assert statement is used for unit testing . assert(cond) The condition must be a boolean expression. Failed assertions result in a call to the Sedona VM's onAssertFailure callback. On most platforms, this will print a message to stdout. See Porting for more details.","title":"Assert"},{"location":"networking/dasp/","text":"DASP \u00b6 Introduction \u00b6 This document specifies the Datagram Authenticated Session Protocol or DASP. This protocol is designed to provide an unordered, reliable, secure session for full-duplex datagram exchange that can be implemented for low power wireless networks and low cost devices. Specifically we target networks that include 6LoWPAN. These networks are typically comprised of devices without the resources to run a protocol such as TCP and must implement their protocol stacks in under 100KB of memory. Requirements \u00b6 The following requirements dictate the design of DASP: DASP runs over an unordered, unreliable packet based transport layer, which is assumed to be UDP or provide the same functionality. DASP will be a datagram oriented protocol, not a stream oriented protocol. Datagram boundaries will be maintained. DASP will deliver datagrams reliably with associated retries. Datagrams are guaranteed to be delivered exactly once. DASP will not guarantee delivery of datagrams in order. Because DASP is designed to run on devices with limited RAM resources, we must assume that buffer space is extremely scarce. Any ordering of datagrams is the responsibility of the application layer. DASP datagrams are delivered within the context of a session. Sessions allow us to efficiently associate datagrams with application context. Application context might include user account privileges, eventing state, or the state associated with a file transfer. DASP sessions are full-duplex - either endpoint may initiate a datagram. DASP sessions are established by authenticating a username and password. However the term password is loosely defined to include any type of secret key. DASP session setup will include an extensible mechanism for negotiating the cryptography capabilities of the two endpoints. The protocol will support plugging in new cryptography standards, but standardizes on SHA-1 for message digest. Version 1.0 does not specify encryption, but could be added via new handshaking headers. DASP will provide flow control in the delivery of datagrams between the endpoints using a sliding window. For example, a session might span both a high speed network such as Ethernet and a low speed network such as 6LoWPAN running over 802.15.4. Compounding the problem is that low speed networks may have few memory resources to allocate to buffering and can quickly be overwhelmed by bursts of packets. Design \u00b6 A DASP session is established when a client initiates a connection to a server. The two endpoints exchange a set of messages called the handshake to establish or reject the session. Once a session is established it is assigned an unsigned 16-bit identifier called the sessionId . The sessionId is included in all subsequent messaging within the context of that session. Messages within the session are consecutively numbered with an unsigned 16-bit value, which we call the sequence number or seqNum . Each endpoint of the session maintains its own sequence and sliding window of outstanding datagrams. This sliding window is used to implement reliability and flow control. Sessions are terminated explicitly via a special control message, or may be timed out after a period where no messages have been received from the remote endpoint. Message Format \u00b6 DASP messages are described as a data structure using the following primitive types: u1 : an unsigned 8-bit integer u2 : an unsigned 16-bit integer in network byte order str : UTF-8 encoded text, followed by a null terminate (zero) byte bytes : an unsigned 8-bit length n, followed by n bytes x[ ] : an array of type x that contains zero or more elements All DASP messages are formatted as follows: message { u2 sessionId u2 seqNum u1 high 4 - bits msgType , low 4 - bits numFields field [] headerFields u1 [] payload } The data in the message is summarized: sessionId : identifies the session associated with the message. During the handshake before a sessionId is allocated, the value 0xffff is used. seqNum : used to sequence each DATAGRAM message for management of the sliding window and matching up requests/responses. Each endpoint maintains its own sequence numbers. msgType : 4-bits are used to identity how to handle the message from an DASP perspective. The list of message types are detailed in a separate section below. numFields : 4-bits specify how many header fields follow in the message. headerFields : a list of zero or more fields that carry additional data about the request much like HTTP header fields. Header fields are detailed in a separate section below. payload : zero or more bytes of message payload. A DASP message does not specify the payload size, but assumes that the underlying transport such as UDP provides the total size of the entire message from which payload size can be computed. Message Types \u00b6 The following table specifies the full list of message type identifiers: Id Name Description 0x0 discover Sent by client or server during device discovery process 0x1 hello Sent by client to initiate handshake 0x2 challenge Response to client's hello message 0x3 authenticate Sent by client to provide authentication credentials 0x4 welcome Response to client's authenticate message if successful 0x5 keepAlive Heartbeat message and message acknowledgements 0x6 datagram Indicates an application datagram message 0x7 close Close the session Header Fields \u00b6 Header fields define a generic way to include an arbitrary set of name/value pairs in an DASP header. They are used much like HTTP header fields - each message type defines required and optional header fields and how they are to be interpreted. Additional header fields can be added to future versions of this specification without breaking the generic processing of DASP messages. Header fields are prefixed with a one byte headerId. The headerId conveys the name of the header in the high 6 bits and the value type of the header in the bottom 2 bits. Implementations can always look at the least significant 2-bits of the headerIds to determine how to decode or skip the header value. Implementations must ignore unknown headers. The 2-bit value type identifiers: Id Name Encoding 0x0 nil The header has no value - the header itself indicates a boolean 0x1 u2 Unsigned 16-bit integer in network byte order 0x2 str UTF-8 encoded text string, followed by null terminator (zero) byte 0x3 bytes 8-bit length, followed by string of raw bytes The list of headerIds defined by this specification: Id (6b, 2b) Name Type Description (default) 0x05 (1,1) version u2 Version of the protocol to use 0x09 (2,1) remoteId u2 Remote endpoint's session id 0x0e (3,2) digestAlgorithm str Name of digest to use (\"SHA-1\") 0x13 (4,3) nonce bytes Nonce to use for digest hash 0x16 (5,2) username str Name of user to authenticate 0x1b (6,3) digest bytes Value of digest hash to authenticate 0x1d (7,1) idealMax u2 Ideal max size in bytes (512) 0x21 (8,1) absMax u2 Absolute max size in bytes (512) 0x25 (9,1) ack u2 Ack a single seqNum 0x2b (a, 3) ackMore bytes Ack a list of seqNums (0x01) 0x2d (b,1) receiveMax u2 Max size of receiving window in bytes (31) 0x31 (c, 1) receiveTimeout u2 Receive timeout in seconds (30sec) 0x35 (d,1) errorCode u2 One of the predefined error codes 0x3a (e,2) platformId str Device's platform ID string Header fields may be specified in any order. Implementations must never assume a specific order. Error Codes \u00b6 The following types defines the error codes to be used with the errorCode header field: Id Name Description 0xe1 incompatibleVersion Server doesn't support version specified by hello 0xe2 busy Server is too busy to allocate new session 0xe3 digestNotSupported Client does not support digest algorithm in challenge 0xe4 notAuthenticated Client supplied invalid credentials 0xe5 timeout Remote endpoint is timing out the session Handshake \u00b6 A session is established by a series of messages called the handshake: The client sends the server a hello message The server responds with the challenge, welcome, or close message The client responds with the authenticate or close message The server responds with either a welcome or close message Once the client receives the welcome message from either step 2 or step 4, then the session is established. An close message during any step terminates the handshake. Hello \u00b6 The hello message is sent by a client to initiate a session. The following header fields apply: version (required): specifies the protocol version to be used. The version of this specification is 1.0, which is represented as 0x0100 in a 16-bit unsigned integer. remoteId (required): the client side sessionId used for messages sent by the server to the client. idealMax (optional): the ideal maximum of bytes per message from the client perspective - see Tuning. If not specified 512 is assumed. absMax (optional): the absolute maximum of bytes per message from the client perspective - see Tuning. If not specified 512 is assumed. receiveMax (optional): the absolute maximum size of the client's receiving windowing (number of messages). If not specified, then a window size of 31 messages is assumed. receiveTimeout (optional): the number of seconds that may elapse without receiving a message before the session is timed out from client perspective; if not specified then a default of 30 seconds is assumed. The sessionId of a hello message must be set to 0xffff to indicate a new session from the server's perspective. The remoteId header specifies the client's sessionId, all messages back to the client will use this sessionId. The seqNum should be a randomly chosen number between 0 and 0xffff , which becomes the start of the client sending window - this sequence number must be the seqNum of the first datagram message sent by the client to server. Challenge \u00b6 Once a hello message has been received, the server assigns a randomly chosen, unused sessionId and then returns a challenge message. The remoteId header of the challenge contains the server side's newly assigned session identifier. The sessionId of the challenge message is the value of the hello's remoteId header. The seqNum should be randomly chosen between 0 and 0xffff - this becomes the start of the server's sending window - the first datagram sent by the server to the client must use this seqNum. The following header fields apply: remoteId (required): the server's sessionId to use for messages sent by the client to the server. digestAlgorithm (optional): this specifies the digest algorithm to use for hashing the username, password, and nonce returned by the authenticate message. If this field is unspecified, then \"SHA-1\" is assumed. Other values that might be used are \"MD5\", \"SHA-256\", \"SHA-384\", and \"SHA-512\". Implementations are only required to implement \"SHA-1\", so this field should only be used when knowledge of client capability is known. Values of this field should always use upper case. nonce (required): the challenge message is required to specify a nonce used to generate a secure hash of the username and password. This value should be randomly generated using a cryptographically strong algorithm. A nonce should only be used once to prevent replay attacks. If the server doesn't support the version specified by the client in the hello message, then it should send the close message with the incompatibleVersion error code. The close message returned should include the version header field, which tells the client which version the server does support. The client may then choose to retry the handshake if supports the server's version. If the server is too busy to allocate a new session, then it should send back a close with the busy error code. A server can by-pass authentication completely by directly sending back a welcome message. Authenticate \u00b6 Once the client receives the challenge message, it has enough information to generate the authenticate message. Clients never pass user credentials directly to the server over the network. Instead the client sends the server a digest of the username, password, and nonce. The algorithm to compute the digest is defined by the digestAlgorithm field defined in the challenge message (or if unspecified then SHA-1 is assumed). The following function is used to compute the digest: credentials = digestAlgorithm(username + \":\" + password) digest = digestAlgorithm(credentials + nonce) First we hash the UTF-8 encoded credentials string, which is the username and password separated by a single \":\" colon character. We call this hash the credentials. We then run the hash function against the credentials and the nonce, which produces a one-time use digest. This mechanism permits DASP enabled devices to avoid storing a password in plain text by storing the username and only the credentials hash. However a device could store the username and password directly and compute the credentials hash as needed. Once the client computes the digest, it sends the server the authenticate message. The authenticate message uses the sessionId specified in the challenge's remoteId header. The seqNum should be the same as that used by the hello message. The following header fields apply: username (required): the UTF-8 encoded string identifier of the user to authenticate. digest (required): the message digest hash computed from the algorithm described above. If using SHA-1, this will be list of 20 bytes (160-bit digest). If the client does not support the digest algorithm specified by the server's challenge message, then the client should immediately send the server a close message with the digestNotSupported error code. Welcome \u00b6 Once the server receives the authenticate message, it validates the username and digest against its user database. If the authentication is successful, then the server responds to the client with the welcome message type. The sessionId of the welcome is the remoteId specified by the client in its hello. The seqNum should be the same as that used by the server's challenge message. The following fields apply: idealMax (optional): the ideal maximum of bytes per message from the server perspective - see Tuning. If not specified 512 is assumed. absMax (optional): the absolute maximum of bytes per message from the server perspective - see Tuning. If not specified 512 is assumed. receiveMax (optional): the absolute maximum size of the server's receiving windowing (number of messages). If not specified, then a window size of 31 messages is assumed. receiveTimeout (optional): the number of seconds that may elapse without receiving a message before the session is timed out from server perspective; if not specified then a default of 30 seconds is assumed. remoteId : if we are skipping the challenge, then the server's sessionId must be returned in the welcome, otherwise this header must be omitted. If authentication fails, then the server sends the client back a close message with the notAuthenticated error code. Tuning \u00b6 The absMax and idealMax header fields are used to negotiate message sizes between the client and server. The absMax is the absolute maximum number of bytes that a message may contain including the DASP headers, but not the transport headers (such as the UDP headers themselves). Typically this value maps to the amount of buffer space a device can dedicate to processing DASP messages. For example a device that can only allocate 256 bytes to buffering an DASP message will not be able to handle larger messages. The idealMax header field specifies the ideal maximum number of bytes a message should contain including the DASP headers (not including the transport headers). Often DASP is running over a network like 6LoWPAN that can support UDP packets larger than the MTU of a 802.15.4 frame. However if implementing a protocol like file transfer, it is desirable to chunk the stream such that messages fit within individual 802.15.4 frames without additional fragmentation overhead. The idealMax header provides for this optimization. Both absMax and idealMax negotiation works the same way. The client specifies its absMax and idealMax fields in its hello message. If either of the header fields are omitted, then they are implied to be 512 bytes. The server has its own absMax and idealMax, which it returns in the welcome message (or else they default to 512). The actual absMax and idealMax used for the session is the minimum between the client and server. For example: client: absMax=512, idealMax=256 server: absMax=1024, idealMax=64 session: absMax=512, idealMax=64 Error Handling \u00b6 Because we assume DASP runs over an unreliable transport, implementations must be prepared to handle lost, delayed, or unordered messages during the handshake process. The following are specific conditions that may arise, and the recommended action for each: The client sends the hello, but does not receive the challenge. In this case, either the hello or the challenge may have been lost. In either case, a new hello request should be sent. If after three attempts fail, then the client should assume communication with the server is not available The server sends the challenge, but doesn't receive an authenticate message. In this case, either the challenge or the authenticate message might have been dropped. In either case the server should never attempt resending the challenge, but rather should time out the session if no authenticate is received. During the handshake process, the server should use a shortened time out period (compared to normal session communication). The client sends the authenticate, but does not receive the welcome. In this case, either the authenticate or the welcome message was lost. The client should resend the authenticate message two more times, before giving up. Servers should gracefully handle receiving multiple authenticate messages for the same session. Messaging \u00b6 Once the session has successfully been established, either end point may initiate application level messaging via the datagram message type. When an endpoint receives a datagram message it performs the following steps: Matches the sessionId to a valid session. If not a valid session, the request is ignored. Checks that the remote address matches the one used to setup the session. If not the request is ignored. Checks that the seqNum is within the valid receiving sliding window, otherwise it is ignored. Checks that the datagram hasn't already been processed, otherwise it is ignored. Each endpoint must keep track of messages it has already processed within its receiving window. Updates its receiving window Sends the datagram to the application layer for processing. Receiver eventually piggybacks an ack on an outgoing message Acks \u00b6 In order to provide reliability, datagrams have to be acknowledged. If there are outgoing messages, then the ack header should be piggybacked to avoid extra messaging. Otherwise a keepAlive message with an ack header is sent back to the remote endpoint to acknowledge the datagrams received so far. The ack header specifies the most recent seqNum successfully received. When an ack header is received, an endpoint can assume that all seqNums <= ackNum have been successfully received and that ackNum + 1 has not been received yet by the remote endpoint. If an endpoint has received messages with gaps in the sequence numbering, it can use the ackMore header to enumerate the seqNums it has received. This allows us to avoid resending those messages just because we've had partial failures. The ackMore is encoded as a list of bits that indicate messages received (bit is set), and messages not received (bit is zero). The least significant bit corresponds to the seqNum in the ack header, and the most significant bit n corresponds to ackNum + n . The ackMore header must always be accompanied by the ack header. By definition the least significant bit of the bitmask must always be one since it corresponds to ackNum itself. Some examples: ack=10 ackMore=15 -> 0x21 ack=10 ackMore=12, 13 -> 0x0d ack=10 ackMore=15, 18, 19 -> 0x03 0x21 Retries \u00b6 Note The following behavior is not currently implemented in the opensource Sedona Framework implementations of DASP. Once an endpoint has sent a datagram message, it should wait for a period of time called the sendRetry (default = 1 sec) (see Flow Control for details). If no acknowledgement has been received for the datagram's seqNum, then one of two things has happened: the original datagram was lost or the acknowledgement was lost. The endpoint should resend the datagram message with the original sequence number, then wait again for sendRetry period. This process should be repeated until the datagram has been sent the number of times specified by the maxSend (default = 3) parameter. If the maxSend attempt fails, then the session should be timed out and the close message sent to the remote endpoint with the timeout error code. Sliding Window \u00b6 DASP supports full duplex messaging - either side may initiate application messages, which are identified with a 16-bit sequence number. An endpoint can have multiple outstanding messages that have not been acknowledged. The sequence of unacknowledged messages sent is called the sending window . Each endpoint also maintains a receiving window , which is the sequence of messages it is prepared to receive. Any messages outside of the receiving window are ignored. The receiveMax header is used to communicate the maximum size of receiving window so that the remote endpoint can tune its sending window. The receiveMax header of the client is specified in its hello message, and the receiveMax of the server is specified in the welcome message. Once receiveMax is established during the handshake, it cannot be changed. The receiveMax header specifies the maximum size of the sliding window, since any messages outside of that window will be ignored. An endpoint should never use a sending window size greater than the remote endpoint's receiving window. However, often the sending window is smaller than the remote's receive window. The sending window is grown and shrunk during the lifetime of the session to allow dynamic optimization of the session's throughput. Tuning the size of the sending window is the basis for flow control and congestion control. Since seqNum is stored in an unsigned 16-bit integer, implementations must handle rollover. The seqNum 65535 is followed by the sequence number 0. For example given lower bound of 65530 and a window size of 10, then the window wraps from 65530 to 3 inclusively. Sequence numbers and the sliding window are only used for datagram messages. The client's handshake hello and authenticate messages define the client's starting sequence number, which is the seqNum of the client's first datagram. The server's handshake challenge and welcome define the sequence number of the server's first datagram. The close and keepAlive messages should always use a sequence number of 0xffff. Flow Control \u00b6 A primary goal for DASP is to provide communication for traffic spanning networks and devices of varying capabilities. For example a common use case is a PC on an Ethernet network communicating to a low cost device on a 6LoWPAN network. The ability to tune a session's communication rates based on the capability of the endpoints is called flow control . It is also common for traffic on networks to vary over time during the course of a session. Tuning the session to handle varying network loads is called congestion control . For practical purposes, flow control and congestion control are handled using the same mechanisms - so we will use the term flow control generically. Flow control in DASP is always managed on the sending side by dynamically tuning the size of the sending window and the sendRetry time. These values are tuned based on analysis of the session's recent past performance. Keep Alive and Termination \u00b6 A session is terminated via one of the following conditions: One endpoint sends the close message No packets are received after a timeout period Close \u00b6 If possible, sessions should be gracefully shutdown using the close message type. If the failure is in the DASP layer (as opposed to the application layer), then the errorCode header should be specified. If an endpoint receives either the close or error message types, then the session is immediately terminated and the sessionId invalidated. No acknowledgement is sent on close messages. It is recommended that close messages be sent twice - endpoints should automatically ignore duplicate close/errors because the sessionId will be invalid. Errors during the handshake should only be sent once. However, since there is no acknowledgment, we can never guarantee that both endpoints are aware of the session termination (in which case we must rely on timeouts). Timeout \u00b6 We can never assume that sessions are closed gracefully, because real-world applications and networks can't be trusted. If an endpoint has not received any messages after a period of time, then the session is timed out. A timed out session is terminated and the sessionId is invalidated. The endpoint should send the remote endpoint an close message with the timeout error code - this error should only be sent once since there is a good chance the remote endpoint is no longer available. Each endpoint specifies its configured timeout via the receiveTimeout header. The client specifies receiveTimeout in its hello message, and the server in the welcome message. If the receiveTimeout is omitted during the handshake, then 30 sec should be assumed. Once the session is established the overall timeout of the session is the maximum timeout between the client and the server. Both endpoints must then use the longer timeout. Because the timeout must be negotiated between the endpoints, care should be taken with using very long time outs. The longer timeout is used because we assume the less capable endpoint's network or device drives overall reliability and speed. However longer timeouts also mean longer periods where the critical memory resources of session state are tied up waiting for a session timeout. keepAlives \u00b6 The keepAlive message type is used to prevent session timeouts and carry acknowledgments when there are no outgoing application messages. If there are no outgoing datagram messages to piggyback an ack header, then an endpoint should sent a keepAlive to acknowledge received messages. Implementations can send these acknowledgements immediately or may use a small delay called the ackDelay . The ackDelay provides a period of time to coalesce multiple acknowledgements and wait for an outgoing datagram message to be generated. Even if all received messages have been acknowledged, then an endpoint still needs to send keepAlive messages to ensure that the remote endpoint doesn't timeout the session. In the absence of other messaging, an endpoint should send keepAlives three times as fast as the timeout period. For example if the negotiated timeout is 30 sec, then keepAlives should be sent every 10 sec. Keep alives should only be used when no application datagrams are being transmitted. KeepAlives are themselves never part of the sliding window. The seqNum of a keepAlives should be 0xffff. When a keep alive is received, it is never checked against the receiving window and is never acknowledged. An endpoint that sends a keepAlive should never attempt to retry the keepAlive, since no acknowledgement is expected. Device Discovery \u00b6 DASP supports device discovery with the following sequence: The client sends a discover request to all listening Sedona servers Any server that receives the discover request opens a Sox session The server then sends a discover response containing its platform ID The server closes the Sox session immediately Each discover response the client receives is added to a list of discovered nodes. Discover \u00b6 A discover message may be sent by a client or a server. The client sends a discover message with no header fields. The server's response message is identical except that it adds a single header field containing its platform ID. platformId (response only): a string containing the platform ID of the responding device. How the discovered devices are collected and processed is not specified.","title":"DASP"},{"location":"networking/dasp/#dasp","text":"","title":"DASP"},{"location":"networking/dasp/#introduction","text":"This document specifies the Datagram Authenticated Session Protocol or DASP. This protocol is designed to provide an unordered, reliable, secure session for full-duplex datagram exchange that can be implemented for low power wireless networks and low cost devices. Specifically we target networks that include 6LoWPAN. These networks are typically comprised of devices without the resources to run a protocol such as TCP and must implement their protocol stacks in under 100KB of memory.","title":"Introduction"},{"location":"networking/dasp/#requirements","text":"The following requirements dictate the design of DASP: DASP runs over an unordered, unreliable packet based transport layer, which is assumed to be UDP or provide the same functionality. DASP will be a datagram oriented protocol, not a stream oriented protocol. Datagram boundaries will be maintained. DASP will deliver datagrams reliably with associated retries. Datagrams are guaranteed to be delivered exactly once. DASP will not guarantee delivery of datagrams in order. Because DASP is designed to run on devices with limited RAM resources, we must assume that buffer space is extremely scarce. Any ordering of datagrams is the responsibility of the application layer. DASP datagrams are delivered within the context of a session. Sessions allow us to efficiently associate datagrams with application context. Application context might include user account privileges, eventing state, or the state associated with a file transfer. DASP sessions are full-duplex - either endpoint may initiate a datagram. DASP sessions are established by authenticating a username and password. However the term password is loosely defined to include any type of secret key. DASP session setup will include an extensible mechanism for negotiating the cryptography capabilities of the two endpoints. The protocol will support plugging in new cryptography standards, but standardizes on SHA-1 for message digest. Version 1.0 does not specify encryption, but could be added via new handshaking headers. DASP will provide flow control in the delivery of datagrams between the endpoints using a sliding window. For example, a session might span both a high speed network such as Ethernet and a low speed network such as 6LoWPAN running over 802.15.4. Compounding the problem is that low speed networks may have few memory resources to allocate to buffering and can quickly be overwhelmed by bursts of packets.","title":"Requirements"},{"location":"networking/dasp/#design","text":"A DASP session is established when a client initiates a connection to a server. The two endpoints exchange a set of messages called the handshake to establish or reject the session. Once a session is established it is assigned an unsigned 16-bit identifier called the sessionId . The sessionId is included in all subsequent messaging within the context of that session. Messages within the session are consecutively numbered with an unsigned 16-bit value, which we call the sequence number or seqNum . Each endpoint of the session maintains its own sequence and sliding window of outstanding datagrams. This sliding window is used to implement reliability and flow control. Sessions are terminated explicitly via a special control message, or may be timed out after a period where no messages have been received from the remote endpoint.","title":"Design"},{"location":"networking/dasp/#message-format","text":"DASP messages are described as a data structure using the following primitive types: u1 : an unsigned 8-bit integer u2 : an unsigned 16-bit integer in network byte order str : UTF-8 encoded text, followed by a null terminate (zero) byte bytes : an unsigned 8-bit length n, followed by n bytes x[ ] : an array of type x that contains zero or more elements All DASP messages are formatted as follows: message { u2 sessionId u2 seqNum u1 high 4 - bits msgType , low 4 - bits numFields field [] headerFields u1 [] payload } The data in the message is summarized: sessionId : identifies the session associated with the message. During the handshake before a sessionId is allocated, the value 0xffff is used. seqNum : used to sequence each DATAGRAM message for management of the sliding window and matching up requests/responses. Each endpoint maintains its own sequence numbers. msgType : 4-bits are used to identity how to handle the message from an DASP perspective. The list of message types are detailed in a separate section below. numFields : 4-bits specify how many header fields follow in the message. headerFields : a list of zero or more fields that carry additional data about the request much like HTTP header fields. Header fields are detailed in a separate section below. payload : zero or more bytes of message payload. A DASP message does not specify the payload size, but assumes that the underlying transport such as UDP provides the total size of the entire message from which payload size can be computed.","title":"Message Format"},{"location":"networking/dasp/#message-types","text":"The following table specifies the full list of message type identifiers: Id Name Description 0x0 discover Sent by client or server during device discovery process 0x1 hello Sent by client to initiate handshake 0x2 challenge Response to client's hello message 0x3 authenticate Sent by client to provide authentication credentials 0x4 welcome Response to client's authenticate message if successful 0x5 keepAlive Heartbeat message and message acknowledgements 0x6 datagram Indicates an application datagram message 0x7 close Close the session","title":"Message Types"},{"location":"networking/dasp/#header-fields","text":"Header fields define a generic way to include an arbitrary set of name/value pairs in an DASP header. They are used much like HTTP header fields - each message type defines required and optional header fields and how they are to be interpreted. Additional header fields can be added to future versions of this specification without breaking the generic processing of DASP messages. Header fields are prefixed with a one byte headerId. The headerId conveys the name of the header in the high 6 bits and the value type of the header in the bottom 2 bits. Implementations can always look at the least significant 2-bits of the headerIds to determine how to decode or skip the header value. Implementations must ignore unknown headers. The 2-bit value type identifiers: Id Name Encoding 0x0 nil The header has no value - the header itself indicates a boolean 0x1 u2 Unsigned 16-bit integer in network byte order 0x2 str UTF-8 encoded text string, followed by null terminator (zero) byte 0x3 bytes 8-bit length, followed by string of raw bytes The list of headerIds defined by this specification: Id (6b, 2b) Name Type Description (default) 0x05 (1,1) version u2 Version of the protocol to use 0x09 (2,1) remoteId u2 Remote endpoint's session id 0x0e (3,2) digestAlgorithm str Name of digest to use (\"SHA-1\") 0x13 (4,3) nonce bytes Nonce to use for digest hash 0x16 (5,2) username str Name of user to authenticate 0x1b (6,3) digest bytes Value of digest hash to authenticate 0x1d (7,1) idealMax u2 Ideal max size in bytes (512) 0x21 (8,1) absMax u2 Absolute max size in bytes (512) 0x25 (9,1) ack u2 Ack a single seqNum 0x2b (a, 3) ackMore bytes Ack a list of seqNums (0x01) 0x2d (b,1) receiveMax u2 Max size of receiving window in bytes (31) 0x31 (c, 1) receiveTimeout u2 Receive timeout in seconds (30sec) 0x35 (d,1) errorCode u2 One of the predefined error codes 0x3a (e,2) platformId str Device's platform ID string Header fields may be specified in any order. Implementations must never assume a specific order.","title":"Header Fields"},{"location":"networking/dasp/#error-codes","text":"The following types defines the error codes to be used with the errorCode header field: Id Name Description 0xe1 incompatibleVersion Server doesn't support version specified by hello 0xe2 busy Server is too busy to allocate new session 0xe3 digestNotSupported Client does not support digest algorithm in challenge 0xe4 notAuthenticated Client supplied invalid credentials 0xe5 timeout Remote endpoint is timing out the session","title":"Error Codes"},{"location":"networking/dasp/#handshake","text":"A session is established by a series of messages called the handshake: The client sends the server a hello message The server responds with the challenge, welcome, or close message The client responds with the authenticate or close message The server responds with either a welcome or close message Once the client receives the welcome message from either step 2 or step 4, then the session is established. An close message during any step terminates the handshake.","title":"Handshake"},{"location":"networking/dasp/#hello","text":"The hello message is sent by a client to initiate a session. The following header fields apply: version (required): specifies the protocol version to be used. The version of this specification is 1.0, which is represented as 0x0100 in a 16-bit unsigned integer. remoteId (required): the client side sessionId used for messages sent by the server to the client. idealMax (optional): the ideal maximum of bytes per message from the client perspective - see Tuning. If not specified 512 is assumed. absMax (optional): the absolute maximum of bytes per message from the client perspective - see Tuning. If not specified 512 is assumed. receiveMax (optional): the absolute maximum size of the client's receiving windowing (number of messages). If not specified, then a window size of 31 messages is assumed. receiveTimeout (optional): the number of seconds that may elapse without receiving a message before the session is timed out from client perspective; if not specified then a default of 30 seconds is assumed. The sessionId of a hello message must be set to 0xffff to indicate a new session from the server's perspective. The remoteId header specifies the client's sessionId, all messages back to the client will use this sessionId. The seqNum should be a randomly chosen number between 0 and 0xffff , which becomes the start of the client sending window - this sequence number must be the seqNum of the first datagram message sent by the client to server.","title":"Hello"},{"location":"networking/dasp/#challenge","text":"Once a hello message has been received, the server assigns a randomly chosen, unused sessionId and then returns a challenge message. The remoteId header of the challenge contains the server side's newly assigned session identifier. The sessionId of the challenge message is the value of the hello's remoteId header. The seqNum should be randomly chosen between 0 and 0xffff - this becomes the start of the server's sending window - the first datagram sent by the server to the client must use this seqNum. The following header fields apply: remoteId (required): the server's sessionId to use for messages sent by the client to the server. digestAlgorithm (optional): this specifies the digest algorithm to use for hashing the username, password, and nonce returned by the authenticate message. If this field is unspecified, then \"SHA-1\" is assumed. Other values that might be used are \"MD5\", \"SHA-256\", \"SHA-384\", and \"SHA-512\". Implementations are only required to implement \"SHA-1\", so this field should only be used when knowledge of client capability is known. Values of this field should always use upper case. nonce (required): the challenge message is required to specify a nonce used to generate a secure hash of the username and password. This value should be randomly generated using a cryptographically strong algorithm. A nonce should only be used once to prevent replay attacks. If the server doesn't support the version specified by the client in the hello message, then it should send the close message with the incompatibleVersion error code. The close message returned should include the version header field, which tells the client which version the server does support. The client may then choose to retry the handshake if supports the server's version. If the server is too busy to allocate a new session, then it should send back a close with the busy error code. A server can by-pass authentication completely by directly sending back a welcome message.","title":"Challenge"},{"location":"networking/dasp/#authenticate","text":"Once the client receives the challenge message, it has enough information to generate the authenticate message. Clients never pass user credentials directly to the server over the network. Instead the client sends the server a digest of the username, password, and nonce. The algorithm to compute the digest is defined by the digestAlgorithm field defined in the challenge message (or if unspecified then SHA-1 is assumed). The following function is used to compute the digest: credentials = digestAlgorithm(username + \":\" + password) digest = digestAlgorithm(credentials + nonce) First we hash the UTF-8 encoded credentials string, which is the username and password separated by a single \":\" colon character. We call this hash the credentials. We then run the hash function against the credentials and the nonce, which produces a one-time use digest. This mechanism permits DASP enabled devices to avoid storing a password in plain text by storing the username and only the credentials hash. However a device could store the username and password directly and compute the credentials hash as needed. Once the client computes the digest, it sends the server the authenticate message. The authenticate message uses the sessionId specified in the challenge's remoteId header. The seqNum should be the same as that used by the hello message. The following header fields apply: username (required): the UTF-8 encoded string identifier of the user to authenticate. digest (required): the message digest hash computed from the algorithm described above. If using SHA-1, this will be list of 20 bytes (160-bit digest). If the client does not support the digest algorithm specified by the server's challenge message, then the client should immediately send the server a close message with the digestNotSupported error code.","title":"Authenticate"},{"location":"networking/dasp/#welcome","text":"Once the server receives the authenticate message, it validates the username and digest against its user database. If the authentication is successful, then the server responds to the client with the welcome message type. The sessionId of the welcome is the remoteId specified by the client in its hello. The seqNum should be the same as that used by the server's challenge message. The following fields apply: idealMax (optional): the ideal maximum of bytes per message from the server perspective - see Tuning. If not specified 512 is assumed. absMax (optional): the absolute maximum of bytes per message from the server perspective - see Tuning. If not specified 512 is assumed. receiveMax (optional): the absolute maximum size of the server's receiving windowing (number of messages). If not specified, then a window size of 31 messages is assumed. receiveTimeout (optional): the number of seconds that may elapse without receiving a message before the session is timed out from server perspective; if not specified then a default of 30 seconds is assumed. remoteId : if we are skipping the challenge, then the server's sessionId must be returned in the welcome, otherwise this header must be omitted. If authentication fails, then the server sends the client back a close message with the notAuthenticated error code.","title":"Welcome"},{"location":"networking/dasp/#tuning","text":"The absMax and idealMax header fields are used to negotiate message sizes between the client and server. The absMax is the absolute maximum number of bytes that a message may contain including the DASP headers, but not the transport headers (such as the UDP headers themselves). Typically this value maps to the amount of buffer space a device can dedicate to processing DASP messages. For example a device that can only allocate 256 bytes to buffering an DASP message will not be able to handle larger messages. The idealMax header field specifies the ideal maximum number of bytes a message should contain including the DASP headers (not including the transport headers). Often DASP is running over a network like 6LoWPAN that can support UDP packets larger than the MTU of a 802.15.4 frame. However if implementing a protocol like file transfer, it is desirable to chunk the stream such that messages fit within individual 802.15.4 frames without additional fragmentation overhead. The idealMax header provides for this optimization. Both absMax and idealMax negotiation works the same way. The client specifies its absMax and idealMax fields in its hello message. If either of the header fields are omitted, then they are implied to be 512 bytes. The server has its own absMax and idealMax, which it returns in the welcome message (or else they default to 512). The actual absMax and idealMax used for the session is the minimum between the client and server. For example: client: absMax=512, idealMax=256 server: absMax=1024, idealMax=64 session: absMax=512, idealMax=64","title":"Tuning"},{"location":"networking/dasp/#error-handling","text":"Because we assume DASP runs over an unreliable transport, implementations must be prepared to handle lost, delayed, or unordered messages during the handshake process. The following are specific conditions that may arise, and the recommended action for each: The client sends the hello, but does not receive the challenge. In this case, either the hello or the challenge may have been lost. In either case, a new hello request should be sent. If after three attempts fail, then the client should assume communication with the server is not available The server sends the challenge, but doesn't receive an authenticate message. In this case, either the challenge or the authenticate message might have been dropped. In either case the server should never attempt resending the challenge, but rather should time out the session if no authenticate is received. During the handshake process, the server should use a shortened time out period (compared to normal session communication). The client sends the authenticate, but does not receive the welcome. In this case, either the authenticate or the welcome message was lost. The client should resend the authenticate message two more times, before giving up. Servers should gracefully handle receiving multiple authenticate messages for the same session.","title":"Error Handling"},{"location":"networking/dasp/#messaging","text":"Once the session has successfully been established, either end point may initiate application level messaging via the datagram message type. When an endpoint receives a datagram message it performs the following steps: Matches the sessionId to a valid session. If not a valid session, the request is ignored. Checks that the remote address matches the one used to setup the session. If not the request is ignored. Checks that the seqNum is within the valid receiving sliding window, otherwise it is ignored. Checks that the datagram hasn't already been processed, otherwise it is ignored. Each endpoint must keep track of messages it has already processed within its receiving window. Updates its receiving window Sends the datagram to the application layer for processing. Receiver eventually piggybacks an ack on an outgoing message","title":"Messaging"},{"location":"networking/dasp/#acks","text":"In order to provide reliability, datagrams have to be acknowledged. If there are outgoing messages, then the ack header should be piggybacked to avoid extra messaging. Otherwise a keepAlive message with an ack header is sent back to the remote endpoint to acknowledge the datagrams received so far. The ack header specifies the most recent seqNum successfully received. When an ack header is received, an endpoint can assume that all seqNums <= ackNum have been successfully received and that ackNum + 1 has not been received yet by the remote endpoint. If an endpoint has received messages with gaps in the sequence numbering, it can use the ackMore header to enumerate the seqNums it has received. This allows us to avoid resending those messages just because we've had partial failures. The ackMore is encoded as a list of bits that indicate messages received (bit is set), and messages not received (bit is zero). The least significant bit corresponds to the seqNum in the ack header, and the most significant bit n corresponds to ackNum + n . The ackMore header must always be accompanied by the ack header. By definition the least significant bit of the bitmask must always be one since it corresponds to ackNum itself. Some examples: ack=10 ackMore=15 -> 0x21 ack=10 ackMore=12, 13 -> 0x0d ack=10 ackMore=15, 18, 19 -> 0x03 0x21","title":"Acks"},{"location":"networking/dasp/#retries","text":"Note The following behavior is not currently implemented in the opensource Sedona Framework implementations of DASP. Once an endpoint has sent a datagram message, it should wait for a period of time called the sendRetry (default = 1 sec) (see Flow Control for details). If no acknowledgement has been received for the datagram's seqNum, then one of two things has happened: the original datagram was lost or the acknowledgement was lost. The endpoint should resend the datagram message with the original sequence number, then wait again for sendRetry period. This process should be repeated until the datagram has been sent the number of times specified by the maxSend (default = 3) parameter. If the maxSend attempt fails, then the session should be timed out and the close message sent to the remote endpoint with the timeout error code.","title":"Retries"},{"location":"networking/dasp/#sliding-window","text":"DASP supports full duplex messaging - either side may initiate application messages, which are identified with a 16-bit sequence number. An endpoint can have multiple outstanding messages that have not been acknowledged. The sequence of unacknowledged messages sent is called the sending window . Each endpoint also maintains a receiving window , which is the sequence of messages it is prepared to receive. Any messages outside of the receiving window are ignored. The receiveMax header is used to communicate the maximum size of receiving window so that the remote endpoint can tune its sending window. The receiveMax header of the client is specified in its hello message, and the receiveMax of the server is specified in the welcome message. Once receiveMax is established during the handshake, it cannot be changed. The receiveMax header specifies the maximum size of the sliding window, since any messages outside of that window will be ignored. An endpoint should never use a sending window size greater than the remote endpoint's receiving window. However, often the sending window is smaller than the remote's receive window. The sending window is grown and shrunk during the lifetime of the session to allow dynamic optimization of the session's throughput. Tuning the size of the sending window is the basis for flow control and congestion control. Since seqNum is stored in an unsigned 16-bit integer, implementations must handle rollover. The seqNum 65535 is followed by the sequence number 0. For example given lower bound of 65530 and a window size of 10, then the window wraps from 65530 to 3 inclusively. Sequence numbers and the sliding window are only used for datagram messages. The client's handshake hello and authenticate messages define the client's starting sequence number, which is the seqNum of the client's first datagram. The server's handshake challenge and welcome define the sequence number of the server's first datagram. The close and keepAlive messages should always use a sequence number of 0xffff.","title":"Sliding Window"},{"location":"networking/dasp/#flow-control","text":"A primary goal for DASP is to provide communication for traffic spanning networks and devices of varying capabilities. For example a common use case is a PC on an Ethernet network communicating to a low cost device on a 6LoWPAN network. The ability to tune a session's communication rates based on the capability of the endpoints is called flow control . It is also common for traffic on networks to vary over time during the course of a session. Tuning the session to handle varying network loads is called congestion control . For practical purposes, flow control and congestion control are handled using the same mechanisms - so we will use the term flow control generically. Flow control in DASP is always managed on the sending side by dynamically tuning the size of the sending window and the sendRetry time. These values are tuned based on analysis of the session's recent past performance.","title":"Flow Control"},{"location":"networking/dasp/#keep-alive-and-termination","text":"A session is terminated via one of the following conditions: One endpoint sends the close message No packets are received after a timeout period","title":"Keep Alive and Termination"},{"location":"networking/dasp/#close","text":"If possible, sessions should be gracefully shutdown using the close message type. If the failure is in the DASP layer (as opposed to the application layer), then the errorCode header should be specified. If an endpoint receives either the close or error message types, then the session is immediately terminated and the sessionId invalidated. No acknowledgement is sent on close messages. It is recommended that close messages be sent twice - endpoints should automatically ignore duplicate close/errors because the sessionId will be invalid. Errors during the handshake should only be sent once. However, since there is no acknowledgment, we can never guarantee that both endpoints are aware of the session termination (in which case we must rely on timeouts).","title":"Close"},{"location":"networking/dasp/#timeout","text":"We can never assume that sessions are closed gracefully, because real-world applications and networks can't be trusted. If an endpoint has not received any messages after a period of time, then the session is timed out. A timed out session is terminated and the sessionId is invalidated. The endpoint should send the remote endpoint an close message with the timeout error code - this error should only be sent once since there is a good chance the remote endpoint is no longer available. Each endpoint specifies its configured timeout via the receiveTimeout header. The client specifies receiveTimeout in its hello message, and the server in the welcome message. If the receiveTimeout is omitted during the handshake, then 30 sec should be assumed. Once the session is established the overall timeout of the session is the maximum timeout between the client and the server. Both endpoints must then use the longer timeout. Because the timeout must be negotiated between the endpoints, care should be taken with using very long time outs. The longer timeout is used because we assume the less capable endpoint's network or device drives overall reliability and speed. However longer timeouts also mean longer periods where the critical memory resources of session state are tied up waiting for a session timeout.","title":"Timeout"},{"location":"networking/dasp/#keepalives","text":"The keepAlive message type is used to prevent session timeouts and carry acknowledgments when there are no outgoing application messages. If there are no outgoing datagram messages to piggyback an ack header, then an endpoint should sent a keepAlive to acknowledge received messages. Implementations can send these acknowledgements immediately or may use a small delay called the ackDelay . The ackDelay provides a period of time to coalesce multiple acknowledgements and wait for an outgoing datagram message to be generated. Even if all received messages have been acknowledged, then an endpoint still needs to send keepAlive messages to ensure that the remote endpoint doesn't timeout the session. In the absence of other messaging, an endpoint should send keepAlives three times as fast as the timeout period. For example if the negotiated timeout is 30 sec, then keepAlives should be sent every 10 sec. Keep alives should only be used when no application datagrams are being transmitted. KeepAlives are themselves never part of the sliding window. The seqNum of a keepAlives should be 0xffff. When a keep alive is received, it is never checked against the receiving window and is never acknowledged. An endpoint that sends a keepAlive should never attempt to retry the keepAlive, since no acknowledgement is expected.","title":"keepAlives"},{"location":"networking/dasp/#device-discovery","text":"DASP supports device discovery with the following sequence: The client sends a discover request to all listening Sedona servers Any server that receives the discover request opens a Sox session The server then sends a discover response containing its platform ID The server closes the Sox session immediately Each discover response the client receives is added to a list of discovered nodes.","title":"Device Discovery"},{"location":"networking/dasp/#discover","text":"A discover message may be sent by a client or a server. The client sends a discover message with no header fields. The server's response message is identical except that it adds a single header field containing its platform ID. platformId (response only): a string containing the platform ID of the responding device. How the discovered devices are collected and processed is not specified.","title":"Discover"},{"location":"networking/discover/","text":"Device Discovery \u00b6 Introduction \u00b6 Sedona Framework (starting with version 1.2) provides a mechanism for performing Sedona device discovery using a special DASP message directed to a multicast address. Any Sedona device on the network that has joined the multicast group then responds to the message with its platform ID and IP address. Basic Operation \u00b6 Join : Each Sedona device that supports DASP device discovery joins a specific IP multicast group at startup. Discover : The Sox client kicks off a device discovery process by sending a DASP DISCOVER request to the multicast group address. Respond : When a device receives the DISCOVER message, it sends a response containing its address and platform ID. Process : The client processes any DISCOVER responses it receives, and maintains a cached list of devices that responded. Porting Tips \u00b6 When porting Sedona to a new platform, the native method inet::UdpSocket.join() must be implemented with the target OS function calls to join the socket to a specified multicast group address. UdpSocket.join() will be called by the Sox service when it opens the socket. The multicast address to use is defined in the inet::UdpSocket native code. Do not change the multicast group address definition in the inet natives unless you also change the corresponding definition in DaspConst.java Whatever address you select, it must be the same in both locations. On the client side, the discover functionality is in sedona.dasp.DaspSocket . Invoking DaspSocket.discover() begins a DASP discovery operation. This clears the current cached list of discovered devices and sends the DASP DISCOVER message to the multicast group address. Call DaspSocket.getDiscovered() to access the list of discovered devices; it returns an array of DiscoveredNode objects. Limitations \u00b6 DASP device discovery cannot be implemented on platforms that do not support multicast addressing on either IPv4 or IPv6. By default the open source code uses IPv4 multicast addressing. (IPv6 addressing is not officially supported for Sedona 1.2.) The specific multicast group address used by this feature is currently not configurable at runtime. It is hardcoded for the Sedona VM within the inet natives, and for the Java side as a DASP constant. To use a different address, it must be changed in both source locations and both the SVM and the sedona.jar module must be rebuilt and deployed. Caution : For DASP Discovery to work, the IP settings for the host's network interface(s) must be correct, including netmask and gateway address. Also, some networks may filter multicast messages, or prohibit them altogether.","title":"Device Discovery"},{"location":"networking/discover/#device-discovery","text":"","title":"Device Discovery"},{"location":"networking/discover/#introduction","text":"Sedona Framework (starting with version 1.2) provides a mechanism for performing Sedona device discovery using a special DASP message directed to a multicast address. Any Sedona device on the network that has joined the multicast group then responds to the message with its platform ID and IP address.","title":"Introduction"},{"location":"networking/discover/#basic-operation","text":"Join : Each Sedona device that supports DASP device discovery joins a specific IP multicast group at startup. Discover : The Sox client kicks off a device discovery process by sending a DASP DISCOVER request to the multicast group address. Respond : When a device receives the DISCOVER message, it sends a response containing its address and platform ID. Process : The client processes any DISCOVER responses it receives, and maintains a cached list of devices that responded.","title":"Basic Operation"},{"location":"networking/discover/#porting-tips","text":"When porting Sedona to a new platform, the native method inet::UdpSocket.join() must be implemented with the target OS function calls to join the socket to a specified multicast group address. UdpSocket.join() will be called by the Sox service when it opens the socket. The multicast address to use is defined in the inet::UdpSocket native code. Do not change the multicast group address definition in the inet natives unless you also change the corresponding definition in DaspConst.java Whatever address you select, it must be the same in both locations. On the client side, the discover functionality is in sedona.dasp.DaspSocket . Invoking DaspSocket.discover() begins a DASP discovery operation. This clears the current cached list of discovered devices and sends the DASP DISCOVER message to the multicast group address. Call DaspSocket.getDiscovered() to access the list of discovered devices; it returns an array of DiscoveredNode objects.","title":"Porting Tips"},{"location":"networking/discover/#limitations","text":"DASP device discovery cannot be implemented on platforms that do not support multicast addressing on either IPv4 or IPv6. By default the open source code uses IPv4 multicast addressing. (IPv6 addressing is not officially supported for Sedona 1.2.) The specific multicast group address used by this feature is currently not configurable at runtime. It is hardcoded for the Sedona VM within the inet natives, and for the Java side as a DASP constant. To use a different address, it must be changed in both source locations and both the SVM and the sedona.jar module must be rebuilt and deployed. Caution : For DASP Discovery to work, the IP settings for the host's network interface(s) must be correct, including netmask and gateway address. Also, some networks may filter multicast messages, or prohibit them altogether.","title":"Limitations"},{"location":"networking/networking/","text":"Networking \u00b6 Overview \u00b6 The Sedona Framework is designed from the ground up to make building smart, networked devices easy. The key networking concepts: Networking APIs: the inet and serial APIs Driver API: framework building your own drivers Sox/Dasp Protocols: the standard protocol stack for provisioning Sedona Framework-enabled devices. APIs \u00b6 The lowest levels of the networking stack are the inet and serial kits. The inet kit specifies the set of APIs used to work with TCP and UDP sockets. These APIs are all designed to be non-blocking to work within the Sedona Framework's single threaded main loop. In order to use the inet API you will need to ensure that your target platform has implemented all the inet native methods. The open source distribution provides an implementation that uses the WinSock and Berkeley socket APIs. The serial kit specifies the set of APIs used to perform serial port communications. The main goal for the serial APIs is to insulate application code from the operating system or hardware's serial port interface. Drivers should use the serial API whenever possible to ensure portability across devices. In order to use the serial API you will need to ensure a port of the native methods is available for your platform. The open source distribution provides a Win32 implementation of the serial natives. Driver Framework \u00b6 You can build your own device/IO drivers for the Sedona Framework. Typically you will use the inet or serial APIs to interface with the network. The driver kit provides a mini-framework used to standardize how custom drivers are built for the Sedona Framework platform. Drivers are structured using the component tree: DeviceNetwork : models the driver's network connectivity and is the container for the devices. Device : is the Sedona Framework representation for an external device. Point : is the Sedona Framework representation for a data point in the external device. Sox Protocol \u00b6 The Sox protocol is the standard protocol used to communicate with Sedona Framework-enabled devices. Sox provides the following services: Version Info : ability to query current version of software. Polling : ability to poll for current values. COV : ability to subscribe to change of value events. RPC : ability to invoke component actions remotely. Programming : ability to add/remove/rename/link/unlink components. File Transfer : ability to get or put arbitrary streams of bytes. Provisioning : ability to backup/upgrade the SVM, kits, or app thru file transfers. The Sox protocol is designed to efficiently enable \"live programming\" of the component model over the network. The Sox protocol itself is run over the Dasp protocol, which provides session based security and reliability over UDP. See Sox and Dasp to learn more about these protocols.","title":"Networking"},{"location":"networking/networking/#networking","text":"","title":"Networking"},{"location":"networking/networking/#overview","text":"The Sedona Framework is designed from the ground up to make building smart, networked devices easy. The key networking concepts: Networking APIs: the inet and serial APIs Driver API: framework building your own drivers Sox/Dasp Protocols: the standard protocol stack for provisioning Sedona Framework-enabled devices.","title":"Overview"},{"location":"networking/networking/#apis","text":"The lowest levels of the networking stack are the inet and serial kits. The inet kit specifies the set of APIs used to work with TCP and UDP sockets. These APIs are all designed to be non-blocking to work within the Sedona Framework's single threaded main loop. In order to use the inet API you will need to ensure that your target platform has implemented all the inet native methods. The open source distribution provides an implementation that uses the WinSock and Berkeley socket APIs. The serial kit specifies the set of APIs used to perform serial port communications. The main goal for the serial APIs is to insulate application code from the operating system or hardware's serial port interface. Drivers should use the serial API whenever possible to ensure portability across devices. In order to use the serial API you will need to ensure a port of the native methods is available for your platform. The open source distribution provides a Win32 implementation of the serial natives.","title":"APIs"},{"location":"networking/networking/#driver-framework","text":"You can build your own device/IO drivers for the Sedona Framework. Typically you will use the inet or serial APIs to interface with the network. The driver kit provides a mini-framework used to standardize how custom drivers are built for the Sedona Framework platform. Drivers are structured using the component tree: DeviceNetwork : models the driver's network connectivity and is the container for the devices. Device : is the Sedona Framework representation for an external device. Point : is the Sedona Framework representation for a data point in the external device.","title":"Driver Framework"},{"location":"networking/networking/#sox-protocol","text":"The Sox protocol is the standard protocol used to communicate with Sedona Framework-enabled devices. Sox provides the following services: Version Info : ability to query current version of software. Polling : ability to poll for current values. COV : ability to subscribe to change of value events. RPC : ability to invoke component actions remotely. Programming : ability to add/remove/rename/link/unlink components. File Transfer : ability to get or put arbitrary streams of bytes. Provisioning : ability to backup/upgrade the SVM, kits, or app thru file transfers. The Sox protocol is designed to efficiently enable \"live programming\" of the component model over the network. The Sox protocol itself is run over the Dasp protocol, which provides session based security and reliability over UDP. See Sox and Dasp to learn more about these protocols.","title":"Sox Protocol"},{"location":"networking/sox/","text":"Sox \u00b6 Overview \u00b6 Sox is the standard protocol used to communicate with Sedona Framework-enabled devices. Sox provides the following services: Version Info : ability to query current version of software. Polling : ability to poll for current values. COV : ability to subscribe to change of value events. RPC : ability to invoke component actions remotely. Programming : ability to add/remove/rename/link/unlink components. File Transfer : ability to get or put arbitrary streams of bytes. Provisioning : ability to backup/upgrade the SVM, kits, or app via file transfers. Dasp \u00b6 Sox is designed to be run over UDP via the Dasp protocol. Dasp handles a lot of complexity for networking: Dasp manages authenticated sessions, so that we can associate incoming Sox messages against a user account. Dasp manages reliability. When Sox sends a message, it doesn't have to worry about retries - Dasp ensures the message gets delivered. Dasp manages flow control. Communication such as a file transfer that creates bursts of packets is automatically throttled to the network's capacity by Dasp. Dasp is full duplex - once a session is established, either side may initiate a message send. Dasp also defines some restrictions that Sox must take into consideration: Dasp is packet based, so Sox must design messages to fit within the maximum packet size (typically around 500 bytes). Dasp is reliable, but unordered, so Sox cannot assume that messages are processed in order. Design \u00b6 Sox has a very basic design. All sox messages are formatted with a standard two byte header: u1 cmd u1 replyNum u1[] payload Every request is assigned a command identifier, which is a lower case ASCII letter. For example 'r' indicates a read property request. Responses to a request use a capitalized ASCII letter, for example a read property response has a cmd identifier of 'R' . Every request is tagged with a one byte replyNum. The replyNum is used to associate requests with their responses. Because the replyNum is only byte, there can only 255 outstanding requests (although it is quite likely Dasp will restrict flow control to a much smaller number of requests). Each specific command has a predefined payload structure . Sedona Framework APIs \u00b6 There is a server side Sox implementation written in 100% Sedona code and deployed in the sox kit. The sox kit includes both the Sox and Dasp protocol stack and depends on inet kit for the IP stack. You must have a port of the inet kit available for your platform in order to run Sox. Most often you will put an instance of the SoxService in your application. The SoxService opens a configured UDP port (default is 1876). The SoxService manages authenticating incoming sessions, handling all the sox commands, and ensuring that sessions are timed out and cleaned up properly. Java APIs \u00b6 The open source distribution also includes a full Java implementation of the Dasp/Sox protocol stacks. These stacks include both a client and service side implementation (although typically you will only use the client side). The Java APIs are designed to \"Sedona Framework enable\" your tools and supervisor applications. The sedona.dasp package implements the lower level Dasp protocol stack. This code is cleanly separated from Sox and may be used stand alone if desired. The sedona.sox package implements the Sox protocol stack and provides a light weight Java model for Sedona Framework components. The SoxClient class provides a Sox aware wrapper around DaspSession for sending/receiving the set of sox commands. Many of the commands use SoxComponent as the Java side representation of Sedona Framework components. The SoxClient class is also used to initiate get/put file transfers. You will use these APIs if implementing your own provisioning strategy. Messages \u00b6 The following Sox message commands are defined: Id Command Description a add Add a new component to the application b fileRename Rename or move a file c readComp Read a component in the application d delete Delete an component and its children from the application e event COV event for a subscribed component f fileOpen Begin a get or put file transfer operation i invoke Invoke a component action k fileChunk Receive or send a chunk during a file transfer l link Add or delete a link n rename Rename a component o reorder Reorder a component's children q query Query installed services r readProp Read a single property from a component s subscribe Subscribe to a component for COV events u unsubscribe Unsubscribe from a component for COV events v version Query for the kits installed w write Write the value of a single component property y versionMore Query for additional version meta-data z fileClose Close a file transfer operation ! error Response id for a command that could not be processed add \u00b6 The add command is used to add a new component to the application. The configProps must match the schema definition for the type. req { u1 'a' u1 replyNum u2 parentId u1 kitId u1 typeId str name val[] configProps } res { u1 'A' u1 replyNum u2 compId } fileRename \u00b6 Rename a file from one path to another path. Also see the sys::File API. req { u1 'b' u1 replyNum str from str to } res { u1 'B' u1 replyNum } readComp \u00b6 Read a given component's state. Component state is broken up into four sections: tree: the component's id, name, parent, and children config: all the persistent properties (marked with @config facet) runtime: all the transient properties (not marked with @config facet) links: all the links to and from the component req { u1 'c' u1 replyNum u2 componentId u1 what: 't', 'c', 'r', 'l' (tree, config, runtime, links) } res { u1 'C' u1 replyNum u2 componentId compTree | compProps | compLinks } compTree { u1 't' u1 kitId u1 typeId str name u2 parent u1 permissions u1 numKids u2[numKids] kidIds } compProps { u1 'c' or 'r' for config or runtime, 'C'/'R' if operator only val[] propValues } compLinks { u1 'l' Link[] links u2 0xffff end marker } delete \u00b6 Delete a component from the application. This command automatically deletes any child components as well as any links to or from the deleted components. req { u1 'd' u1 replyNum u2 compId } res { u1 'D' u1 replyNum } event \u00b6 The event command packages up a COV event and is pushed asynchronously from the server to client periodically for subscribed components. It uses the same component state model as readComp . Events don't have responses, but rather rely on Dasp's acknowledgements to guarantee delivery. req { u1 'e' u1 replyNum u2 componentId compTree | compProps | compLinks } fileOpen \u00b6 The fileOpen command is used to initiate a get or put file transfer. The chunk size is negotiated such that chunk messages fit within the underlying transport's packet size (for example if running over 6LoWPAN we want to fit each chunk into a single 802.15.4 packet). On a put, the fileSize is the number of bytes that will be written. On a get, the fileSize is the maximum number of bytes to read. The actual number of bytes read might be less if there are not fileSize bytes available (taking into account the size of the actual file, and the potential offset). req { u1 'f' u1 replyNum str method (\"g\" for get, \"p\" for put) str uri u4 fileSize u2 suggestedChunkSize (suggested by client) headers[] { str name str value } u1 end of headers '\\0' } res { u1 'F' u1 replyNum u4 fileSize u2 actualChunkSize headers[] { str name str value } u1 end of headers '\\0' } Supported Headers \u00b6 Name Value Method Default Description offset int get, put 0 Byte offset to use when reading/writing the uri mode w, m put w File mode to use on a put. 'w' opens the file and truncates it if the file already exists. 'm' opens the file for random access invoke \u00b6 Invoke an action on a component. This command can be used as an RPC mechanism. Note that the action is executed synchronously; the Sox server blocks until the action completes and returns. req { u1 'i' u1 replyNum u2 componentId u1 slotId val argument } res { u1 'I' u1 replyNum } fileChunk \u00b6 The fileChunk command transfers a single chunk within a file transfer operation. The same message structure is used for both get and put operations. Because Sox is run over Dasp, it is quite possible for chunks to be received out of order. req { u1 'k' u1 replyNum (ignored) u2 chunkNum u2 chunkSize u1[chunkSize] chunk } link \u00b6 The link command is used to add or delete a link between two Component slots in the application. req { u1 'l' u1 replyNum u1 'a' | 'd' (add/delete) u2 fromCompId u1 fromSlotId u2 toCompId u1 toSlotId } res { u1 'L' u1 replyNum } rename \u00b6 Rename is used to change a Component's name. req { u1 'n' u1 replyNum u2 compId str newName } res { u1 'N' u1 replyNum } reorder \u00b6 Reorder a component's child components. req { u1 'o' u1 replyNum u2 compId u1 numChildren u2[] childrenIds } res { u1 'O' u1 replyNum } readProp \u00b6 Read a single property value from a component. req { u1 'r' u1 replyNum u2 compId u1 propId } res { u1 'R' u1 replyNum u1 any code var propValue } subscribe \u00b6 The subscribe command allows you to subscribe to multiple components by registering for a set of change events . The subscribe command will return the number of components that were actually subscribed. This number may be less than the number of components requested if the user does not have permissions on a component, or if the component does not exist anymore You can also subscribe to all tree events (instead of subscribing to individual component tree events). In this case, the response contains no payload. req { u1 's' u1 replyNum u1 whatMask: tree=0x1 config=0x2 rt=0x4 links=0x8 0xff all tree u1 num: u2[] compIds: The ids of all the components to subscribe to } res { u1 'S' u1 replyNum u1 numSubscribed: The actual number of components that were subscribed } unsubscribe \u00b6 Unregister a subscription . The client will stop receiving change events for the set of components specified. req { u1 'u' u1 replyNum u1 whatMask: tree=0x1 config=0x2 rt=0x4 links=0x8 0xff all tree u1 num u2[] compIds } res { u1 'U' u1 replyNum } version \u00b6 Get the list of installed kits and their checksums, which defines the schema . versionReq { u1 'v' u1 replyNum } versionRes { u1 'V' u1 replyNum u1 kitCount kits[kitCount] { str name i4 checksum } } write \u00b6 Set a component property value to a specific value. req { u1 'w' u1 replyNum u2 componentId u1 slotId val value } res { u1 'W' u1 replyNum } versionMore \u00b6 Get extra version information, which includes the version of the installed kits plus platform specific name/value pairs. Name/Value pairs \u00b6 Name Value Notes soxVer Sox protocol version Introduced in build 1.0.45 (see discussion below) All builds of the Sedona Framework prior to 1.0.45 will return null for the sox protocol version. Starting in build 1.0.45 the sox protocol was changed to allow batch subscription , to components. If the sox protocol supports batch subscription, then it will return a soxVer of 1.1 (or higher). req { u1 'y' u1 replyNum } res { u1 'Y' u1 replyNum str platformId u1 scodeFlags kitVersions[kitCount] { str version } u1 pairs pairs { str key str val } } query \u00b6 Perform a query for a set of components. Currently you can only query for a service type using queryType of 's'. But the message is designed to be enhanced thru additional queryTypes. req { u1 'q' u1 replyNum u1 queryType u1[] queryReq } queryType 's': query service req-service { u1 kitId u1 typeId } res { u1 'Q' u1 replyNum u1[] queryRes } queryType 's': query service res-service { u2[num] compIds u2 0xffff end marker } fileClose \u00b6 Terminates a file transfer operation. req { u1 'z' u1 replyNum } res { u1 'Z' u1 replyNum } error \u00b6 The error response may sent back as a response to any request. It indicates to the client that the request could not be processed. The cause of failure is returned as a short string in the message. res { u1 '!' u1 replyNum str cause }","title":"Sox"},{"location":"networking/sox/#sox","text":"","title":"Sox"},{"location":"networking/sox/#overview","text":"Sox is the standard protocol used to communicate with Sedona Framework-enabled devices. Sox provides the following services: Version Info : ability to query current version of software. Polling : ability to poll for current values. COV : ability to subscribe to change of value events. RPC : ability to invoke component actions remotely. Programming : ability to add/remove/rename/link/unlink components. File Transfer : ability to get or put arbitrary streams of bytes. Provisioning : ability to backup/upgrade the SVM, kits, or app via file transfers.","title":"Overview"},{"location":"networking/sox/#dasp","text":"Sox is designed to be run over UDP via the Dasp protocol. Dasp handles a lot of complexity for networking: Dasp manages authenticated sessions, so that we can associate incoming Sox messages against a user account. Dasp manages reliability. When Sox sends a message, it doesn't have to worry about retries - Dasp ensures the message gets delivered. Dasp manages flow control. Communication such as a file transfer that creates bursts of packets is automatically throttled to the network's capacity by Dasp. Dasp is full duplex - once a session is established, either side may initiate a message send. Dasp also defines some restrictions that Sox must take into consideration: Dasp is packet based, so Sox must design messages to fit within the maximum packet size (typically around 500 bytes). Dasp is reliable, but unordered, so Sox cannot assume that messages are processed in order.","title":"Dasp"},{"location":"networking/sox/#design","text":"Sox has a very basic design. All sox messages are formatted with a standard two byte header: u1 cmd u1 replyNum u1[] payload Every request is assigned a command identifier, which is a lower case ASCII letter. For example 'r' indicates a read property request. Responses to a request use a capitalized ASCII letter, for example a read property response has a cmd identifier of 'R' . Every request is tagged with a one byte replyNum. The replyNum is used to associate requests with their responses. Because the replyNum is only byte, there can only 255 outstanding requests (although it is quite likely Dasp will restrict flow control to a much smaller number of requests). Each specific command has a predefined payload structure .","title":"Design"},{"location":"networking/sox/#sedona-framework-apis","text":"There is a server side Sox implementation written in 100% Sedona code and deployed in the sox kit. The sox kit includes both the Sox and Dasp protocol stack and depends on inet kit for the IP stack. You must have a port of the inet kit available for your platform in order to run Sox. Most often you will put an instance of the SoxService in your application. The SoxService opens a configured UDP port (default is 1876). The SoxService manages authenticating incoming sessions, handling all the sox commands, and ensuring that sessions are timed out and cleaned up properly.","title":"Sedona Framework APIs"},{"location":"networking/sox/#java-apis","text":"The open source distribution also includes a full Java implementation of the Dasp/Sox protocol stacks. These stacks include both a client and service side implementation (although typically you will only use the client side). The Java APIs are designed to \"Sedona Framework enable\" your tools and supervisor applications. The sedona.dasp package implements the lower level Dasp protocol stack. This code is cleanly separated from Sox and may be used stand alone if desired. The sedona.sox package implements the Sox protocol stack and provides a light weight Java model for Sedona Framework components. The SoxClient class provides a Sox aware wrapper around DaspSession for sending/receiving the set of sox commands. Many of the commands use SoxComponent as the Java side representation of Sedona Framework components. The SoxClient class is also used to initiate get/put file transfers. You will use these APIs if implementing your own provisioning strategy.","title":"Java APIs"},{"location":"networking/sox/#messages","text":"The following Sox message commands are defined: Id Command Description a add Add a new component to the application b fileRename Rename or move a file c readComp Read a component in the application d delete Delete an component and its children from the application e event COV event for a subscribed component f fileOpen Begin a get or put file transfer operation i invoke Invoke a component action k fileChunk Receive or send a chunk during a file transfer l link Add or delete a link n rename Rename a component o reorder Reorder a component's children q query Query installed services r readProp Read a single property from a component s subscribe Subscribe to a component for COV events u unsubscribe Unsubscribe from a component for COV events v version Query for the kits installed w write Write the value of a single component property y versionMore Query for additional version meta-data z fileClose Close a file transfer operation ! error Response id for a command that could not be processed","title":"Messages"},{"location":"networking/sox/#add","text":"The add command is used to add a new component to the application. The configProps must match the schema definition for the type. req { u1 'a' u1 replyNum u2 parentId u1 kitId u1 typeId str name val[] configProps } res { u1 'A' u1 replyNum u2 compId }","title":"add"},{"location":"networking/sox/#filerename","text":"Rename a file from one path to another path. Also see the sys::File API. req { u1 'b' u1 replyNum str from str to } res { u1 'B' u1 replyNum }","title":"fileRename"},{"location":"networking/sox/#readcomp","text":"Read a given component's state. Component state is broken up into four sections: tree: the component's id, name, parent, and children config: all the persistent properties (marked with @config facet) runtime: all the transient properties (not marked with @config facet) links: all the links to and from the component req { u1 'c' u1 replyNum u2 componentId u1 what: 't', 'c', 'r', 'l' (tree, config, runtime, links) } res { u1 'C' u1 replyNum u2 componentId compTree | compProps | compLinks } compTree { u1 't' u1 kitId u1 typeId str name u2 parent u1 permissions u1 numKids u2[numKids] kidIds } compProps { u1 'c' or 'r' for config or runtime, 'C'/'R' if operator only val[] propValues } compLinks { u1 'l' Link[] links u2 0xffff end marker }","title":"readComp"},{"location":"networking/sox/#delete","text":"Delete a component from the application. This command automatically deletes any child components as well as any links to or from the deleted components. req { u1 'd' u1 replyNum u2 compId } res { u1 'D' u1 replyNum }","title":"delete"},{"location":"networking/sox/#event","text":"The event command packages up a COV event and is pushed asynchronously from the server to client periodically for subscribed components. It uses the same component state model as readComp . Events don't have responses, but rather rely on Dasp's acknowledgements to guarantee delivery. req { u1 'e' u1 replyNum u2 componentId compTree | compProps | compLinks }","title":"event"},{"location":"networking/sox/#fileopen","text":"The fileOpen command is used to initiate a get or put file transfer. The chunk size is negotiated such that chunk messages fit within the underlying transport's packet size (for example if running over 6LoWPAN we want to fit each chunk into a single 802.15.4 packet). On a put, the fileSize is the number of bytes that will be written. On a get, the fileSize is the maximum number of bytes to read. The actual number of bytes read might be less if there are not fileSize bytes available (taking into account the size of the actual file, and the potential offset). req { u1 'f' u1 replyNum str method (\"g\" for get, \"p\" for put) str uri u4 fileSize u2 suggestedChunkSize (suggested by client) headers[] { str name str value } u1 end of headers '\\0' } res { u1 'F' u1 replyNum u4 fileSize u2 actualChunkSize headers[] { str name str value } u1 end of headers '\\0' }","title":"fileOpen"},{"location":"networking/sox/#supported-headers","text":"Name Value Method Default Description offset int get, put 0 Byte offset to use when reading/writing the uri mode w, m put w File mode to use on a put. 'w' opens the file and truncates it if the file already exists. 'm' opens the file for random access","title":"Supported Headers"},{"location":"networking/sox/#invoke","text":"Invoke an action on a component. This command can be used as an RPC mechanism. Note that the action is executed synchronously; the Sox server blocks until the action completes and returns. req { u1 'i' u1 replyNum u2 componentId u1 slotId val argument } res { u1 'I' u1 replyNum }","title":"invoke"},{"location":"networking/sox/#filechunk","text":"The fileChunk command transfers a single chunk within a file transfer operation. The same message structure is used for both get and put operations. Because Sox is run over Dasp, it is quite possible for chunks to be received out of order. req { u1 'k' u1 replyNum (ignored) u2 chunkNum u2 chunkSize u1[chunkSize] chunk }","title":"fileChunk"},{"location":"networking/sox/#link","text":"The link command is used to add or delete a link between two Component slots in the application. req { u1 'l' u1 replyNum u1 'a' | 'd' (add/delete) u2 fromCompId u1 fromSlotId u2 toCompId u1 toSlotId } res { u1 'L' u1 replyNum }","title":"link"},{"location":"networking/sox/#rename","text":"Rename is used to change a Component's name. req { u1 'n' u1 replyNum u2 compId str newName } res { u1 'N' u1 replyNum }","title":"rename"},{"location":"networking/sox/#reorder","text":"Reorder a component's child components. req { u1 'o' u1 replyNum u2 compId u1 numChildren u2[] childrenIds } res { u1 'O' u1 replyNum }","title":"reorder"},{"location":"networking/sox/#readprop","text":"Read a single property value from a component. req { u1 'r' u1 replyNum u2 compId u1 propId } res { u1 'R' u1 replyNum u1 any code var propValue }","title":"readProp"},{"location":"networking/sox/#subscribe","text":"The subscribe command allows you to subscribe to multiple components by registering for a set of change events . The subscribe command will return the number of components that were actually subscribed. This number may be less than the number of components requested if the user does not have permissions on a component, or if the component does not exist anymore You can also subscribe to all tree events (instead of subscribing to individual component tree events). In this case, the response contains no payload. req { u1 's' u1 replyNum u1 whatMask: tree=0x1 config=0x2 rt=0x4 links=0x8 0xff all tree u1 num: u2[] compIds: The ids of all the components to subscribe to } res { u1 'S' u1 replyNum u1 numSubscribed: The actual number of components that were subscribed }","title":"subscribe"},{"location":"networking/sox/#unsubscribe","text":"Unregister a subscription . The client will stop receiving change events for the set of components specified. req { u1 'u' u1 replyNum u1 whatMask: tree=0x1 config=0x2 rt=0x4 links=0x8 0xff all tree u1 num u2[] compIds } res { u1 'U' u1 replyNum }","title":"unsubscribe"},{"location":"networking/sox/#version","text":"Get the list of installed kits and their checksums, which defines the schema . versionReq { u1 'v' u1 replyNum } versionRes { u1 'V' u1 replyNum u1 kitCount kits[kitCount] { str name i4 checksum } }","title":"version"},{"location":"networking/sox/#write","text":"Set a component property value to a specific value. req { u1 'w' u1 replyNum u2 componentId u1 slotId val value } res { u1 'W' u1 replyNum }","title":"write"},{"location":"networking/sox/#versionmore","text":"Get extra version information, which includes the version of the installed kits plus platform specific name/value pairs.","title":"versionMore"},{"location":"networking/sox/#namevalue-pairs","text":"Name Value Notes soxVer Sox protocol version Introduced in build 1.0.45 (see discussion below) All builds of the Sedona Framework prior to 1.0.45 will return null for the sox protocol version. Starting in build 1.0.45 the sox protocol was changed to allow batch subscription , to components. If the sox protocol supports batch subscription, then it will return a soxVer of 1.1 (or higher). req { u1 'y' u1 replyNum } res { u1 'Y' u1 replyNum str platformId u1 scodeFlags kitVersions[kitCount] { str version } u1 pairs pairs { str key str val } }","title":"Name/Value pairs"},{"location":"networking/sox/#query","text":"Perform a query for a set of components. Currently you can only query for a service type using queryType of 's'. But the message is designed to be enhanced thru additional queryTypes. req { u1 'q' u1 replyNum u1 queryType u1[] queryReq } queryType 's': query service req-service { u1 kitId u1 typeId } res { u1 'Q' u1 replyNum u1[] queryRes } queryType 's': query service res-service { u2[num] compIds u2 0xffff end marker }","title":"query"},{"location":"networking/sox/#fileclose","text":"Terminates a file transfer operation. req { u1 'z' u1 replyNum } res { u1 'Z' u1 replyNum }","title":"fileClose"},{"location":"networking/sox/#error","text":"The error response may sent back as a response to any request. It indicates to the client that the request could not be processed. The cause of failure is returned as a short string in the message. res { u1 '!' u1 replyNum str cause }","title":"error"},{"location":"platforms/deviceSim/","text":"Device Simulator \u00b6 Overview \u00b6 A Sedona Device Simulator allows an app designed for a specific Sedona platform to run on another platform. The Simulator consists of a simulator Sedona VM plus a special scode file and platform manifest that allow the app to run as if it were on the original device. In a simulator Sedona VM, the native methods for the original platform are replaced with functions compatible with the simulator platform. The new functions may supply functionality equivalent to the originals, or they may be stubs, depending on how the simulator SVM is built. The degree to which a given Device Simulator will mimic the actual device is largely a function of the effort level put into creating it. Example : The native code for DigitalIo.gpioGet() in the SVM for a specific hardware platform reads an actual GPIO input on the device. In a simulator SVM designed to run apps for that platform on Windows, the DigitalIo.gpioGet() native table entry might simply point to a stub function that always returns 0. Or, it may point instead to an implementation that returns a calculated value that simulates a particular behavior. In either case the native function pointer is valid, and an app designed to run on the original platform should also run successfully on the simulator SVM. The Sedona compiler sedonac provides some functionality to aid in the creation of a simulator SVM. In particular, it can automatically create empty stub functions for any native methods that have not already been supplied by the developer. These source stubs can then be edited to add the desired functionality, or can simply be left as-is to create a limited (but usable) simulator SVM. Build Steps \u00b6 The following instructions will help you create a Sedona device simulator SVM for your own device. (It is usually convenient to bundle these operations into a script that can be run as needed.) Step 1 : Create a platform XML file for the simulator SVM Step 2 : Stage the Device Simulator SVM source files Step 3 : Build the simulator SVM Step 4 : Build scode for the Device Simulator Step 5 : Include an app for the Device Simulator Step 6 : Package and install the Device Simulator Step 7 : Run the Device Simulator Create platDef file \u00b6 The first step in creating a Device Simulator is setting up a simulator version of the platform XML file. By convention, the new file should have the same name as the original, with -sim inserted just before the extension. Example : the simulator version of generic-unix.xml would be generic-unix-sim.xml . Platform ID \u00b6 Inside the new XML file, the platform ID should be modified in the same way as the filename. Example : generic-unix-sim-${sedona.env.version} Simulator platform compile attributes \u00b6 Next, the attributes of the <compile> tag should modified to match the simulator platform rather than the original target platform. Example : For a Device Simulator that will run on Windows, set endian=\"little\" and blockSize=\"4\" . Native kits \u00b6 The list of <nativeKit> tags requires no modification. Native source paths \u00b6 The list of <nativeSource> tags must be modified to reflect the location of the native method implementations for the simulator platform. If any native methods are not supplied in the paths provided here, sedonac will create empty stubs for them at staging time. This is also where any simulator-specific native method implementations will be included - just provide the path to the desired source code in a <nativeSource> tag like the others. Example : to create a Device Simulator to simulate a unix platform on Windows, modify the <nativeSource> tags as follows: <nativeSource path= \"/src/sys/native/unix\" /> <nativeSource path= \"/platforms/src/generic/unix/native\" /> should become <nativeSource path= \"/src/sys/native/win32\" /> <nativeSource path= \"/platforms/src/generic/win32/native\" /> If there is a native method for the original platform that must return a specific value (or must not return 0), the developer can provide source code for a substitute that returns the desired value. The native source code file containing the substitute can be stored anywhere, as long as there is a <nativeSource> tag in the sim platform XML file that points to its location. At the other end of the simplicity spectrum, it is also possible to develop a more elaborate Device Simulator. For example one could provide a graphical representation for digital outputs on the simulator platform. The native code that generates the graphics, as well as the native method implementations that control them, would similarly be located and staged via one or more <nativeSource> tags. Tip If you are creating a device simulator for a device running Sedona 1.0 / TXS 1.1, native source must be provided for whatever methods the simulated platform uses to populate the platformId , platformVer , and memAvailable slots. These slots are often used by provisioning tools, and must have valid values for the tools to work. (Beginning with 1.2, there are native methods of sys::PlatformService so that sedonac can provide them automatically. Pre-1.2 however, they were unique to each platform.) Native patches \u00b6 Any native patches required for the Simulator SVM need to be accounted for in <nativePatch> tags. Note: The set of patches for the Device Simulator SVM may not be the same as the set for the original platform. In fact, since native patches are generally created only for SVMs that cannot be rebuilt easily, it is unlikely any will be needed in a simulator SVM. Manifest includes \u00b6 If the platform definition file uses the <manifestInclude> tag, the developer should judiciously consider whether it can remain as-is or needs to be modified for the simulator SVM. In particular, depending on how (or if) the original platform supports the Manifest Server feature then it may need to be omitted or re-implemented for the simulator. Stage source files \u00b6 When the platform XML file for the simulator SVM is complete, run sedonac on the new file using the option -stageSim . Specify the location to be used for the staging area via the -outDir option. Example : sedonac -stageSim -outDir temp generic-unix-sim.xml Sedonac will collect the files from all the <nativeSource> paths and store them in the staging area, and then scan the source code to identify any missing native method implementations. It will then create empty stubs for the missing methods. It will also create a .par folder in the staging directory to hold the platform archive (generated later), and create the platform manifest file for the simulator platform. Example : After running the above command, the directory temp has the following contents: win32> ls -A temp .par/ inet_util_std.c sys_FileStore_std.c datetimeStd_DateTimeServiceStd.c inet_util_std.h sys_File_std.c errorcodes.h main.c sys_StdOutStream_std.c inet_Crypto_sha1.c nativetable.c sys_Str.c inet_TcpServerSocket_std.c platUnix_native_stubs.c sys_Sys.c inet_TcpSocket_std.c platWin32_Win32PlatformService_win32.c sys_Sys_std.c inet_UdpSocket_std.c scode.h sys_Sys_win32.c inet_sha1.c sedona.h sys_Test.c inet_sha1.h sedonaPlatform.h sys_Type.c inet_util.h sys_Component.c vm.c And the subfolder .par contains: win32>ls -A temp/.par platformManifest.xml svm/ At this time, the source code for the Simulator's SVM is ready for building. If desired, any stub functions created by sedonac may be edited now to add functionality. Tip If you are creating a device simulator for a device running Sedona 1.0 / TXS 1.1, you will need to use sedonac.exe and sedonac.jar from a 1.2 installation for this step, since the pre-1.2 versions do not have the simulator feature. Build simulator SVM \u00b6 The next step is to compile the source code into an SVM executable. Use any toolchain that is appropriate for the simulator platform. When the executable has been created, copy it into the .par/svm folder inside the staging folder. Build scode file \u00b6 The Device Simulator requires a specially built scode file, so that the scode will run on the simulator platform. To do this, simply copy a basic scode XML file (such as one that is normally used for building scode for the original platform) and change the platform-specific parameters in the <sedonaCode> tag to match the simulator platform. This is the same as what was done earlier for the platform definition XML, e.g. to run on Windows set endian=\"little\" and blockSize=\"4\" . The list of kits requires no modifications. Run sedonac on the new scode file, and place it in .par/svm with the SVM executable. (Name it kits.scode for later convenience.) Build test app \u00b6 Finally, find or create a basic app with a schema that matches the scode built in the previous step. It does not require any modification. Simply build it and place the .sab file into .par/svm with the SVM and scode files. (Name it app.sab for later convenience.) Package and install \u00b6 Install the simulator platform into the platform database using the platArchive tool, as follows: platArchive --stage [path to .par folder] --svm --db Example : platArchive --stage temp/.par --svm --db This will also package the .par folder into a zip archive (in this example, the archive would be named tridium-generic-unix-sim-1.2.2.par ), which is a convenient way to distribute the Device Simulator with its associated files. Run Simulator \u00b6 To run the simulator SVM from the command line, simply navigate to the svm/ folder on the simulator host and run the SVM executable, e.g. svm>svm --plat kits.scode app.sab Sedona VM 2 .1.28-sim buildDate: Jan 14 2013 10 :01:34 endian: little blockSize: 4 refSize: 4 Running SVM in Platform Mode -- MESSAGE [ sys::App ] starting -- MESSAGE [ sox::SoxService ] started port = 1876 -- MESSAGE [ sox::SoxService ] DASP Discovery enabled -- MESSAGE [ sys::App ] running Make sure you are running the SVM executable in the svm/ folder, and not the one in {Sedona home}/bin . (You may need to modify your path variable to pick up the current directory first.) The simulator SVM is now running on the simulator host. It is a real Sedona VM and can be discovered and connected to by any Sox client on the same network. Any Sedona app that was designed to run on the original hardware platform should run successfully on this SVM as well. The main difference is that any native methods that are stubbed out in the simulator SVM will offer only their stubbed behavior to the app. The simulator SVM will be as realistic as the implementations of its native methods will allow. Note The svm/ folder is probably not the best location for running the simulator SVM, since it is likely just a temporary directory. This example is just a way to demonstrate the simulator SVM functionality.","title":"Device Simulator"},{"location":"platforms/deviceSim/#device-simulator","text":"","title":"Device Simulator"},{"location":"platforms/deviceSim/#overview","text":"A Sedona Device Simulator allows an app designed for a specific Sedona platform to run on another platform. The Simulator consists of a simulator Sedona VM plus a special scode file and platform manifest that allow the app to run as if it were on the original device. In a simulator Sedona VM, the native methods for the original platform are replaced with functions compatible with the simulator platform. The new functions may supply functionality equivalent to the originals, or they may be stubs, depending on how the simulator SVM is built. The degree to which a given Device Simulator will mimic the actual device is largely a function of the effort level put into creating it. Example : The native code for DigitalIo.gpioGet() in the SVM for a specific hardware platform reads an actual GPIO input on the device. In a simulator SVM designed to run apps for that platform on Windows, the DigitalIo.gpioGet() native table entry might simply point to a stub function that always returns 0. Or, it may point instead to an implementation that returns a calculated value that simulates a particular behavior. In either case the native function pointer is valid, and an app designed to run on the original platform should also run successfully on the simulator SVM. The Sedona compiler sedonac provides some functionality to aid in the creation of a simulator SVM. In particular, it can automatically create empty stub functions for any native methods that have not already been supplied by the developer. These source stubs can then be edited to add the desired functionality, or can simply be left as-is to create a limited (but usable) simulator SVM.","title":"Overview"},{"location":"platforms/deviceSim/#build-steps","text":"The following instructions will help you create a Sedona device simulator SVM for your own device. (It is usually convenient to bundle these operations into a script that can be run as needed.) Step 1 : Create a platform XML file for the simulator SVM Step 2 : Stage the Device Simulator SVM source files Step 3 : Build the simulator SVM Step 4 : Build scode for the Device Simulator Step 5 : Include an app for the Device Simulator Step 6 : Package and install the Device Simulator Step 7 : Run the Device Simulator","title":"Build Steps"},{"location":"platforms/deviceSim/#create-platdef-file","text":"The first step in creating a Device Simulator is setting up a simulator version of the platform XML file. By convention, the new file should have the same name as the original, with -sim inserted just before the extension. Example : the simulator version of generic-unix.xml would be generic-unix-sim.xml .","title":"Create platDef file"},{"location":"platforms/deviceSim/#platform-id","text":"Inside the new XML file, the platform ID should be modified in the same way as the filename. Example : generic-unix-sim-${sedona.env.version}","title":"Platform ID"},{"location":"platforms/deviceSim/#simulator-platform-compile-attributes","text":"Next, the attributes of the <compile> tag should modified to match the simulator platform rather than the original target platform. Example : For a Device Simulator that will run on Windows, set endian=\"little\" and blockSize=\"4\" .","title":"Simulator platform compile attributes"},{"location":"platforms/deviceSim/#native-kits","text":"The list of <nativeKit> tags requires no modification.","title":"Native kits"},{"location":"platforms/deviceSim/#native-source-paths","text":"The list of <nativeSource> tags must be modified to reflect the location of the native method implementations for the simulator platform. If any native methods are not supplied in the paths provided here, sedonac will create empty stubs for them at staging time. This is also where any simulator-specific native method implementations will be included - just provide the path to the desired source code in a <nativeSource> tag like the others. Example : to create a Device Simulator to simulate a unix platform on Windows, modify the <nativeSource> tags as follows: <nativeSource path= \"/src/sys/native/unix\" /> <nativeSource path= \"/platforms/src/generic/unix/native\" /> should become <nativeSource path= \"/src/sys/native/win32\" /> <nativeSource path= \"/platforms/src/generic/win32/native\" /> If there is a native method for the original platform that must return a specific value (or must not return 0), the developer can provide source code for a substitute that returns the desired value. The native source code file containing the substitute can be stored anywhere, as long as there is a <nativeSource> tag in the sim platform XML file that points to its location. At the other end of the simplicity spectrum, it is also possible to develop a more elaborate Device Simulator. For example one could provide a graphical representation for digital outputs on the simulator platform. The native code that generates the graphics, as well as the native method implementations that control them, would similarly be located and staged via one or more <nativeSource> tags. Tip If you are creating a device simulator for a device running Sedona 1.0 / TXS 1.1, native source must be provided for whatever methods the simulated platform uses to populate the platformId , platformVer , and memAvailable slots. These slots are often used by provisioning tools, and must have valid values for the tools to work. (Beginning with 1.2, there are native methods of sys::PlatformService so that sedonac can provide them automatically. Pre-1.2 however, they were unique to each platform.)","title":"Native source paths"},{"location":"platforms/deviceSim/#native-patches","text":"Any native patches required for the Simulator SVM need to be accounted for in <nativePatch> tags. Note: The set of patches for the Device Simulator SVM may not be the same as the set for the original platform. In fact, since native patches are generally created only for SVMs that cannot be rebuilt easily, it is unlikely any will be needed in a simulator SVM.","title":"Native patches"},{"location":"platforms/deviceSim/#manifest-includes","text":"If the platform definition file uses the <manifestInclude> tag, the developer should judiciously consider whether it can remain as-is or needs to be modified for the simulator SVM. In particular, depending on how (or if) the original platform supports the Manifest Server feature then it may need to be omitted or re-implemented for the simulator.","title":"Manifest includes"},{"location":"platforms/deviceSim/#stage-source-files","text":"When the platform XML file for the simulator SVM is complete, run sedonac on the new file using the option -stageSim . Specify the location to be used for the staging area via the -outDir option. Example : sedonac -stageSim -outDir temp generic-unix-sim.xml Sedonac will collect the files from all the <nativeSource> paths and store them in the staging area, and then scan the source code to identify any missing native method implementations. It will then create empty stubs for the missing methods. It will also create a .par folder in the staging directory to hold the platform archive (generated later), and create the platform manifest file for the simulator platform. Example : After running the above command, the directory temp has the following contents: win32> ls -A temp .par/ inet_util_std.c sys_FileStore_std.c datetimeStd_DateTimeServiceStd.c inet_util_std.h sys_File_std.c errorcodes.h main.c sys_StdOutStream_std.c inet_Crypto_sha1.c nativetable.c sys_Str.c inet_TcpServerSocket_std.c platUnix_native_stubs.c sys_Sys.c inet_TcpSocket_std.c platWin32_Win32PlatformService_win32.c sys_Sys_std.c inet_UdpSocket_std.c scode.h sys_Sys_win32.c inet_sha1.c sedona.h sys_Test.c inet_sha1.h sedonaPlatform.h sys_Type.c inet_util.h sys_Component.c vm.c And the subfolder .par contains: win32>ls -A temp/.par platformManifest.xml svm/ At this time, the source code for the Simulator's SVM is ready for building. If desired, any stub functions created by sedonac may be edited now to add functionality. Tip If you are creating a device simulator for a device running Sedona 1.0 / TXS 1.1, you will need to use sedonac.exe and sedonac.jar from a 1.2 installation for this step, since the pre-1.2 versions do not have the simulator feature.","title":"Stage source files"},{"location":"platforms/deviceSim/#build-simulator-svm","text":"The next step is to compile the source code into an SVM executable. Use any toolchain that is appropriate for the simulator platform. When the executable has been created, copy it into the .par/svm folder inside the staging folder.","title":"Build simulator SVM"},{"location":"platforms/deviceSim/#build-scode-file","text":"The Device Simulator requires a specially built scode file, so that the scode will run on the simulator platform. To do this, simply copy a basic scode XML file (such as one that is normally used for building scode for the original platform) and change the platform-specific parameters in the <sedonaCode> tag to match the simulator platform. This is the same as what was done earlier for the platform definition XML, e.g. to run on Windows set endian=\"little\" and blockSize=\"4\" . The list of kits requires no modifications. Run sedonac on the new scode file, and place it in .par/svm with the SVM executable. (Name it kits.scode for later convenience.)","title":"Build scode file"},{"location":"platforms/deviceSim/#build-test-app","text":"Finally, find or create a basic app with a schema that matches the scode built in the previous step. It does not require any modification. Simply build it and place the .sab file into .par/svm with the SVM and scode files. (Name it app.sab for later convenience.)","title":"Build test app"},{"location":"platforms/deviceSim/#package-and-install","text":"Install the simulator platform into the platform database using the platArchive tool, as follows: platArchive --stage [path to .par folder] --svm --db Example : platArchive --stage temp/.par --svm --db This will also package the .par folder into a zip archive (in this example, the archive would be named tridium-generic-unix-sim-1.2.2.par ), which is a convenient way to distribute the Device Simulator with its associated files.","title":"Package and install"},{"location":"platforms/deviceSim/#run-simulator","text":"To run the simulator SVM from the command line, simply navigate to the svm/ folder on the simulator host and run the SVM executable, e.g. svm>svm --plat kits.scode app.sab Sedona VM 2 .1.28-sim buildDate: Jan 14 2013 10 :01:34 endian: little blockSize: 4 refSize: 4 Running SVM in Platform Mode -- MESSAGE [ sys::App ] starting -- MESSAGE [ sox::SoxService ] started port = 1876 -- MESSAGE [ sox::SoxService ] DASP Discovery enabled -- MESSAGE [ sys::App ] running Make sure you are running the SVM executable in the svm/ folder, and not the one in {Sedona home}/bin . (You may need to modify your path variable to pick up the current directory first.) The simulator SVM is now running on the simulator host. It is a real Sedona VM and can be discovered and connected to by any Sox client on the same network. Any Sedona app that was designed to run on the original hardware platform should run successfully on this SVM as well. The main difference is that any native methods that are stubbed out in the simulator SVM will offer only their stubbed behavior to the app. The simulator SVM will be as realistic as the implementations of its native methods will allow. Note The svm/ folder is probably not the best location for running the simulator SVM, since it is likely just a temporary directory. This example is just a way to demonstrate the simulator SVM functionality.","title":"Run Simulator"},{"location":"platforms/par/","text":"Platform Archive \u00b6 PAR file \u00b6 A Platform Archive, or PAR file, provides a way of organizing various files and metadata about a platform into a single entity. A PAR file is a zip file with a .par extension. All paths and filenames within the PAR file are reserved by the Sedona Framework, except the vendor folder where vendor-specific files may be stored. The following filenames and paths are currently defined by the Sedona Framework: <myplatform>.par/ /platformManifest.xml /svm/<svm binary> /vendor/* platformManifest.xml : (required) Must be in the root of the PAR file. If the PAR file does not have a platformManifest.xml, then it is not a valid PAR file. Invalid PAR files will not be accepted by the sedonadev.org database. In addition, the manifest must set the id attribute to match the platform id. svm/<svm binary> : (optional) If you wish to package the svm binary for the platform, it should be placed in the /svm directory. It can have any name, as long as it does not have one of the scode or app extensions: xml , scode , sax , or sab . An scode and app file may also be included in this directory with the svm. vendor/ : (optional) The vendor may put any arbitrary contents in this location. The PAR file may have any name, but it must have a .par extension. The PAR file should be created as part of the vendor's build toolchain. sedonac will facilitate this by staging the platform manifest in stageDir.par , but ultimately each vendor must create the full contents of the PAR. You should create a PAR file if you want information about a platform to be available to Sedona Framework tools, or if you want to submit your platform for Sedona Framework certification. If a vendor is registered with sedonadev.org, the PAR file can be uploaded to sedonadev.org so that tools can retrieve them based on the platform id returned by the platform service running in the app. Platform Database \u00b6 When PAR files are stored locally, they are stored in the platform database. The platform database resides on the local filesystem at sedona_home/platforms/db/ When a PAR file is stored in the platform database, it is unzipped and stored in a directory called .par . The location of this directory is based on the platform id specified in the platform manifest. The platform database interprets every '-' character in the platform id as a directory separator. For example, if the platform id is acme-basicPlatform-win32-1.0.38 the unzipped PAR file contents can be found in the platform database at sedona_home/platforms/db/ +- acme/ | +- basicPlatform/ | | +- win32/ | | | +- .par/ | | | | +- platformManifest.xml | | | +- 1.0.37/ | | | +- 1.0.38/ | | | | +- .par/ | | | | | +- platformManifest.xml | | | | | +- svm/ | | | | | | +- <svm binary> +- tridium/ | +- <etc> You can use the sedona_home/adm/platformdb.py script to view and administrate your local platform database. When looking up a platform manifest or SVM for a given platform id, the platform database will use a \"best match\" algorithm. It begins by looking for a platform with the exact same id. If one cannot be found, it \"backs up\" one directory level in the platform database and searches for a platform manifest there. If one still cannot be found, it backs up again until it hits the root directory of the platform database, or finds a platform manifest. For example, suppose the platform database looks like the example above. If a Sedona Framework tool requests the platform manifest for a platform with id acme-basicPlatform-win32-1.0.39 , the sedona_home/platforms/db/acme/basicPlatform/win32/.par/platformManifest.xml manifest is the best match. Note The Sedona Framework API contains a PlatformDb object in sedona.jar for working with the local platform database. See sedona.PlatformDb .","title":"Platform Archive"},{"location":"platforms/par/#platform-archive","text":"","title":"Platform Archive"},{"location":"platforms/par/#par-file","text":"A Platform Archive, or PAR file, provides a way of organizing various files and metadata about a platform into a single entity. A PAR file is a zip file with a .par extension. All paths and filenames within the PAR file are reserved by the Sedona Framework, except the vendor folder where vendor-specific files may be stored. The following filenames and paths are currently defined by the Sedona Framework: <myplatform>.par/ /platformManifest.xml /svm/<svm binary> /vendor/* platformManifest.xml : (required) Must be in the root of the PAR file. If the PAR file does not have a platformManifest.xml, then it is not a valid PAR file. Invalid PAR files will not be accepted by the sedonadev.org database. In addition, the manifest must set the id attribute to match the platform id. svm/<svm binary> : (optional) If you wish to package the svm binary for the platform, it should be placed in the /svm directory. It can have any name, as long as it does not have one of the scode or app extensions: xml , scode , sax , or sab . An scode and app file may also be included in this directory with the svm. vendor/ : (optional) The vendor may put any arbitrary contents in this location. The PAR file may have any name, but it must have a .par extension. The PAR file should be created as part of the vendor's build toolchain. sedonac will facilitate this by staging the platform manifest in stageDir.par , but ultimately each vendor must create the full contents of the PAR. You should create a PAR file if you want information about a platform to be available to Sedona Framework tools, or if you want to submit your platform for Sedona Framework certification. If a vendor is registered with sedonadev.org, the PAR file can be uploaded to sedonadev.org so that tools can retrieve them based on the platform id returned by the platform service running in the app.","title":"PAR file"},{"location":"platforms/par/#platform-database","text":"When PAR files are stored locally, they are stored in the platform database. The platform database resides on the local filesystem at sedona_home/platforms/db/ When a PAR file is stored in the platform database, it is unzipped and stored in a directory called .par . The location of this directory is based on the platform id specified in the platform manifest. The platform database interprets every '-' character in the platform id as a directory separator. For example, if the platform id is acme-basicPlatform-win32-1.0.38 the unzipped PAR file contents can be found in the platform database at sedona_home/platforms/db/ +- acme/ | +- basicPlatform/ | | +- win32/ | | | +- .par/ | | | | +- platformManifest.xml | | | +- 1.0.37/ | | | +- 1.0.38/ | | | | +- .par/ | | | | | +- platformManifest.xml | | | | | +- svm/ | | | | | | +- <svm binary> +- tridium/ | +- <etc> You can use the sedona_home/adm/platformdb.py script to view and administrate your local platform database. When looking up a platform manifest or SVM for a given platform id, the platform database will use a \"best match\" algorithm. It begins by looking for a platform with the exact same id. If one cannot be found, it \"backs up\" one directory level in the platform database and searches for a platform manifest there. If one still cannot be found, it backs up again until it hits the root directory of the platform database, or finds a platform manifest. For example, suppose the platform database looks like the example above. If a Sedona Framework tool requests the platform manifest for a platform with id acme-basicPlatform-win32-1.0.39 , the sedona_home/platforms/db/acme/basicPlatform/win32/.par/platformManifest.xml manifest is the best match. Note The Sedona Framework API contains a PlatformDb object in sedona.jar for working with the local platform database. See sedona.PlatformDb .","title":"Platform Database"},{"location":"platforms/platCertified/","text":"Certified Platforms \u00b6 Info Given that Tridium no longer supports Sedona directly, the certification program may have been discontinued. This page is preserved for historical reasons only. Please check Sedona Alliance for background. Overview \u00b6 One of the steps involved in getting your platform Sedona Framework certified is that it must pass all tests when run against the sedonacert test suite. The sedonacert program verifies that 1) your platform is compliant with the Sox protocol and 2) your platform can be provisioned in a standard way. In order for your platform to pass the tests for provisioning, it must implement the following requirements: Requirements \u00b6 App and Scode naming requirements \u00b6 a Sox get file request for a file with URI app.sab must return the currently running app.sab file. a Sox get file request for a file with URI kits.scode must return the currently running kits.scode file. Standard provisioning process requirements \u00b6 A Sox client must be able to provision a new app.sab and kits.scode on your device by executing these steps: Write the new app.sab with URI app.sab.writing using a Sox put file request. Write the new kits.scode with URI kits.scode.writing using a Sox put file request. Rename URI app.sab.writing to URI app.sab.stage using a Sox file rename request. Rename URI kits.scode.writing to URI kits.scode.stage using a Sox file rename request. Invoke the restart() action on the device's platform service to restart the SVM. When the SVM restarts, it must use the newly staged app and scode files to run the application. See the section on bootstrapping for more details.","title":"Certified Platforms"},{"location":"platforms/platCertified/#certified-platforms","text":"Info Given that Tridium no longer supports Sedona directly, the certification program may have been discontinued. This page is preserved for historical reasons only. Please check Sedona Alliance for background.","title":"Certified Platforms"},{"location":"platforms/platCertified/#overview","text":"One of the steps involved in getting your platform Sedona Framework certified is that it must pass all tests when run against the sedonacert test suite. The sedonacert program verifies that 1) your platform is compliant with the Sox protocol and 2) your platform can be provisioned in a standard way. In order for your platform to pass the tests for provisioning, it must implement the following requirements:","title":"Overview"},{"location":"platforms/platCertified/#requirements","text":"","title":"Requirements"},{"location":"platforms/platCertified/#app-and-scode-naming-requirements","text":"a Sox get file request for a file with URI app.sab must return the currently running app.sab file. a Sox get file request for a file with URI kits.scode must return the currently running kits.scode file.","title":"App and Scode naming requirements"},{"location":"platforms/platCertified/#standard-provisioning-process-requirements","text":"A Sox client must be able to provision a new app.sab and kits.scode on your device by executing these steps: Write the new app.sab with URI app.sab.writing using a Sox put file request. Write the new kits.scode with URI kits.scode.writing using a Sox put file request. Rename URI app.sab.writing to URI app.sab.stage using a Sox file rename request. Rename URI kits.scode.writing to URI kits.scode.stage using a Sox file rename request. Invoke the restart() action on the device's platform service to restart the SVM. When the SVM restarts, it must use the newly staged app and scode files to run the application. See the section on bootstrapping for more details.","title":"Standard provisioning process requirements"},{"location":"platforms/platDef/","text":"Platform Definition \u00b6 Overview \u00b6 One of Sedona Framework's strengths is the portability of Sedona apps across different hardware platforms. This is accomplished by building a custom version of the SVM for each supported platform, tailored to the specific underlying architecture. Details on the customization of the SVM will be covered in the Porting chapter. Here we cover how that process is streamlined, by encapsulating platform-specific information into a platform definition file. When you run sedonac on a platform definition file, it will do the following: Stage the native method source code so that a native toolchain can be used to build the SVM. Produce a platform manifest and stage it for later packaging into a PAR file . Note sedonac does not actually build the SVM, it merely stages the native source files for convenient building with the native toolchain. See the Staging section for more details about how sedonac uses the platform definition to stage native source code and the platform manifest. Platform Definition XML \u00b6 The platform definition file is an XML file created by a Sedona platform developer. It serves three major purposes: Specifies a unique platform id that will be reported by platforms using this SVM. Declares properties needed for building the SVM, such as endianness, block size, and pointer size. If you want your SVM to support a kit that contains native methods, you must declare that dependency as well, and specify the location of the source code for the native methods . Declares arbitrary metadata about the platform. Sedona Framework tools can use this metadata to enhance the experience of working with a specific platform. The following is an example platform definition file for a win32 platform. <sedonaPlatform vendor= \"Acme\" id= \"acme-basicPlatform-win32-${sedona.env.version}\" > <compile endian= \"little\" blockSize= \"4\" refSize= \"4\" debug= \"true\" test= \"true\" > <!-- Native Kits --> <nativeKit depend= \"sys 1.0\" /> <nativeKit depend= \"inet 1.0\" /> <nativeKit depend= \"datetimeStd 1.0\" /> <nativeKit depend= \"acmePlatform 1.0\" /> <!-- Native Sources --> <nativeSource path= \"/src/vm\" /> <nativeSource path= \"/src/sys/native\" /> <nativeSource path= \"/src/sys/native/std\" /> <nativeSource path= \"/src/sys/native/win32\" /> <nativeSource path= \"/src/inet/native\" /> <nativeSource path= \"/src/inet/native/std\" /> <nativeSource path= \"/src/inet/native/sha1\" /> <nativeSource path= \"/src/datetimeStd/native/std\" /> <nativeSource path= \"/../acme/src/platforms/acmePlatform/native/win32\" /> </compile> <manifestInclude path= \"more_metadata.xml\" /> <manifestInclude> <contact email= \"jdoe@acme.com\" url= \"http://www.acme.com/sedona/help.html\" /> <schemes> <!-- this platform implements the manifest transfer scheme \"m:\" --> <scheme id= \"m\" /> </schemes> </manifestInclude> </sedonaPlatform> <sedonaPlatform> top level element for the platform definition: vendor : (required) The vendor owning this platform. id : (optional)The id that uniquely identifies this platform. This id must be prefixed with the string \" vendor- \". In the example above the vendor is \"Acme\" and the id is prefixed with \"acme-\". sedonac will generate a C header file sedonaPlatform.h in the stage directory containing a macro PLATFORM_ID with the value of the resolved id. The resolved platform id must be returned by the corresponding platform's implementation of sys::PlatformService.platformId() . The generated header file is intended to help facilitate this. The platform id can generally have any format, but the '-' character in the platform id will be interpreted as a directory separator when storing the PAR file for that platform into the platform database. See the section on the Platform Database for more details. If the id is omitted, no sedonaPlatform.h will be generated, and the platform manifest generated by sedonac will not contain an id. The platform manifest is not valid when an id is missing. That is, a PAR file containing a platform manifest with no id will be rejected by sedonadev.org when an upload is attempted. It becomes the responsibility of the build toolchain to insert the appropriate id attribute into the platform manifest before generating a PAR file. For this reason, it is better to try and specify an id variable pattern in your platform definition. This attribute supports variable substitution . There are a number of variables that sedonac will recognize when compiling a platform definition. These two are the most commonly used: ${stage.nativeChecksum} : sedonac will calculate a native checksum for all native methods that are supported by this platform SVM. This variable represents that checksum value. Note This is NOT the same as a kit checksum . Kit checksums are used for checking component-level compatibility when connecting to a Sedona device. The native checksum is used when provisioning a device, to check native compatibility of a kit on a given platform; if the SVM doesn't support the kit's native methods then the kit shouldn't be loaded on that device. ${sedona.env.version} : sedonac will look up the value of the environment variable sedona.env.version and substitute it wherever it occurs in the platform definition XML. See the section on Variable Substitution for other variables sedonac will recognize. <compile> provides platform-specific parameters: endian : (required) either \"little\" or \"big\" based on target processor. blockSize : (required) size of a scode block in bytes (see the source for src/vm/sedona.h ) refSize : (required) size of a memory pointer in bytes for target processor (4 for 32-bit processor). debug : (optional) boolean to include debug meta-data in image. Defaults to false test : (optional) boolean to include test code in image. Defaults to false armDouble : (optional) set to true if using an ARM microprocessor where 64-bit doubles are stored using byte level little endian, word level big endian. <nativeKit> indicates that this platform SVM implements the native methods from the specified kit. depend : (required) dependency as a kit name and version constraint. <nativeSource> designates a source path to native code: path : (required) path to a folder with native code that must be built into the SVM image. The path must start with \"/\" and be relative to sedona_home . This attribute supports variable substitution . <manifestInclude> (optional) is used to include arbitrary XML metadata in the generated platform manifest file. All XML elements that are children of the manifest include will be copied into the platform manifest. Note All XML namespace URIs that begin with http://sedonadev.org/ns are reserved by the Sedona Framework. Vendor specific XML elements should not use any such namespace URI. path : (optional) specifies the path to an external XML file to be included. The entire XML contents of that file will be copied into the platform manifest. (This could be used to include time-varying metadata into a platform definition file that stays fixed, or to include common metadata, such as contact info, shared by several related platforms.) If the path starts with \"/\" then the path is relative to sedona_home . Otherwise, the path is relative to the directory containing the platform definition. <schemes> (optional) The schemes child of the manifest include can be used to explicitly declare what schemes the platform supports. Each implemented scheme has the format <scheme id=\"scheme\"/> . See the examples below for more details. Platform Manifest \u00b6 In addition to staging the native source code, sedonac will stage a platform manifest XML file. This file will eventually be packaged into a PAR file for upload to sedonadev.org or installation into the local platform database. The following is an abridged version of the platformManifest.xml that might be generated for the platform definition above. <?xml version='1.0'?> <platformManifest platformId= \"acme-basicPlatform-win32-1.0.38\" vendor= \"Acme\" endian= \"little\" blockSize= \"4\" refSize= \"4\" armDouble= \"false\" debug= \"true\" test= \"true\" > <!-- Natives --> <natives> <nativeKit depend= \"sys 1.0\" /> <nativeKit depend= \"inet 1.0\" /> <nativeKit depend= \"datetimeStd 1.0\" /> <nativeKit depend= \"acmeBasicPlatform 1.0\" /> <nativeMethod qname= \"sys::Sys.platformType\" id= \"0::0\" /> <nativeMethod qname= \"sys::Sys.copy\" id= \"0::1\" /> <!-- ... --> <nativeMethod qname= \"acmeBasicPlatform::BasicPlatform.doPlatformId\" id= \"1::0\" /> <nativeMethod qname= \"inet::TcpSocket.connect\" id= \"2::0\" /> <nativeMethod qname= \"inet::TcpSocket.finishConnect\" id= \"2::1\" /> <!-- ... --> </natives> <!-- Manifest Includes --> <manifestIncludes> <metadata foo= \"bar\" /> <contact email= \"jdoe@acme.com\" url= \"http://www.acme.com/sedona/help.html\" /> <schemes> <!-- this platform implements the manifest transfer scheme --> <!-- If the packed attribute is 'true' (default), then all the kit manifests will be sent in a single zip file. If the packed attribute is anything else then each manifest will be zipped and sent one at a time.--> <scheme id= \"m\" packed= \"true\" /> </schemes> </manifestIncludes> </platformManifest> <platformManifest> top level element for the platform manifest. It contains all attributes from the platform definition root element and <compile> element. The id is the resolved platform id. Note The qname attribute of the <nativeMethod> is for reference - tools should typically compare scode compatibility with a given platform SVM by comparing the native method id, not the qname . <manifestIncludes> this element contains all the manifest include XML from the platform definition.","title":"Platform Definition"},{"location":"platforms/platDef/#platform-definition","text":"","title":"Platform Definition"},{"location":"platforms/platDef/#overview","text":"One of Sedona Framework's strengths is the portability of Sedona apps across different hardware platforms. This is accomplished by building a custom version of the SVM for each supported platform, tailored to the specific underlying architecture. Details on the customization of the SVM will be covered in the Porting chapter. Here we cover how that process is streamlined, by encapsulating platform-specific information into a platform definition file. When you run sedonac on a platform definition file, it will do the following: Stage the native method source code so that a native toolchain can be used to build the SVM. Produce a platform manifest and stage it for later packaging into a PAR file . Note sedonac does not actually build the SVM, it merely stages the native source files for convenient building with the native toolchain. See the Staging section for more details about how sedonac uses the platform definition to stage native source code and the platform manifest.","title":"Overview"},{"location":"platforms/platDef/#platform-definition-xml","text":"The platform definition file is an XML file created by a Sedona platform developer. It serves three major purposes: Specifies a unique platform id that will be reported by platforms using this SVM. Declares properties needed for building the SVM, such as endianness, block size, and pointer size. If you want your SVM to support a kit that contains native methods, you must declare that dependency as well, and specify the location of the source code for the native methods . Declares arbitrary metadata about the platform. Sedona Framework tools can use this metadata to enhance the experience of working with a specific platform. The following is an example platform definition file for a win32 platform. <sedonaPlatform vendor= \"Acme\" id= \"acme-basicPlatform-win32-${sedona.env.version}\" > <compile endian= \"little\" blockSize= \"4\" refSize= \"4\" debug= \"true\" test= \"true\" > <!-- Native Kits --> <nativeKit depend= \"sys 1.0\" /> <nativeKit depend= \"inet 1.0\" /> <nativeKit depend= \"datetimeStd 1.0\" /> <nativeKit depend= \"acmePlatform 1.0\" /> <!-- Native Sources --> <nativeSource path= \"/src/vm\" /> <nativeSource path= \"/src/sys/native\" /> <nativeSource path= \"/src/sys/native/std\" /> <nativeSource path= \"/src/sys/native/win32\" /> <nativeSource path= \"/src/inet/native\" /> <nativeSource path= \"/src/inet/native/std\" /> <nativeSource path= \"/src/inet/native/sha1\" /> <nativeSource path= \"/src/datetimeStd/native/std\" /> <nativeSource path= \"/../acme/src/platforms/acmePlatform/native/win32\" /> </compile> <manifestInclude path= \"more_metadata.xml\" /> <manifestInclude> <contact email= \"jdoe@acme.com\" url= \"http://www.acme.com/sedona/help.html\" /> <schemes> <!-- this platform implements the manifest transfer scheme \"m:\" --> <scheme id= \"m\" /> </schemes> </manifestInclude> </sedonaPlatform> <sedonaPlatform> top level element for the platform definition: vendor : (required) The vendor owning this platform. id : (optional)The id that uniquely identifies this platform. This id must be prefixed with the string \" vendor- \". In the example above the vendor is \"Acme\" and the id is prefixed with \"acme-\". sedonac will generate a C header file sedonaPlatform.h in the stage directory containing a macro PLATFORM_ID with the value of the resolved id. The resolved platform id must be returned by the corresponding platform's implementation of sys::PlatformService.platformId() . The generated header file is intended to help facilitate this. The platform id can generally have any format, but the '-' character in the platform id will be interpreted as a directory separator when storing the PAR file for that platform into the platform database. See the section on the Platform Database for more details. If the id is omitted, no sedonaPlatform.h will be generated, and the platform manifest generated by sedonac will not contain an id. The platform manifest is not valid when an id is missing. That is, a PAR file containing a platform manifest with no id will be rejected by sedonadev.org when an upload is attempted. It becomes the responsibility of the build toolchain to insert the appropriate id attribute into the platform manifest before generating a PAR file. For this reason, it is better to try and specify an id variable pattern in your platform definition. This attribute supports variable substitution . There are a number of variables that sedonac will recognize when compiling a platform definition. These two are the most commonly used: ${stage.nativeChecksum} : sedonac will calculate a native checksum for all native methods that are supported by this platform SVM. This variable represents that checksum value. Note This is NOT the same as a kit checksum . Kit checksums are used for checking component-level compatibility when connecting to a Sedona device. The native checksum is used when provisioning a device, to check native compatibility of a kit on a given platform; if the SVM doesn't support the kit's native methods then the kit shouldn't be loaded on that device. ${sedona.env.version} : sedonac will look up the value of the environment variable sedona.env.version and substitute it wherever it occurs in the platform definition XML. See the section on Variable Substitution for other variables sedonac will recognize. <compile> provides platform-specific parameters: endian : (required) either \"little\" or \"big\" based on target processor. blockSize : (required) size of a scode block in bytes (see the source for src/vm/sedona.h ) refSize : (required) size of a memory pointer in bytes for target processor (4 for 32-bit processor). debug : (optional) boolean to include debug meta-data in image. Defaults to false test : (optional) boolean to include test code in image. Defaults to false armDouble : (optional) set to true if using an ARM microprocessor where 64-bit doubles are stored using byte level little endian, word level big endian. <nativeKit> indicates that this platform SVM implements the native methods from the specified kit. depend : (required) dependency as a kit name and version constraint. <nativeSource> designates a source path to native code: path : (required) path to a folder with native code that must be built into the SVM image. The path must start with \"/\" and be relative to sedona_home . This attribute supports variable substitution . <manifestInclude> (optional) is used to include arbitrary XML metadata in the generated platform manifest file. All XML elements that are children of the manifest include will be copied into the platform manifest. Note All XML namespace URIs that begin with http://sedonadev.org/ns are reserved by the Sedona Framework. Vendor specific XML elements should not use any such namespace URI. path : (optional) specifies the path to an external XML file to be included. The entire XML contents of that file will be copied into the platform manifest. (This could be used to include time-varying metadata into a platform definition file that stays fixed, or to include common metadata, such as contact info, shared by several related platforms.) If the path starts with \"/\" then the path is relative to sedona_home . Otherwise, the path is relative to the directory containing the platform definition. <schemes> (optional) The schemes child of the manifest include can be used to explicitly declare what schemes the platform supports. Each implemented scheme has the format <scheme id=\"scheme\"/> . See the examples below for more details.","title":"Platform Definition XML"},{"location":"platforms/platDef/#platform-manifest","text":"In addition to staging the native source code, sedonac will stage a platform manifest XML file. This file will eventually be packaged into a PAR file for upload to sedonadev.org or installation into the local platform database. The following is an abridged version of the platformManifest.xml that might be generated for the platform definition above. <?xml version='1.0'?> <platformManifest platformId= \"acme-basicPlatform-win32-1.0.38\" vendor= \"Acme\" endian= \"little\" blockSize= \"4\" refSize= \"4\" armDouble= \"false\" debug= \"true\" test= \"true\" > <!-- Natives --> <natives> <nativeKit depend= \"sys 1.0\" /> <nativeKit depend= \"inet 1.0\" /> <nativeKit depend= \"datetimeStd 1.0\" /> <nativeKit depend= \"acmeBasicPlatform 1.0\" /> <nativeMethod qname= \"sys::Sys.platformType\" id= \"0::0\" /> <nativeMethod qname= \"sys::Sys.copy\" id= \"0::1\" /> <!-- ... --> <nativeMethod qname= \"acmeBasicPlatform::BasicPlatform.doPlatformId\" id= \"1::0\" /> <nativeMethod qname= \"inet::TcpSocket.connect\" id= \"2::0\" /> <nativeMethod qname= \"inet::TcpSocket.finishConnect\" id= \"2::1\" /> <!-- ... --> </natives> <!-- Manifest Includes --> <manifestIncludes> <metadata foo= \"bar\" /> <contact email= \"jdoe@acme.com\" url= \"http://www.acme.com/sedona/help.html\" /> <schemes> <!-- this platform implements the manifest transfer scheme --> <!-- If the packed attribute is 'true' (default), then all the kit manifests will be sent in a single zip file. If the packed attribute is anything else then each manifest will be zipped and sent one at a time.--> <scheme id= \"m\" packed= \"true\" /> </schemes> </manifestIncludes> </platformManifest> <platformManifest> top level element for the platform manifest. It contains all attributes from the platform definition root element and <compile> element. The id is the resolved platform id. Note The qname attribute of the <nativeMethod> is for reference - tools should typically compare scode compatibility with a given platform SVM by comparing the native method id, not the qname . <manifestIncludes> this element contains all the manifest include XML from the platform definition.","title":"Platform Manifest"},{"location":"platforms/platTutorial/","text":"Platform Tutorial \u00b6 Introduction \u00b6 A Sedona Framework platform is simply any device running an SVM. The platform is uniquely identified by the platformId property of the platform service running in the app on that device. This section presents a high-level, step-by-step guide to creating a Sedona Framework platform for your own device. We will use the Win32 platform provided in the open source distribution as a case study in creating a new Sedona Framework platform. Step 1: Create a kit for your platform service Step 2: Implement PlatformService native methods Step 3: Create a platform definition file Step 4: Port the SVM Step 5: Build the SVM Step 6: Create a PAR file Step 7: SAX and Scode setup for your platform Create Kit \u00b6 Every app must have a sys::PlatformService component running in it. A platform service encapsulates the behavior of that specific OS/Hardware platform. The sys::PlatformService class itself is generic, so some key methods do nothing. To implement a real Sedona platform, it must be subclassed so that platform-specific behavior can be implemented. The first step in porting Sedona to a new platform is the creation of a PlatformService subclass for the platform. As an example, the win32 platform service is defined in a kit called \"platWin32\" and the kit definition file is in sedona_home/platforms/src/generic/win32/kit.xml Implement Native Methods \u00b6 The base class sys::PlatformService defines three native methods that must be implemented for every platform. They are called by PlatformService as needed to populate the corresponding properties. doPlatformId() : returns platform ID string getPlatVersion() : returns platform version string getNativeMemAvailable() : returns number of bytes of physical memory available The open source includes win32 natives as an example, see sedona_home/src/sys/native/win32 . doPlatformId() \u00b6 One of the most important properties on the platform service is the platformId property. This property uniquely identifies your platform, and maps to a platform manifest stored in the platform database. The native method doPlatformId() provides a means for Sedona to access this native property. The native implementation of doPlatformId() for the win32 platform is #include \"sedona.h\" #include \"sedonaPlatform.h\" #include <windows.h> // Str PlatformService.doPlatformId() Cell sys_PlatformService_doPlatformId(SedonaVM* vm, Cell* params) { Cell result; result.aval = PLATFORM_ID; return result; } The value of PLATFORM_ID is defined in the header file sedonaPlatform.h , which is generated automatically from the platform definition XML file. So the next step is to create one. Create platDef file \u00b6 Please refer to the section on platform definition for an in depth discussion of this file and all its sections and attributes. The platform definition for the win32 platform is located in sedona_home/platforms/src/generic/win32/generic-win32.xml . (This file can be located anywhere, but the convention is to put it under sedona_home/platforms/src/ .) <sedonaPlatform vendor= \"Tridium\" id= \"tridium-generic-win32-${sedona.env.version}\" > <compile endian= \"little\" blockSize= \"4\" refSize= \"4\" debug= \"true\" test= \"true\" > <!-- Native Kits --> <nativeKit depend= \"sys 1.0\" /> <nativeKit depend= \"inet 1.0\" /> <nativeKit depend= \"datetimeStd 1.0\" /> <nativeKit depend= \"platWin32 1.0\" /> <!-- Native Sources --> <nativeSource path= \"/src/vm\" /> <nativeSource path= \"/src/sys/native\" /> <nativeSource path= \"/src/sys/native/std\" /> <nativeSource path= \"/src/sys/native/win32\" /> <nativeSource path= \"/src/inet/native\" /> <nativeSource path= \"/src/inet/native/std\" /> <nativeSource path= \"/src/inet/native/sha1\" /> <nativeSource path= \"/src/datetimeStd/native/std\" /> <nativeSource path= \"/platforms/src/generic/win32/native\" /> </compile> </sedonaPlatform> There are a few things to note about this platform definition. It specifies the id attribute for the platform. Later, when we run sedonac on this file to stage the source, it will generate the header file sedonaPlatform.h based on this file. That header file will contain the PLATFORM_ID definition required by the doPlatformId() native code. The SVM created from this platform definition will only support the native methods from the sys, inet, datetimeStd, and platWin32 kits because those are the only kits included in <nativeKit> declarations. In order to support other kits with native methods, they will have to be added to the platform definition. Port SVM \u00b6 This process is already described in detail in the porting section. We specified in the platform definition file where all the native source code is located. If the native source file locations change at any time during the platform development process, the platform definition will need to be updated accordingly. Refer to the win32 platform definition to see where all the native code for the win32 SVM resides. Build SVM \u00b6 Once the native source code is written and the platform definition file is correct, we are ready to build the SVM. As described in the staging section, we use sedonac to stage all native source files in one directory. Then we use the appropriate native tool-chain to actually build the SVM. The open source distribution includes a makewinvm.py script that will build the win32 platform SVM. It runs sedonac on the generic-win32.xml platform definition file to stage all the source code for the SVM, and then it compiles the source code into a binary. This is the same svm.exe that appears in the bin/ directory of the open source distribution. To run makewinvm.py you must first have set up your environment for Windows 32-bit development. You must provide your own native tool-chain to accomplish the same tasks for a different platform. Create PAR file \u00b6 Refer to the section on PAR files for a more in-depth discussion on PAR files. When we staged the native source by running sedonac on the platform definition file, it also created a .par/ directory containing a valid platformManifest.xml file for the platform. Therefore, all we need to do is zip up the contents of that directory and use the platformdb.py script to install it in our platform database. The makewinvm.py script does the database installation step automatically for the open source win32 platform. If you issue the platformdb.py --list command you should see output similar to the following sedona> platformdb.py --list tridium-generic-win32-1.0.46 This output indicates that the we have successfully installed the win32 platform into the platform database. The toolchain steps you perform for another platform will need to do the same thing for that platform. You can use the platformdb -i <par file> command to install a PAR file into the platform database. Note The path within the platform database where the .par folder will be located must match the platform ID exactly. For example, the win32 platform definition file defines the platform ID as tridium-generic-win32-${sedona.env.version} . When we ran sedonac on the platform definition file it substituted an actual version number, so the resulting platform manifest file contains a specific definition, for example tridium-generic-win32-1.2.29 . Sedona would then expect to find the manifest file for this platform in the platform database under sedona_home/platforms/db/tridium/generic/win32/1.2.29/.par/ . Test Platform \u00b6 To use your new platform service, you will need to create an application (SAX) that uses your platform service. There is an example SAX file that uses the Win32PlatformService at sedona_home/apps/platWin32.sax . You can use this file as a template and make the following modifications to use it for your platform: In the <schema> section, remove the platWin32 kit and add the kit for your platform service. In the <app> section there is a component called \"plat\". Change the type of that component from \"platWin32::Win32PlatformService\" to the type of your platform service. After you have made these changes you can run sedonac on your new SAX file to create an binary application (SAB) that your SVM can run. Finally, you will need to create a scode image corresponding to the kits in your SAX. There is an example scode configuration file in sedona_home/scode/platWin32.xml . You can use this file as a template and make the following modifications for your platform: Modify the <sedonaCode> elements to match the settings for your device. For example, make sure the blockSize, refSize, endian, etc. are correct. Remove the dependency on \"platWin32 1.0\" and add a dependency for the kit containing your platform service. After you have made these changes you an run sedonac on your new scode XML file to produce an scode image that your SVM can run.","title":"Platform Tutorial"},{"location":"platforms/platTutorial/#platform-tutorial","text":"","title":"Platform Tutorial"},{"location":"platforms/platTutorial/#introduction","text":"A Sedona Framework platform is simply any device running an SVM. The platform is uniquely identified by the platformId property of the platform service running in the app on that device. This section presents a high-level, step-by-step guide to creating a Sedona Framework platform for your own device. We will use the Win32 platform provided in the open source distribution as a case study in creating a new Sedona Framework platform. Step 1: Create a kit for your platform service Step 2: Implement PlatformService native methods Step 3: Create a platform definition file Step 4: Port the SVM Step 5: Build the SVM Step 6: Create a PAR file Step 7: SAX and Scode setup for your platform","title":"Introduction"},{"location":"platforms/platTutorial/#create-kit","text":"Every app must have a sys::PlatformService component running in it. A platform service encapsulates the behavior of that specific OS/Hardware platform. The sys::PlatformService class itself is generic, so some key methods do nothing. To implement a real Sedona platform, it must be subclassed so that platform-specific behavior can be implemented. The first step in porting Sedona to a new platform is the creation of a PlatformService subclass for the platform. As an example, the win32 platform service is defined in a kit called \"platWin32\" and the kit definition file is in sedona_home/platforms/src/generic/win32/kit.xml","title":"Create Kit"},{"location":"platforms/platTutorial/#implement-native-methods","text":"The base class sys::PlatformService defines three native methods that must be implemented for every platform. They are called by PlatformService as needed to populate the corresponding properties. doPlatformId() : returns platform ID string getPlatVersion() : returns platform version string getNativeMemAvailable() : returns number of bytes of physical memory available The open source includes win32 natives as an example, see sedona_home/src/sys/native/win32 .","title":"Implement Native Methods"},{"location":"platforms/platTutorial/#doplatformid","text":"One of the most important properties on the platform service is the platformId property. This property uniquely identifies your platform, and maps to a platform manifest stored in the platform database. The native method doPlatformId() provides a means for Sedona to access this native property. The native implementation of doPlatformId() for the win32 platform is #include \"sedona.h\" #include \"sedonaPlatform.h\" #include <windows.h> // Str PlatformService.doPlatformId() Cell sys_PlatformService_doPlatformId(SedonaVM* vm, Cell* params) { Cell result; result.aval = PLATFORM_ID; return result; } The value of PLATFORM_ID is defined in the header file sedonaPlatform.h , which is generated automatically from the platform definition XML file. So the next step is to create one.","title":"doPlatformId()"},{"location":"platforms/platTutorial/#create-platdef-file","text":"Please refer to the section on platform definition for an in depth discussion of this file and all its sections and attributes. The platform definition for the win32 platform is located in sedona_home/platforms/src/generic/win32/generic-win32.xml . (This file can be located anywhere, but the convention is to put it under sedona_home/platforms/src/ .) <sedonaPlatform vendor= \"Tridium\" id= \"tridium-generic-win32-${sedona.env.version}\" > <compile endian= \"little\" blockSize= \"4\" refSize= \"4\" debug= \"true\" test= \"true\" > <!-- Native Kits --> <nativeKit depend= \"sys 1.0\" /> <nativeKit depend= \"inet 1.0\" /> <nativeKit depend= \"datetimeStd 1.0\" /> <nativeKit depend= \"platWin32 1.0\" /> <!-- Native Sources --> <nativeSource path= \"/src/vm\" /> <nativeSource path= \"/src/sys/native\" /> <nativeSource path= \"/src/sys/native/std\" /> <nativeSource path= \"/src/sys/native/win32\" /> <nativeSource path= \"/src/inet/native\" /> <nativeSource path= \"/src/inet/native/std\" /> <nativeSource path= \"/src/inet/native/sha1\" /> <nativeSource path= \"/src/datetimeStd/native/std\" /> <nativeSource path= \"/platforms/src/generic/win32/native\" /> </compile> </sedonaPlatform> There are a few things to note about this platform definition. It specifies the id attribute for the platform. Later, when we run sedonac on this file to stage the source, it will generate the header file sedonaPlatform.h based on this file. That header file will contain the PLATFORM_ID definition required by the doPlatformId() native code. The SVM created from this platform definition will only support the native methods from the sys, inet, datetimeStd, and platWin32 kits because those are the only kits included in <nativeKit> declarations. In order to support other kits with native methods, they will have to be added to the platform definition.","title":"Create platDef file"},{"location":"platforms/platTutorial/#port-svm","text":"This process is already described in detail in the porting section. We specified in the platform definition file where all the native source code is located. If the native source file locations change at any time during the platform development process, the platform definition will need to be updated accordingly. Refer to the win32 platform definition to see where all the native code for the win32 SVM resides.","title":"Port SVM"},{"location":"platforms/platTutorial/#build-svm","text":"Once the native source code is written and the platform definition file is correct, we are ready to build the SVM. As described in the staging section, we use sedonac to stage all native source files in one directory. Then we use the appropriate native tool-chain to actually build the SVM. The open source distribution includes a makewinvm.py script that will build the win32 platform SVM. It runs sedonac on the generic-win32.xml platform definition file to stage all the source code for the SVM, and then it compiles the source code into a binary. This is the same svm.exe that appears in the bin/ directory of the open source distribution. To run makewinvm.py you must first have set up your environment for Windows 32-bit development. You must provide your own native tool-chain to accomplish the same tasks for a different platform.","title":"Build SVM"},{"location":"platforms/platTutorial/#create-par-file","text":"Refer to the section on PAR files for a more in-depth discussion on PAR files. When we staged the native source by running sedonac on the platform definition file, it also created a .par/ directory containing a valid platformManifest.xml file for the platform. Therefore, all we need to do is zip up the contents of that directory and use the platformdb.py script to install it in our platform database. The makewinvm.py script does the database installation step automatically for the open source win32 platform. If you issue the platformdb.py --list command you should see output similar to the following sedona> platformdb.py --list tridium-generic-win32-1.0.46 This output indicates that the we have successfully installed the win32 platform into the platform database. The toolchain steps you perform for another platform will need to do the same thing for that platform. You can use the platformdb -i <par file> command to install a PAR file into the platform database. Note The path within the platform database where the .par folder will be located must match the platform ID exactly. For example, the win32 platform definition file defines the platform ID as tridium-generic-win32-${sedona.env.version} . When we ran sedonac on the platform definition file it substituted an actual version number, so the resulting platform manifest file contains a specific definition, for example tridium-generic-win32-1.2.29 . Sedona would then expect to find the manifest file for this platform in the platform database under sedona_home/platforms/db/tridium/generic/win32/1.2.29/.par/ .","title":"Create PAR file"},{"location":"platforms/platTutorial/#test-platform","text":"To use your new platform service, you will need to create an application (SAX) that uses your platform service. There is an example SAX file that uses the Win32PlatformService at sedona_home/apps/platWin32.sax . You can use this file as a template and make the following modifications to use it for your platform: In the <schema> section, remove the platWin32 kit and add the kit for your platform service. In the <app> section there is a component called \"plat\". Change the type of that component from \"platWin32::Win32PlatformService\" to the type of your platform service. After you have made these changes you can run sedonac on your new SAX file to create an binary application (SAB) that your SVM can run. Finally, you will need to create a scode image corresponding to the kits in your SAX. There is an example scode configuration file in sedona_home/scode/platWin32.xml . You can use this file as a template and make the following modifications for your platform: Modify the <sedonaCode> elements to match the settings for your device. For example, make sure the blockSize, refSize, endian, etc. are correct. Remove the dependency on \"platWin32 1.0\" and add a dependency for the kit containing your platform service. After you have made these changes you an run sedonac on your new scode XML file to produce an scode image that your SVM can run.","title":"Test Platform"},{"location":"quickstart/architecture/","text":"Architecture \u00b6 Actors \u00b6 One of the goals of the Sedona Framework is to empower non-programmers to graphically assemble applications by wiring together predefined components. It is useful to consider two primary actors involved in building Sedona Framework applications: Developers are software engineers who write components using the Sedona programming language. These components include function blocks, I/O drivers, and packaged applications. Components are then bundled into modules and deployed as kits Integrators are typically domain experts who use graphical tools to assemble applications from the components written by developers. Components are configured via their properties and wired together with links In the real world, users don't fit into these two buckets so cleanly - many belong to both camps. But characterizing users according to these two actors is useful for discussion. Sedona Language \u00b6 Sedona Framework applications all start with software written in the Sedona programming language . The Sedona language is based on Java and C# - so if you are familiar with those languages then you should have no problem learning Sedona. Key characteristics of the Sedona language include: Familiar Java/C# syntax Object oriented (inheritance, polymorphism, all that good stuff) Component oriented (first class properties and actions, reflection, graphical assembly) Single inheritance only (no interfaces) Static memory model (components cannot create new objects at runtime) Semicolons are optional as statement separator Components \u00b6 The Sedona Framework's standard API includes a special class called Component . Classes that extend Component are designed to be used by integrators to assemble applications. All components have the following characteristics designed to enable component-oriented application assembly: Two byte component id for identity and naming inside an application A short ASCII character name as a human label Designed to be organized into a tree structure similar to your file system Reflective type Named set of reflective slots Slots are the members of a component class that specify how the component is exposed to an integrator during the assembly process. There are two types of slots: property defines a configuration or runtime variable and action defines a command that can be invoked. Kits \u00b6 Developers write software organized into classes much like C++, Java, or C#. These classes are then packaged up into a kit . A kit is the primary unit of deployment, versioning, and naming in the Sedona Framework. A kit is like a Java JAR file or a .NET DLL. Kits are stored as a single file that ends with the \".kit\" extension. The file itself is a standard archive file you can open using your favorite 'zip' tool. Inside the kit file is an XML manifest file that specifies meta-data about the kit such as its name, version, vendor, and description. The manifest also enumerates all the kit's component types that are available for constructing applications. Kits are compiled from Sedona language source code using the sedonac compiler. During compilation, all the classes in the kit are checked for validity and compiled into a special format called IR for intermediate representation . The IR format is a text based \"assembly language\". IR code is portable, which means one kit file can be deployed for all platforms. SCode \u00b6 Sedona Framework software deployed as kits still isn't quite ready for execution. Even though we've compiled source language down to IR, we still don't have a format suitable for machine execution. The next step is to compile a set of kits into a single file called an scode image . SCode is a very compact, binary representation of the code, designed to be executed directly by the Sedona VM. The sedonac compiler is used to compile a set of kits into a binary \".scode\" file. During this compilation process the following tasks are performed: Layout method code in memory Layout fields in memory Layout reflection meta-data in memory Optimize for big-endian or little-endian Optimize for native platform pointer size Link method calls to their memory locations To maximize performance, sedonac optimizes the scode for a specific platform's endianness and pointer size; this means that an scode image is not portable to other platforms. Sedona Virtual Machine \u00b6 Once a set of kits has been compiled into an scode file, we can run the scode using the Sedona Virtual Machine , or SVM for short. The SVM interprets the scode and brings Sedona programs to life! The SVM itself is written in ANSI C and compiled for a target hardware platform. See the Porting chapter for instructions to get the SVM running on your target device. Sedona Framework Applications \u00b6 Writing code in the Sedona programming language and building kits is the domain of developers. Developers build libraries of ready-to-use components deployed as kits. Integrators can then use graphical programming tools to design applications by assembling and linking component instances. Due to their dynamic nature, Sedona Framework applications are modeled and persisted differently from kits and scode. A Sedona Framework application is modeled as a tree of components. Each component is assigned a unique two byte identifier and a custom name. Components instances may also be customized via their configuration properties. Links are used to establish relationships between components to specify data and event flow within the application. Sedona Framework applications may be stored in two different file formats. The Sedona Application XML format uses the \".sax\" file extension, and is a human-readable XML file. The Sedona Application Binary format uses the \".sab\" file extension and is a compact binary representation of the application. The binary format is the one used at runtime on Sedona Framework-enabled devices. The sedonac tool can be used to convert between the file formats. Sedona Framework Devices \u00b6 Of course the end goal of the Sedona Framework is to create programmable smart devices. This is where everything comes together. The typical process of Sedona Framework-enabling a device: Port the SVM to the device's hardware platform Run the SVM on the device (typically loaded or run from flash memory on startup) Commission the device with an scode image. This allows integrators to pick their own kits to use for applications. In devices with limited resources the scode may be fixed or even in ROM. More typically, the scode is stored in flash memory and the location of the image passed to the VM at boot time Load the sab application file. The integrator may write a complete application to the device; applications can also be modified dynamically on the device while it is running. At the other extreme, such as for a small, dedicated device, the application might be fixed or stored in ROM Workflow \u00b6 The diagram below illustrates the workflow for building and deploying Sedona Framework applications to devices. The Sedona developer workflow typically involves these steps: Build library of components in the Sedona programming language Components are compiled into kits using sedonac Developers or integrators will choose which kits to install onto a device, and then sedonac is used to link the kits into a binary scode image (this step is often done under the covers by a high level tool) The SVM and scode are loaded onto the device. These files may be predefined such as in ROM, or may be dynamically provisioned over the network using the Sox protocol System integrators are usually domain experts who build Sedona applications by \"wiring together\" the components provided by developers. These users typically use graphical tools to assemble applications. Applications may be modified remotely on a running device using the Sox protocol, or they may be built offline and stored in a \"sax\" file. If the app is built offline, then it compiled into a \"sab\" file with sedonac and installed on the device at commissioning time using the Sox protocol.","title":"Architecture"},{"location":"quickstart/architecture/#architecture","text":"","title":"Architecture"},{"location":"quickstart/architecture/#actors","text":"One of the goals of the Sedona Framework is to empower non-programmers to graphically assemble applications by wiring together predefined components. It is useful to consider two primary actors involved in building Sedona Framework applications: Developers are software engineers who write components using the Sedona programming language. These components include function blocks, I/O drivers, and packaged applications. Components are then bundled into modules and deployed as kits Integrators are typically domain experts who use graphical tools to assemble applications from the components written by developers. Components are configured via their properties and wired together with links In the real world, users don't fit into these two buckets so cleanly - many belong to both camps. But characterizing users according to these two actors is useful for discussion.","title":"Actors"},{"location":"quickstart/architecture/#sedona-language","text":"Sedona Framework applications all start with software written in the Sedona programming language . The Sedona language is based on Java and C# - so if you are familiar with those languages then you should have no problem learning Sedona. Key characteristics of the Sedona language include: Familiar Java/C# syntax Object oriented (inheritance, polymorphism, all that good stuff) Component oriented (first class properties and actions, reflection, graphical assembly) Single inheritance only (no interfaces) Static memory model (components cannot create new objects at runtime) Semicolons are optional as statement separator","title":"Sedona Language"},{"location":"quickstart/architecture/#components","text":"The Sedona Framework's standard API includes a special class called Component . Classes that extend Component are designed to be used by integrators to assemble applications. All components have the following characteristics designed to enable component-oriented application assembly: Two byte component id for identity and naming inside an application A short ASCII character name as a human label Designed to be organized into a tree structure similar to your file system Reflective type Named set of reflective slots Slots are the members of a component class that specify how the component is exposed to an integrator during the assembly process. There are two types of slots: property defines a configuration or runtime variable and action defines a command that can be invoked.","title":"Components"},{"location":"quickstart/architecture/#kits","text":"Developers write software organized into classes much like C++, Java, or C#. These classes are then packaged up into a kit . A kit is the primary unit of deployment, versioning, and naming in the Sedona Framework. A kit is like a Java JAR file or a .NET DLL. Kits are stored as a single file that ends with the \".kit\" extension. The file itself is a standard archive file you can open using your favorite 'zip' tool. Inside the kit file is an XML manifest file that specifies meta-data about the kit such as its name, version, vendor, and description. The manifest also enumerates all the kit's component types that are available for constructing applications. Kits are compiled from Sedona language source code using the sedonac compiler. During compilation, all the classes in the kit are checked for validity and compiled into a special format called IR for intermediate representation . The IR format is a text based \"assembly language\". IR code is portable, which means one kit file can be deployed for all platforms.","title":"Kits"},{"location":"quickstart/architecture/#scode","text":"Sedona Framework software deployed as kits still isn't quite ready for execution. Even though we've compiled source language down to IR, we still don't have a format suitable for machine execution. The next step is to compile a set of kits into a single file called an scode image . SCode is a very compact, binary representation of the code, designed to be executed directly by the Sedona VM. The sedonac compiler is used to compile a set of kits into a binary \".scode\" file. During this compilation process the following tasks are performed: Layout method code in memory Layout fields in memory Layout reflection meta-data in memory Optimize for big-endian or little-endian Optimize for native platform pointer size Link method calls to their memory locations To maximize performance, sedonac optimizes the scode for a specific platform's endianness and pointer size; this means that an scode image is not portable to other platforms.","title":"SCode"},{"location":"quickstart/architecture/#sedona-virtual-machine","text":"Once a set of kits has been compiled into an scode file, we can run the scode using the Sedona Virtual Machine , or SVM for short. The SVM interprets the scode and brings Sedona programs to life! The SVM itself is written in ANSI C and compiled for a target hardware platform. See the Porting chapter for instructions to get the SVM running on your target device.","title":"Sedona Virtual Machine"},{"location":"quickstart/architecture/#sedona-framework-applications","text":"Writing code in the Sedona programming language and building kits is the domain of developers. Developers build libraries of ready-to-use components deployed as kits. Integrators can then use graphical programming tools to design applications by assembling and linking component instances. Due to their dynamic nature, Sedona Framework applications are modeled and persisted differently from kits and scode. A Sedona Framework application is modeled as a tree of components. Each component is assigned a unique two byte identifier and a custom name. Components instances may also be customized via their configuration properties. Links are used to establish relationships between components to specify data and event flow within the application. Sedona Framework applications may be stored in two different file formats. The Sedona Application XML format uses the \".sax\" file extension, and is a human-readable XML file. The Sedona Application Binary format uses the \".sab\" file extension and is a compact binary representation of the application. The binary format is the one used at runtime on Sedona Framework-enabled devices. The sedonac tool can be used to convert between the file formats.","title":"Sedona Framework Applications"},{"location":"quickstart/architecture/#sedona-framework-devices","text":"Of course the end goal of the Sedona Framework is to create programmable smart devices. This is where everything comes together. The typical process of Sedona Framework-enabling a device: Port the SVM to the device's hardware platform Run the SVM on the device (typically loaded or run from flash memory on startup) Commission the device with an scode image. This allows integrators to pick their own kits to use for applications. In devices with limited resources the scode may be fixed or even in ROM. More typically, the scode is stored in flash memory and the location of the image passed to the VM at boot time Load the sab application file. The integrator may write a complete application to the device; applications can also be modified dynamically on the device while it is running. At the other extreme, such as for a small, dedicated device, the application might be fixed or stored in ROM","title":"Sedona Framework Devices"},{"location":"quickstart/architecture/#workflow","text":"The diagram below illustrates the workflow for building and deploying Sedona Framework applications to devices. The Sedona developer workflow typically involves these steps: Build library of components in the Sedona programming language Components are compiled into kits using sedonac Developers or integrators will choose which kits to install onto a device, and then sedonac is used to link the kits into a binary scode image (this step is often done under the covers by a high level tool) The SVM and scode are loaded onto the device. These files may be predefined such as in ROM, or may be dynamically provisioned over the network using the Sox protocol System integrators are usually domain experts who build Sedona applications by \"wiring together\" the components provided by developers. These users typically use graphical tools to assemble applications. Applications may be modified remotely on a running device using the Sox protocol, or they may be built offline and stored in a \"sax\" file. If the app is built offline, then it compiled into a \"sab\" file with sedonac and installed on the device at commissioning time using the Sox protocol.","title":"Workflow"},{"location":"quickstart/intro/","text":"Introduction \u00b6 Overview \u00b6 The Sedona Framework is a software framework designed to make it easy to build smart, networked embedded devices. Some of the Sedona Framework highlights: Sedona Language : This is a general purpose component-oriented programming language very similar to Java or C#. The Sedona language is used to write your own custom functionality Sedona Virtual Machine : The virtual machine is a small interpreter written in ANSI C and designed for portability. It allows code written in the Sedona programming language to be written once, but run on any Sedona Framework-enabled device. The VM itself is designed to be highly portable to new microprocessors and operating systems Small Devices : The Sedona Framework is ideal for very small embedded devices. It can run on platforms with less than 100KB of memory! Component Oriented Programming : The Sedona Framework enables a style of programming where pre-built components are assembled into applications. Components can act as services or be explicitly linked together to create data and control flow. This model is especially suited to graphical programming tools Networking : Several protocols are bundled with the Sedona Framework to provision, program, and communicate with Sedona Framework-enabled devices over various network topologies. You can remotely add, remove, and modify the components in your application in real-time. You can even upgrade the firmware itself over the network. Sedona Framework networking is designed to work over any IP network, including 6LoWPAN Open Source Ecosystem : The core Sedona Framework technology uses a flexible academic styled license. This makes it easy for manufacturers to Sedona Framework-enable their devices. Tools and applications written in Sedona are guaranteed portable to any Sedona Framework device","title":"Introduction"},{"location":"quickstart/intro/#introduction","text":"","title":"Introduction"},{"location":"quickstart/intro/#overview","text":"The Sedona Framework is a software framework designed to make it easy to build smart, networked embedded devices. Some of the Sedona Framework highlights: Sedona Language : This is a general purpose component-oriented programming language very similar to Java or C#. The Sedona language is used to write your own custom functionality Sedona Virtual Machine : The virtual machine is a small interpreter written in ANSI C and designed for portability. It allows code written in the Sedona programming language to be written once, but run on any Sedona Framework-enabled device. The VM itself is designed to be highly portable to new microprocessors and operating systems Small Devices : The Sedona Framework is ideal for very small embedded devices. It can run on platforms with less than 100KB of memory! Component Oriented Programming : The Sedona Framework enables a style of programming where pre-built components are assembled into applications. Components can act as services or be explicitly linked together to create data and control flow. This model is especially suited to graphical programming tools Networking : Several protocols are bundled with the Sedona Framework to provision, program, and communicate with Sedona Framework-enabled devices over various network topologies. You can remotely add, remove, and modify the components in your application in real-time. You can even upgrade the firmware itself over the network. Sedona Framework networking is designed to work over any IP network, including 6LoWPAN Open Source Ecosystem : The core Sedona Framework technology uses a flexible academic styled license. This makes it easy for manufacturers to Sedona Framework-enable their devices. Tools and applications written in Sedona are guaranteed portable to any Sedona Framework device","title":"Overview"},{"location":"quickstart/setup/","text":"Setup \u00b6 Overview \u00b6 The root directory of your Sedona Framework installation or development environment is referred to as Sedona home . Relative paths in this documentation always start from the Sedona home directory. Sedona home is organized into the following sub directories: adm : administration scripts used to build and test apps : Sedona application files (.sab and .sax formats) bin : Win32 binaries and some Unix shell scripts doc : documentation kits : directory for kit database lib : Java jar files and properties files manifests : directory for manifest database platforms : directory for platform database; also contains source files for Sedona Framework platforms scode : scode images, and linker files for creating them src : directory tree for Java, C, and Sedona source code Sedonac \u00b6 Sedona Framework development primarily centers around the tool sedonac . It functions as a compiler for Sedona applications as well as Sedona kits (library modules); its behavior depends on the input file it is processing. Windows \u00b6 For Windows you will be using the sedonac.exe launcher executable, located in the bin directory. If you are developing at the command line, make sure that bin is in your path. The compiler requires a Java Runtime of 1.4 or greater. sedonac will look in the registry to find the path to your current Java VM. For more details about how sedonac starts up, use the --v command line switch (that's two dashes before the 'v'), which will trace the registry access and jvm.dll load. To verify sedonac is correctly installed, run with the -ver switch: D: \\s edona>sedonac -ver Sedona Compiler 1 .2.28 Copyright ( c ) 2007 -2013 Tridium, Inc. sedona.version = 1 .2.28 sedona.home = D: \\s edona java.home = C: \\P rogram Files ( x86 ) \\J ava \\j re7 java.version = 1 .7.0_13 Unix \u00b6 There is a bash shell script in adm/unix called init.sh that initializes your Sedona Framework development environment. In order to use this script, you must first export JAVA_HOME in your login script create a symbolic link in your home directory called sedonadev that points to your actual Sedona home directory. For example, ~/sedonadev > ~/repos/sedona-1.0/pub If you don't want to use this symbolic link, edit init.sh to explicitly set the sedona_home environment variable After doing the above configuration, change your login script to run init.sh . This script will make sure some key programs are in your path, check that all the python scripts have executable permissions, and create some useful aliases. There are two Unix specific commands that you should use for building in a Unix environment: makeunixvm.py : Compiles the Sedona VM (SVM) for Unix using gcc. Run makeunixvm -h for more details makeunixdev.py : Builds sedona.jar, sedonac.jar, all opensource kits, and makes the Unix SVM Java Command Line \u00b6 If you need to invoke Sedonac directly you can launch it directly with Java: Put lib/sedona.jar and lib/sedonac.jar in the classpath Pass the installation directory to the \"sedona.home\" system property Run the \"sedonac.Main\" class with the desired arguments For example: java -cp { lib } sedona.jar: { lib } sedonac.jar -Dsedona.home ={ home } sedonac.Main src/sox Environment \u00b6 You can rebuild from source using the python scripts in the adm directory (or adm/unix ). These scripts are used to rebuild the compiler itself and the SVM. In order to use the python scripts, you will need to install Python (version 2.7 or better). Also the following environment variables must be defined: sedona_home : directory of your Sedona Framework installation (the parent directory of adm, bin, lib, etc) java_home : directory of the Java JDK (1.4 or later). Note: the scripts use adm/jikes.exe to compile Java code, but still require the JDK for bin/jar.exe and jre/lib/rt.jar win_sdk : if you wish to compile the VM using the Visual Studio C compiler then win_sdk should reference your Windows development kit. Also make sure you have run the vcvars32.bat script included in your Visual Studio installation. Many users can skip this step, though, and just use the pre-built Win32 svm.exe provided in the bin directory To verify your environment you can run the adm/env.py script, which will print all the files and directories being used with your current setup. Common commands \u00b6 The following commands are commonly used when building and running the Sedona Framework: Command Outcome makesedona.py compile sedona runtime Java source into sedona.jar makesedonac.py compile sedonac Java source into sedonac.jar (depends on sedona.jar) makewinvm.py recompile svm.exe for Win32 using Visual Studio compiler sedonac src\\zoo\\kit.xml compile Sedona source for kit zoo into a kit file (you can also specify just src\\zoo ) sedonac scode\\zdevice.xml link Sedona kits specified by zdevice.xml into zdevice.scode image file sedonac apps\\bar.sax compile a SAX (application XML) file into a SAB (binary) file svm scode\\zdevice.scode apps\\bar.sab run Win32 SVM with the specified scode and app file svm scode\\zdevice.scode -test run test suite with the Win32 SVM and the specified scode file svm --plat For the open source Win32 and Unix SVM implementations, this allows you to run the SVM in platform mode . Running in platform mode allows the SVM to handle restart commands, and it will handle loading staged scode and sab files. The SVM must be running in platform mode to pass the certification test suite makedev.py recompile all the commonly used targets and run tests with the Win32 SVM Note Any command that builds the SVM will need to have the appropriate target toolchain set up first.","title":"Setup"},{"location":"quickstart/setup/#setup","text":"","title":"Setup"},{"location":"quickstart/setup/#overview","text":"The root directory of your Sedona Framework installation or development environment is referred to as Sedona home . Relative paths in this documentation always start from the Sedona home directory. Sedona home is organized into the following sub directories: adm : administration scripts used to build and test apps : Sedona application files (.sab and .sax formats) bin : Win32 binaries and some Unix shell scripts doc : documentation kits : directory for kit database lib : Java jar files and properties files manifests : directory for manifest database platforms : directory for platform database; also contains source files for Sedona Framework platforms scode : scode images, and linker files for creating them src : directory tree for Java, C, and Sedona source code","title":"Overview"},{"location":"quickstart/setup/#sedonac","text":"Sedona Framework development primarily centers around the tool sedonac . It functions as a compiler for Sedona applications as well as Sedona kits (library modules); its behavior depends on the input file it is processing.","title":"Sedonac"},{"location":"quickstart/setup/#windows","text":"For Windows you will be using the sedonac.exe launcher executable, located in the bin directory. If you are developing at the command line, make sure that bin is in your path. The compiler requires a Java Runtime of 1.4 or greater. sedonac will look in the registry to find the path to your current Java VM. For more details about how sedonac starts up, use the --v command line switch (that's two dashes before the 'v'), which will trace the registry access and jvm.dll load. To verify sedonac is correctly installed, run with the -ver switch: D: \\s edona>sedonac -ver Sedona Compiler 1 .2.28 Copyright ( c ) 2007 -2013 Tridium, Inc. sedona.version = 1 .2.28 sedona.home = D: \\s edona java.home = C: \\P rogram Files ( x86 ) \\J ava \\j re7 java.version = 1 .7.0_13","title":"Windows"},{"location":"quickstart/setup/#unix","text":"There is a bash shell script in adm/unix called init.sh that initializes your Sedona Framework development environment. In order to use this script, you must first export JAVA_HOME in your login script create a symbolic link in your home directory called sedonadev that points to your actual Sedona home directory. For example, ~/sedonadev > ~/repos/sedona-1.0/pub If you don't want to use this symbolic link, edit init.sh to explicitly set the sedona_home environment variable After doing the above configuration, change your login script to run init.sh . This script will make sure some key programs are in your path, check that all the python scripts have executable permissions, and create some useful aliases. There are two Unix specific commands that you should use for building in a Unix environment: makeunixvm.py : Compiles the Sedona VM (SVM) for Unix using gcc. Run makeunixvm -h for more details makeunixdev.py : Builds sedona.jar, sedonac.jar, all opensource kits, and makes the Unix SVM","title":"Unix"},{"location":"quickstart/setup/#java-command-line","text":"If you need to invoke Sedonac directly you can launch it directly with Java: Put lib/sedona.jar and lib/sedonac.jar in the classpath Pass the installation directory to the \"sedona.home\" system property Run the \"sedonac.Main\" class with the desired arguments For example: java -cp { lib } sedona.jar: { lib } sedonac.jar -Dsedona.home ={ home } sedonac.Main src/sox","title":"Java Command Line"},{"location":"quickstart/setup/#environment","text":"You can rebuild from source using the python scripts in the adm directory (or adm/unix ). These scripts are used to rebuild the compiler itself and the SVM. In order to use the python scripts, you will need to install Python (version 2.7 or better). Also the following environment variables must be defined: sedona_home : directory of your Sedona Framework installation (the parent directory of adm, bin, lib, etc) java_home : directory of the Java JDK (1.4 or later). Note: the scripts use adm/jikes.exe to compile Java code, but still require the JDK for bin/jar.exe and jre/lib/rt.jar win_sdk : if you wish to compile the VM using the Visual Studio C compiler then win_sdk should reference your Windows development kit. Also make sure you have run the vcvars32.bat script included in your Visual Studio installation. Many users can skip this step, though, and just use the pre-built Win32 svm.exe provided in the bin directory To verify your environment you can run the adm/env.py script, which will print all the files and directories being used with your current setup.","title":"Environment"},{"location":"quickstart/setup/#common-commands","text":"The following commands are commonly used when building and running the Sedona Framework: Command Outcome makesedona.py compile sedona runtime Java source into sedona.jar makesedonac.py compile sedonac Java source into sedonac.jar (depends on sedona.jar) makewinvm.py recompile svm.exe for Win32 using Visual Studio compiler sedonac src\\zoo\\kit.xml compile Sedona source for kit zoo into a kit file (you can also specify just src\\zoo ) sedonac scode\\zdevice.xml link Sedona kits specified by zdevice.xml into zdevice.scode image file sedonac apps\\bar.sax compile a SAX (application XML) file into a SAB (binary) file svm scode\\zdevice.scode apps\\bar.sab run Win32 SVM with the specified scode and app file svm scode\\zdevice.scode -test run test suite with the Win32 SVM and the specified scode file svm --plat For the open source Win32 and Unix SVM implementations, this allows you to run the SVM in platform mode . Running in platform mode allows the SVM to handle restart commands, and it will handle loading staged scode and sab files. The SVM must be running in platform mode to pass the certification test suite makedev.py recompile all the commonly used targets and run tests with the Win32 SVM Note Any command that builds the SVM will need to have the appropriate target toolchain set up first.","title":"Common commands"},{"location":"quickstart/tutorial/","text":"Tutorial \u00b6 Overview \u00b6 This tutorial takes you through the various development steps involved in building Sedona Framework applications: Build a new kit and component Build a new scode image Build an application Run the application It is recommended that you read the Architecture chapter before exploring this tutorial. Refer to the diagram , which illustrates the work flow this tutorial will take. Also make sure you have your Sedona Framework environment setup correctly before. Build New Kit \u00b6 Kits are modules used to organize Sedona code. For this example we will create a new kit called tutorial . In our kit we will create a component called Add , which adds two inputs together. First let's create a directory under src called \"tutorial\", with two text files: src/ tutorial/ +- kit.xml +- Add.sedona For more information see Structure to see how kits are organized. The kit.xml file is used to define the kit's meta-data for the compiler: <sedonaKit name= \"tutorial\" vendor= \"Tridium\" description= \"blah\" > <depend on= \"sys 1.2+\" /> <source dir= \".\" /> </sedonaKit> The kit.xml file specifies the name of our kit, a short description, dependencies, and the directories of source code. (The vendor attribute specifies the company that developed the kit - for the purposes of the tutorial leave this as \"Tridium\" because otherwise the kit name must be prefixed with the vendor name.) For more information see Kits and Compile Kit . The \"Add.sedona\" file defines the source code for our new component: public class Add extends Component { property float out property float in1 property float in2 override void execute () { out : = in1 + in2 } } The Add component is pretty simple - it declares two inputs and an output. When the component is \"executed\" we add the two inputs and update the output. For more information see Components To compile our new kit we just need to run sedonac against our directory or the kit.xml file: C: \\S edona \\S edona-1.2.27 \\s rc \\t utorial>dir Volume in drive C has no label. Volume Serial Number is 50BC-4286 Directory of C: \\S edona \\S edona-1.2.27 \\s rc \\t utorial 02 /25/2013 09 :57 AM <DIR> . 02 /25/2013 09 :57 AM <DIR> .. 02 /25/2013 09 :52 AM 160 Add.sedona 02 /25/2013 09 :55 AM 131 kit.xml 2 File ( s ) 291 bytes 2 Dir ( s ) 170 ,500,431,872 bytes free C: \\S edona \\S edona-1.2.27 \\s rc \\t utorial>sedonac kit.xml Parse [ 1 files ] WriteKit [ C: \\S edona \\S edona-1.2.27 \\k its \\t utorial \\t utorial-89858e3e-1.2.27.kit ] WriteManifest [ C: \\S edona \\S edona-1.2.27 \\m anifests \\t utorial \\t utorial-89858e3e.xml ] *** Success! *** If successful, you should have a new kit file in your kits/tutorial directory. You can open this file in a tool like WinZip to explore the compiler's output. For more information see Sedonac . If you have trouble running sedonac, then see Setup . Build New SCode Image \u00b6 Kits are units of deployment, but are not run directly by the SVM. First we have to compile a set of kits into an scode image that can be run directly by the SVM. Create a new directory called tutorialApp with one file: tutorialApp/ +- kits.xml The \"kits.xml\" file specifies the kits we wish to compile into an image: <sedonaCode endian= \"little\" blockSize= \"4\" refSize= \"4\" main= \"sys::Sys.main\" debug= \"true\" test= \"true\" > <depend on= \"sys 1.2+\" /> <depend on= \"sox 1.2+\" /> <depend on= \"inet 1.2+\" /> <depend on= \"web 1.2+\" /> <depend on= \"func 1.2+\" /> <depend on= \"platWin32 1.2+\" /> <depend on= \"tutorial 1.2+\" /> </sedonaCode> Info See Sedonac for more information on these settings. Run sedonac on this file to produce an scode image: C: \\S edona \\S edona-1.2.27 \\t utorialApp>sedonac kits.xml ReadKits [ 7 kits ] WriteImage [ C: \\S edona \\S edona-1.2.27 \\t utorialApp \\k its.scode ] ( 89088 bytes ) +---------------------------------- | Data: 7 .8kb ( 8020 bytes ) | Code: 87kb ( 89088 bytes ) | Total: 94 .8kb ( 97108 bytes ) +---------------------------------- *** Success! *** C: \\S edona \\S edona-1.2.27 \\t utorialApp>dir Volume in drive C has no label. Volume Serial Number is 50BC-4286 Directory of C: \\S edona \\S edona-1.2.27 \\t utorialApp 02 /25/2013 10 :30 AM <DIR> . 02 /25/2013 10 :30 AM <DIR> .. 02 /25/2013 10 :30 AM 89 ,088 kits.scode 02 /25/2013 09 :57 AM 336 kits.xml 2 File ( s ) 89 ,424 bytes 2 Dir ( s ) 170 ,506,817,536 bytes free If successful, then you should have now have a kits.scode file. Build New App \u00b6 Sedona is a component oriented language that enables you to build new applications by assembling components. The application file stores a tree of components, their configuration properties, and how they are linked together. Typically applications are built with graphical tools. For this tutorial we will hand code an application file using XML. In the tutorialApp directory let's create a new app.sax file: <sedonaApp> <schema> <kit name= 'sys' /> <kit name= 'sox' /> <kit name= 'inet' /> <kit name= 'web' /> <kit name= 'func' /> <kit name= 'platWin32' /> <kit name= 'tutorial' /> </schema> <app> <comp name= \"plat\" type= \"platWin32::Win32PlatformService\" /> <comp name= \"users\" type= \"sys::UserService\" > <comp name= \"admin\" type= \"sys::User\" > <prop name= \"cred\" val= \"hE49ksThgAeLkWB3NUU1NWeDO54=\" /> <prop name= \"perm\" val= \"2147483647\" /> <prop name= \"prov\" val= \"255\" /> </comp> </comp> <comp name= \"sox\" type= \"sox::SoxService\" /> <comp name= \"web\" type= \"web::WebService\" > <prop name= \"port\" val= \"8080\" /> </comp> <comp name= \"rampA\" type= \"func::Ramp\" /> <comp name= \"rampB\" type= \"func::Ramp\" /> <comp name= \"add\" type= \"tutorial::Add\" id= \"12\" /> </app> <links> <link from= \"/rampA.out\" to= \"/add.in1\" /> <link from= \"/rampB.out\" to= \"/add.in2\" /> </links> </sedonaApp> The file above declares four Service components: The Win32PlatformService component provides access to platform properties and other platform-specific features. It is a subclass of sys::PlatformService class which provides generic platform functionality. Sedona running on another platform would need a different PlatformService subclass designed for that platform. The UserService component contains an entry for each authorized user, specifying the user's credentials and privileges. The properties here set up a user named \"admin\" with a blank password. (Using a blank password for 'admin' should NOT be done on real Sedona devices! We only do it here to simplify the tutorial.) The SoxService component is required in order to create and use a Sox connection to or from the device The WebService component will run an HTTP server so we can use a browser for debugging. The web server's port is set to 8080 Note Platforms with limited resources may not be able to run a web server. We then declare two func::Ramp components, which are used to generate dummy data. Finally we declare a tutorial::Add component, which is the component we built ourselves in the step above. In the links section we create links between the Ramp component outputs and the inputs to our Add block to create control flow. Sedona Framework-enabled devices don't run the XML file directly, so now we need to compile the XML into a binary format that the SVM can use directly. Do this by running sedonac on app.sax : C: \\S edona \\S edona-1.2.27 \\t utorialApp>sedonac app.sax ConvertAppFile [ C: \\S edona \\S edona-1.2.27 \\t utorialApp \\a pp.sax -> C: \\S edona \\S edona-1.2.27 \\t utorialApp \\a pp.sab ] +---------------------------------- | RAM: 14 .5kb ( 14848 bytes ) | FLASH: 0 .3kb ( 356 bytes ) +---------------------------------- *** Success! *** Now we should have a file called app.sab . See Apps for more information. Run App \u00b6 If you have followed the steps above, we have: Built a new kit called tutorial with a component called Add Compiled our new kit into an scode image called kits.scode Defined and compiled an app into a file called app.sab At this point we can run our application using the SVM. Assuming we are running on Windows we can run our application as follows: C: \\S edona \\S edona-1.2.27 \\t utorialApp>svm kits.scode app.sab Sedona VM 1 .2.27 buildDate: Oct 17 2012 08 :40:10 endian: little blockSize: 4 refSize: 4 -- MESSAGE [ sys::App ] starting -- MESSAGE [ sox::SoxService ] started port = 1876 -- MESSAGE [ sox::SoxService ] DASP Discovery enabled -- MESSAGE [ web::WebService ] started port = 8080 -- MESSAGE [ sys::App ] running Here we just pass our code and application filenames to the prebuilt Win32 \"svm.exe\" executable included with the Sedona open source. If you are running on a different platform you will need an SVM executable designed for that platform - see Porting . Note that if you plan to restart or reboot the Sedona VM remotely, you should start the Sedona VM with the --plat option to run it in \"platform mode\". (See Common Commands for more details.) Now that the SVM is running the application, you should be able to access it with your browser at http://localhost:8080/ . You can use the spy URL http://localhost:8080/spy/app/12 to view the current values of your tutorial::Add component. Hit refresh a couple times to see how the inputs and output change in real-time. If you have a remote administration tool such as the Sedona Framework Workbench, you should now be able to connect to Sox port 1876 with the username \"admin\" and empty password. Refer to your Sedona Framework tool documentation for more information. Success! \u00b6 Congratulations, you've just built and deployed your first Sedona Framework application! This tutorial illustrates just the very basics of Sedona, using only the command line tools. Continue to explore sedonadev.org to learn more about Sedona and the tools available for managing Sedona devices. Info As of summer of 2018, SedonaDev website was taken down by Tridium.","title":"Tutorial"},{"location":"quickstart/tutorial/#tutorial","text":"","title":"Tutorial"},{"location":"quickstart/tutorial/#overview","text":"This tutorial takes you through the various development steps involved in building Sedona Framework applications: Build a new kit and component Build a new scode image Build an application Run the application It is recommended that you read the Architecture chapter before exploring this tutorial. Refer to the diagram , which illustrates the work flow this tutorial will take. Also make sure you have your Sedona Framework environment setup correctly before.","title":"Overview"},{"location":"quickstart/tutorial/#build-new-kit","text":"Kits are modules used to organize Sedona code. For this example we will create a new kit called tutorial . In our kit we will create a component called Add , which adds two inputs together. First let's create a directory under src called \"tutorial\", with two text files: src/ tutorial/ +- kit.xml +- Add.sedona For more information see Structure to see how kits are organized. The kit.xml file is used to define the kit's meta-data for the compiler: <sedonaKit name= \"tutorial\" vendor= \"Tridium\" description= \"blah\" > <depend on= \"sys 1.2+\" /> <source dir= \".\" /> </sedonaKit> The kit.xml file specifies the name of our kit, a short description, dependencies, and the directories of source code. (The vendor attribute specifies the company that developed the kit - for the purposes of the tutorial leave this as \"Tridium\" because otherwise the kit name must be prefixed with the vendor name.) For more information see Kits and Compile Kit . The \"Add.sedona\" file defines the source code for our new component: public class Add extends Component { property float out property float in1 property float in2 override void execute () { out : = in1 + in2 } } The Add component is pretty simple - it declares two inputs and an output. When the component is \"executed\" we add the two inputs and update the output. For more information see Components To compile our new kit we just need to run sedonac against our directory or the kit.xml file: C: \\S edona \\S edona-1.2.27 \\s rc \\t utorial>dir Volume in drive C has no label. Volume Serial Number is 50BC-4286 Directory of C: \\S edona \\S edona-1.2.27 \\s rc \\t utorial 02 /25/2013 09 :57 AM <DIR> . 02 /25/2013 09 :57 AM <DIR> .. 02 /25/2013 09 :52 AM 160 Add.sedona 02 /25/2013 09 :55 AM 131 kit.xml 2 File ( s ) 291 bytes 2 Dir ( s ) 170 ,500,431,872 bytes free C: \\S edona \\S edona-1.2.27 \\s rc \\t utorial>sedonac kit.xml Parse [ 1 files ] WriteKit [ C: \\S edona \\S edona-1.2.27 \\k its \\t utorial \\t utorial-89858e3e-1.2.27.kit ] WriteManifest [ C: \\S edona \\S edona-1.2.27 \\m anifests \\t utorial \\t utorial-89858e3e.xml ] *** Success! *** If successful, you should have a new kit file in your kits/tutorial directory. You can open this file in a tool like WinZip to explore the compiler's output. For more information see Sedonac . If you have trouble running sedonac, then see Setup .","title":"Build New Kit"},{"location":"quickstart/tutorial/#build-new-scode-image","text":"Kits are units of deployment, but are not run directly by the SVM. First we have to compile a set of kits into an scode image that can be run directly by the SVM. Create a new directory called tutorialApp with one file: tutorialApp/ +- kits.xml The \"kits.xml\" file specifies the kits we wish to compile into an image: <sedonaCode endian= \"little\" blockSize= \"4\" refSize= \"4\" main= \"sys::Sys.main\" debug= \"true\" test= \"true\" > <depend on= \"sys 1.2+\" /> <depend on= \"sox 1.2+\" /> <depend on= \"inet 1.2+\" /> <depend on= \"web 1.2+\" /> <depend on= \"func 1.2+\" /> <depend on= \"platWin32 1.2+\" /> <depend on= \"tutorial 1.2+\" /> </sedonaCode> Info See Sedonac for more information on these settings. Run sedonac on this file to produce an scode image: C: \\S edona \\S edona-1.2.27 \\t utorialApp>sedonac kits.xml ReadKits [ 7 kits ] WriteImage [ C: \\S edona \\S edona-1.2.27 \\t utorialApp \\k its.scode ] ( 89088 bytes ) +---------------------------------- | Data: 7 .8kb ( 8020 bytes ) | Code: 87kb ( 89088 bytes ) | Total: 94 .8kb ( 97108 bytes ) +---------------------------------- *** Success! *** C: \\S edona \\S edona-1.2.27 \\t utorialApp>dir Volume in drive C has no label. Volume Serial Number is 50BC-4286 Directory of C: \\S edona \\S edona-1.2.27 \\t utorialApp 02 /25/2013 10 :30 AM <DIR> . 02 /25/2013 10 :30 AM <DIR> .. 02 /25/2013 10 :30 AM 89 ,088 kits.scode 02 /25/2013 09 :57 AM 336 kits.xml 2 File ( s ) 89 ,424 bytes 2 Dir ( s ) 170 ,506,817,536 bytes free If successful, then you should have now have a kits.scode file.","title":"Build New SCode Image"},{"location":"quickstart/tutorial/#build-new-app","text":"Sedona is a component oriented language that enables you to build new applications by assembling components. The application file stores a tree of components, their configuration properties, and how they are linked together. Typically applications are built with graphical tools. For this tutorial we will hand code an application file using XML. In the tutorialApp directory let's create a new app.sax file: <sedonaApp> <schema> <kit name= 'sys' /> <kit name= 'sox' /> <kit name= 'inet' /> <kit name= 'web' /> <kit name= 'func' /> <kit name= 'platWin32' /> <kit name= 'tutorial' /> </schema> <app> <comp name= \"plat\" type= \"platWin32::Win32PlatformService\" /> <comp name= \"users\" type= \"sys::UserService\" > <comp name= \"admin\" type= \"sys::User\" > <prop name= \"cred\" val= \"hE49ksThgAeLkWB3NUU1NWeDO54=\" /> <prop name= \"perm\" val= \"2147483647\" /> <prop name= \"prov\" val= \"255\" /> </comp> </comp> <comp name= \"sox\" type= \"sox::SoxService\" /> <comp name= \"web\" type= \"web::WebService\" > <prop name= \"port\" val= \"8080\" /> </comp> <comp name= \"rampA\" type= \"func::Ramp\" /> <comp name= \"rampB\" type= \"func::Ramp\" /> <comp name= \"add\" type= \"tutorial::Add\" id= \"12\" /> </app> <links> <link from= \"/rampA.out\" to= \"/add.in1\" /> <link from= \"/rampB.out\" to= \"/add.in2\" /> </links> </sedonaApp> The file above declares four Service components: The Win32PlatformService component provides access to platform properties and other platform-specific features. It is a subclass of sys::PlatformService class which provides generic platform functionality. Sedona running on another platform would need a different PlatformService subclass designed for that platform. The UserService component contains an entry for each authorized user, specifying the user's credentials and privileges. The properties here set up a user named \"admin\" with a blank password. (Using a blank password for 'admin' should NOT be done on real Sedona devices! We only do it here to simplify the tutorial.) The SoxService component is required in order to create and use a Sox connection to or from the device The WebService component will run an HTTP server so we can use a browser for debugging. The web server's port is set to 8080 Note Platforms with limited resources may not be able to run a web server. We then declare two func::Ramp components, which are used to generate dummy data. Finally we declare a tutorial::Add component, which is the component we built ourselves in the step above. In the links section we create links between the Ramp component outputs and the inputs to our Add block to create control flow. Sedona Framework-enabled devices don't run the XML file directly, so now we need to compile the XML into a binary format that the SVM can use directly. Do this by running sedonac on app.sax : C: \\S edona \\S edona-1.2.27 \\t utorialApp>sedonac app.sax ConvertAppFile [ C: \\S edona \\S edona-1.2.27 \\t utorialApp \\a pp.sax -> C: \\S edona \\S edona-1.2.27 \\t utorialApp \\a pp.sab ] +---------------------------------- | RAM: 14 .5kb ( 14848 bytes ) | FLASH: 0 .3kb ( 356 bytes ) +---------------------------------- *** Success! *** Now we should have a file called app.sab . See Apps for more information.","title":"Build New App"},{"location":"quickstart/tutorial/#run-app","text":"If you have followed the steps above, we have: Built a new kit called tutorial with a component called Add Compiled our new kit into an scode image called kits.scode Defined and compiled an app into a file called app.sab At this point we can run our application using the SVM. Assuming we are running on Windows we can run our application as follows: C: \\S edona \\S edona-1.2.27 \\t utorialApp>svm kits.scode app.sab Sedona VM 1 .2.27 buildDate: Oct 17 2012 08 :40:10 endian: little blockSize: 4 refSize: 4 -- MESSAGE [ sys::App ] starting -- MESSAGE [ sox::SoxService ] started port = 1876 -- MESSAGE [ sox::SoxService ] DASP Discovery enabled -- MESSAGE [ web::WebService ] started port = 8080 -- MESSAGE [ sys::App ] running Here we just pass our code and application filenames to the prebuilt Win32 \"svm.exe\" executable included with the Sedona open source. If you are running on a different platform you will need an SVM executable designed for that platform - see Porting . Note that if you plan to restart or reboot the Sedona VM remotely, you should start the Sedona VM with the --plat option to run it in \"platform mode\". (See Common Commands for more details.) Now that the SVM is running the application, you should be able to access it with your browser at http://localhost:8080/ . You can use the spy URL http://localhost:8080/spy/app/12 to view the current values of your tutorial::Add component. Hit refresh a couple times to see how the inputs and output change in real-time. If you have a remote administration tool such as the Sedona Framework Workbench, you should now be able to connect to Sox port 1876 with the username \"admin\" and empty password. Refer to your Sedona Framework tool documentation for more information.","title":"Run App"},{"location":"quickstart/tutorial/#success","text":"Congratulations, you've just built and deployed your first Sedona Framework application! This tutorial illustrates just the very basics of Sedona, using only the command line tools. Continue to explore sedonadev.org to learn more about Sedona and the tools available for managing Sedona devices. Info As of summer of 2018, SedonaDev website was taken down by Tridium.","title":"Success!"},{"location":"releases/newFor12/","text":"New for v1.2 \u00b6 Highlights \u00b6 With the release of Sedona Framework 1.2 a number of features have been added. Versioning : You didn't miss anything, the Sedona open source version skipped from 1.0 straight to 1.2 Kit and Platform Manifest Server : Kit and platform manifest files can now be stored directly on the Sedona device, if desired, and served automatically to Sox clients as needed. See the section Manifest Server to learn how to implement it on your platform Device Discovery : Sedona devices can now be discovered automatically using IP multicast. Details can be found in the section on Device Discovery Multi-rate App Components : Components now have some control over when the App cycle executes their child components. This can be used, for example, to have certain child components execute at a lower rate than the App cycle rate. See the Apps chapter for more details Device Simulation : New capability has been added to sedonac to make it easy to create a simulator version of any Sedona VM. Apps that depend on kits with platform-specific native methods can now be run on a different host platform using a simulator SVM. Detailed instructions on how to create a simulator SVM will be presented in the Sedona Device Simulator chapter Refactored Control Kit : The control kit has been split into several smaller kits, organized roughly by functionality. This should make it easier to use the control components on resource-limited devices Prioritized Array Components : A new kit pricomp offers components with prioritized inputs, including override capability: Each component in the pricomp kit uses a 16-level priority scheme, with inputs in1 (highest) through in16 (lowest) plus a fallback property, and a single output out . It also has override actions that explicitly set certain input slots. The value of out is determined by a priority scan of the inputs, looking for a valid value at in1 first, then each of the other inputs in turn, all the way down to in16 and then fallback . (A \"valid\" value is one that is not set to null , or its equivalent for that property's type.) The highest priority valid input propagates to the out slot. Most of the component inputs are linkable, with the few exceptions being inputs that can be set only via right-click override actions. Overridden inputs are evaluated along with the linkable ones, using the same priority scheme. PrioritizedBoolean components also offer built-in timers for minimum on and/or off times to protect sensitive equipment. See the pricomp kit docs for more about these components.","title":"v1.2"},{"location":"releases/newFor12/#new-for-v12","text":"","title":"New for v1.2"},{"location":"releases/newFor12/#highlights","text":"With the release of Sedona Framework 1.2 a number of features have been added. Versioning : You didn't miss anything, the Sedona open source version skipped from 1.0 straight to 1.2 Kit and Platform Manifest Server : Kit and platform manifest files can now be stored directly on the Sedona device, if desired, and served automatically to Sox clients as needed. See the section Manifest Server to learn how to implement it on your platform Device Discovery : Sedona devices can now be discovered automatically using IP multicast. Details can be found in the section on Device Discovery Multi-rate App Components : Components now have some control over when the App cycle executes their child components. This can be used, for example, to have certain child components execute at a lower rate than the App cycle rate. See the Apps chapter for more details Device Simulation : New capability has been added to sedonac to make it easy to create a simulator version of any Sedona VM. Apps that depend on kits with platform-specific native methods can now be run on a different host platform using a simulator SVM. Detailed instructions on how to create a simulator SVM will be presented in the Sedona Device Simulator chapter Refactored Control Kit : The control kit has been split into several smaller kits, organized roughly by functionality. This should make it easier to use the control components on resource-limited devices Prioritized Array Components : A new kit pricomp offers components with prioritized inputs, including override capability: Each component in the pricomp kit uses a 16-level priority scheme, with inputs in1 (highest) through in16 (lowest) plus a fallback property, and a single output out . It also has override actions that explicitly set certain input slots. The value of out is determined by a priority scan of the inputs, looking for a valid value at in1 first, then each of the other inputs in turn, all the way down to in16 and then fallback . (A \"valid\" value is one that is not set to null , or its equivalent for that property's type.) The highest priority valid input propagates to the out slot. Most of the component inputs are linkable, with the few exceptions being inputs that can be set only via right-click override actions. Overridden inputs are evaluated along with the linkable ones, using the same priority scheme. PrioritizedBoolean components also offer built-in timers for minimum on and/or off times to protect sensitive equipment. See the pricomp kit docs for more about these components.","title":"Highlights"}]}